index.js:654 Uncaught ModuleBuildError: Module build failed (from ./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js):
Error: 
  Ã— the name `collection` is defined multiple times
     â•­â”€[/home/runner/workspace/lib/firebase/firestore.ts:1:1]
   1 â”‚ import {
   2 â”‚   collection,
     Â·   â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€
     Â·        â•°â”€â”€ previous definition of `collection` here
   3 â”‚   doc,
   4 â”‚   setDoc,
   5 â”‚   addDoc,
   6 â”‚   getDoc,
   7 â”‚   getDocs,
   8 â”‚   updateDoc,
   9 â”‚   deleteDoc,
  10 â”‚   query,
  11 â”‚   where,
  12 â”‚   orderBy,
  13 â”‚   limit,
  14 â”‚   DocumentData,
  15 â”‚   QueryConstraint,
  16 â”‚   Timestamp,
  17 â”‚   serverTimestamp
  18 â”‚ } from 'firebase/firestore'
  19 â”‚ import { db } from './config'
  20 â”‚ import { Room, SeasonalPrice } from '@/lib/types'
  21 â”‚ import { differenceInDays } from 'date-fns'
  22 â”‚ 
  23 â”‚ // Tipos de dados
  24 â”‚ export interface Booking {
  25 â”‚   id?: string
  26 â”‚   userId?: string
  27 â”‚   guestName: string
  28 â”‚   guestEmail: string
  29 â”‚   guestPhone: string
  30 â”‚   roomId: string
  31 â”‚   roomName: string
  32 â”‚   checkIn: Timestamp
  33 â”‚   checkOut: Timestamp
  34 â”‚   adults: number
  35 â”‚   children: number
  36 â”‚   totalPrice: number
  37 â”‚   status: 'pending' | 'confirmed' | 'cancelled' | 'completed'
  38 â”‚   paymentStatus: 'pending' | 'paid' | 'refunded'
  39 â”‚   specialRequests?: string
  40 â”‚   createdAt?: Timestamp
  41 â”‚   updatedAt?: Timestamp
  42 â”‚ }
  43 â”‚ 
  44 â”‚ export interface Contact {
  45 â”‚   id?: string
  46 â”‚   name: string
  47 â”‚   email: string
  48 â”‚   phone?: string
  49 â”‚   subject: string
  50 â”‚   message: string
  51 â”‚   status: 'new' | 'read' | 'replied'
  52 â”‚   createdAt: Timestamp
  53 â”‚   updatedAt?: Timestamp
  54 â”‚   repliedAt?: Timestamp
  55 â”‚   replyContent?: string
  56 â”‚   reservationDetails?: {
  57 â”‚     checkIn?: Timestamp
  58 â”‚     checkOut?: Timestamp
  59 â”‚     roomId?: string
  60 â”‚     roomName?: string
  61 â”‚     totalGuests?: number
  62 â”‚     totalPrice?: number
  63 â”‚   }
  64 â”‚ }
  65 â”‚ 
  66 â”‚ // FunÃ§Ãµes genÃ©ricas para CRUD
  67 â”‚ export const createDocument = async <T extends DocumentData>(
  68 â”‚   collectionName: string,
  69 â”‚   data: T
  70 â”‚ ): Promise<string> => {
  71 â”‚   const docRef = await addDoc(collection(db, collectionName), {
  72 â”‚     ...data,
  73 â”‚     createdAt: serverTimestamp(),
  74 â”‚     updatedAt: serverTimestamp()
  75 â”‚   })
  76 â”‚   return docRef.id
  77 â”‚ }
  78 â”‚ 
  79 â”‚ export const createDocumentWithId = async <T extends DocumentData>(
  80 â”‚   collectionName: string,
  81 â”‚   id: string,
  82 â”‚   data: T
  83 â”‚ ): Promise<void> => {
  84 â”‚   await setDoc(doc(db, collectionName, id), {
  85 â”‚     ...data,
  86 â”‚     createdAt: serverTimestamp(),
  87 â”‚     updatedAt: serverTimestamp()
  88 â”‚   })
  89 â”‚ }
  90 â”‚ 
  91 â”‚ export const getDocument = async <T>(
  92 â”‚   collectionName: string,
  93 â”‚   id: string
  94 â”‚ ): Promise<T | null> => {
  95 â”‚   const docRef = doc(db, collectionName, id)
  96 â”‚   const docSnap = await getDoc(docRef)
  97 â”‚   
  98 â”‚   if (docSnap.exists()) {
  99 â”‚     const data = docSnap.data();
 100 â”‚     console.log("Dados brutos recuperados do Firestore para quarto:", id, data);
 101 â”‚     
 102 â”‚     if (data?.serviceFeePct !== undefined) {
 103 â”‚       console.log("serviceFeePct antes da conversÃ£o:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
 104 â”‚       // Garantir que serviceFeePct seja um nÃºmero
 105 â”‚       data.serviceFeePct = Number(data.serviceFeePct);
 106 â”‚       console.log("serviceFeePct apÃ³s conversÃ£o:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
 107 â”‚     }
 108 â”‚     
 109 â”‚     return { id: docSnap.id, ...data } as T
 110 â”‚   } else {
 111 â”‚     return null
 112 â”‚   }
 113 â”‚ }
 114 â”‚ 
 115 â”‚ export const getDocuments = async <T>(
 116 â”‚   collectionName: string,
 117 â”‚   constraints: QueryConstraint[] = [],
 118 â”‚   forceRefresh = false
 119 â”‚ ): Promise<T[]> => {
 120 â”‚   try {
 121 â”‚     const collectionRef = collection(db, collectionName)
 122 â”‚     const q = query(collectionRef, ...constraints)
 123 â”‚     
 124 â”‚     // Se forceRefresh for verdadeiro, adicionar opÃ§Ãµes que forÃ§am uma nova consulta ao Firestore
 125 â”‚     const querySnapshot = await getDocs(q)
 126 â”‚     
 127 â”‚     console.log(`Buscando documentos na coleÃ§Ã£o ${collectionName} - ForÃ§a atualizaÃ§Ã£o: ${forceRefresh}`);
 128 â”‚     
 129 â”‚     return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }) as T)
 130 â”‚   } catch (error) {
 131 â”‚     console.error(`Erro ao buscar documentos da coleÃ§Ã£o ${collectionName}:`, error);
 132 â”‚     return [];
 133 â”‚   }
 134 â”‚ }
 135 â”‚ 
 136 â”‚ export const updateDocument = async <T extends DocumentData>(
 137 â”‚   collectionName: string,
 138 â”‚   id: string,
 139 â”‚   data: Partial<T>
 140 â”‚ ): Promise<void> => {
 141 â”‚   const docRef = doc(db, collectionName, id)
 142 â”‚   await updateDoc(docRef, {
 143 â”‚     ...data,
 144 â”‚     updatedAt: serverTimestamp()
 145 â”‚   })
 146 â”‚ }
 147 â”‚ 
 148 â”‚ export const deleteDocument = async (
 149 â”‚   collectionName: string,
 150 â”‚   id: string
 151 â”‚ ): Promise<boolean> => {
 152 â”‚   const docRef = doc(db, collectionName, id)
 153 â”‚   await deleteDoc(docRef)
 154 â”‚   return true
 155 â”‚ }
 156 â”‚ 
 157 â”‚ // FunÃ§Ãµes para gerenciar quartos
 158 â”‚ export const getRooms = async (forceRefresh = false): Promise<Room[]> => {
 159 â”‚   try {
 160 â”‚     const constraints: QueryConstraint[] = []
 161 â”‚     
 162 â”‚     constraints.push(orderBy('name', 'asc'))
 163 â”‚     
 164 â”‚     const rooms = await getDocuments<Room>('rooms', constraints, forceRefresh)
 165 â”‚     
 166 â”‚     // Garantir que todos os campos necessÃ¡rios estejam presentes
 167 â”‚     return rooms.map(room => {
 168 â”‚       console.log(`Firebase - Quarto ${room.id} dados brutos:`, room);
 169 â”‚       
 170 â”‚       // Garantir que serviceFeePct seja um nÃºmero
 171 â”‚       const serviceFeePct = room.serviceFeePct !== undefined 
 172 â”‚         ? Number(room.serviceFeePct) 
 173 â”‚         : 10;
 174 â”‚         
 175 â”‚       console.log(`Firebase - Quarto ${room.id} serviceFeePct:`, {
 176 â”‚         original: room.serviceFeePct,
 177 â”‚         tipo: typeof room.serviceFeePct,
 178 â”‚         convertido: serviceFeePct
 179 â”‚       });
 180 â”‚       
 181 â”‚       return {
 182 â”‚         id: room.id,
 183 â”‚         name: room.name || '',
 184 â”‚         type: room.type || 'standard',
 185 â”‚         description: room.description || '',
 186 â”‚         price: room.price || 0,
 187 â”‚         capacity: room.capacity || 2,
 188 â”‚         size: room.size || 0,
 189 â”‚         available: room.available !== undefined ? room.available : true,
 190 â”‚         serviceFeePct: serviceFeePct,
 191 â”‚         images: room.images || [],
 192 â”‚         amenities: room.amenities || [],
 193 â”‚         additionalServices: room.additionalServices || [],
 194 â”‚         highlights: room.highlights || [],
 195 â”‚         createdAt: room.createdAt,
 196 â”‚         updatedAt: room.updatedAt
 197 â”‚       };
 198 â”‚     });
 199 â”‚   } catch (error) {
 200 â”‚     console.error('Erro ao buscar quartos:', error)
 201 â”‚     return []
 202 â”‚   }
 203 â”‚ }
 204 â”‚ 
 205 â”‚ export const getAvailableRooms = async (
 206 â”‚   checkIn: Date,
 207 â”‚   checkOut: Date
 208 â”‚ ): Promise<Room[]> => {
 209 â”‚   try {
 210 â”‚     // Buscar todos os quartos que estÃ£o marcados como disponÃ­veis em geral
 211 â”‚     const constraints: QueryConstraint[] = [
 212 â”‚       where('available', '==', true)
 213 â”‚     ]
 214 â”‚     
 215 â”‚     const rooms = await getDocuments<Room>('rooms', constraints);
 216 â”‚     
 217 â”‚     // Filtrar os quartos que estÃ£o disponÃ­veis nas datas especÃ­ficas
 218 â”‚     return filterAvailableRoomsByDate(rooms, checkIn, checkOut);
 219 â”‚   } catch (error) {
 220 â”‚     console.error('Erro ao buscar quartos disponÃ­veis:', error)
 221 â”‚     return []
 222 â”‚   }
 223 â”‚ }
 224 â”‚ 
 225 â”‚ // FunÃ§Ã£o auxiliar para verificar disponibilidade entre datas
 226 â”‚ export const filterAvailableRoomsByDate = (
 227 â”‚   rooms: Room[],
 228 â”‚   checkIn: Date,
 229 â”‚   checkOut: Date
 230 â”‚ ): Room[] => {
 231 â”‚   // Converter checkIn e checkOut para ISO strings
 232 â”‚   const dateStrings = getDatesInRange(checkIn, checkOut);
 233 â”‚   
 234 â”‚   return rooms.filter(room => {
 235 â”‚     // Se nÃ£o tiver controle de disponibilidade especÃ­fico, considera disponÃ­vel
 236 â”‚     if (!room.availabilityDates) return true;
 237 â”‚     
 238 â”‚     // Verificar se alguma data no intervalo estÃ¡ indisponÃ­vel
 239 â”‚     return !dateStrings.some(dateStr => 
 240 â”‚       room.availabilityDates?.[dateStr] === false
 241 â”‚     );
 242 â”‚   });
 243 â”‚ };
 244 â”‚ 
 245 â”‚ // FunÃ§Ã£o para obter disponibilidade de um quarto especÃ­fico
 246 â”‚ export const getRoomAvailability = async (
 247 â”‚   roomId: string, 
 248 â”‚   startDate: Date, 
 249 â”‚   endDate: Date
 250 â”‚ ): Promise<{[date: string]: boolean}> => {
 251 â”‚   try {
 252 â”‚     const room = await getRoomById(roomId);
 253 â”‚     if (!room) throw new Error(`Quarto com ID ${roomId} nÃ£o encontrado`);
 254 â”‚     
 255 â”‚     // Gerar datas no intervalo
 256 â”‚     const dateStrings = getDatesInRange(startDate, endDate);
 257 â”‚     
 258 â”‚     // Se nÃ£o tiver configuraÃ§Ã£o de disponibilidade especÃ­fica, assume tudo disponÃ­vel
 259 â”‚     if (!room.availabilityDates) {
 260 â”‚       return dateStrings.reduce((acc, date) => {
 261 â”‚         acc[date] = true;
 262 â”‚         return acc;
 263 â”‚       }, {} as {[date: string]: boolean});
 264 â”‚     }
 265 â”‚     
 266 â”‚     // Preencher com os dados de disponibilidade existentes
 267 â”‚     return dateStrings.reduce((acc, date) => {
 268 â”‚       acc[date] = room.availabilityDates?.[date] !== false; // disponÃ­vel por padrÃ£o se nÃ£o estiver explicitamente indisponÃ­vel
 269 â”‚       return acc;
 270 â”‚     }, {} as {[date: string]: boolean});
 271 â”‚   } catch (error) {
 272 â”‚     console.error(`Erro ao verificar disponibilidade do quarto ${roomId}:`, error);
 273 â”‚     throw error;
 274 â”‚   }
 275 â”‚ };
 276 â”‚ 
 277 â”‚ // FunÃ§Ã£o para atualizar disponibilidade de um quarto
 278 â”‚ export const updateRoomAvailability = async (
 279 â”‚   roomId: string,
 280 â”‚   availabilityDates: {[date: string]: boolean}
 281 â”‚ ): Promise<boolean> => {
 282 â”‚   try {
 283 â”‚     await updateDocument('rooms', roomId, {
 284 â”‚       availabilityDates,
 285 â”‚       updatedAt: serverTimestamp()
 286 â”‚     });
 287 â”‚     return true;
 288 â”‚   } catch (error) {
 289 â”‚     console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
 290 â”‚     return false;
 291 â”‚   }
 292 â”‚ };
 293 â”‚ 
 294 â”‚ // FunÃ§Ã£o auxiliar para gerar array de strings de data entre um intervalo
 295 â”‚ export const getDatesInRange = (startDate: Date, endDate: Date): string[] => {
 296 â”‚   const dates: string[] = [];
 297 â”‚   const currentDate = new Date(startDate);
 298 â”‚   
 299 â”‚   // Normalizar para meia-noite no fuso horÃ¡rio local
 300 â”‚   currentDate.setHours(0, 0, 0, 0);
 301 â”‚   const endDateNormalized = new Date(endDate);
 302 â”‚   endDateNormalized.setHours(0, 0, 0, 0);
 303 â”‚   
 304 â”‚   // Adicionar cada data no intervalo EXCETO o dia de checkout
 305 â”‚   // Usando < em vez de <= para nÃ£o incluir o dia de checkout
 306 â”‚   while (currentDate < endDateNormalized) {
 307 â”‚     dates.push(currentDate.toISOString().split('T')[0]); // Formato YYYY-MM-DD
 308 â”‚     currentDate.setDate(currentDate.getDate() + 1);
 309 â”‚   }
 310 â”‚   
 311 â”‚   return dates;
 312 â”‚ };
 313 â”‚ 
 314 â”‚ export const getRoomById = async (id: string): Promise<Room | null> => {
 315 â”‚   try {
 316 â”‚     const room = await getDocument<Room>('rooms', id);
 317 â”‚     
 318 â”‚     if (!room) return null;
 319 â”‚     
 320 â”‚     console.log(`Firebase - getRoomById ${id} dados brutos:`, room);
 321 â”‚     
 322 â”‚     // Log especÃ­fico para serviceFeePct
 323 â”‚     console.log(`serviceFeePct no Firestore:`, room.serviceFeePct);
 324 â”‚     
 325 â”‚     // Garantir que todos os campos necessÃ¡rios estejam presentes
 326 â”‚     return {
 327 â”‚       ...room,
 328 â”‚       name: room.name || '',
 329 â”‚       type: room.type || 'standard',
 330 â”‚       description: room.description || '',
 331 â”‚       price: room.price || 0,
 332 â”‚       capacity: room.capacity || 2,
 333 â”‚       size: room.size || 0,
 334 â”‚       available: room.available !== undefined ? room.available : true,
 335 â”‚       serviceFeePct: room.serviceFeePct !== undefined ? room.serviceFeePct : 10,
 336 â”‚       images: room.images || [],
 337 â”‚       amenities: room.amenities || [],
 338 â”‚       additionalServices: room.additionalServices || [],
 339 â”‚       highlights: room.highlights || []
 340 â”‚     };
 341 â”‚   } catch (error) {
 342 â”‚     console.error(`Erro ao buscar quarto com ID ${id}:`, error);
 343 â”‚     return null;
 344 â”‚   }
 345 â”‚ }
 346 â”‚ 
 347 â”‚ export const createRoom = async (roomData: Omit<Room, 'id' | 'createdAt' | 'updatedAt'>): Promise<Room> => {
 348 â”‚   try {
 349 â”‚     console.log("createRoom - Dados recebidos:", roomData);
 350 â”‚     
 351 â”‚     const roomWithTimestamps = {
 352 â”‚       ...roomData,
 353 â”‚       available: roomData.available !== undefined ? roomData.available : true,
 354 â”‚       featured: roomData.featured || false,
 355 â”‚       amenities: roomData.amenities || [],
 356 â”‚       additionalServices: roomData.additionalServices || [],
 357 â”‚       highlights: roomData.highlights || [],
 358 â”‚       createdAt: serverTimestamp(),
 359 â”‚       updatedAt: serverTimestamp()
 360 â”‚     }
 361 â”‚     
 362 â”‚     console.log("createRoom - Dados a serem salvos:", roomWithTimestamps);
 363 â”‚     
 364 â”‚     const id = await createDocument('rooms', roomWithTimestamps)
 365 â”‚     
 366 â”‚     return {
 367 â”‚       id,
 368 â”‚       ...roomData,
 369 â”‚       amenities: roomData.amenities || [],
 370 â”‚       additionalServices: roomData.additionalServices || [],
 371 â”‚       highlights: roomData.highlights || [],
 372 â”‚       createdAt: Timestamp.now(),
 373 â”‚       updatedAt: Timestamp.now()
 374 â”‚     }
 375 â”‚   } catch (error) {
 376 â”‚     console.error('Erro ao criar quarto:', error)
 377 â”‚     throw error
 378 â”‚   }
 379 â”‚ }
 380 â”‚ 
 381 â”‚ export const updateRoom = async (id: string, roomData: Partial<Omit<Room, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Room> => {
 382 â”‚   try {
 383 â”‚     console.log(`updateRoom - ID: ${id}, Dados recebidos:`, roomData);
 384 â”‚     
 385 â”‚     // Garantir que estamos lidando explicitamente com o serviceFeePct se ele for 0
 386 â”‚     if (roomData.serviceFeePct === 0) {
 387 â”‚       console.log("updateRoom - Detectado serviceFeePct com valor 0, salvando explicitamente.", roomData.serviceFeePct);
 388 â”‚     }
 389 â”‚     
 390 â”‚     // Adicionar timestamp de atualizaÃ§Ã£o
 391 â”‚     const roomWithTimestamp = {
 392 â”‚       ...roomData,
 393 â”‚       amenities: roomData.amenities || [],
 394 â”‚       additionalServices: roomData.additionalServices || [],
 395 â”‚       highlights: roomData.highlights || [],
 396 â”‚       updatedAt: serverTimestamp()
 397 â”‚     }
 398 â”‚     
 399 â”‚     console.log(`updateRoom - Dados a serem salvos:`, roomWithTimestamp);
 400 â”‚     
 401 â”‚     await updateDocument('rooms', id, roomWithTimestamp)
 402 â”‚     
 403 â”‚     const updatedRoom = await getRoomById(id)
 404 â”‚     if (!updatedRoom) {
 405 â”‚       throw new Error(`Quarto com ID ${id} nÃ£o encontrado apÃ³s atualizaÃ§Ã£o`)
 406 â”‚     }
 407 â”‚     
 408 â”‚     return updatedRoom
 409 â”‚   } catch (error) {
 410 â”‚     console.error('Erro ao atualizar quarto:', error)
 411 â”‚     throw error
 412 â”‚   }
 413 â”‚ }
 414 â”‚ 
 415 â”‚ export const deleteRoom = async (id: string): Promise<boolean> => {
 416 â”‚   return await deleteDocument('rooms', id)
 417 â”‚ }
 418 â”‚ 
 419 â”‚ // FunÃ§Ãµes especÃ­ficas para reservas
 420 â”‚ export const createBooking = async (bookingData: any) => {
 421 â”‚   try {
 422 â”‚     const bookingsCollection = collection(db, 'bookings');
 423 â”‚     const docRef = await addDoc(bookingsCollection, bookingData);
 424 â”‚     
 425 â”‚     // CORREÃ‡ÃƒO: NÃ£o bloquear a data no momento da criaÃ§Ã£o da reserva
 426 â”‚     // O bloqueio serÃ¡ feito apenas quando o pagamento for confirmado
 427 â”‚     // atravÃ©s da funÃ§Ã£o updateBookingStatus
 428 â”‚     
 429 â”‚     return docRef;
 430 â”‚   } catch (error) {
 431 â”‚     console.error('Erro ao criar reserva:', error);
 432 â”‚     throw error;
 433 â”‚   }
 434 â”‚ };
 435 â”‚ 
 436 â”‚ // Nova funÃ§Ã£o para atualizar status da reserva e bloquear as datas da estadia
 437 â”‚ export const updateBookingStatus = async (
 438 â”‚   bookingId: string, 
 439 â”‚   newStatus: 'pending' | 'confirmed' | 'cancelled' | 'completed',
 440 â”‚   newPaymentStatus: 'pending' | 'paid' | 'refunded'
 441 â”‚ ): Promise<boolean> => {
 442 â”‚   try {
 443 â”‚     // ReferÃªncia ao documento da reserva
 444 â”‚     const bookingRef = doc(db, 'bookings', bookingId);
 445 â”‚     const bookingSnap = await getDoc(bookingRef);
 446 â”‚     
 447 â”‚     if (!bookingSnap.exists()) {
 448 â”‚       console.error(`Booking ${bookingId} nÃ£o existe ao atualizar status`);
 449 â”‚       return false;
 450 â”‚     }
 451 â”‚     
 452 â”‚     const bookingData = bookingSnap.data();
 453 â”‚     
 454 â”‚     // Atualizar o status da reserva
 455 â”‚     await updateDoc(bookingRef, {
 456 â”‚       status: newStatus,
 457 â”‚       paymentStatus: newPaymentStatus,
 458 â”‚       updatedAt: serverTimestamp(),
 459 â”‚       ...(newStatus === 'confirmed' && { confirmedAt: serverTimestamp() })
 460 â”‚     });
 461 â”‚     
 462 â”‚     // Se a reserva estÃ¡ sendo confirmada, precisamos bloquear as datas
 463 â”‚     if (newStatus === 'confirmed') {
 464 â”‚       console.log(`Atualizando disponibilidade para reserva confirmada: ${bookingId}`);
 465 â”‚       
 466 â”‚       // Recuperar datas de check-in e check-out
 467 â”‚       const checkIn = bookingData.checkIn.toDate();
 468 â”‚       const checkOut = bookingData.checkOut.toDate();
 469 â”‚       const roomId = bookingData.roomId;
 470 â”‚       
 471 â”‚       // Obter todas as datas entre check-in e check-out
 472 â”‚       const dates: Date[] = [];
 473 â”‚       const currentDate = new Date(checkIn);
 474 â”‚       
 475 â”‚       while (currentDate < checkOut) {
 476 â”‚         dates.push(new Date(currentDate));
 477 â”‚         currentDate.setDate(currentDate.getDate() + 1);
 478 â”‚       }
 479 â”‚       
 480 â”‚       console.log(`Bloqueando ${dates.length} dias para quarto ${roomId}`);
 481 â”‚       
 482 â”‚       // Atualizar disponibilidade para cada data
 483 â”‚       const availabilityUpdates: {[date: string]: boolean} = {};
 484 â”‚       
 485 â”‚       dates.forEach(date => {
 486 â”‚         const dateString = date.toISOString().split('T')[0]; // formato YYYY-MM-DD
 487 â”‚         availabilityUpdates[dateString] = false; // false significa indisponÃ­vel
 488 â”‚       });
 489 â”‚       
 490 â”‚       // Atualizar disponibilidade do quarto
 491 â”‚       if (Object.keys(availabilityUpdates).length > 0) {
 492 â”‚         try {
 493 â”‚           // Obter o documento do quarto
 494 â”‚           const roomRef = doc(db, 'rooms', roomId);
 495 â”‚           const roomSnap = await getDoc(roomRef);
 496 â”‚           
 497 â”‚           if (roomSnap.exists()) {
 498 â”‚             const roomData = roomSnap.data();
 499 â”‚             const currentAvailability = roomData.availabilityDates || {};
 500 â”‚             
 501 â”‚             // Mesclar a disponibilidade atual com as novas atualizaÃ§Ãµes
 502 â”‚             const updatedAvailability = {
 503 â”‚               ...currentAvailability,
 504 â”‚               ...availabilityUpdates
 505 â”‚             };
 506 â”‚             
 507 â”‚             // Atualizar o documento do quarto
 508 â”‚             await updateDoc(roomRef, {
 509 â”‚               availabilityDates: updatedAvailability,
 510 â”‚               updatedAt: serverTimestamp()
 511 â”‚             });
 512 â”‚             
 513 â”‚             console.log(`Disponibilidade atualizada com sucesso para quarto ${roomId}`);
 514 â”‚             
 515 â”‚             // Criar log da reserva
 516 â”‚             await addDoc(collection(db, 'bookingLogs'), {
 517 â”‚               bookingId,
 518 â”‚               roomId,
 519 â”‚               action: 'status_updated',
 520 â”‚               previousStatus: bookingData.status,
 521 â”‚               newStatus,
 522 â”‚               previousPaymentStatus: bookingData.paymentStatus,
 523 â”‚               newPaymentStatus,
 524 â”‚               datesBlocked: Object.keys(availabilityUpdates),
 525 â”‚               timestamp: serverTimestamp(),
 526 â”‚               userId: bookingData.userId || 'system'
 527 â”‚             });
 528 â”‚           } else {
 529 â”‚             console.error(`Quarto ${roomId} nÃ£o encontrado ao atualizar disponibilidade`);
 530 â”‚           }
 531 â”‚         } catch (error) {
 532 â”‚           console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
 533 â”‚         }
 534 â”‚       }
 535 â”‚     }
 536 â”‚     
 537 â”‚     return true;
 538 â”‚   } catch (error) {
 539 â”‚     console.error(`Erro ao atualizar status da reserva ${bookingId}:`, error);
 540 â”‚     return false;
 541 â”‚   }
 542 â”‚ }
 543 â”‚ 
 544 â”‚ export const getUserBookings = async (userId: string): Promise<Booking[]> => {
 545 â”‚   return getDocuments<Booking>('bookings', [
 546 â”‚     where('userId', '==', userId),
 547 â”‚     orderBy('createdAt', 'desc')
 548 â”‚   ])
 549 â”‚ }
 550 â”‚ 
 551 â”‚ export const getRecentBookings = async (count = 5): Promise<Booking[]> => {
 552 â”‚   return getDocuments<Booking>('bookings', [
 553 â”‚     orderBy('createdAt', 'desc'),
 554 â”‚     limit(count)
 555 â”‚   ])
 556 â”‚ }
 557 â”‚ 
 558 â”‚ export const getRoomBookings = async (roomId: string): Promise<Booking[]> => {
 559 â”‚   try {
 560 â”‚     const constraints: QueryConstraint[] = [
 561 â”‚       where('roomId', '==', roomId),
 562 â”‚       orderBy('checkIn', 'asc')
 563 â”‚     ];
 564 â”‚     
 565 â”‚     return await getDocuments<Booking>('bookings', constraints);
 566 â”‚   } catch (error) {
 567 â”‚     console.error(`Erro ao buscar reservas do quarto ${roomId}:`, error);
 568 â”‚     return [];
 569 â”‚   }
 570 â”‚ };
 571 â”‚ 
 572 â”‚ // FunÃ§Ãµes especÃ­ficas para contatos
 573 â”‚ export const createContactMessage = async (contactData: Contact) => {
 574 â”‚   try {
 575 â”‚     const contactsCollection = collection(db, 'contacts')
 576 â”‚     
 577 â”‚     // Garantir que o status seja 'new' para novos contatos
 578 â”‚     const contactWithDefaults = {
 579 â”‚       ...contactData,
 580 â”‚       status: contactData.status || 'new',
 581 â”‚       createdAt: contactData.createdAt || Timestamp.now()
 582 â”‚     }
 583 â”‚     
 584 â”‚     // Se tiver detalhes de reserva, adicionar metadados
 585 â”‚     if (contactWithDefaults.reservationDetails) {
 586 â”‚       // Ajustar subject para indicar que Ã© relacionado a reserva
 587 â”‚       if (!contactWithDefaults.subject.includes('Reserva')) {
 588 â”‚         contactWithDefaults.subject = `Reserva: ${contactWithDefaults.subject}`;
 589 â”‚       }
 590 â”‚     }
 591 â”‚     
 592 â”‚     const docRef = await addDoc(contactsCollection, contactWithDefaults)
 593 â”‚     return docRef
 594 â”‚   } catch (error) {
 595 â”‚     console.error('Erro ao criar mensagem de contato:', error)
 596 â”‚     throw error
 597 â”‚   }
 598 â”‚ }
 599 â”‚ 
 600 â”‚ export const getNewContactMessages = async (): Promise<Contact[]> => {
 601 â”‚   return getDocuments<Contact>('contacts', [
 602 â”‚     where('status', '==', 'new'),
 603 â”‚     orderBy('createdAt', 'desc')
 604 â”‚   ])
 605 â”‚ }
 606 â”‚ 
 607 â”‚ // FunÃ§Ãµes para Dashboard com dados reais
 608 â”‚ 
 609 â”‚ export const getDashboardStats = async () => {
 610 â”‚   try {
 611 â”‚     const [totalBookings, totalRevenue, occupancyRate, bookingsByPlatform] = await Promise.all([
 612 â”‚       getTotalBookings(),
 613 â”‚       getMonthlyRevenue(),
 614 â”‚       getOccupancyRate(),
 615 â”‚       getBookingsByPlatform()
 616 â”‚     ]);
 617 â”‚ 
 618 â”‚     return {
 619 â”‚       totalBookings,
 620 â”‚       totalRevenue,
 621 â”‚       occupancyRate,
 622 â”‚       bookingsByPlatform
 623 â”‚     };
 624 â”‚   } catch (error) {
 625 â”‚     console.error('Erro ao obter estatÃ­sticas do dashboard:', error);
 626 â”‚     throw error;
 627 â”‚   }
 628 â”‚ };
 629 â”‚ 
 630 â”‚ // Obter total de reservas
 631 â”‚ export const getTotalBookings = async () => {
 632 â”‚   try {
 633 â”‚     // Obter todas as reservas
 634 â”‚     const bookings = await getDocuments<Booking>('bookings');
 635 â”‚     
 636 â”‚     // Contar reservas por status
 637 â”‚     const confirmed = bookings.filter(b => b.status === 'confirmed').length;
 638 â”‚     const pending = bookings.filter(b => b.status === 'pending').length;
 639 â”‚     const cancelled = bookings.filter(b => b.status === 'cancelled').length;
 640 â”‚     const completed = bookings.filter(b => b.status === 'completed').length;
 641 â”‚     
 642 â”‚     // Calcular crescimento em relaÃ§Ã£o ao mÃªs anterior (simulado por enquanto)
 643 â”‚     // Em uma implementaÃ§Ã£o real, vocÃª compararia com dados do mÃªs anterior
 644 â”‚     const growth = ((confirmed + completed) / (bookings.length || 1) * 100) - 50;
 645 â”‚     
 646 â”‚     return {
 647 â”‚       total: bookings.length,
 648 â”‚       confirmed,
 649 â”‚       pending,
 650 â”‚       cancelled,
 651 â”‚       completed,
 652 â”‚       growth: Math.round(growth) // Arredonda para nÃºmero inteiro
 653 â”‚     };
 654 â”‚   } catch (error) {
 655 â”‚     console.error('Erro ao obter total de reservas:', error);
 656 â”‚     return {
 657 â”‚       total: 0,
 658 â”‚       confirmed: 0,
 659 â”‚       pending: 0, 
 660 â”‚       cancelled: 0,
 661 â”‚       completed: 0,
 662 â”‚       growth: 0
 663 â”‚     };
 664 â”‚   }
 665 â”‚ };
 666 â”‚ 
 667 â”‚ // Obter receita mensal
 668 â”‚ export const getMonthlyRevenue = async () => {
 669 â”‚   try {
 670 â”‚     const bookings = await getDocuments<Booking>('bookings');
 671 â”‚     
 672 â”‚     // Filtrar reservas confirmadas e concluÃ­das
 673 â”‚     const validBookings = bookings.filter(b => 
 674 â”‚       b.status === 'confirmed' || b.status === 'completed'
 675 â”‚     );
 676 â”‚     
 677 â”‚     // Calcular receita total
 678 â”‚     const totalRevenue = validBookings.reduce((acc, booking) => acc + booking.totalPrice, 0);
 679 â”‚     
 680 â”‚     // Agrupar receita por mÃªs
 681 â”‚     const revenueByMonth = validBookings.reduce((acc, booking) => {
 682 â”‚       const date = booking.checkIn.toDate();
 683 â”‚       const month = date.getMonth(); // 0-11
 684 â”‚       const year = date.getFullYear();
 685 â”‚       const key = `${year}-${month}`;
 686 â”‚       
 687 â”‚       if (!acc[key]) {
 688 â”‚         acc[key] = 0;
 689 â”‚       }
 690 â”‚       acc[key] += booking.totalPrice;
 691 â”‚       return acc;
 692 â”‚     }, {} as Record<string, number>);
 693 â”‚     
 694 â”‚     // Converter para formato de array para grÃ¡fico
 695 â”‚     const monthNames = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
 696 â”‚     
 697 â”‚     const currentDate = new Date();
 698 â”‚     const currentMonth = currentDate.getMonth();
 699 â”‚     const currentYear = currentDate.getFullYear();
 700 â”‚     
 701 â”‚     const revenueData = [];
 702 â”‚     
 703 â”‚     // Gerar dados dos Ãºltimos 12 meses
 704 â”‚     for (let i = 0; i < 12; i++) {
 705 â”‚       const month = (currentMonth - i + 12) % 12;
 706 â”‚       const year = currentMonth - i < 0 ? currentYear - 1 : currentYear;
 707 â”‚       const key = `${year}-${month}`;
 708 â”‚       
 709 â”‚       revenueData.unshift({
 710 â”‚         month: monthNames[month],
 711 â”‚         value: revenueByMonth[key] || 0
 712 â”‚       });
 713 â”‚     }
 714 â”‚     
 715 â”‚     // Calcular crescimento em relaÃ§Ã£o ao mÃªs anterior
 716 â”‚     const lastMonthRevenue = revenueData[revenueData.length - 2]?.value || 0;
 717 â”‚     const currentMonthRevenue = revenueData[revenueData.length - 1]?.value || 0;
 718 â”‚     
 719 â”‚     const growth = lastMonthRevenue ? ((currentMonthRevenue - lastMonthRevenue) / lastMonthRevenue) * 100 : 0;
 720 â”‚     
 721 â”‚     return {
 722 â”‚       monthly: currentMonthRevenue,
 723 â”‚       total: totalRevenue,
 724 â”‚       growth: Math.round(growth),
 725 â”‚       revenueData
 726 â”‚     };
 727 â”‚   } catch (error) {
 728 â”‚     console.error('Erro ao obter receita mensal:', error);
 729 â”‚     return {
 730 â”‚       monthly: 0,
 731 â”‚       total: 0,
 732 â”‚       growth: 0,
 733 â”‚       revenueData: []
 734 â”‚     };
 735 â”‚   }
 736 â”‚ };
 737 â”‚ 
 738 â”‚ // Calcular taxa de ocupaÃ§Ã£o
 739 â”‚ export const getOccupancyRate = async () => {
 740 â”‚   try {
 741 â”‚     // Obter todos os quartos
 742 â”‚     const rooms = await getDocuments<Room>('rooms');
 743 â”‚     const totalRooms = rooms.length;
 744 â”‚     
 745 â”‚     if (totalRooms === 0) {
 746 â”‚       return { rate: 0, growth: 0 };
 747 â”‚     }
 748 â”‚     
 749 â”‚     // Obter todas as reservas
 750 â”‚     const bookings = await getDocuments<Booking>('bookings');
 751 â”‚     
 752 â”‚     // Filtrar reservas confirmadas e concluÃ­das para o mÃªs atual
 753 â”‚     const currentDate = new Date();
 754 â”‚     const currentMonth = currentDate.getMonth();
 755 â”‚     const currentYear = currentDate.getFullYear();
 756 â”‚     
 757 â”‚     const currentMonthBookings = bookings.filter(booking => {
 758 â”‚       const checkInDate = booking.checkIn.toDate();
 759 â”‚       return (
 760 â”‚         (booking.status === 'confirmed' || booking.status === 'completed') &&
 761 â”‚         checkInDate.getMonth() === currentMonth &&
 762 â”‚         checkInDate.getFullYear() === currentYear
 763 â”‚       );
 764 â”‚     });
 765 â”‚     
 766 â”‚     // Calcular dias ocupados por quarto
 767 â”‚     const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
 768 â”‚     const totalPossibleRoomDays = totalRooms * daysInMonth;
 769 â”‚     
 770 â”‚     // Contar dias ocupados (simplificado - em produÃ§Ã£o seria mais complexo)
 771 â”‚     let occupiedDays = 0;
 772 â”‚     
 773 â”‚     currentMonthBookings.forEach(booking => {
 774 â”‚       const checkIn = booking.checkIn.toDate();
 775 â”‚       const checkOut = booking.checkOut.toDate();
 776 â”‚       
 777 â”‚       // Ajustar datas para considerar apenas o mÃªs atual
 778 â”‚       const startDate = new Date(Math.max(
 779 â”‚         checkIn.getTime(),
 780 â”‚         new Date(currentYear, currentMonth, 1).getTime()
 781 â”‚       ));
 782 â”‚       const endDate = new Date(Math.min(
 783 â”‚         checkOut.getTime(),
 784 â”‚         new Date(currentYear, currentMonth + 1, 0).getTime()
 785 â”‚       ));
 786 â”‚       
 787 â”‚       // Calcular dias entre datas (incluindo check-in, excluindo check-out)
 788 â”‚       const days = Math.max(0, Math.floor((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)));
 789 â”‚       occupiedDays += days;
 790 â”‚     });
 791 â”‚     
 792 â”‚     const occupancyRate = (occupiedDays / totalPossibleRoomDays) * 100;
 793 â”‚     
 794 â”‚     // SimulaÃ§Ã£o de crescimento (em produÃ§Ã£o, compararia com mÃªs anterior)
 795 â”‚     const growth = occupancyRate > 50 ? 5 : -3;
 796 â”‚     
 797 â”‚     return {
 798 â”‚       rate: Math.round(occupancyRate),
 799 â”‚       growth: Math.round(growth)
 800 â”‚     };
 801 â”‚   } catch (error) {
 802 â”‚     console.error('Erro ao calcular taxa de ocupaÃ§Ã£o:', error);
 803 â”‚     return { rate: 0, growth: 0 };
 804 â”‚   }
 805 â”‚ };
 806 â”‚ 
 807 â”‚ // Obter reservas agrupadas por plataforma
 808 â”‚ export const getBookingsByPlatform = async () => {
 809 â”‚   try {
 810 â”‚     const bookings = await getDocuments<Booking>('bookings');
 811 â”‚     
 812 â”‚     // Categorizar reservas por origem
 813 â”‚     const platforms = [
 814 â”‚       { 
 815 â”‚         platform: "Booking.com", 
 816 â”‚         color: "#003580", 
 817 â”‚         icon: "Globe",
 818 â”‚         bookings: []
 819 â”‚       },
 820 â”‚       { 
 821 â”‚         platform: "Airbnb", 
 822 â”‚         color: "#FF5A5F", 
 823 â”‚         icon: "Heart",
 824 â”‚         bookings: []
 825 â”‚       },
 826 â”‚       { 
 827 â”‚         platform: "Direto", 
 828 â”‚         color: "#4CAF50", 
 829 â”‚         icon: "Home",
 830 â”‚         bookings: []
 831 â”‚       }
 832 â”‚     ];
 833 â”‚     
 834 â”‚     // Para fins de demonstraÃ§Ã£o, colocar todas as reservas como "Direto" por enquanto
 835 â”‚     // Em produÃ§Ã£o, usaria um campo "platformOrigin" ou similar na tabela de reservas
 836 â”‚     const platformIndex = 2; // Ãndice da plataforma "Direto"
 837 â”‚     
 838 â”‚     bookings.forEach(booking => {
 839 â”‚       // Transformar para o formato esperado pelo componente
 840 â”‚       const transformedBooking = {
 841 â”‚         id: booking.id || '',
 842 â”‚         guestName: booking.guestName,
 843 â”‚         roomName: booking.roomName,
 844 â”‚         checkIn: booking.checkIn.toDate().toLocaleDateString('pt-PT'),
 845 â”‚         checkOut: booking.checkOut.toDate().toLocaleDateString('pt-PT'),
 846 â”‚         status: booking.status,
 847 â”‚         value: new Intl.NumberFormat('pt-PT', {
 848 â”‚           style: 'currency',
 849 â”‚           currency: 'EUR'
 850 â”‚         }).format(booking.totalPrice)
 851 â”‚       };
 852 â”‚       
 853 â”‚       // Adicionar Ã  plataforma "Direto"
 854 â”‚       (platforms[platformIndex] as any).bookings.push(transformedBooking);
 855 â”‚     });
 856 â”‚     
 857 â”‚     return platforms;
 858 â”‚   } catch (error) {
 859 â”‚     console.error('Erro ao obter reservas por plataforma:', error);
 860 â”‚     return [];
 861 â”‚   }
 862 â”‚ };
 863 â”‚ 
 864 â”‚ // FunÃ§Ã£o para obter o preÃ§o de um quarto para uma data especÃ­fica
 865 â”‚ export const getRoomPriceForDate = async (roomId: string, date: Date): Promise<number> => {
 866 â”‚   try {
 867 â”‚     const roomDoc = await getDoc(doc(db, "rooms", roomId));
 868 â”‚     
 869 â”‚     if (!roomDoc.exists()) {
 870 â”‚       throw new Error("Quarto nÃ£o encontrado");
 871 â”‚     }
 872 â”‚     
 873 â”‚     const roomData = roomDoc.data() as Room;
 874 â”‚     const basePrice = roomData.price;
 875 â”‚     
 876 â”‚     if (!roomData.seasonalPrices || roomData.seasonalPrices.length === 0) {
 877 â”‚       return basePrice;
 878 â”‚     }
 879 â”‚     
 880 â”‚     // Verificar se a data estÃ¡ dentro de algum perÃ­odo sazonal
 881 â”‚     for (const seasonalPrice of roomData.seasonalPrices) {
 882 â”‚       const startDate = new Date(seasonalPrice.startDate);
 883 â”‚       const endDate = new Date(seasonalPrice.endDate);
 884 â”‚       
 885 â”‚       if (date >= startDate && date <= endDate) {
 886 â”‚         return seasonalPrice.price;
 887 â”‚       }
 888 â”‚     }
 889 â”‚     
 890 â”‚     // Se nÃ£o cair em nenhum perÃ­odo sazonal, retorna o preÃ§o base
 891 â”‚     return basePrice;
 892 â”‚   } catch (error) {
 893 â”‚     console.error("Erro ao obter preÃ§o do quarto:", error);
 894 â”‚     throw error;
 895 â”‚   }
 896 â”‚ }
 897 â”‚ 
 898 â”‚ // FunÃ§Ã£o para calcular o preÃ§o total de uma estadia
 899 â”‚ export const calculateStayPrice = async (
 900 â”‚   roomId: string, 
 901 â”‚   checkIn: Date, 
 902 â”‚   checkOut: Date
 903 â”‚ ): Promise<{
 904 â”‚   totalPrice: number;
 905 â”‚   nightlyPrices: { date: string; price: number }[];
 906 â”‚   serviceFee: number;
 907 â”‚   totalWithFee: number;
 908 â”‚ }> => {
 909 â”‚   try {
 910 â”‚     console.log(`ğŸ” Iniciando cÃ¡lculo de preÃ§o para estadia: ${checkIn.toISOString().split('T')[0]} atÃ© ${checkOut.toISOString().split('T')[0]}`);
 911 â”‚     
 912 â”‚     const roomDoc = await getDoc(doc(db, "rooms", roomId));
 913 â”‚     
 914 â”‚     if (!roomDoc.exists()) {
 915 â”‚       throw new Error("Quarto nÃ£o encontrado");
 916 â”‚     }
 917 â”‚     
 918 â”‚     const roomData = roomDoc.data() as Room;
 919 â”‚     console.log(`ğŸ“ Dados do quarto ${roomId}:`, {
 920 â”‚       nome: roomData.name,
 921 â”‚       precoBase: roomData.price,
 922 â”‚       taxaServico: roomData.serviceFeePct || 0,
 923 â”‚       temPrecosSazonais: !!roomData.seasonalPrices?.length
 924 â”‚     });
 925 â”‚     
 926 â”‚     const nightlyPrices: { date: string; price: number }[] = [];
 927 â”‚     let totalPrice = 0;
 928 â”‚     
 929 â”‚     // Calcular o nÃºmero de noites - corrigido para usar o mÃ©todo correto de cÃ¡lculo
 930 â”‚     // O nÃºmero de noites Ã© a diferenÃ§a em dias (estadia = checkout - checkin)
 931 â”‚     const noites = differenceInDays(checkOut, checkIn);
 932 â”‚     console.log(`ğŸ—“ï¸ NÃºmero de noites calculado: ${noites}`);
 933 â”‚     
 934 â”‚     if (noites <= 0) {
 935 â”‚       console.error(`âš ï¸ Erro: nÃºmero de noites invÃ¡lido (${noites})`);
 936 â”‚       throw new Error("Data de check-out deve ser posterior Ã  data de check-in");
 937 â”‚     }
 938 â”‚     
 939 â”‚     // Para cada noite, verificar o preÃ§o aplicÃ¡vel (preÃ§o base ou sazonal)
 940 â”‚     // ComeÃ§amos exatamente do dia de check-in
 941 â”‚     const currentDate = new Date(checkIn);
 942 â”‚     currentDate.setHours(0, 0, 0, 0); // Normalizar para meia-noite
 943 â”‚     
 944 â”‚     // Processamos cada dia de estadia (noite)
 945 â”‚     console.log(`ğŸ“Š Calculando preÃ§os por noite:`);
 946 â”‚     for (let i = 0; i < noites; i++) {
 947 â”‚       // Obtemos o preÃ§o para esta data
 948 â”‚       const dateCopy = new Date(currentDate);
 949 â”‚       const priceForDate = await getRoomPriceForDate(roomId, dateCopy);
 950 â”‚       const dateString = dateCopy.toISOString().split('T')[0]; // YYYY-MM-DD
 951 â”‚       
 952 â”‚       console.log(`   - ${dateString}: â‚¬${priceForDate}`);
 953 â”‚       
 954 â”‚       nightlyPrices.push({
 955 â”‚         date: dateString,
 956 â”‚         price: priceForDate
 957 â”‚       });
 958 â”‚       
 959 â”‚       totalPrice += priceForDate;
 960 â”‚       
 961 â”‚       // AvanÃ§amos para o prÃ³ximo dia
 962 â”‚       currentDate.setDate(currentDate.getDate() + 1);
 963 â”‚     }
 964 â”‚     
 965 â”‚     // VerificaÃ§Ã£o de seguranÃ§a para o cÃ¡lculo do totalPrice
 966 â”‚     const manualTotal = nightlyPrices.reduce((sum, night) => sum + night.price, 0);
 967 â”‚     if (Math.abs(totalPrice - manualTotal) > 1) {
 968 â”‚       console.error(`âš ï¸ DiscrepÃ¢ncia detectada no cÃ¡lculo do preÃ§o total!`);
 969 â”‚       console.error(`   - Total calculado iterativamente: â‚¬${totalPrice}`);
 970 â”‚       console.error(`   - Total calculado via reduce: â‚¬${manualTotal}`);
 971 â”‚       console.error(`   - Usando o valor recalculado para seguranÃ§a!`);
 972 â”‚       totalPrice = manualTotal;
 973 â”‚     }
 974 â”‚     
 975 â”‚     // Calcular taxa de serviÃ§o
 976 â”‚     const serviceFee = (totalPrice * (roomData.serviceFeePct || 0)) / 100;
 977 â”‚     const totalWithFee = totalPrice + serviceFee;
 978 â”‚     
 979 â”‚     console.log(`ğŸ’° Resumo do cÃ¡lculo:`);
 980 â”‚     console.log(`   - Total das diÃ¡rias: â‚¬${totalPrice}`);
 981 â”‚     console.log(`   - Taxa de serviÃ§o (${roomData.serviceFeePct || 0}%): â‚¬${serviceFee}`);
 982 â”‚     console.log(`   - Total com taxas: â‚¬${totalWithFee}`);
 983 â”‚     
 984 â”‚     return {
 985 â”‚       totalPrice,
 986 â”‚       nightlyPrices,
 987 â”‚       serviceFee,
 988 â”‚       totalWithFee
 989 â”‚     };
 990 â”‚   } catch (error) {
 991 â”‚     console.error("âŒ Erro ao calcular preÃ§o da estadia:", error);
 992 â”‚     throw error;
 993 â”‚   }
 994 â”‚ } 
 995 â”‚ import { 
 996 â”‚   collection, 
     Â·   â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€
     Â·        â•°â”€â”€ `collection` redefined here
 997 â”‚   getDocs, 
 998 â”‚   getDoc, 
 999 â”‚   doc, 
     â•°â”€â”€â”€â”€

  Ã— the name `getDocs` is defined multiple times
      â•­â”€[/home/runner/workspace/lib/firebase/firestore.ts:4:1]
    4 â”‚   setDoc,
    5 â”‚   addDoc,
    6 â”‚   getDoc,
    7 â”‚   getDocs,
      Â·   â”€â”€â”€â”¬â”€â”€â”€
      Â·      â•°â”€â”€ previous definition of `getDocs` here
    8 â”‚   updateDoc,
    9 â”‚   deleteDoc,
   10 â”‚   query,
   11 â”‚   where,
   12 â”‚   orderBy,
   13 â”‚   limit,
   14 â”‚   DocumentData,
   15 â”‚   QueryConstraint,
   16 â”‚   Timestamp,
   17 â”‚   serverTimestamp
   18 â”‚ } from 'firebase/firestore'
   19 â”‚ import { db } from './config'
   20 â”‚ import { Room, SeasonalPrice } from '@/lib/types'
   21 â”‚ import { differenceInDays } from 'date-fns'
   22 â”‚ 
   23 â”‚ // Tipos de dados
   24 â”‚ export interface Booking {
   25 â”‚   id?: string
   26 â”‚   userId?: string
   27 â”‚   guestName: string
   28 â”‚   guestEmail: string
   29 â”‚   guestPhone: string
   30 â”‚   roomId: string
   31 â”‚   roomName: string
   32 â”‚   checkIn: Timestamp
   33 â”‚   checkOut: Timestamp
   34 â”‚   adults: number
   35 â”‚   children: number
   36 â”‚   totalPrice: number
   37 â”‚   status: 'pending' | 'confirmed' | 'cancelled' | 'completed'
   38 â”‚   paymentStatus: 'pending' | 'paid' | 'refunded'
   39 â”‚   specialRequests?: string
   40 â”‚   createdAt?: Timestamp
   41 â”‚   updatedAt?: Timestamp
   42 â”‚ }
   43 â”‚ 
   44 â”‚ export interface Contact {
   45 â”‚   id?: string
   46 â”‚   name: string
   47 â”‚   email: string
   48 â”‚   phone?: string
   49 â”‚   subject: string
   50 â”‚   message: string
   51 â”‚   status: 'new' | 'read' | 'replied'
   52 â”‚   createdAt: Timestamp
   53 â”‚   updatedAt?: Timestamp
   54 â”‚   repliedAt?: Timestamp
   55 â”‚   replyContent?: string
   56 â”‚   reservationDetails?: {
   57 â”‚     checkIn?: Timestamp
   58 â”‚     checkOut?: Timestamp
   59 â”‚     roomId?: string
   60 â”‚     roomName?: string
   61 â”‚     totalGuests?: number
   62 â”‚     totalPrice?: number
   63 â”‚   }
   64 â”‚ }
   65 â”‚ 
   66 â”‚ // FunÃ§Ãµes genÃ©ricas para CRUD
   67 â”‚ export const createDocument = async <T extends DocumentData>(
   68 â”‚   collectionName: string,
   69 â”‚   data: T
   70 â”‚ ): Promise<string> => {
   71 â”‚   const docRef = await addDoc(collection(db, collectionName), {
   72 â”‚     ...data,
   73 â”‚     createdAt: serverTimestamp(),
   74 â”‚     updatedAt: serverTimestamp()
   75 â”‚   })
   76 â”‚   return docRef.id
   77 â”‚ }
   78 â”‚ 
   79 â”‚ export const createDocumentWithId = async <T extends DocumentData>(
   80 â”‚   collectionName: string,
   81 â”‚   id: string,
   82 â”‚   data: T
   83 â”‚ ): Promise<void> => {
   84 â”‚   await setDoc(doc(db, collectionName, id), {
   85 â”‚     ...data,
   86 â”‚     createdAt: serverTimestamp(),
   87 â”‚     updatedAt: serverTimestamp()
   88 â”‚   })
   89 â”‚ }
   90 â”‚ 
   91 â”‚ export const getDocument = async <T>(
   92 â”‚   collectionName: string,
   93 â”‚   id: string
   94 â”‚ ): Promise<T | null> => {
   95 â”‚   const docRef = doc(db, collectionName, id)
   96 â”‚   const docSnap = await getDoc(docRef)
   97 â”‚   
   98 â”‚   if (docSnap.exists()) {
   99 â”‚     const data = docSnap.data();
  100 â”‚     console.log("Dados brutos recuperados do Firestore para quarto:", id, data);
  101 â”‚     
  102 â”‚     if (data?.serviceFeePct !== undefined) {
  103 â”‚       console.log("serviceFeePct antes da conversÃ£o:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
  104 â”‚       // Garantir que serviceFeePct seja um nÃºmero
  105 â”‚       data.serviceFeePct = Number(data.serviceFeePct);
  106 â”‚       console.log("serviceFeePct apÃ³s conversÃ£o:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
  107 â”‚     }
  108 â”‚     
  109 â”‚     return { id: docSnap.id, ...data } as T
  110 â”‚   } else {
  111 â”‚     return null
  112 â”‚   }
  113 â”‚ }
  114 â”‚ 
  115 â”‚ export const getDocuments = async <T>(
  116 â”‚   collectionName: string,
  117 â”‚   constraints: QueryConstraint[] = [],
  118 â”‚   forceRefresh = false
  119 â”‚ ): Promise<T[]> => {
  120 â”‚   try {
  121 â”‚     const collectionRef = collection(db, collectionName)
  122 â”‚     const q = query(collectionRef, ...constraints)
  123 â”‚     
  124 â”‚     // Se forceRefresh for verdadeiro, adicionar opÃ§Ãµes que forÃ§am uma nova consulta ao Firestore
  125 â”‚     const querySnapshot = await getDocs(q)
  126 â”‚     
  127 â”‚     console.log(`Buscando documentos na coleÃ§Ã£o ${collectionName} - ForÃ§a atualizaÃ§Ã£o: ${forceRefresh}`);
  128 â”‚     
  129 â”‚     return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }) as T)
  130 â”‚   } catch (error) {
  131 â”‚     console.error(`Erro ao buscar documentos da coleÃ§Ã£o ${collectionName}:`, error);
  132 â”‚     return [];
  133 â”‚   }
  134 â”‚ }
  135 â”‚ 
  136 â”‚ export const updateDocument = async <T extends DocumentData>(
  137 â”‚   collectionName: string,
  138 â”‚   id: string,
  139 â”‚   data: Partial<T>
  140 â”‚ ): Promise<void> => {
  141 â”‚   const docRef = doc(db, collectionName, id)
  142 â”‚   await updateDoc(docRef, {
  143 â”‚     ...data,
  144 â”‚     updatedAt: serverTimestamp()
  145 â”‚   })
  146 â”‚ }
  147 â”‚ 
  148 â”‚ export const deleteDocument = async (
  149 â”‚   collectionName: string,
  150 â”‚   id: string
  151 â”‚ ): Promise<boolean> => {
  152 â”‚   const docRef = doc(db, collectionName, id)
  153 â”‚   await deleteDoc(docRef)
  154 â”‚   return true
  155 â”‚ }
  156 â”‚ 
  157 â”‚ // FunÃ§Ãµes para gerenciar quartos
  158 â”‚ export const getRooms = async (forceRefresh = false): Promise<Room[]> => {
  159 â”‚   try {
  160 â”‚     const constraints: QueryConstraint[] = []
  161 â”‚     
  162 â”‚     constraints.push(orderBy('name', 'asc'))
  163 â”‚     
  164 â”‚     const rooms = await getDocuments<Room>('rooms', constraints, forceRefresh)
  165 â”‚     
  166 â”‚     // Garantir que todos os campos necessÃ¡rios estejam presentes
  167 â”‚     return rooms.map(room => {
  168 â”‚       console.log(`Firebase - Quarto ${room.id} dados brutos:`, room);
  169 â”‚       
  170 â”‚       // Garantir que serviceFeePct seja um nÃºmero
  171 â”‚       const serviceFeePct = room.serviceFeePct !== undefined 
  172 â”‚         ? Number(room.serviceFeePct) 
  173 â”‚         : 10;
  174 â”‚         
  175 â”‚       console.log(`Firebase - Quarto ${room.id} serviceFeePct:`, {
  176 â”‚         original: room.serviceFeePct,
  177 â”‚         tipo: typeof room.serviceFeePct,
  178 â”‚         convertido: serviceFeePct
  179 â”‚       });
  180 â”‚       
  181 â”‚       return {
  182 â”‚         id: room.id,
  183 â”‚         name: room.name || '',
  184 â”‚         type: room.type || 'standard',
  185 â”‚         description: room.description || '',
  186 â”‚         price: room.price || 0,
  187 â”‚         capacity: room.capacity || 2,
  188 â”‚         size: room.size || 0,
  189 â”‚         available: room.available !== undefined ? room.available : true,
  190 â”‚         serviceFeePct: serviceFeePct,
  191 â”‚         images: room.images || [],
  192 â”‚         amenities: room.amenities || [],
  193 â”‚         additionalServices: room.additionalServices || [],
  194 â”‚         highlights: room.highlights || [],
  195 â”‚         createdAt: room.createdAt,
  196 â”‚         updatedAt: room.updatedAt
  197 â”‚       };
  198 â”‚     });
  199 â”‚   } catch (error) {
  200 â”‚     console.error('Erro ao buscar quartos:', error)
  201 â”‚     return []
  202 â”‚   }
  203 â”‚ }
  204 â”‚ 
  205 â”‚ export const getAvailableRooms = async (
  206 â”‚   checkIn: Date,
  207 â”‚   checkOut: Date
  208 â”‚ ): Promise<Room[]> => {
  209 â”‚   try {
  210 â”‚     // Buscar todos os quartos que estÃ£o marcados como disponÃ­veis em geral
  211 â”‚     const constraints: QueryConstraint[] = [
  212 â”‚       where('available', '==', true)
  213 â”‚     ]
  214 â”‚     
  215 â”‚     const rooms = await getDocuments<Room>('rooms', constraints);
  216 â”‚     
  217 â”‚     // Filtrar os quartos que estÃ£o disponÃ­veis nas datas especÃ­ficas
  218 â”‚     return filterAvailableRoomsByDate(rooms, checkIn, checkOut);
  219 â”‚   } catch (error) {
  220 â”‚     console.error('Erro ao buscar quartos disponÃ­veis:', error)
  221 â”‚     return []
  222 â”‚   }
  223 â”‚ }
  224 â”‚ 
  225 â”‚ // FunÃ§Ã£o auxiliar para verificar disponibilidade entre datas
  226 â”‚ export const filterAvailableRoomsByDate = (
  227 â”‚   rooms: Room[],
  228 â”‚   checkIn: Date,
  229 â”‚   checkOut: Date
  230 â”‚ ): Room[] => {
  231 â”‚   // Converter checkIn e checkOut para ISO strings
  232 â”‚   const dateStrings = getDatesInRange(checkIn, checkOut);
  233 â”‚   
  234 â”‚   return rooms.filter(room => {
  235 â”‚     // Se nÃ£o tiver controle de disponibilidade especÃ­fico, considera disponÃ­vel
  236 â”‚     if (!room.availabilityDates) return true;
  237 â”‚     
  238 â”‚     // Verificar se alguma data no intervalo estÃ¡ indisponÃ­vel
  239 â”‚     return !dateStrings.some(dateStr => 
  240 â”‚       room.availabilityDates?.[dateStr] === false
  241 â”‚     );
  242 â”‚   });
  243 â”‚ };
  244 â”‚ 
  245 â”‚ // FunÃ§Ã£o para obter disponibilidade de um quarto especÃ­fico
  246 â”‚ export const getRoomAvailability = async (
  247 â”‚   roomId: string, 
  248 â”‚   startDate: Date, 
  249 â”‚   endDate: Date
  250 â”‚ ): Promise<{[date: string]: boolean}> => {
  251 â”‚   try {
  252 â”‚     const room = await getRoomById(roomId);
  253 â”‚     if (!room) throw new Error(`Quarto com ID ${roomId} nÃ£o encontrado`);
  254 â”‚     
  255 â”‚     // Gerar datas no intervalo
  256 â”‚     const dateStrings = getDatesInRange(startDate, endDate);
  257 â”‚     
  258 â”‚     // Se nÃ£o tiver configuraÃ§Ã£o de disponibilidade especÃ­fica, assume tudo disponÃ­vel
  259 â”‚     if (!room.availabilityDates) {
  260 â”‚       return dateStrings.reduce((acc, date) => {
  261 â”‚         acc[date] = true;
  262 â”‚         return acc;
  263 â”‚       }, {} as {[date: string]: boolean});
  264 â”‚     }
  265 â”‚     
  266 â”‚     // Preencher com os dados de disponibilidade existentes
  267 â”‚     return dateStrings.reduce((acc, date) => {
  268 â”‚       acc[date] = room.availabilityDates?.[date] !== false; // disponÃ­vel por padrÃ£o se nÃ£o estiver explicitamente indisponÃ­vel
  269 â”‚       return acc;
  270 â”‚     }, {} as {[date: string]: boolean});
  271 â”‚   } catch (error) {
  272 â”‚     console.error(`Erro ao verificar disponibilidade do quarto ${roomId}:`, error);
  273 â”‚     throw error;
  274 â”‚   }
  275 â”‚ };
  276 â”‚ 
  277 â”‚ // FunÃ§Ã£o para atualizar disponibilidade de um quarto
  278 â”‚ export const updateRoomAvailability = async (
  279 â”‚   roomId: string,
  280 â”‚   availabilityDates: {[date: string]: boolean}
  281 â”‚ ): Promise<boolean> => {
  282 â”‚   try {
  283 â”‚     await updateDocument('rooms', roomId, {
  284 â”‚       availabilityDates,
  285 â”‚       updatedAt: serverTimestamp()
  286 â”‚     });
  287 â”‚     return true;
  288 â”‚   } catch (error) {
  289 â”‚     console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  290 â”‚     return false;
  291 â”‚   }
  292 â”‚ };
  293 â”‚ 
  294 â”‚ // FunÃ§Ã£o auxiliar para gerar array de strings de data entre um intervalo
  295 â”‚ export const getDatesInRange = (startDate: Date, endDate: Date): string[] => {
  296 â”‚   const dates: string[] = [];
  297 â”‚   const currentDate = new Date(startDate);
  298 â”‚   
  299 â”‚   // Normalizar para meia-noite no fuso horÃ¡rio local
  300 â”‚   currentDate.setHours(0, 0, 0, 0);
  301 â”‚   const endDateNormalized = new Date(endDate);
  302 â”‚   endDateNormalized.setHours(0, 0, 0, 0);
  303 â”‚   
  304 â”‚   // Adicionar cada data no intervalo EXCETO o dia de checkout
  305 â”‚   // Usando < em vez de <= para nÃ£o incluir o dia de checkout
  306 â”‚   while (currentDate < endDateNormalized) {
  307 â”‚     dates.push(currentDate.toISOString().split('T')[0]); // Formato YYYY-MM-DD
  308 â”‚     currentDate.setDate(currentDate.getDate() + 1);
  309 â”‚   }
  310 â”‚   
  311 â”‚   return dates;
  312 â”‚ };
  313 â”‚ 
  314 â”‚ export const getRoomById = async (id: string): Promise<Room | null> => {
  315 â”‚   try {
  316 â”‚     const room = await getDocument<Room>('rooms', id);
  317 â”‚     
  318 â”‚     if (!room) return null;
  319 â”‚     
  320 â”‚     console.log(`Firebase - getRoomById ${id} dados brutos:`, room);
  321 â”‚     
  322 â”‚     // Log especÃ­fico para serviceFeePct
  323 â”‚     console.log(`serviceFeePct no Firestore:`, room.serviceFeePct);
  324 â”‚     
  325 â”‚     // Garantir que todos os campos necessÃ¡rios estejam presentes
  326 â”‚     return {
  327 â”‚       ...room,
  328 â”‚       name: room.name || '',
  329 â”‚       type: room.type || 'standard',
  330 â”‚       description: room.description || '',
  331 â”‚       price: room.price || 0,
  332 â”‚       capacity: room.capacity || 2,
  333 â”‚       size: room.size || 0,
  334 â”‚       available: room.available !== undefined ? room.available : true,
  335 â”‚       serviceFeePct: room.serviceFeePct !== undefined ? room.serviceFeePct : 10,
  336 â”‚       images: room.images || [],
  337 â”‚       amenities: room.amenities || [],
  338 â”‚       additionalServices: room.additionalServices || [],
  339 â”‚       highlights: room.highlights || []
  340 â”‚     };
  341 â”‚   } catch (error) {
  342 â”‚     console.error(`Erro ao buscar quarto com ID ${id}:`, error);
  343 â”‚     return null;
  344 â”‚   }
  345 â”‚ }
  346 â”‚ 
  347 â”‚ export const createRoom = async (roomData: Omit<Room, 'id' | 'createdAt' | 'updatedAt'>): Promise<Room> => {
  348 â”‚   try {
  349 â”‚     console.log("createRoom - Dados recebidos:", roomData);
  350 â”‚     
  351 â”‚     const roomWithTimestamps = {
  352 â”‚       ...roomData,
  353 â”‚       available: roomData.available !== undefined ? roomData.available : true,
  354 â”‚       featured: roomData.featured || false,
  355 â”‚       amenities: roomData.amenities || [],
  356 â”‚       additionalServices: roomData.additionalServices || [],
  357 â”‚       highlights: roomData.highlights || [],
  358 â”‚       createdAt: serverTimestamp(),
  359 â”‚       updatedAt: serverTimestamp()
  360 â”‚     }
  361 â”‚     
  362 â”‚     console.log("createRoom - Dados a serem salvos:", roomWithTimestamps);
  363 â”‚     
  364 â”‚     const id = await createDocument('rooms', roomWithTimestamps)
  365 â”‚     
  366 â”‚     return {
  367 â”‚       id,
  368 â”‚       ...roomData,
  369 â”‚       amenities: roomData.amenities || [],
  370 â”‚       additionalServices: roomData.additionalServices || [],
  371 â”‚       highlights: roomData.highlights || [],
  372 â”‚       createdAt: Timestamp.now(),
  373 â”‚       updatedAt: Timestamp.now()
  374 â”‚     }
  375 â”‚   } catch (error) {
  376 â”‚     console.error('Erro ao criar quarto:', error)
  377 â”‚     throw error
  378 â”‚   }
  379 â”‚ }
  380 â”‚ 
  381 â”‚ export const updateRoom = async (id: string, roomData: Partial<Omit<Room, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Room> => {
  382 â”‚   try {
  383 â”‚     console.log(`updateRoom - ID: ${id}, Dados recebidos:`, roomData);
  384 â”‚     
  385 â”‚     // Garantir que estamos lidando explicitamente com o serviceFeePct se ele for 0
  386 â”‚     if (roomData.serviceFeePct === 0) {
  387 â”‚       console.log("updateRoom - Detectado serviceFeePct com valor 0, salvando explicitamente.", roomData.serviceFeePct);
  388 â”‚     }
  389 â”‚     
  390 â”‚     // Adicionar timestamp de atualizaÃ§Ã£o
  391 â”‚     const roomWithTimestamp = {
  392 â”‚       ...roomData,
  393 â”‚       amenities: roomData.amenities || [],
  394 â”‚       additionalServices: roomData.additionalServices || [],
  395 â”‚       highlights: roomData.highlights || [],
  396 â”‚       updatedAt: serverTimestamp()
  397 â”‚     }
  398 â”‚     
  399 â”‚     console.log(`updateRoom - Dados a serem salvos:`, roomWithTimestamp);
  400 â”‚     
  401 â”‚     await updateDocument('rooms', id, roomWithTimestamp)
  402 â”‚     
  403 â”‚     const updatedRoom = await getRoomById(id)
  404 â”‚     if (!updatedRoom) {
  405 â”‚       throw new Error(`Quarto com ID ${id} nÃ£o encontrado apÃ³s atualizaÃ§Ã£o`)
  406 â”‚     }
  407 â”‚     
  408 â”‚     return updatedRoom
  409 â”‚   } catch (error) {
  410 â”‚     console.error('Erro ao atualizar quarto:', error)
  411 â”‚     throw error
  412 â”‚   }
  413 â”‚ }
  414 â”‚ 
  415 â”‚ export const deleteRoom = async (id: string): Promise<boolean> => {
  416 â”‚   return await deleteDocument('rooms', id)
  417 â”‚ }
  418 â”‚ 
  419 â”‚ // FunÃ§Ãµes especÃ­ficas para reservas
  420 â”‚ export const createBooking = async (bookingData: any) => {
  421 â”‚   try {
  422 â”‚     const bookingsCollection = collection(db, 'bookings');
  423 â”‚     const docRef = await addDoc(bookingsCollection, bookingData);
  424 â”‚     
  425 â”‚     // CORREÃ‡ÃƒO: NÃ£o bloquear a data no momento da criaÃ§Ã£o da reserva
  426 â”‚     // O bloqueio serÃ¡ feito apenas quando o pagamento for confirmado
  427 â”‚     // atravÃ©s da funÃ§Ã£o updateBookingStatus
  428 â”‚     
  429 â”‚     return docRef;
  430 â”‚   } catch (error) {
  431 â”‚     console.error('Erro ao criar reserva:', error);
  432 â”‚     throw error;
  433 â”‚   }
  434 â”‚ };
  435 â”‚ 
  436 â”‚ // Nova funÃ§Ã£o para atualizar status da reserva e bloquear as datas da estadia
  437 â”‚ export const updateBookingStatus = async (
  438 â”‚   bookingId: string, 
  439 â”‚   newStatus: 'pending' | 'confirmed' | 'cancelled' | 'completed',
  440 â”‚   newPaymentStatus: 'pending' | 'paid' | 'refunded'
  441 â”‚ ): Promise<boolean> => {
  442 â”‚   try {
  443 â”‚     // ReferÃªncia ao documento da reserva
  444 â”‚     const bookingRef = doc(db, 'bookings', bookingId);
  445 â”‚     const bookingSnap = await getDoc(bookingRef);
  446 â”‚     
  447 â”‚     if (!bookingSnap.exists()) {
  448 â”‚       console.error(`Booking ${bookingId} nÃ£o existe ao atualizar status`);
  449 â”‚       return false;
  450 â”‚     }
  451 â”‚     
  452 â”‚     const bookingData = bookingSnap.data();
  453 â”‚     
  454 â”‚     // Atualizar o status da reserva
  455 â”‚     await updateDoc(bookingRef, {
  456 â”‚       status: newStatus,
  457 â”‚       paymentStatus: newPaymentStatus,
  458 â”‚       updatedAt: serverTimestamp(),
  459 â”‚       ...(newStatus === 'confirmed' && { confirmedAt: serverTimestamp() })
  460 â”‚     });
  461 â”‚     
  462 â”‚     // Se a reserva estÃ¡ sendo confirmada, precisamos bloquear as datas
  463 â”‚     if (newStatus === 'confirmed') {
  464 â”‚       console.log(`Atualizando disponibilidade para reserva confirmada: ${bookingId}`);
  465 â”‚       
  466 â”‚       // Recuperar datas de check-in e check-out
  467 â”‚       const checkIn = bookingData.checkIn.toDate();
  468 â”‚       const checkOut = bookingData.checkOut.toDate();
  469 â”‚       const roomId = bookingData.roomId;
  470 â”‚       
  471 â”‚       // Obter todas as datas entre check-in e check-out
  472 â”‚       const dates: Date[] = [];
  473 â”‚       const currentDate = new Date(checkIn);
  474 â”‚       
  475 â”‚       while (currentDate < checkOut) {
  476 â”‚         dates.push(new Date(currentDate));
  477 â”‚         currentDate.setDate(currentDate.getDate() + 1);
  478 â”‚       }
  479 â”‚       
  480 â”‚       console.log(`Bloqueando ${dates.length} dias para quarto ${roomId}`);
  481 â”‚       
  482 â”‚       // Atualizar disponibilidade para cada data
  483 â”‚       const availabilityUpdates: {[date: string]: boolean} = {};
  484 â”‚       
  485 â”‚       dates.forEach(date => {
  486 â”‚         const dateString = date.toISOString().split('T')[0]; // formato YYYY-MM-DD
  487 â”‚         availabilityUpdates[dateString] = false; // false significa indisponÃ­vel
  488 â”‚       });
  489 â”‚       
  490 â”‚       // Atualizar disponibilidade do quarto
  491 â”‚       if (Object.keys(availabilityUpdates).length > 0) {
  492 â”‚         try {
  493 â”‚           // Obter o documento do quarto
  494 â”‚           const roomRef = doc(db, 'rooms', roomId);
  495 â”‚           const roomSnap = await getDoc(roomRef);
  496 â”‚           
  497 â”‚           if (roomSnap.exists()) {
  498 â”‚             const roomData = roomSnap.data();
  499 â”‚             const currentAvailability = roomData.availabilityDates || {};
  500 â”‚             
  501 â”‚             // Mesclar a disponibilidade atual com as novas atualizaÃ§Ãµes
  502 â”‚             const updatedAvailability = {
  503 â”‚               ...currentAvailability,
  504 â”‚               ...availabilityUpdates
  505 â”‚             };
  506 â”‚             
  507 â”‚             // Atualizar o documento do quarto
  508 â”‚             await updateDoc(roomRef, {
  509 â”‚               availabilityDates: updatedAvailability,
  510 â”‚               updatedAt: serverTimestamp()
  511 â”‚             });
  512 â”‚             
  513 â”‚             console.log(`Disponibilidade atualizada com sucesso para quarto ${roomId}`);
  514 â”‚             
  515 â”‚             // Criar log da reserva
  516 â”‚             await addDoc(collection(db, 'bookingLogs'), {
  517 â”‚               bookingId,
  518 â”‚               roomId,
  519 â”‚               action: 'status_updated',
  520 â”‚               previousStatus: bookingData.status,
  521 â”‚               newStatus,
  522 â”‚               previousPaymentStatus: bookingData.paymentStatus,
  523 â”‚               newPaymentStatus,
  524 â”‚               datesBlocked: Object.keys(availabilityUpdates),
  525 â”‚               timestamp: serverTimestamp(),
  526 â”‚               userId: bookingData.userId || 'system'
  527 â”‚             });
  528 â”‚           } else {
  529 â”‚             console.error(`Quarto ${roomId} nÃ£o encontrado ao atualizar disponibilidade`);
  530 â”‚           }
  531 â”‚         } catch (error) {
  532 â”‚           console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  533 â”‚         }
  534 â”‚       }
  535 â”‚     }
  536 â”‚     
  537 â”‚     return true;
  538 â”‚   } catch (error) {
  539 â”‚     console.error(`Erro ao atualizar status da reserva ${bookingId}:`, error);
  540 â”‚     return false;
  541 â”‚   }
  542 â”‚ }
  543 â”‚ 
  544 â”‚ export const getUserBookings = async (userId: string): Promise<Booking[]> => {
  545 â”‚   return getDocuments<Booking>('bookings', [
  546 â”‚     where('userId', '==', userId),
  547 â”‚     orderBy('createdAt', 'desc')
  548 â”‚   ])
  549 â”‚ }
  550 â”‚ 
  551 â”‚ export const getRecentBookings = async (count = 5): Promise<Booking[]> => {
  552 â”‚   return getDocuments<Booking>('bookings', [
  553 â”‚     orderBy('createdAt', 'desc'),
  554 â”‚     limit(count)
  555 â”‚   ])
  556 â”‚ }
  557 â”‚ 
  558 â”‚ export const getRoomBookings = async (roomId: string): Promise<Booking[]> => {
  559 â”‚   try {
  560 â”‚     const constraints: QueryConstraint[] = [
  561 â”‚       where('roomId', '==', roomId),
  562 â”‚       orderBy('checkIn', 'asc')
  563 â”‚     ];
  564 â”‚     
  565 â”‚     return await getDocuments<Booking>('bookings', constraints);
  566 â”‚   } catch (error) {
  567 â”‚     console.error(`Erro ao buscar reservas do quarto ${roomId}:`, error);
  568 â”‚     return [];
  569 â”‚   }
  570 â”‚ };
  571 â”‚ 
  572 â”‚ // FunÃ§Ãµes especÃ­ficas para contatos
  573 â”‚ export const createContactMessage = async (contactData: Contact) => {
  574 â”‚   try {
  575 â”‚     const contactsCollection = collection(db, 'contacts')
  576 â”‚     
  577 â”‚     // Garantir que o status seja 'new' para novos contatos
  578 â”‚     const contactWithDefaults = {
  579 â”‚       ...contactData,
  580 â”‚       status: contactData.status || 'new',
  581 â”‚       createdAt: contactData.createdAt || Timestamp.now()
  582 â”‚     }
  583 â”‚     
  584 â”‚     // Se tiver detalhes de reserva, adicionar metadados
  585 â”‚     if (contactWithDefaults.reservationDetails) {
  586 â”‚       // Ajustar subject para indicar que Ã© relacionado a reserva
  587 â”‚       if (!contactWithDefaults.subject.includes('Reserva')) {
  588 â”‚         contactWithDefaults.subject = `Reserva: ${contactWithDefaults.subject}`;
  589 â”‚       }
  590 â”‚     }
  591 â”‚     
  592 â”‚     const docRef = await addDoc(contactsCollection, contactWithDefaults)
  593 â”‚     return docRef
  594 â”‚   } catch (error) {
  595 â”‚     console.error('Erro ao criar mensagem de contato:', error)
  596 â”‚     throw error
  597 â”‚   }
  598 â”‚ }
  599 â”‚ 
  600 â”‚ export const getNewContactMessages = async (): Promise<Contact[]> => {
  601 â”‚   return getDocuments<Contact>('contacts', [
  602 â”‚     where('status', '==', 'new'),
  603 â”‚     orderBy('createdAt', 'desc')
  604 â”‚   ])
  605 â”‚ }
  606 â”‚ 
  607 â”‚ // FunÃ§Ãµes para Dashboard com dados reais
  608 â”‚ 
  609 â”‚ export const getDashboardStats = async () => {
  610 â”‚   try {
  611 â”‚     const [totalBookings, totalRevenue, occupancyRate, bookingsByPlatform] = await Promise.all([
  612 â”‚       getTotalBookings(),
  613 â”‚       getMonthlyRevenue(),
  614 â”‚       getOccupancyRate(),
  615 â”‚       getBookingsByPlatform()
  616 â”‚     ]);
  617 â”‚ 
  618 â”‚     return {
  619 â”‚       totalBookings,
  620 â”‚       totalRevenue,
  621 â”‚       occupancyRate,
  622 â”‚       bookingsByPlatform
  623 â”‚     };
  624 â”‚   } catch (error) {
  625 â”‚     console.error('Erro ao obter estatÃ­sticas do dashboard:', error);
  626 â”‚     throw error;
  627 â”‚   }
  628 â”‚ };
  629 â”‚ 
  630 â”‚ // Obter total de reservas
  631 â”‚ export const getTotalBookings = async () => {
  632 â”‚   try {
  633 â”‚     // Obter todas as reservas
  634 â”‚     const bookings = await getDocuments<Booking>('bookings');
  635 â”‚     
  636 â”‚     // Contar reservas por status
  637 â”‚     const confirmed = bookings.filter(b => b.status === 'confirmed').length;
  638 â”‚     const pending = bookings.filter(b => b.status === 'pending').length;
  639 â”‚     const cancelled = bookings.filter(b => b.status === 'cancelled').length;
  640 â”‚     const completed = bookings.filter(b => b.status === 'completed').length;
  641 â”‚     
  642 â”‚     // Calcular crescimento em relaÃ§Ã£o ao mÃªs anterior (simulado por enquanto)
  643 â”‚     // Em uma implementaÃ§Ã£o real, vocÃª compararia com dados do mÃªs anterior
  644 â”‚     const growth = ((confirmed + completed) / (bookings.length || 1) * 100) - 50;
  645 â”‚     
  646 â”‚     return {
  647 â”‚       total: bookings.length,
  648 â”‚       confirmed,
  649 â”‚       pending,
  650 â”‚       cancelled,
  651 â”‚       completed,
  652 â”‚       growth: Math.round(growth) // Arredonda para nÃºmero inteiro
  653 â”‚     };
  654 â”‚   } catch (error) {
  655 â”‚     console.error('Erro ao obter total de reservas:', error);
  656 â”‚     return {
  657 â”‚       total: 0,
  658 â”‚       confirmed: 0,
  659 â”‚       pending: 0, 
  660 â”‚       cancelled: 0,
  661 â”‚       completed: 0,
  662 â”‚       growth: 0
  663 â”‚     };
  664 â”‚   }
  665 â”‚ };
  666 â”‚ 
  667 â”‚ // Obter receita mensal
  668 â”‚ export const getMonthlyRevenue = async () => {
  669 â”‚   try {
  670 â”‚     const bookings = await getDocuments<Booking>('bookings');
  671 â”‚     
  672 â”‚     // Filtrar reservas confirmadas e concluÃ­das
  673 â”‚     const validBookings = bookings.filter(b => 
  674 â”‚       b.status === 'confirmed' || b.status === 'completed'
  675 â”‚     );
  676 â”‚     
  677 â”‚     // Calcular receita total
  678 â”‚     const totalRevenue = validBookings.reduce((acc, booking) => acc + booking.totalPrice, 0);
  679 â”‚     
  680 â”‚     // Agrupar receita por mÃªs
  681 â”‚     const revenueByMonth = validBookings.reduce((acc, booking) => {
  682 â”‚       const date = booking.checkIn.toDate();
  683 â”‚       const month = date.getMonth(); // 0-11
  684 â”‚       const year = date.getFullYear();
  685 â”‚       const key = `${year}-${month}`;
  686 â”‚       
  687 â”‚       if (!acc[key]) {
  688 â”‚         acc[key] = 0;
  689 â”‚       }
  690 â”‚       acc[key] += booking.totalPrice;
  691 â”‚       return acc;
  692 â”‚     }, {} as Record<string, number>);
  693 â”‚     
  694 â”‚     // Converter para formato de array para grÃ¡fico
  695 â”‚     const monthNames = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
  696 â”‚     
  697 â”‚     const currentDate = new Date();
  698 â”‚     const currentMonth = currentDate.getMonth();
  699 â”‚     const currentYear = currentDate.getFullYear();
  700 â”‚     
  701 â”‚     const revenueData = [];
  702 â”‚     
  703 â”‚     // Gerar dados dos Ãºltimos 12 meses
  704 â”‚     for (let i = 0; i < 12; i++) {
  705 â”‚       const month = (currentMonth - i + 12) % 12;
  706 â”‚       const year = currentMonth - i < 0 ? currentYear - 1 : currentYear;
  707 â”‚       const key = `${year}-${month}`;
  708 â”‚       
  709 â”‚       revenueData.unshift({
  710 â”‚         month: monthNames[month],
  711 â”‚         value: revenueByMonth[key] || 0
  712 â”‚       });
  713 â”‚     }
  714 â”‚     
  715 â”‚     // Calcular crescimento em relaÃ§Ã£o ao mÃªs anterior
  716 â”‚     const lastMonthRevenue = revenueData[revenueData.length - 2]?.value || 0;
  717 â”‚     const currentMonthRevenue = revenueData[revenueData.length - 1]?.value || 0;
  718 â”‚     
  719 â”‚     const growth = lastMonthRevenue ? ((currentMonthRevenue - lastMonthRevenue) / lastMonthRevenue) * 100 : 0;
  720 â”‚     
  721 â”‚     return {
  722 â”‚       monthly: currentMonthRevenue,
  723 â”‚       total: totalRevenue,
  724 â”‚       growth: Math.round(growth),
  725 â”‚       revenueData
  726 â”‚     };
  727 â”‚   } catch (error) {
  728 â”‚     console.error('Erro ao obter receita mensal:', error);
  729 â”‚     return {
  730 â”‚       monthly: 0,
  731 â”‚       total: 0,
  732 â”‚       growth: 0,
  733 â”‚       revenueData: []
  734 â”‚     };
  735 â”‚   }
  736 â”‚ };
  737 â”‚ 
  738 â”‚ // Calcular taxa de ocupaÃ§Ã£o
  739 â”‚ export const getOccupancyRate = async () => {
  740 â”‚   try {
  741 â”‚     // Obter todos os quartos
  742 â”‚     const rooms = await getDocuments<Room>('rooms');
  743 â”‚     const totalRooms = rooms.length;
  744 â”‚     
  745 â”‚     if (totalRooms === 0) {
  746 â”‚       return { rate: 0, growth: 0 };
  747 â”‚     }
  748 â”‚     
  749 â”‚     // Obter todas as reservas
  750 â”‚     const bookings = await getDocuments<Booking>('bookings');
  751 â”‚     
  752 â”‚     // Filtrar reservas confirmadas e concluÃ­das para o mÃªs atual
  753 â”‚     const currentDate = new Date();
  754 â”‚     const currentMonth = currentDate.getMonth();
  755 â”‚     const currentYear = currentDate.getFullYear();
  756 â”‚     
  757 â”‚     const currentMonthBookings = bookings.filter(booking => {
  758 â”‚       const checkInDate = booking.checkIn.toDate();
  759 â”‚       return (
  760 â”‚         (booking.status === 'confirmed' || booking.status === 'completed') &&
  761 â”‚         checkInDate.getMonth() === currentMonth &&
  762 â”‚         checkInDate.getFullYear() === currentYear
  763 â”‚       );
  764 â”‚     });
  765 â”‚     
  766 â”‚     // Calcular dias ocupados por quarto
  767 â”‚     const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
  768 â”‚     const totalPossibleRoomDays = totalRooms * daysInMonth;
  769 â”‚     
  770 â”‚     // Contar dias ocupados (simplificado - em produÃ§Ã£o seria mais complexo)
  771 â”‚     let occupiedDays = 0;
  772 â”‚     
  773 â”‚     currentMonthBookings.forEach(booking => {
  774 â”‚       const checkIn = booking.checkIn.toDate();
  775 â”‚       const checkOut = booking.checkOut.toDate();
  776 â”‚       
  777 â”‚       // Ajustar datas para considerar apenas o mÃªs atual
  778 â”‚       const startDate = new Date(Math.max(
  779 â”‚         checkIn.getTime(),
  780 â”‚         new Date(currentYear, currentMonth, 1).getTime()
  781 â”‚       ));
  782 â”‚       const endDate = new Date(Math.min(
  783 â”‚         checkOut.getTime(),
  784 â”‚         new Date(currentYear, currentMonth + 1, 0).getTime()
  785 â”‚       ));
  786 â”‚       
  787 â”‚       // Calcular dias entre datas (incluindo check-in, excluindo check-out)
  788 â”‚       const days = Math.max(0, Math.floor((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)));
  789 â”‚       occupiedDays += days;
  790 â”‚     });
  791 â”‚     
  792 â”‚     const occupancyRate = (occupiedDays / totalPossibleRoomDays) * 100;
  793 â”‚     
  794 â”‚     // SimulaÃ§Ã£o de crescimento (em produÃ§Ã£o, compararia com mÃªs anterior)
  795 â”‚     const growth = occupancyRate > 50 ? 5 : -3;
  796 â”‚     
  797 â”‚     return {
  798 â”‚       rate: Math.round(occupancyRate),
  799 â”‚       growth: Math.round(growth)
  800 â”‚     };
  801 â”‚   } catch (error) {
  802 â”‚     console.error('Erro ao calcular taxa de ocupaÃ§Ã£o:', error);
  803 â”‚     return { rate: 0, growth: 0 };
  804 â”‚   }
  805 â”‚ };
  806 â”‚ 
  807 â”‚ // Obter reservas agrupadas por plataforma
  808 â”‚ export const getBookingsByPlatform = async () => {
  809 â”‚   try {
  810 â”‚     const bookings = await getDocuments<Booking>('bookings');
  811 â”‚     
  812 â”‚     // Categorizar reservas por origem
  813 â”‚     const platforms = [
  814 â”‚       { 
  815 â”‚         platform: "Booking.com", 
  816 â”‚         color: "#003580", 
  817 â”‚         icon: "Globe",
  818 â”‚         bookings: []
  819 â”‚       },
  820 â”‚       { 
  821 â”‚         platform: "Airbnb", 
  822 â”‚         color: "#FF5A5F", 
  823 â”‚         icon: "Heart",
  824 â”‚         bookings: []
  825 â”‚       },
  826 â”‚       { 
  827 â”‚         platform: "Direto", 
  828 â”‚         color: "#4CAF50", 
  829 â”‚         icon: "Home",
  830 â”‚         bookings: []
  831 â”‚       }
  832 â”‚     ];
  833 â”‚     
  834 â”‚     // Para fins de demonstraÃ§Ã£o, colocar todas as reservas como "Direto" por enquanto
  835 â”‚     // Em produÃ§Ã£o, usaria um campo "platformOrigin" ou similar na tabela de reservas
  836 â”‚     const platformIndex = 2; // Ãndice da plataforma "Direto"
  837 â”‚     
  838 â”‚     bookings.forEach(booking => {
  839 â”‚       // Transformar para o formato esperado pelo componente
  840 â”‚       const transformedBooking = {
  841 â”‚         id: booking.id || '',
  842 â”‚         guestName: booking.guestName,
  843 â”‚         roomName: booking.roomName,
  844 â”‚         checkIn: booking.checkIn.toDate().toLocaleDateString('pt-PT'),
  845 â”‚         checkOut: booking.checkOut.toDate().toLocaleDateString('pt-PT'),
  846 â”‚         status: booking.status,
  847 â”‚         value: new Intl.NumberFormat('pt-PT', {
  848 â”‚           style: 'currency',
  849 â”‚           currency: 'EUR'
  850 â”‚         }).format(booking.totalPrice)
  851 â”‚       };
  852 â”‚       
  853 â”‚       // Adicionar Ã  plataforma "Direto"
  854 â”‚       (platforms[platformIndex] as any).bookings.push(transformedBooking);
  855 â”‚     });
  856 â”‚     
  857 â”‚     return platforms;
  858 â”‚   } catch (error) {
  859 â”‚     console.error('Erro ao obter reservas por plataforma:', error);
  860 â”‚     return [];
  861 â”‚   }
  862 â”‚ };
  863 â”‚ 
  864 â”‚ // FunÃ§Ã£o para obter o preÃ§o de um quarto para uma data especÃ­fica
  865 â”‚ export const getRoomPriceForDate = async (roomId: string, date: Date): Promise<number> => {
  866 â”‚   try {
  867 â”‚     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  868 â”‚     
  869 â”‚     if (!roomDoc.exists()) {
  870 â”‚       throw new Error("Quarto nÃ£o encontrado");
  871 â”‚     }
  872 â”‚     
  873 â”‚     const roomData = roomDoc.data() as Room;
  874 â”‚     const basePrice = roomData.price;
  875 â”‚     
  876 â”‚     if (!roomData.seasonalPrices || roomData.seasonalPrices.length === 0) {
  877 â”‚       return basePrice;
  878 â”‚     }
  879 â”‚     
  880 â”‚     // Verificar se a data estÃ¡ dentro de algum perÃ­odo sazonal
  881 â”‚     for (const seasonalPrice of roomData.seasonalPrices) {
  882 â”‚       const startDate = new Date(seasonalPrice.startDate);
  883 â”‚       const endDate = new Date(seasonalPrice.endDate);
  884 â”‚       
  885 â”‚       if (date >= startDate && date <= endDate) {
  886 â”‚         return seasonalPrice.price;
  887 â”‚       }
  888 â”‚     }
  889 â”‚     
  890 â”‚     // Se nÃ£o cair em nenhum perÃ­odo sazonal, retorna o preÃ§o base
  891 â”‚     return basePrice;
  892 â”‚   } catch (error) {
  893 â”‚     console.error("Erro ao obter preÃ§o do quarto:", error);
  894 â”‚     throw error;
  895 â”‚   }
  896 â”‚ }
  897 â”‚ 
  898 â”‚ // FunÃ§Ã£o para calcular o preÃ§o total de uma estadia
  899 â”‚ export const calculateStayPrice = async (
  900 â”‚   roomId: string, 
  901 â”‚   checkIn: Date, 
  902 â”‚   checkOut: Date
  903 â”‚ ): Promise<{
  904 â”‚   totalPrice: number;
  905 â”‚   nightlyPrices: { date: string; price: number }[];
  906 â”‚   serviceFee: number;
  907 â”‚   totalWithFee: number;
  908 â”‚ }> => {
  909 â”‚   try {
  910 â”‚     console.log(`ğŸ” Iniciando cÃ¡lculo de preÃ§o para estadia: ${checkIn.toISOString().split('T')[0]} atÃ© ${checkOut.toISOString().split('T')[0]}`);
  911 â”‚     
  912 â”‚     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  913 â”‚     
  914 â”‚     if (!roomDoc.exists()) {
  915 â”‚       throw new Error("Quarto nÃ£o encontrado");
  916 â”‚     }
  917 â”‚     
  918 â”‚     const roomData = roomDoc.data() as Room;
  919 â”‚     console.log(`ğŸ“ Dados do quarto ${roomId}:`, {
  920 â”‚       nome: roomData.name,
  921 â”‚       precoBase: roomData.price,
  922 â”‚       taxaServico: roomData.serviceFeePct || 0,
  923 â”‚       temPrecosSazonais: !!roomData.seasonalPrices?.length
  924 â”‚     });
  925 â”‚     
  926 â”‚     const nightlyPrices: { date: string; price: number }[] = [];
  927 â”‚     let totalPrice = 0;
  928 â”‚     
  929 â”‚     // Calcular o nÃºmero de noites - corrigido para usar o mÃ©todo correto de cÃ¡lculo
  930 â”‚     // O nÃºmero de noites Ã© a diferenÃ§a em dias (estadia = checkout - checkin)
  931 â”‚     const noites = differenceInDays(checkOut, checkIn);
  932 â”‚     console.log(`ğŸ—“ï¸ NÃºmero de noites calculado: ${noites}`);
  933 â”‚     
  934 â”‚     if (noites <= 0) {
  935 â”‚       console.error(`âš ï¸ Erro: nÃºmero de noites invÃ¡lido (${noites})`);
  936 â”‚       throw new Error("Data de check-out deve ser posterior Ã  data de check-in");
  937 â”‚     }
  938 â”‚     
  939 â”‚     // Para cada noite, verificar o preÃ§o aplicÃ¡vel (preÃ§o base ou sazonal)
  940 â”‚     // ComeÃ§amos exatamente do dia de check-in
  941 â”‚     const currentDate = new Date(checkIn);
  942 â”‚     currentDate.setHours(0, 0, 0, 0); // Normalizar para meia-noite
  943 â”‚     
  944 â”‚     // Processamos cada dia de estadia (noite)
  945 â”‚     console.log(`ğŸ“Š Calculando preÃ§os por noite:`);
  946 â”‚     for (let i = 0; i < noites; i++) {
  947 â”‚       // Obtemos o preÃ§o para esta data
  948 â”‚       const dateCopy = new Date(currentDate);
  949 â”‚       const priceForDate = await getRoomPriceForDate(roomId, dateCopy);
  950 â”‚       const dateString = dateCopy.toISOString().split('T')[0]; // YYYY-MM-DD
  951 â”‚       
  952 â”‚       console.log(`   - ${dateString}: â‚¬${priceForDate}`);
  953 â”‚       
  954 â”‚       nightlyPrices.push({
  955 â”‚         date: dateString,
  956 â”‚         price: priceForDate
  957 â”‚       });
  958 â”‚       
  959 â”‚       totalPrice += priceForDate;
  960 â”‚       
  961 â”‚       // AvanÃ§amos para o prÃ³ximo dia
  962 â”‚       currentDate.setDate(currentDate.getDate() + 1);
  963 â”‚     }
  964 â”‚     
  965 â”‚     // VerificaÃ§Ã£o de seguranÃ§a para o cÃ¡lculo do totalPrice
  966 â”‚     const manualTotal = nightlyPrices.reduce((sum, night) => sum + night.price, 0);
  967 â”‚     if (Math.abs(totalPrice - manualTotal) > 1) {
  968 â”‚       console.error(`âš ï¸ DiscrepÃ¢ncia detectada no cÃ¡lculo do preÃ§o total!`);
  969 â”‚       console.error(`   - Total calculado iterativamente: â‚¬${totalPrice}`);
  970 â”‚       console.error(`   - Total calculado via reduce: â‚¬${manualTotal}`);
  971 â”‚       console.error(`   - Usando o valor recalculado para seguranÃ§a!`);
  972 â”‚       totalPrice = manualTotal;
  973 â”‚     }
  974 â”‚     
  975 â”‚     // Calcular taxa de serviÃ§o
  976 â”‚     const serviceFee = (totalPrice * (roomData.serviceFeePct || 0)) / 100;
  977 â”‚     const totalWithFee = totalPrice + serviceFee;
  978 â”‚     
  979 â”‚     console.log(`ğŸ’° Resumo do cÃ¡lculo:`);
  980 â”‚     console.log(`   - Total das diÃ¡rias: â‚¬${totalPrice}`);
  981 â”‚     console.log(`   - Taxa de serviÃ§o (${roomData.serviceFeePct || 0}%): â‚¬${serviceFee}`);
  982 â”‚     console.log(`   - Total com taxas: â‚¬${totalWithFee}`);
  983 â”‚     
  984 â”‚     return {
  985 â”‚       totalPrice,
  986 â”‚       nightlyPrices,
  987 â”‚       serviceFee,
  988 â”‚       totalWithFee
  989 â”‚     };
  990 â”‚   } catch (error) {
  991 â”‚     console.error("âŒ Erro ao calcular preÃ§o da estadia:", error);
  992 â”‚     throw error;
  993 â”‚   }
  994 â”‚ } 
  995 â”‚ import { 
  996 â”‚   collection, 
  997 â”‚   getDocs, 
      Â·   â”€â”€â”€â”¬â”€â”€â”€
      Â·      â•°â”€â”€ `getDocs` redefined here
  998 â”‚   getDoc, 
  999 â”‚   doc, 
 1000 â”‚   setDoc, 
      â•°â”€â”€â”€â”€

  Ã— the name `getDoc` is defined multiple times
      â•­â”€[/home/runner/workspace/lib/firebase/firestore.ts:3:1]
    3 â”‚   doc,
    4 â”‚   setDoc,
    5 â”‚   addDoc,
    6 â”‚   getDoc,
      Â·   â”€â”€â”€â”¬â”€â”€
      Â·      â•°â”€â”€ previous definition of `getDoc` here
    7 â”‚   getDocs,
    8 â”‚   updateDoc,
    9 â”‚   deleteDoc,
   10 â”‚   query,
   11 â”‚   where,
   12 â”‚   orderBy,
   13 â”‚   limit,
   14 â”‚   DocumentData,
   15 â”‚   QueryConstraint,
   16 â”‚   Timestamp,
   17 â”‚   serverTimestamp
   18 â”‚ } from 'firebase/firestore'
   19 â”‚ import { db } from './config'
   20 â”‚ import { Room, SeasonalPrice } from '@/lib/types'
   21 â”‚ import { differenceInDays } from 'date-fns'
   22 â”‚ 
   23 â”‚ // Tipos de dados
   24 â”‚ export interface Booking {
   25 â”‚   id?: string
   26 â”‚   userId?: string
   27 â”‚   guestName: string
   28 â”‚   guestEmail: string
   29 â”‚   guestPhone: string
   30 â”‚   roomId: string
   31 â”‚   roomName: string
   32 â”‚   checkIn: Timestamp
   33 â”‚   checkOut: Timestamp
   34 â”‚   adults: number
   35 â”‚   children: number
   36 â”‚   totalPrice: number
   37 â”‚   status: 'pending' | 'confirmed' | 'cancelled' | 'completed'
   38 â”‚   paymentStatus: 'pending' | 'paid' | 'refunded'
   39 â”‚   specialRequests?: string
   40 â”‚   createdAt?: Timestamp
   41 â”‚   updatedAt?: Timestamp
   42 â”‚ }
   43 â”‚ 
   44 â”‚ export interface Contact {
   45 â”‚   id?: string
   46 â”‚   name: string
   47 â”‚   email: string
   48 â”‚   phone?: string
   49 â”‚   subject: string
   50 â”‚   message: string
   51 â”‚   status: 'new' | 'read' | 'replied'
   52 â”‚   createdAt: Timestamp
   53 â”‚   updatedAt?: Timestamp
   54 â”‚   repliedAt?: Timestamp
   55 â”‚   replyContent?: string
   56 â”‚   reservationDetails?: {
   57 â”‚     checkIn?: Timestamp
   58 â”‚     checkOut?: Timestamp
   59 â”‚     roomId?: string
   60 â”‚     roomName?: string
   61 â”‚     totalGuests?: number
   62 â”‚     totalPrice?: number
   63 â”‚   }
   64 â”‚ }
   65 â”‚ 
   66 â”‚ // FunÃ§Ãµes genÃ©ricas para CRUD
   67 â”‚ export const createDocument = async <T extends DocumentData>(
   68 â”‚   collectionName: string,
   69 â”‚   data: T
   70 â”‚ ): Promise<string> => {
   71 â”‚   const docRef = await addDoc(collection(db, collectionName), {
   72 â”‚     ...data,
   73 â”‚     createdAt: serverTimestamp(),
   74 â”‚     updatedAt: serverTimestamp()
   75 â”‚   })
   76 â”‚   return docRef.id
   77 â”‚ }
   78 â”‚ 
   79 â”‚ export const createDocumentWithId = async <T extends DocumentData>(
   80 â”‚   collectionName: string,
   81 â”‚   id: string,
   82 â”‚   data: T
   83 â”‚ ): Promise<void> => {
   84 â”‚   await setDoc(doc(db, collectionName, id), {
   85 â”‚     ...data,
   86 â”‚     createdAt: serverTimestamp(),
   87 â”‚     updatedAt: serverTimestamp()
   88 â”‚   })
   89 â”‚ }
   90 â”‚ 
   91 â”‚ export const getDocument = async <T>(
   92 â”‚   collectionName: string,
   93 â”‚   id: string
   94 â”‚ ): Promise<T | null> => {
   95 â”‚   const docRef = doc(db, collectionName, id)
   96 â”‚   const docSnap = await getDoc(docRef)
   97 â”‚   
   98 â”‚   if (docSnap.exists()) {
   99 â”‚     const data = docSnap.data();
  100 â”‚     console.log("Dados brutos recuperados do Firestore para quarto:", id, data);
  101 â”‚     
  102 â”‚     if (data?.serviceFeePct !== undefined) {
  103 â”‚       console.log("serviceFeePct antes da conversÃ£o:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
  104 â”‚       // Garantir que serviceFeePct seja um nÃºmero
  105 â”‚       data.serviceFeePct = Number(data.serviceFeePct);
  106 â”‚       console.log("serviceFeePct apÃ³s conversÃ£o:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
  107 â”‚     }
  108 â”‚     
  109 â”‚     return { id: docSnap.id, ...data } as T
  110 â”‚   } else {
  111 â”‚     return null
  112 â”‚   }
  113 â”‚ }
  114 â”‚ 
  115 â”‚ export const getDocuments = async <T>(
  116 â”‚   collectionName: string,
  117 â”‚   constraints: QueryConstraint[] = [],
  118 â”‚   forceRefresh = false
  119 â”‚ ): Promise<T[]> => {
  120 â”‚   try {
  121 â”‚     const collectionRef = collection(db, collectionName)
  122 â”‚     const q = query(collectionRef, ...constraints)
  123 â”‚     
  124 â”‚     // Se forceRefresh for verdadeiro, adicionar opÃ§Ãµes que forÃ§am uma nova consulta ao Firestore
  125 â”‚     const querySnapshot = await getDocs(q)
  126 â”‚     
  127 â”‚     console.log(`Buscando documentos na coleÃ§Ã£o ${collectionName} - ForÃ§a atualizaÃ§Ã£o: ${forceRefresh}`);
  128 â”‚     
  129 â”‚     return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }) as T)
  130 â”‚   } catch (error) {
  131 â”‚     console.error(`Erro ao buscar documentos da coleÃ§Ã£o ${collectionName}:`, error);
  132 â”‚     return [];
  133 â”‚   }
  134 â”‚ }
  135 â”‚ 
  136 â”‚ export const updateDocument = async <T extends DocumentData>(
  137 â”‚   collectionName: string,
  138 â”‚   id: string,
  139 â”‚   data: Partial<T>
  140 â”‚ ): Promise<void> => {
  141 â”‚   const docRef = doc(db, collectionName, id)
  142 â”‚   await updateDoc(docRef, {
  143 â”‚     ...data,
  144 â”‚     updatedAt: serverTimestamp()
  145 â”‚   })
  146 â”‚ }
  147 â”‚ 
  148 â”‚ export const deleteDocument = async (
  149 â”‚   collectionName: string,
  150 â”‚   id: string
  151 â”‚ ): Promise<boolean> => {
  152 â”‚   const docRef = doc(db, collectionName, id)
  153 â”‚   await deleteDoc(docRef)
  154 â”‚   return true
  155 â”‚ }
  156 â”‚ 
  157 â”‚ // FunÃ§Ãµes para gerenciar quartos
  158 â”‚ export const getRooms = async (forceRefresh = false): Promise<Room[]> => {
  159 â”‚   try {
  160 â”‚     const constraints: QueryConstraint[] = []
  161 â”‚     
  162 â”‚     constraints.push(orderBy('name', 'asc'))
  163 â”‚     
  164 â”‚     const rooms = await getDocuments<Room>('rooms', constraints, forceRefresh)
  165 â”‚     
  166 â”‚     // Garantir que todos os campos necessÃ¡rios estejam presentes
  167 â”‚     return rooms.map(room => {
  168 â”‚       console.log(`Firebase - Quarto ${room.id} dados brutos:`, room);
  169 â”‚       
  170 â”‚       // Garantir que serviceFeePct seja um nÃºmero
  171 â”‚       const serviceFeePct = room.serviceFeePct !== undefined 
  172 â”‚         ? Number(room.serviceFeePct) 
  173 â”‚         : 10;
  174 â”‚         
  175 â”‚       console.log(`Firebase - Quarto ${room.id} serviceFeePct:`, {
  176 â”‚         original: room.serviceFeePct,
  177 â”‚         tipo: typeof room.serviceFeePct,
  178 â”‚         convertido: serviceFeePct
  179 â”‚       });
  180 â”‚       
  181 â”‚       return {
  182 â”‚         id: room.id,
  183 â”‚         name: room.name || '',
  184 â”‚         type: room.type || 'standard',
  185 â”‚         description: room.description || '',
  186 â”‚         price: room.price || 0,
  187 â”‚         capacity: room.capacity || 2,
  188 â”‚         size: room.size || 0,
  189 â”‚         available: room.available !== undefined ? room.available : true,
  190 â”‚         serviceFeePct: serviceFeePct,
  191 â”‚         images: room.images || [],
  192 â”‚         amenities: room.amenities || [],
  193 â”‚         additionalServices: room.additionalServices || [],
  194 â”‚         highlights: room.highlights || [],
  195 â”‚         createdAt: room.createdAt,
  196 â”‚         updatedAt: room.updatedAt
  197 â”‚       };
  198 â”‚     });
  199 â”‚   } catch (error) {
  200 â”‚     console.error('Erro ao buscar quartos:', error)
  201 â”‚     return []
  202 â”‚   }
  203 â”‚ }
  204 â”‚ 
  205 â”‚ export const getAvailableRooms = async (
  206 â”‚   checkIn: Date,
  207 â”‚   checkOut: Date
  208 â”‚ ): Promise<Room[]> => {
  209 â”‚   try {
  210 â”‚     // Buscar todos os quartos que estÃ£o marcados como disponÃ­veis em geral
  211 â”‚     const constraints: QueryConstraint[] = [
  212 â”‚       where('available', '==', true)
  213 â”‚     ]
  214 â”‚     
  215 â”‚     const rooms = await getDocuments<Room>('rooms', constraints);
  216 â”‚     
  217 â”‚     // Filtrar os quartos que estÃ£o disponÃ­veis nas datas especÃ­ficas
  218 â”‚     return filterAvailableRoomsByDate(rooms, checkIn, checkOut);
  219 â”‚   } catch (error) {
  220 â”‚     console.error('Erro ao buscar quartos disponÃ­veis:', error)
  221 â”‚     return []
  222 â”‚   }
  223 â”‚ }
  224 â”‚ 
  225 â”‚ // FunÃ§Ã£o auxiliar para verificar disponibilidade entre datas
  226 â”‚ export const filterAvailableRoomsByDate = (
  227 â”‚   rooms: Room[],
  228 â”‚   checkIn: Date,
  229 â”‚   checkOut: Date
  230 â”‚ ): Room[] => {
  231 â”‚   // Converter checkIn e checkOut para ISO strings
  232 â”‚   const dateStrings = getDatesInRange(checkIn, checkOut);
  233 â”‚   
  234 â”‚   return rooms.filter(room => {
  235 â”‚     // Se nÃ£o tiver controle de disponibilidade especÃ­fico, considera disponÃ­vel
  236 â”‚     if (!room.availabilityDates) return true;
  237 â”‚     
  238 â”‚     // Verificar se alguma data no intervalo estÃ¡ indisponÃ­vel
  239 â”‚     return !dateStrings.some(dateStr => 
  240 â”‚       room.availabilityDates?.[dateStr] === false
  241 â”‚     );
  242 â”‚   });
  243 â”‚ };
  244 â”‚ 
  245 â”‚ // FunÃ§Ã£o para obter disponibilidade de um quarto especÃ­fico
  246 â”‚ export const getRoomAvailability = async (
  247 â”‚   roomId: string, 
  248 â”‚   startDate: Date, 
  249 â”‚   endDate: Date
  250 â”‚ ): Promise<{[date: string]: boolean}> => {
  251 â”‚   try {
  252 â”‚     const room = await getRoomById(roomId);
  253 â”‚     if (!room) throw new Error(`Quarto com ID ${roomId} nÃ£o encontrado`);
  254 â”‚     
  255 â”‚     // Gerar datas no intervalo
  256 â”‚     const dateStrings = getDatesInRange(startDate, endDate);
  257 â”‚     
  258 â”‚     // Se nÃ£o tiver configuraÃ§Ã£o de disponibilidade especÃ­fica, assume tudo disponÃ­vel
  259 â”‚     if (!room.availabilityDates) {
  260 â”‚       return dateStrings.reduce((acc, date) => {
  261 â”‚         acc[date] = true;
  262 â”‚         return acc;
  263 â”‚       }, {} as {[date: string]: boolean});
  264 â”‚     }
  265 â”‚     
  266 â”‚     // Preencher com os dados de disponibilidade existentes
  267 â”‚     return dateStrings.reduce((acc, date) => {
  268 â”‚       acc[date] = room.availabilityDates?.[date] !== false; // disponÃ­vel por padrÃ£o se nÃ£o estiver explicitamente indisponÃ­vel
  269 â”‚       return acc;
  270 â”‚     }, {} as {[date: string]: boolean});
  271 â”‚   } catch (error) {
  272 â”‚     console.error(`Erro ao verificar disponibilidade do quarto ${roomId}:`, error);
  273 â”‚     throw error;
  274 â”‚   }
  275 â”‚ };
  276 â”‚ 
  277 â”‚ // FunÃ§Ã£o para atualizar disponibilidade de um quarto
  278 â”‚ export const updateRoomAvailability = async (
  279 â”‚   roomId: string,
  280 â”‚   availabilityDates: {[date: string]: boolean}
  281 â”‚ ): Promise<boolean> => {
  282 â”‚   try {
  283 â”‚     await updateDocument('rooms', roomId, {
  284 â”‚       availabilityDates,
  285 â”‚       updatedAt: serverTimestamp()
  286 â”‚     });
  287 â”‚     return true;
  288 â”‚   } catch (error) {
  289 â”‚     console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  290 â”‚     return false;
  291 â”‚   }
  292 â”‚ };
  293 â”‚ 
  294 â”‚ // FunÃ§Ã£o auxiliar para gerar array de strings de data entre um intervalo
  295 â”‚ export const getDatesInRange = (startDate: Date, endDate: Date): string[] => {
  296 â”‚   const dates: string[] = [];
  297 â”‚   const currentDate = new Date(startDate);
  298 â”‚   
  299 â”‚   // Normalizar para meia-noite no fuso horÃ¡rio local
  300 â”‚   currentDate.setHours(0, 0, 0, 0);
  301 â”‚   const endDateNormalized = new Date(endDate);
  302 â”‚   endDateNormalized.setHours(0, 0, 0, 0);
  303 â”‚   
  304 â”‚   // Adicionar cada data no intervalo EXCETO o dia de checkout
  305 â”‚   // Usando < em vez de <= para nÃ£o incluir o dia de checkout
  306 â”‚   while (currentDate < endDateNormalized) {
  307 â”‚     dates.push(currentDate.toISOString().split('T')[0]); // Formato YYYY-MM-DD
  308 â”‚     currentDate.setDate(currentDate.getDate() + 1);
  309 â”‚   }
  310 â”‚   
  311 â”‚   return dates;
  312 â”‚ };
  313 â”‚ 
  314 â”‚ export const getRoomById = async (id: string): Promise<Room | null> => {
  315 â”‚   try {
  316 â”‚     const room = await getDocument<Room>('rooms', id);
  317 â”‚     
  318 â”‚     if (!room) return null;
  319 â”‚     
  320 â”‚     console.log(`Firebase - getRoomById ${id} dados brutos:`, room);
  321 â”‚     
  322 â”‚     // Log especÃ­fico para serviceFeePct
  323 â”‚     console.log(`serviceFeePct no Firestore:`, room.serviceFeePct);
  324 â”‚     
  325 â”‚     // Garantir que todos os campos necessÃ¡rios estejam presentes
  326 â”‚     return {
  327 â”‚       ...room,
  328 â”‚       name: room.name || '',
  329 â”‚       type: room.type || 'standard',
  330 â”‚       description: room.description || '',
  331 â”‚       price: room.price || 0,
  332 â”‚       capacity: room.capacity || 2,
  333 â”‚       size: room.size || 0,
  334 â”‚       available: room.available !== undefined ? room.available : true,
  335 â”‚       serviceFeePct: room.serviceFeePct !== undefined ? room.serviceFeePct : 10,
  336 â”‚       images: room.images || [],
  337 â”‚       amenities: room.amenities || [],
  338 â”‚       additionalServices: room.additionalServices || [],
  339 â”‚       highlights: room.highlights || []
  340 â”‚     };
  341 â”‚   } catch (error) {
  342 â”‚     console.error(`Erro ao buscar quarto com ID ${id}:`, error);
  343 â”‚     return null;
  344 â”‚   }
  345 â”‚ }
  346 â”‚ 
  347 â”‚ export const createRoom = async (roomData: Omit<Room, 'id' | 'createdAt' | 'updatedAt'>): Promise<Room> => {
  348 â”‚   try {
  349 â”‚     console.log("createRoom - Dados recebidos:", roomData);
  350 â”‚     
  351 â”‚     const roomWithTimestamps = {
  352 â”‚       ...roomData,
  353 â”‚       available: roomData.available !== undefined ? roomData.available : true,
  354 â”‚       featured: roomData.featured || false,
  355 â”‚       amenities: roomData.amenities || [],
  356 â”‚       additionalServices: roomData.additionalServices || [],
  357 â”‚       highlights: roomData.highlights || [],
  358 â”‚       createdAt: serverTimestamp(),
  359 â”‚       updatedAt: serverTimestamp()
  360 â”‚     }
  361 â”‚     
  362 â”‚     console.log("createRoom - Dados a serem salvos:", roomWithTimestamps);
  363 â”‚     
  364 â”‚     const id = await createDocument('rooms', roomWithTimestamps)
  365 â”‚     
  366 â”‚     return {
  367 â”‚       id,
  368 â”‚       ...roomData,
  369 â”‚       amenities: roomData.amenities || [],
  370 â”‚       additionalServices: roomData.additionalServices || [],
  371 â”‚       highlights: roomData.highlights || [],
  372 â”‚       createdAt: Timestamp.now(),
  373 â”‚       updatedAt: Timestamp.now()
  374 â”‚     }
  375 â”‚   } catch (error) {
  376 â”‚     console.error('Erro ao criar quarto:', error)
  377 â”‚     throw error
  378 â”‚   }
  379 â”‚ }
  380 â”‚ 
  381 â”‚ export const updateRoom = async (id: string, roomData: Partial<Omit<Room, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Room> => {
  382 â”‚   try {
  383 â”‚     console.log(`updateRoom - ID: ${id}, Dados recebidos:`, roomData);
  384 â”‚     
  385 â”‚     // Garantir que estamos lidando explicitamente com o serviceFeePct se ele for 0
  386 â”‚     if (roomData.serviceFeePct === 0) {
  387 â”‚       console.log("updateRoom - Detectado serviceFeePct com valor 0, salvando explicitamente.", roomData.serviceFeePct);
  388 â”‚     }
  389 â”‚     
  390 â”‚     // Adicionar timestamp de atualizaÃ§Ã£o
  391 â”‚     const roomWithTimestamp = {
  392 â”‚       ...roomData,
  393 â”‚       amenities: roomData.amenities || [],
  394 â”‚       additionalServices: roomData.additionalServices || [],
  395 â”‚       highlights: roomData.highlights || [],
  396 â”‚       updatedAt: serverTimestamp()
  397 â”‚     }
  398 â”‚     
  399 â”‚     console.log(`updateRoom - Dados a serem salvos:`, roomWithTimestamp);
  400 â”‚     
  401 â”‚     await updateDocument('rooms', id, roomWithTimestamp)
  402 â”‚     
  403 â”‚     const updatedRoom = await getRoomById(id)
  404 â”‚     if (!updatedRoom) {
  405 â”‚       throw new Error(`Quarto com ID ${id} nÃ£o encontrado apÃ³s atualizaÃ§Ã£o`)
  406 â”‚     }
  407 â”‚     
  408 â”‚     return updatedRoom
  409 â”‚   } catch (error) {
  410 â”‚     console.error('Erro ao atualizar quarto:', error)
  411 â”‚     throw error
  412 â”‚   }
  413 â”‚ }
  414 â”‚ 
  415 â”‚ export const deleteRoom = async (id: string): Promise<boolean> => {
  416 â”‚   return await deleteDocument('rooms', id)
  417 â”‚ }
  418 â”‚ 
  419 â”‚ // FunÃ§Ãµes especÃ­ficas para reservas
  420 â”‚ export const createBooking = async (bookingData: any) => {
  421 â”‚   try {
  422 â”‚     const bookingsCollection = collection(db, 'bookings');
  423 â”‚     const docRef = await addDoc(bookingsCollection, bookingData);
  424 â”‚     
  425 â”‚     // CORREÃ‡ÃƒO: NÃ£o bloquear a data no momento da criaÃ§Ã£o da reserva
  426 â”‚     // O bloqueio serÃ¡ feito apenas quando o pagamento for confirmado
  427 â”‚     // atravÃ©s da funÃ§Ã£o updateBookingStatus
  428 â”‚     
  429 â”‚     return docRef;
  430 â”‚   } catch (error) {
  431 â”‚     console.error('Erro ao criar reserva:', error);
  432 â”‚     throw error;
  433 â”‚   }
  434 â”‚ };
  435 â”‚ 
  436 â”‚ // Nova funÃ§Ã£o para atualizar status da reserva e bloquear as datas da estadia
  437 â”‚ export const updateBookingStatus = async (
  438 â”‚   bookingId: string, 
  439 â”‚   newStatus: 'pending' | 'confirmed' | 'cancelled' | 'completed',
  440 â”‚   newPaymentStatus: 'pending' | 'paid' | 'refunded'
  441 â”‚ ): Promise<boolean> => {
  442 â”‚   try {
  443 â”‚     // ReferÃªncia ao documento da reserva
  444 â”‚     const bookingRef = doc(db, 'bookings', bookingId);
  445 â”‚     const bookingSnap = await getDoc(bookingRef);
  446 â”‚     
  447 â”‚     if (!bookingSnap.exists()) {
  448 â”‚       console.error(`Booking ${bookingId} nÃ£o existe ao atualizar status`);
  449 â”‚       return false;
  450 â”‚     }
  451 â”‚     
  452 â”‚     const bookingData = bookingSnap.data();
  453 â”‚     
  454 â”‚     // Atualizar o status da reserva
  455 â”‚     await updateDoc(bookingRef, {
  456 â”‚       status: newStatus,
  457 â”‚       paymentStatus: newPaymentStatus,
  458 â”‚       updatedAt: serverTimestamp(),
  459 â”‚       ...(newStatus === 'confirmed' && { confirmedAt: serverTimestamp() })
  460 â”‚     });
  461 â”‚     
  462 â”‚     // Se a reserva estÃ¡ sendo confirmada, precisamos bloquear as datas
  463 â”‚     if (newStatus === 'confirmed') {
  464 â”‚       console.log(`Atualizando disponibilidade para reserva confirmada: ${bookingId}`);
  465 â”‚       
  466 â”‚       // Recuperar datas de check-in e check-out
  467 â”‚       const checkIn = bookingData.checkIn.toDate();
  468 â”‚       const checkOut = bookingData.checkOut.toDate();
  469 â”‚       const roomId = bookingData.roomId;
  470 â”‚       
  471 â”‚       // Obter todas as datas entre check-in e check-out
  472 â”‚       const dates: Date[] = [];
  473 â”‚       const currentDate = new Date(checkIn);
  474 â”‚       
  475 â”‚       while (currentDate < checkOut) {
  476 â”‚         dates.push(new Date(currentDate));
  477 â”‚         currentDate.setDate(currentDate.getDate() + 1);
  478 â”‚       }
  479 â”‚       
  480 â”‚       console.log(`Bloqueando ${dates.length} dias para quarto ${roomId}`);
  481 â”‚       
  482 â”‚       // Atualizar disponibilidade para cada data
  483 â”‚       const availabilityUpdates: {[date: string]: boolean} = {};
  484 â”‚       
  485 â”‚       dates.forEach(date => {
  486 â”‚         const dateString = date.toISOString().split('T')[0]; // formato YYYY-MM-DD
  487 â”‚         availabilityUpdates[dateString] = false; // false significa indisponÃ­vel
  488 â”‚       });
  489 â”‚       
  490 â”‚       // Atualizar disponibilidade do quarto
  491 â”‚       if (Object.keys(availabilityUpdates).length > 0) {
  492 â”‚         try {
  493 â”‚           // Obter o documento do quarto
  494 â”‚           const roomRef = doc(db, 'rooms', roomId);
  495 â”‚           const roomSnap = await getDoc(roomRef);
  496 â”‚           
  497 â”‚           if (roomSnap.exists()) {
  498 â”‚             const roomData = roomSnap.data();
  499 â”‚             const currentAvailability = roomData.availabilityDates || {};
  500 â”‚             
  501 â”‚             // Mesclar a disponibilidade atual com as novas atualizaÃ§Ãµes
  502 â”‚             const updatedAvailability = {
  503 â”‚               ...currentAvailability,
  504 â”‚               ...availabilityUpdates
  505 â”‚             };
  506 â”‚             
  507 â”‚             // Atualizar o documento do quarto
  508 â”‚             await updateDoc(roomRef, {
  509 â”‚               availabilityDates: updatedAvailability,
  510 â”‚               updatedAt: serverTimestamp()
  511 â”‚             });
  512 â”‚             
  513 â”‚             console.log(`Disponibilidade atualizada com sucesso para quarto ${roomId}`);
  514 â”‚             
  515 â”‚             // Criar log da reserva
  516 â”‚             await addDoc(collection(db, 'bookingLogs'), {
  517 â”‚               bookingId,
  518 â”‚               roomId,
  519 â”‚               action: 'status_updated',
  520 â”‚               previousStatus: bookingData.status,
  521 â”‚               newStatus,
  522 â”‚               previousPaymentStatus: bookingData.paymentStatus,
  523 â”‚               newPaymentStatus,
  524 â”‚               datesBlocked: Object.keys(availabilityUpdates),
  525 â”‚               timestamp: serverTimestamp(),
  526 â”‚               userId: bookingData.userId || 'system'
  527 â”‚             });
  528 â”‚           } else {
  529 â”‚             console.error(`Quarto ${roomId} nÃ£o encontrado ao atualizar disponibilidade`);
  530 â”‚           }
  531 â”‚         } catch (error) {
  532 â”‚           console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  533 â”‚         }
  534 â”‚       }
  535 â”‚     }
  536 â”‚     
  537 â”‚     return true;
  538 â”‚   } catch (error) {
  539 â”‚     console.error(`Erro ao atualizar status da reserva ${bookingId}:`, error);
  540 â”‚     return false;
  541 â”‚   }
  542 â”‚ }
  543 â”‚ 
  544 â”‚ export const getUserBookings = async (userId: string): Promise<Booking[]> => {
  545 â”‚   return getDocuments<Booking>('bookings', [
  546 â”‚     where('userId', '==', userId),
  547 â”‚     orderBy('createdAt', 'desc')
  548 â”‚   ])
  549 â”‚ }
  550 â”‚ 
  551 â”‚ export const getRecentBookings = async (count = 5): Promise<Booking[]> => {
  552 â”‚   return getDocuments<Booking>('bookings', [
  553 â”‚     orderBy('createdAt', 'desc'),
  554 â”‚     limit(count)
  555 â”‚   ])
  556 â”‚ }
  557 â”‚ 
  558 â”‚ export const getRoomBookings = async (roomId: string): Promise<Booking[]> => {
  559 â”‚   try {
  560 â”‚     const constraints: QueryConstraint[] = [
  561 â”‚       where('roomId', '==', roomId),
  562 â”‚       orderBy('checkIn', 'asc')
  563 â”‚     ];
  564 â”‚     
  565 â”‚     return await getDocuments<Booking>('bookings', constraints);
  566 â”‚   } catch (error) {
  567 â”‚     console.error(`Erro ao buscar reservas do quarto ${roomId}:`, error);
  568 â”‚     return [];
  569 â”‚   }
  570 â”‚ };
  571 â”‚ 
  572 â”‚ // FunÃ§Ãµes especÃ­ficas para contatos
  573 â”‚ export const createContactMessage = async (contactData: Contact) => {
  574 â”‚   try {
  575 â”‚     const contactsCollection = collection(db, 'contacts')
  576 â”‚     
  577 â”‚     // Garantir que o status seja 'new' para novos contatos
  578 â”‚     const contactWithDefaults = {
  579 â”‚       ...contactData,
  580 â”‚       status: contactData.status || 'new',
  581 â”‚       createdAt: contactData.createdAt || Timestamp.now()
  582 â”‚     }
  583 â”‚     
  584 â”‚     // Se tiver detalhes de reserva, adicionar metadados
  585 â”‚     if (contactWithDefaults.reservationDetails) {
  586 â”‚       // Ajustar subject para indicar que Ã© relacionado a reserva
  587 â”‚       if (!contactWithDefaults.subject.includes('Reserva')) {
  588 â”‚         contactWithDefaults.subject = `Reserva: ${contactWithDefaults.subject}`;
  589 â”‚       }
  590 â”‚     }
  591 â”‚     
  592 â”‚     const docRef = await addDoc(contactsCollection, contactWithDefaults)
  593 â”‚     return docRef
  594 â”‚   } catch (error) {
  595 â”‚     console.error('Erro ao criar mensagem de contato:', error)
  596 â”‚     throw error
  597 â”‚   }
  598 â”‚ }
  599 â”‚ 
  600 â”‚ export const getNewContactMessages = async (): Promise<Contact[]> => {
  601 â”‚   return getDocuments<Contact>('contacts', [
  602 â”‚     where('status', '==', 'new'),
  603 â”‚     orderBy('createdAt', 'desc')
  604 â”‚   ])
  605 â”‚ }
  606 â”‚ 
  607 â”‚ // FunÃ§Ãµes para Dashboard com dados reais
  608 â”‚ 
  609 â”‚ export const getDashboardStats = async () => {
  610 â”‚   try {
  611 â”‚     const [totalBookings, totalRevenue, occupancyRate, bookingsByPlatform] = await Promise.all([
  612 â”‚       getTotalBookings(),
  613 â”‚       getMonthlyRevenue(),
  614 â”‚       getOccupancyRate(),
  615 â”‚       getBookingsByPlatform()
  616 â”‚     ]);
  617 â”‚ 
  618 â”‚     return {
  619 â”‚       totalBookings,
  620 â”‚       totalRevenue,
  621 â”‚       occupancyRate,
  622 â”‚       bookingsByPlatform
  623 â”‚     };
  624 â”‚   } catch (error) {
  625 â”‚     console.error('Erro ao obter estatÃ­sticas do dashboard:', error);
  626 â”‚     throw error;
  627 â”‚   }
  628 â”‚ };
  629 â”‚ 
  630 â”‚ // Obter total de reservas
  631 â”‚ export const getTotalBookings = async () => {
  632 â”‚   try {
  633 â”‚     // Obter todas as reservas
  634 â”‚     const bookings = await getDocuments<Booking>('bookings');
  635 â”‚     
  636 â”‚     // Contar reservas por status
  637 â”‚     const confirmed = bookings.filter(b => b.status === 'confirmed').length;
  638 â”‚     const pending = bookings.filter(b => b.status === 'pending').length;
  639 â”‚     const cancelled = bookings.filter(b => b.status === 'cancelled').length;
  640 â”‚     const completed = bookings.filter(b => b.status === 'completed').length;
  641 â”‚     
  642 â”‚     // Calcular crescimento em relaÃ§Ã£o ao mÃªs anterior (simulado por enquanto)
  643 â”‚     // Em uma implementaÃ§Ã£o real, vocÃª compararia com dados do mÃªs anterior
  644 â”‚     const growth = ((confirmed + completed) / (bookings.length || 1) * 100) - 50;
  645 â”‚     
  646 â”‚     return {
  647 â”‚       total: bookings.length,
  648 â”‚       confirmed,
  649 â”‚       pending,
  650 â”‚       cancelled,
  651 â”‚       completed,
  652 â”‚       growth: Math.round(growth) // Arredonda para nÃºmero inteiro
  653 â”‚     };
  654 â”‚   } catch (error) {
  655 â”‚     console.error('Erro ao obter total de reservas:', error);
  656 â”‚     return {
  657 â”‚       total: 0,
  658 â”‚       confirmed: 0,
  659 â”‚       pending: 0, 
  660 â”‚       cancelled: 0,
  661 â”‚       completed: 0,
  662 â”‚       growth: 0
  663 â”‚     };
  664 â”‚   }
  665 â”‚ };
  666 â”‚ 
  667 â”‚ // Obter receita mensal
  668 â”‚ export const getMonthlyRevenue = async () => {
  669 â”‚   try {
  670 â”‚     const bookings = await getDocuments<Booking>('bookings');
  671 â”‚     
  672 â”‚     // Filtrar reservas confirmadas e concluÃ­das
  673 â”‚     const validBookings = bookings.filter(b => 
  674 â”‚       b.status === 'confirmed' || b.status === 'completed'
  675 â”‚     );
  676 â”‚     
  677 â”‚     // Calcular receita total
  678 â”‚     const totalRevenue = validBookings.reduce((acc, booking) => acc + booking.totalPrice, 0);
  679 â”‚     
  680 â”‚     // Agrupar receita por mÃªs
  681 â”‚     const revenueByMonth = validBookings.reduce((acc, booking) => {
  682 â”‚       const date = booking.checkIn.toDate();
  683 â”‚       const month = date.getMonth(); // 0-11
  684 â”‚       const year = date.getFullYear();
  685 â”‚       const key = `${year}-${month}`;
  686 â”‚       
  687 â”‚       if (!acc[key]) {
  688 â”‚         acc[key] = 0;
  689 â”‚       }
  690 â”‚       acc[key] += booking.totalPrice;
  691 â”‚       return acc;
  692 â”‚     }, {} as Record<string, number>);
  693 â”‚     
  694 â”‚     // Converter para formato de array para grÃ¡fico
  695 â”‚     const monthNames = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
  696 â”‚     
  697 â”‚     const currentDate = new Date();
  698 â”‚     const currentMonth = currentDate.getMonth();
  699 â”‚     const currentYear = currentDate.getFullYear();
  700 â”‚     
  701 â”‚     const revenueData = [];
  702 â”‚     
  703 â”‚     // Gerar dados dos Ãºltimos 12 meses
  704 â”‚     for (let i = 0; i < 12; i++) {
  705 â”‚       const month = (currentMonth - i + 12) % 12;
  706 â”‚       const year = currentMonth - i < 0 ? currentYear - 1 : currentYear;
  707 â”‚       const key = `${year}-${month}`;
  708 â”‚       
  709 â”‚       revenueData.unshift({
  710 â”‚         month: monthNames[month],
  711 â”‚         value: revenueByMonth[key] || 0
  712 â”‚       });
  713 â”‚     }
  714 â”‚     
  715 â”‚     // Calcular crescimento em relaÃ§Ã£o ao mÃªs anterior
  716 â”‚     const lastMonthRevenue = revenueData[revenueData.length - 2]?.value || 0;
  717 â”‚     const currentMonthRevenue = revenueData[revenueData.length - 1]?.value || 0;
  718 â”‚     
  719 â”‚     const growth = lastMonthRevenue ? ((currentMonthRevenue - lastMonthRevenue) / lastMonthRevenue) * 100 : 0;
  720 â”‚     
  721 â”‚     return {
  722 â”‚       monthly: currentMonthRevenue,
  723 â”‚       total: totalRevenue,
  724 â”‚       growth: Math.round(growth),
  725 â”‚       revenueData
  726 â”‚     };
  727 â”‚   } catch (error) {
  728 â”‚     console.error('Erro ao obter receita mensal:', error);
  729 â”‚     return {
  730 â”‚       monthly: 0,
  731 â”‚       total: 0,
  732 â”‚       growth: 0,
  733 â”‚       revenueData: []
  734 â”‚     };
  735 â”‚   }
  736 â”‚ };
  737 â”‚ 
  738 â”‚ // Calcular taxa de ocupaÃ§Ã£o
  739 â”‚ export const getOccupancyRate = async () => {
  740 â”‚   try {
  741 â”‚     // Obter todos os quartos
  742 â”‚     const rooms = await getDocuments<Room>('rooms');
  743 â”‚     const totalRooms = rooms.length;
  744 â”‚     
  745 â”‚     if (totalRooms === 0) {
  746 â”‚       return { rate: 0, growth: 0 };
  747 â”‚     }
  748 â”‚     
  749 â”‚     // Obter todas as reservas
  750 â”‚     const bookings = await getDocuments<Booking>('bookings');
  751 â”‚     
  752 â”‚     // Filtrar reservas confirmadas e concluÃ­das para o mÃªs atual
  753 â”‚     const currentDate = new Date();
  754 â”‚     const currentMonth = currentDate.getMonth();
  755 â”‚     const currentYear = currentDate.getFullYear();
  756 â”‚     
  757 â”‚     const currentMonthBookings = bookings.filter(booking => {
  758 â”‚       const checkInDate = booking.checkIn.toDate();
  759 â”‚       return (
  760 â”‚         (booking.status === 'confirmed' || booking.status === 'completed') &&
  761 â”‚         checkInDate.getMonth() === currentMonth &&
  762 â”‚         checkInDate.getFullYear() === currentYear
  763 â”‚       );
  764 â”‚     });
  765 â”‚     
  766 â”‚     // Calcular dias ocupados por quarto
  767 â”‚     const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
  768 â”‚     const totalPossibleRoomDays = totalRooms * daysInMonth;
  769 â”‚     
  770 â”‚     // Contar dias ocupados (simplificado - em produÃ§Ã£o seria mais complexo)
  771 â”‚     let occupiedDays = 0;
  772 â”‚     
  773 â”‚     currentMonthBookings.forEach(booking => {
  774 â”‚       const checkIn = booking.checkIn.toDate();
  775 â”‚       const checkOut = booking.checkOut.toDate();
  776 â”‚       
  777 â”‚       // Ajustar datas para considerar apenas o mÃªs atual
  778 â”‚       const startDate = new Date(Math.max(
  779 â”‚         checkIn.getTime(),
  780 â”‚         new Date(currentYear, currentMonth, 1).getTime()
  781 â”‚       ));
  782 â”‚       const endDate = new Date(Math.min(
  783 â”‚         checkOut.getTime(),
  784 â”‚         new Date(currentYear, currentMonth + 1, 0).getTime()
  785 â”‚       ));
  786 â”‚       
  787 â”‚       // Calcular dias entre datas (incluindo check-in, excluindo check-out)
  788 â”‚       const days = Math.max(0, Math.floor((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)));
  789 â”‚       occupiedDays += days;
  790 â”‚     });
  791 â”‚     
  792 â”‚     const occupancyRate = (occupiedDays / totalPossibleRoomDays) * 100;
  793 â”‚     
  794 â”‚     // SimulaÃ§Ã£o de crescimento (em produÃ§Ã£o, compararia com mÃªs anterior)
  795 â”‚     const growth = occupancyRate > 50 ? 5 : -3;
  796 â”‚     
  797 â”‚     return {
  798 â”‚       rate: Math.round(occupancyRate),
  799 â”‚       growth: Math.round(growth)
  800 â”‚     };
  801 â”‚   } catch (error) {
  802 â”‚     console.error('Erro ao calcular taxa de ocupaÃ§Ã£o:', error);
  803 â”‚     return { rate: 0, growth: 0 };
  804 â”‚   }
  805 â”‚ };
  806 â”‚ 
  807 â”‚ // Obter reservas agrupadas por plataforma
  808 â”‚ export const getBookingsByPlatform = async () => {
  809 â”‚   try {
  810 â”‚     const bookings = await getDocuments<Booking>('bookings');
  811 â”‚     
  812 â”‚     // Categorizar reservas por origem
  813 â”‚     const platforms = [
  814 â”‚       { 
  815 â”‚         platform: "Booking.com", 
  816 â”‚         color: "#003580", 
  817 â”‚         icon: "Globe",
  818 â”‚         bookings: []
  819 â”‚       },
  820 â”‚       { 
  821 â”‚         platform: "Airbnb", 
  822 â”‚         color: "#FF5A5F", 
  823 â”‚         icon: "Heart",
  824 â”‚         bookings: []
  825 â”‚       },
  826 â”‚       { 
  827 â”‚         platform: "Direto", 
  828 â”‚         color: "#4CAF50", 
  829 â”‚         icon: "Home",
  830 â”‚         bookings: []
  831 â”‚       }
  832 â”‚     ];
  833 â”‚     
  834 â”‚     // Para fins de demonstraÃ§Ã£o, colocar todas as reservas como "Direto" por enquanto
  835 â”‚     // Em produÃ§Ã£o, usaria um campo "platformOrigin" ou similar na tabela de reservas
  836 â”‚     const platformIndex = 2; // Ãndice da plataforma "Direto"
  837 â”‚     
  838 â”‚     bookings.forEach(booking => {
  839 â”‚       // Transformar para o formato esperado pelo componente
  840 â”‚       const transformedBooking = {
  841 â”‚         id: booking.id || '',
  842 â”‚         guestName: booking.guestName,
  843 â”‚         roomName: booking.roomName,
  844 â”‚         checkIn: booking.checkIn.toDate().toLocaleDateString('pt-PT'),
  845 â”‚         checkOut: booking.checkOut.toDate().toLocaleDateString('pt-PT'),
  846 â”‚         status: booking.status,
  847 â”‚         value: new Intl.NumberFormat('pt-PT', {
  848 â”‚           style: 'currency',
  849 â”‚           currency: 'EUR'
  850 â”‚         }).format(booking.totalPrice)
  851 â”‚       };
  852 â”‚       
  853 â”‚       // Adicionar Ã  plataforma "Direto"
  854 â”‚       (platforms[platformIndex] as any).bookings.push(transformedBooking);
  855 â”‚     });
  856 â”‚     
  857 â”‚     return platforms;
  858 â”‚   } catch (error) {
  859 â”‚     console.error('Erro ao obter reservas por plataforma:', error);
  860 â”‚     return [];
  861 â”‚   }
  862 â”‚ };
  863 â”‚ 
  864 â”‚ // FunÃ§Ã£o para obter o preÃ§o de um quarto para uma data especÃ­fica
  865 â”‚ export const getRoomPriceForDate = async (roomId: string, date: Date): Promise<number> => {
  866 â”‚   try {
  867 â”‚     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  868 â”‚     
  869 â”‚     if (!roomDoc.exists()) {
  870 â”‚       throw new Error("Quarto nÃ£o encontrado");
  871 â”‚     }
  872 â”‚     
  873 â”‚     const roomData = roomDoc.data() as Room;
  874 â”‚     const basePrice = roomData.price;
  875 â”‚     
  876 â”‚     if (!roomData.seasonalPrices || roomData.seasonalPrices.length === 0) {
  877 â”‚       return basePrice;
  878 â”‚     }
  879 â”‚     
  880 â”‚     // Verificar se a data estÃ¡ dentro de algum perÃ­odo sazonal
  881 â”‚     for (const seasonalPrice of roomData.seasonalPrices) {
  882 â”‚       const startDate = new Date(seasonalPrice.startDate);
  883 â”‚       const endDate = new Date(seasonalPrice.endDate);
  884 â”‚       
  885 â”‚       if (date >= startDate && date <= endDate) {
  886 â”‚         return seasonalPrice.price;
  887 â”‚       }
  888 â”‚     }
  889 â”‚     
  890 â”‚     // Se nÃ£o cair em nenhum perÃ­odo sazonal, retorna o preÃ§o base
  891 â”‚     return basePrice;
  892 â”‚   } catch (error) {
  893 â”‚     console.error("Erro ao obter preÃ§o do quarto:", error);
  894 â”‚     throw error;
  895 â”‚   }
  896 â”‚ }
  897 â”‚ 
  898 â”‚ // FunÃ§Ã£o para calcular o preÃ§o total de uma estadia
  899 â”‚ export const calculateStayPrice = async (
  900 â”‚   roomId: string, 
  901 â”‚   checkIn: Date, 
  902 â”‚   checkOut: Date
  903 â”‚ ): Promise<{
  904 â”‚   totalPrice: number;
  905 â”‚   nightlyPrices: { date: string; price: number }[];
  906 â”‚   serviceFee: number;
  907 â”‚   totalWithFee: number;
  908 â”‚ }> => {
  909 â”‚   try {
  910 â”‚     console.log(`ğŸ” Iniciando cÃ¡lculo de preÃ§o para estadia: ${checkIn.toISOString().split('T')[0]} atÃ© ${checkOut.toISOString().split('T')[0]}`);
  911 â”‚     
  912 â”‚     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  913 â”‚     
  914 â”‚     if (!roomDoc.exists()) {
  915 â”‚       throw new Error("Quarto nÃ£o encontrado");
  916 â”‚     }
  917 â”‚     
  918 â”‚     const roomData = roomDoc.data() as Room;
  919 â”‚     console.log(`ğŸ“ Dados do quarto ${roomId}:`, {
  920 â”‚       nome: roomData.name,
  921 â”‚       precoBase: roomData.price,
  922 â”‚       taxaServico: roomData.serviceFeePct || 0,
  923 â”‚       temPrecosSazonais: !!roomData.seasonalPrices?.length
  924 â”‚     });
  925 â”‚     
  926 â”‚     const nightlyPrices: { date: string; price: number }[] = [];
  927 â”‚     let totalPrice = 0;
  928 â”‚     
  929 â”‚     // Calcular o nÃºmero de noites - corrigido para usar o mÃ©todo correto de cÃ¡lculo
  930 â”‚     // O nÃºmero de noites Ã© a diferenÃ§a em dias (estadia = checkout - checkin)
  931 â”‚     const noites = differenceInDays(checkOut, checkIn);
  932 â”‚     console.log(`ğŸ—“ï¸ NÃºmero de noites calculado: ${noites}`);
  933 â”‚     
  934 â”‚     if (noites <= 0) {
  935 â”‚       console.error(`âš ï¸ Erro: nÃºmero de noites invÃ¡lido (${noites})`);
  936 â”‚       throw new Error("Data de check-out deve ser posterior Ã  data de check-in");
  937 â”‚     }
  938 â”‚     
  939 â”‚     // Para cada noite, verificar o preÃ§o aplicÃ¡vel (preÃ§o base ou sazonal)
  940 â”‚     // ComeÃ§amos exatamente do dia de check-in
  941 â”‚     const currentDate = new Date(checkIn);
  942 â”‚     currentDate.setHours(0, 0, 0, 0); // Normalizar para meia-noite
  943 â”‚     
  944 â”‚     // Processamos cada dia de estadia (noite)
  945 â”‚     console.log(`ğŸ“Š Calculando preÃ§os por noite:`);
  946 â”‚     for (let i = 0; i < noites; i++) {
  947 â”‚       // Obtemos o preÃ§o para esta data
  948 â”‚       const dateCopy = new Date(currentDate);
  949 â”‚       const priceForDate = await getRoomPriceForDate(roomId, dateCopy);
  950 â”‚       const dateString = dateCopy.toISOString().split('T')[0]; // YYYY-MM-DD
  951 â”‚       
  952 â”‚       console.log(`   - ${dateString}: â‚¬${priceForDate}`);
  953 â”‚       
  954 â”‚       nightlyPrices.push({
  955 â”‚         date: dateString,
  956 â”‚         price: priceForDate
  957 â”‚       });
  958 â”‚       
  959 â”‚       totalPrice += priceForDate;
  960 â”‚       
  961 â”‚       // AvanÃ§amos para o prÃ³ximo dia
  962 â”‚       currentDate.setDate(currentDate.getDate() + 1);
  963 â”‚     }
  964 â”‚     
  965 â”‚     // VerificaÃ§Ã£o de seguranÃ§a para o cÃ¡lculo do totalPrice
  966 â”‚     const manualTotal = nightlyPrices.reduce((sum, night) => sum + night.price, 0);
  967 â”‚     if (Math.abs(totalPrice - manualTotal) > 1) {
  968 â”‚       console.error(`âš ï¸ DiscrepÃ¢ncia detectada no cÃ¡lculo do preÃ§o total!`);
  969 â”‚       console.error(`   - Total calculado iterativamente: â‚¬${totalPrice}`);
  970 â”‚       console.error(`   - Total calculado via reduce: â‚¬${manualTotal}`);
  971 â”‚       console.error(`   - Usando o valor recalculado para seguranÃ§a!`);
  972 â”‚       totalPrice = manualTotal;
  973 â”‚     }
  974 â”‚     
  975 â”‚     // Calcular taxa de serviÃ§o
  976 â”‚     const serviceFee = (totalPrice * (roomData.serviceFeePct || 0)) / 100;
  977 â”‚     const totalWithFee = totalPrice + serviceFee;
  978 â”‚     
  979 â”‚     console.log(`ğŸ’° Resumo do cÃ¡lculo:`);
  980 â”‚     console.log(`   - Total das diÃ¡rias: â‚¬${totalPrice}`);
  981 â”‚     console.log(`   - Taxa de serviÃ§o (${roomData.serviceFeePct || 0}%): â‚¬${serviceFee}`);
  982 â”‚     console.log(`   - Total com taxas: â‚¬${totalWithFee}`);
  983 â”‚     
  984 â”‚     return {
  985 â”‚       totalPrice,
  986 â”‚       nightlyPrices,
  987 â”‚       serviceFee,
  988 â”‚       totalWithFee
  989 â”‚     };
  990 â”‚   } catch (error) {
  991 â”‚     console.error("âŒ Erro ao calcular preÃ§o da estadia:", error);
  992 â”‚     throw error;
  993 â”‚   }
  994 â”‚ } 
  995 â”‚ import { 
  996 â”‚   collection, 
  997 â”‚   getDocs, 
  998 â”‚   getDoc, 
      Â·   â”€â”€â”€â”¬â”€â”€
      Â·      â•°â”€â”€ `getDoc` redefined here
  999 â”‚   doc, 
 1000 â”‚   setDoc, 
 1001 â”‚   addDoc, 
      â•°â”€â”€â”€â”€

  Ã— the name `doc` is defined multiple times
      â•­â”€[/home/runner/workspace/lib/firebase/firestore.ts:1:1]
    1 â”‚ import {
    2 â”‚   collection,
    3 â”‚   doc,
      Â·   â”€â”¬â”€
      Â·    â•°â”€â”€ previous definition of `doc` here
    4 â”‚   setDoc,
    5 â”‚   addDoc,
    6 â”‚   getDoc,
    7 â”‚   getDocs,
    8 â”‚   updateDoc,
    9 â”‚   deleteDoc,
   10 â”‚   query,
   11 â”‚   where,
   12 â”‚   orderBy,
   13 â”‚   limit,
   14 â”‚   DocumentData,
   15 â”‚   QueryConstraint,
   16 â”‚   Timestamp,
   17 â”‚   serverTimestamp
   18 â”‚ } from 'firebase/firestore'
   19 â”‚ import { db } from './config'
   20 â”‚ import { Room, SeasonalPrice } from '@/lib/types'
   21 â”‚ import { differenceInDays } from 'date-fns'
   22 â”‚ 
   23 â”‚ // Tipos de dados
   24 â”‚ export interface Booking {
   25 â”‚   id?: string
   26 â”‚   userId?: string
   27 â”‚   guestName: string
   28 â”‚   guestEmail: string
   29 â”‚   guestPhone: string
   30 â”‚   roomId: string
   31 â”‚   roomName: string
   32 â”‚   checkIn: Timestamp
   33 â”‚   checkOut: Timestamp
   34 â”‚   adults: number
   35 â”‚   children: number
   36 â”‚   totalPrice: number
   37 â”‚   status: 'pending' | 'confirmed' | 'cancelled' | 'completed'
   38 â”‚   paymentStatus: 'pending' | 'paid' | 'refunded'
   39 â”‚   specialRequests?: string
   40 â”‚   createdAt?: Timestamp
   41 â”‚   updatedAt?: Timestamp
   42 â”‚ }
   43 â”‚ 
   44 â”‚ export interface Contact {
   45 â”‚   id?: string
   46 â”‚   name: string
   47 â”‚   email: string
   48 â”‚   phone?: string
   49 â”‚   subject: string
   50 â”‚   message: string
   51 â”‚   status: 'new' | 'read' | 'replied'
   52 â”‚   createdAt: Timestamp
   53 â”‚   updatedAt?: Timestamp
   54 â”‚   repliedAt?: Timestamp
   55 â”‚   replyContent?: string
   56 â”‚   reservationDetails?: {
   57 â”‚     checkIn?: Timestamp
   58 â”‚     checkOut?: Timestamp
   59 â”‚     roomId?: string
   60 â”‚     roomName?: string
   61 â”‚     totalGuests?: number
   62 â”‚     totalPrice?: number
   63 â”‚   }
   64 â”‚ }
   65 â”‚ 
   66 â”‚ // FunÃ§Ãµes genÃ©ricas para CRUD
   67 â”‚ export const createDocument = async <T extends DocumentData>(
   68 â”‚   collectionName: string,
   69 â”‚   data: T
   70 â”‚ ): Promise<string> => {
   71 â”‚   const docRef = await addDoc(collection(db, collectionName), {
   72 â”‚     ...data,
   73 â”‚     createdAt: serverTimestamp(),
   74 â”‚     updatedAt: serverTimestamp()
   75 â”‚   })
   76 â”‚   return docRef.id
   77 â”‚ }
   78 â”‚ 
   79 â”‚ export const createDocumentWithId = async <T extends DocumentData>(
   80 â”‚   collectionName: string,
   81 â”‚   id: string,
   82 â”‚   data: T
   83 â”‚ ): Promise<void> => {
   84 â”‚   await setDoc(doc(db, collectionName, id), {
   85 â”‚     ...data,
   86 â”‚     createdAt: serverTimestamp(),
   87 â”‚     updatedAt: serverTimestamp()
   88 â”‚   })
   89 â”‚ }
   90 â”‚ 
   91 â”‚ export const getDocument = async <T>(
   92 â”‚   collectionName: string,
   93 â”‚   id: string
   94 â”‚ ): Promise<T | null> => {
   95 â”‚   const docRef = doc(db, collectionName, id)
   96 â”‚   const docSnap = await getDoc(docRef)
   97 â”‚   
   98 â”‚   if (docSnap.exists()) {
   99 â”‚     const data = docSnap.data();
  100 â”‚     console.log("Dados brutos recuperados do Firestore para quarto:", id, data);
  101 â”‚     
  102 â”‚     if (data?.serviceFeePct !== undefined) {
  103 â”‚       console.log("serviceFeePct antes da conversÃ£o:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
  104 â”‚       // Garantir que serviceFeePct seja um nÃºmero
  105 â”‚       data.serviceFeePct = Number(data.serviceFeePct);
  106 â”‚       console.log("serviceFeePct apÃ³s conversÃ£o:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
  107 â”‚     }
  108 â”‚     
  109 â”‚     return { id: docSnap.id, ...data } as T
  110 â”‚   } else {
  111 â”‚     return null
  112 â”‚   }
  113 â”‚ }
  114 â”‚ 
  115 â”‚ export const getDocuments = async <T>(
  116 â”‚   collectionName: string,
  117 â”‚   constraints: QueryConstraint[] = [],
  118 â”‚   forceRefresh = false
  119 â”‚ ): Promise<T[]> => {
  120 â”‚   try {
  121 â”‚     const collectionRef = collection(db, collectionName)
  122 â”‚     const q = query(collectionRef, ...constraints)
  123 â”‚     
  124 â”‚     // Se forceRefresh for verdadeiro, adicionar opÃ§Ãµes que forÃ§am uma nova consulta ao Firestore
  125 â”‚     const querySnapshot = await getDocs(q)
  126 â”‚     
  127 â”‚     console.log(`Buscando documentos na coleÃ§Ã£o ${collectionName} - ForÃ§a atualizaÃ§Ã£o: ${forceRefresh}`);
  128 â”‚     
  129 â”‚     return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }) as T)
  130 â”‚   } catch (error) {
  131 â”‚     console.error(`Erro ao buscar documentos da coleÃ§Ã£o ${collectionName}:`, error);
  132 â”‚     return [];
  133 â”‚   }
  134 â”‚ }
  135 â”‚ 
  136 â”‚ export const updateDocument = async <T extends DocumentData>(
  137 â”‚   collectionName: string,
  138 â”‚   id: string,
  139 â”‚   data: Partial<T>
  140 â”‚ ): Promise<void> => {
  141 â”‚   const docRef = doc(db, collectionName, id)
  142 â”‚   await updateDoc(docRef, {
  143 â”‚     ...data,
  144 â”‚     updatedAt: serverTimestamp()
  145 â”‚   })
  146 â”‚ }
  147 â”‚ 
  148 â”‚ export const deleteDocument = async (
  149 â”‚   collectionName: string,
  150 â”‚   id: string
  151 â”‚ ): Promise<boolean> => {
  152 â”‚   const docRef = doc(db, collectionName, id)
  153 â”‚   await deleteDoc(docRef)
  154 â”‚   return true
  155 â”‚ }
  156 â”‚ 
  157 â”‚ // FunÃ§Ãµes para gerenciar quartos
  158 â”‚ export const getRooms = async (forceRefresh = false): Promise<Room[]> => {
  159 â”‚   try {
  160 â”‚     const constraints: QueryConstraint[] = []
  161 â”‚     
  162 â”‚     constraints.push(orderBy('name', 'asc'))
  163 â”‚     
  164 â”‚     const rooms = await getDocuments<Room>('rooms', constraints, forceRefresh)
  165 â”‚     
  166 â”‚     // Garantir que todos os campos necessÃ¡rios estejam presentes
  167 â”‚     return rooms.map(room => {
  168 â”‚       console.log(`Firebase - Quarto ${room.id} dados brutos:`, room);
  169 â”‚       
  170 â”‚       // Garantir que serviceFeePct seja um nÃºmero
  171 â”‚       const serviceFeePct = room.serviceFeePct !== undefined 
  172 â”‚         ? Number(room.serviceFeePct) 
  173 â”‚         : 10;
  174 â”‚         
  175 â”‚       console.log(`Firebase - Quarto ${room.id} serviceFeePct:`, {
  176 â”‚         original: room.serviceFeePct,
  177 â”‚         tipo: typeof room.serviceFeePct,
  178 â”‚         convertido: serviceFeePct
  179 â”‚       });
  180 â”‚       
  181 â”‚       return {
  182 â”‚         id: room.id,
  183 â”‚         name: room.name || '',
  184 â”‚         type: room.type || 'standard',
  185 â”‚         description: room.description || '',
  186 â”‚         price: room.price || 0,
  187 â”‚         capacity: room.capacity || 2,
  188 â”‚         size: room.size || 0,
  189 â”‚         available: room.available !== undefined ? room.available : true,
  190 â”‚         serviceFeePct: serviceFeePct,
  191 â”‚         images: room.images || [],
  192 â”‚         amenities: room.amenities || [],
  193 â”‚         additionalServices: room.additionalServices || [],
  194 â”‚         highlights: room.highlights || [],
  195 â”‚         createdAt: room.createdAt,
  196 â”‚         updatedAt: room.updatedAt
  197 â”‚       };
  198 â”‚     });
  199 â”‚   } catch (error) {
  200 â”‚     console.error('Erro ao buscar quartos:', error)
  201 â”‚     return []
  202 â”‚   }
  203 â”‚ }
  204 â”‚ 
  205 â”‚ export const getAvailableRooms = async (
  206 â”‚   checkIn: Date,
  207 â”‚   checkOut: Date
  208 â”‚ ): Promise<Room[]> => {
  209 â”‚   try {
  210 â”‚     // Buscar todos os quartos que estÃ£o marcados como disponÃ­veis em geral
  211 â”‚     const constraints: QueryConstraint[] = [
  212 â”‚       where('available', '==', true)
  213 â”‚     ]
  214 â”‚     
  215 â”‚     const rooms = await getDocuments<Room>('rooms', constraints);
  216 â”‚     
  217 â”‚     // Filtrar os quartos que estÃ£o disponÃ­veis nas datas especÃ­ficas
  218 â”‚     return filterAvailableRoomsByDate(rooms, checkIn, checkOut);
  219 â”‚   } catch (error) {
  220 â”‚     console.error('Erro ao buscar quartos disponÃ­veis:', error)
  221 â”‚     return []
  222 â”‚   }
  223 â”‚ }
  224 â”‚ 
  225 â”‚ // FunÃ§Ã£o auxiliar para verificar disponibilidade entre datas
  226 â”‚ export const filterAvailableRoomsByDate = (
  227 â”‚   rooms: Room[],
  228 â”‚   checkIn: Date,
  229 â”‚   checkOut: Date
  230 â”‚ ): Room[] => {
  231 â”‚   // Converter checkIn e checkOut para ISO strings
  232 â”‚   const dateStrings = getDatesInRange(checkIn, checkOut);
  233 â”‚   
  234 â”‚   return rooms.filter(room => {
  235 â”‚     // Se nÃ£o tiver controle de disponibilidade especÃ­fico, considera disponÃ­vel
  236 â”‚     if (!room.availabilityDates) return true;
  237 â”‚     
  238 â”‚     // Verificar se alguma data no intervalo estÃ¡ indisponÃ­vel
  239 â”‚     return !dateStrings.some(dateStr => 
  240 â”‚       room.availabilityDates?.[dateStr] === false
  241 â”‚     );
  242 â”‚   });
  243 â”‚ };
  244 â”‚ 
  245 â”‚ // FunÃ§Ã£o para obter disponibilidade de um quarto especÃ­fico
  246 â”‚ export const getRoomAvailability = async (
  247 â”‚   roomId: string, 
  248 â”‚   startDate: Date, 
  249 â”‚   endDate: Date
  250 â”‚ ): Promise<{[date: string]: boolean}> => {
  251 â”‚   try {
  252 â”‚     const room = await getRoomById(roomId);
  253 â”‚     if (!room) throw new Error(`Quarto com ID ${roomId} nÃ£o encontrado`);
  254 â”‚     
  255 â”‚     // Gerar datas no intervalo
  256 â”‚     const dateStrings = getDatesInRange(startDate, endDate);
  257 â”‚     
  258 â”‚     // Se nÃ£o tiver configuraÃ§Ã£o de disponibilidade especÃ­fica, assume tudo disponÃ­vel
  259 â”‚     if (!room.availabilityDates) {
  260 â”‚       return dateStrings.reduce((acc, date) => {
  261 â”‚         acc[date] = true;
  262 â”‚         return acc;
  263 â”‚       }, {} as {[date: string]: boolean});
  264 â”‚     }
  265 â”‚     
  266 â”‚     // Preencher com os dados de disponibilidade existentes
  267 â”‚     return dateStrings.reduce((acc, date) => {
  268 â”‚       acc[date] = room.availabilityDates?.[date] !== false; // disponÃ­vel por padrÃ£o se nÃ£o estiver explicitamente indisponÃ­vel
  269 â”‚       return acc;
  270 â”‚     }, {} as {[date: string]: boolean});
  271 â”‚   } catch (error) {
  272 â”‚     console.error(`Erro ao verificar disponibilidade do quarto ${roomId}:`, error);
  273 â”‚     throw error;
  274 â”‚   }
  275 â”‚ };
  276 â”‚ 
  277 â”‚ // FunÃ§Ã£o para atualizar disponibilidade de um quarto
  278 â”‚ export const updateRoomAvailability = async (
  279 â”‚   roomId: string,
  280 â”‚   availabilityDates: {[date: string]: boolean}
  281 â”‚ ): Promise<boolean> => {
  282 â”‚   try {
  283 â”‚     await updateDocument('rooms', roomId, {
  284 â”‚       availabilityDates,
  285 â”‚       updatedAt: serverTimestamp()
  286 â”‚     });
  287 â”‚     return true;
  288 â”‚   } catch (error) {
  289 â”‚     console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  290 â”‚     return false;
  291 â”‚   }
  292 â”‚ };
  293 â”‚ 
  294 â”‚ // FunÃ§Ã£o auxiliar para gerar array de strings de data entre um intervalo
  295 â”‚ export const getDatesInRange = (startDate: Date, endDate: Date): string[] => {
  296 â”‚   const dates: string[] = [];
  297 â”‚   const currentDate = new Date(startDate);
  298 â”‚   
  299 â”‚   // Normalizar para meia-noite no fuso horÃ¡rio local
  300 â”‚   currentDate.setHours(0, 0, 0, 0);
  301 â”‚   const endDateNormalized = new Date(endDate);
  302 â”‚   endDateNormalized.setHours(0, 0, 0, 0);
  303 â”‚   
  304 â”‚   // Adicionar cada data no intervalo EXCETO o dia de checkout
  305 â”‚   // Usando < em vez de <= para nÃ£o incluir o dia de checkout
  306 â”‚   while (currentDate < endDateNormalized) {
  307 â”‚     dates.push(currentDate.toISOString().split('T')[0]); // Formato YYYY-MM-DD
  308 â”‚     currentDate.setDate(currentDate.getDate() + 1);
  309 â”‚   }
  310 â”‚   
  311 â”‚   return dates;
  312 â”‚ };
  313 â”‚ 
  314 â”‚ export const getRoomById = async (id: string): Promise<Room | null> => {
  315 â”‚   try {
  316 â”‚     const room = await getDocument<Room>('rooms', id);
  317 â”‚     
  318 â”‚     if (!room) return null;
  319 â”‚     
  320 â”‚     console.log(`Firebase - getRoomById ${id} dados brutos:`, room);
  321 â”‚     
  322 â”‚     // Log especÃ­fico para serviceFeePct
  323 â”‚     console.log(`serviceFeePct no Firestore:`, room.serviceFeePct);
  324 â”‚     
  325 â”‚     // Garantir que todos os campos necessÃ¡rios estejam presentes
  326 â”‚     return {
  327 â”‚       ...room,
  328 â”‚       name: room.name || '',
  329 â”‚       type: room.type || 'standard',
  330 â”‚       description: room.description || '',
  331 â”‚       price: room.price || 0,
  332 â”‚       capacity: room.capacity || 2,
  333 â”‚       size: room.size || 0,
  334 â”‚       available: room.available !== undefined ? room.available : true,
  335 â”‚       serviceFeePct: room.serviceFeePct !== undefined ? room.serviceFeePct : 10,
  336 â”‚       images: room.images || [],
  337 â”‚       amenities: room.amenities || [],
  338 â”‚       additionalServices: room.additionalServices || [],
  339 â”‚       highlights: room.highlights || []
  340 â”‚     };
  341 â”‚   } catch (error) {
  342 â”‚     console.error(`Erro ao buscar quarto com ID ${id}:`, error);
  343 â”‚     return null;
  344 â”‚   }
  345 â”‚ }
  346 â”‚ 
  347 â”‚ export const createRoom = async (roomData: Omit<Room, 'id' | 'createdAt' | 'updatedAt'>): Promise<Room> => {
  348 â”‚   try {
  349 â”‚     console.log("createRoom - Dados recebidos:", roomData);
  350 â”‚     
  351 â”‚     const roomWithTimestamps = {
  352 â”‚       ...roomData,
  353 â”‚       available: roomData.available !== undefined ? roomData.available : true,
  354 â”‚       featured: roomData.featured || false,
  355 â”‚       amenities: roomData.amenities || [],
  356 â”‚       additionalServices: roomData.additionalServices || [],
  357 â”‚       highlights: roomData.highlights || [],
  358 â”‚       createdAt: serverTimestamp(),
  359 â”‚       updatedAt: serverTimestamp()
  360 â”‚     }
  361 â”‚     
  362 â”‚     console.log("createRoom - Dados a serem salvos:", roomWithTimestamps);
  363 â”‚     
  364 â”‚     const id = await createDocument('rooms', roomWithTimestamps)
  365 â”‚     
  366 â”‚     return {
  367 â”‚       id,
  368 â”‚       ...roomData,
  369 â”‚       amenities: roomData.amenities || [],
  370 â”‚       additionalServices: roomData.additionalServices || [],
  371 â”‚       highlights: roomData.highlights || [],
  372 â”‚       createdAt: Timestamp.now(),
  373 â”‚       updatedAt: Timestamp.now()
  374 â”‚     }
  375 â”‚   } catch (error) {
  376 â”‚     console.error('Erro ao criar quarto:', error)
  377 â”‚     throw error
  378 â”‚   }
  379 â”‚ }
  380 â”‚ 
  381 â”‚ export const updateRoom = async (id: string, roomData: Partial<Omit<Room, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Room> => {
  382 â”‚   try {
  383 â”‚     console.log(`updateRoom - ID: ${id}, Dados recebidos:`, roomData);
  384 â”‚     
  385 â”‚     // Garantir que estamos lidando explicitamente com o serviceFeePct se ele for 0
  386 â”‚     if (roomData.serviceFeePct === 0) {
  387 â”‚       console.log("updateRoom - Detectado serviceFeePct com valor 0, salvando explicitamente.", roomData.serviceFeePct);
  388 â”‚     }
  389 â”‚     
  390 â”‚     // Adicionar timestamp de atualizaÃ§Ã£o
  391 â”‚     const roomWithTimestamp = {
  392 â”‚       ...roomData,
  393 â”‚       amenities: roomData.amenities || [],
  394 â”‚       additionalServices: roomData.additionalServices || [],
  395 â”‚       highlights: roomData.highlights || [],
  396 â”‚       updatedAt: serverTimestamp()
  397 â”‚     }
  398 â”‚     
  399 â”‚     console.log(`updateRoom - Dados a serem salvos:`, roomWithTimestamp);
  400 â”‚     
  401 â”‚     await updateDocument('rooms', id, roomWithTimestamp)
  402 â”‚     
  403 â”‚     const updatedRoom = await getRoomById(id)
  404 â”‚     if (!updatedRoom) {
  405 â”‚       throw new Error(`Quarto com ID ${id} nÃ£o encontrado apÃ³s atualizaÃ§Ã£o`)
  406 â”‚     }
  407 â”‚     
  408 â”‚     return updatedRoom
  409 â”‚   } catch (error) {
  410 â”‚     console.error('Erro ao atualizar quarto:', error)
  411 â”‚     throw error
  412 â”‚   }
  413 â”‚ }
  414 â”‚ 
  415 â”‚ export const deleteRoom = async (id: string): Promise<boolean> => {
  416 â”‚   return await deleteDocument('rooms', id)
  417 â”‚ }
  418 â”‚ 
  419 â”‚ // FunÃ§Ãµes especÃ­ficas para reservas
  420 â”‚ export const createBooking = async (bookingData: any) => {
  421 â”‚   try {
  422 â”‚     const bookingsCollection = collection(db, 'bookings');
  423 â”‚     const docRef = await addDoc(bookingsCollection, bookingData);
  424 â”‚     
  425 â”‚     // CORREÃ‡ÃƒO: NÃ£o bloquear a data no momento da criaÃ§Ã£o da reserva
  426 â”‚     // O bloqueio serÃ¡ feito apenas quando o pagamento for confirmado
  427 â”‚     // atravÃ©s da funÃ§Ã£o updateBookingStatus
  428 â”‚     
  429 â”‚     return docRef;
  430 â”‚   } catch (error) {
  431 â”‚     console.error('Erro ao criar reserva:', error);
  432 â”‚     throw error;
  433 â”‚   }
  434 â”‚ };
  435 â”‚ 
  436 â”‚ // Nova funÃ§Ã£o para atualizar status da reserva e bloquear as datas da estadia
  437 â”‚ export const updateBookingStatus = async (
  438 â”‚   bookingId: string, 
  439 â”‚   newStatus: 'pending' | 'confirmed' | 'cancelled' | 'completed',
  440 â”‚   newPaymentStatus: 'pending' | 'paid' | 'refunded'
  441 â”‚ ): Promise<boolean> => {
  442 â”‚   try {
  443 â”‚     // ReferÃªncia ao documento da reserva
  444 â”‚     const bookingRef = doc(db, 'bookings', bookingId);
  445 â”‚     const bookingSnap = await getDoc(bookingRef);
  446 â”‚     
  447 â”‚     if (!bookingSnap.exists()) {
  448 â”‚       console.error(`Booking ${bookingId} nÃ£o existe ao atualizar status`);
  449 â”‚       return false;
  450 â”‚     }
  451 â”‚     
  452 â”‚     const bookingData = bookingSnap.data();
  453 â”‚     
  454 â”‚     // Atualizar o status da reserva
  455 â”‚     await updateDoc(bookingRef, {
  456 â”‚       status: newStatus,
  457 â”‚       paymentStatus: newPaymentStatus,
  458 â”‚       updatedAt: serverTimestamp(),
  459 â”‚       ...(newStatus === 'confirmed' && { confirmedAt: serverTimestamp() })
  460 â”‚     });
  461 â”‚     
  462 â”‚     // Se a reserva estÃ¡ sendo confirmada, precisamos bloquear as datas
  463 â”‚     if (newStatus === 'confirmed') {
  464 â”‚       console.log(`Atualizando disponibilidade para reserva confirmada: ${bookingId}`);
  465 â”‚       
  466 â”‚       // Recuperar datas de check-in e check-out
  467 â”‚       const checkIn = bookingData.checkIn.toDate();
  468 â”‚       const checkOut = bookingData.checkOut.toDate();
  469 â”‚       const roomId = bookingData.roomId;
  470 â”‚       
  471 â”‚       // Obter todas as datas entre check-in e check-out
  472 â”‚       const dates: Date[] = [];
  473 â”‚       const currentDate = new Date(checkIn);
  474 â”‚       
  475 â”‚       while (currentDate < checkOut) {
  476 â”‚         dates.push(new Date(currentDate));
  477 â”‚         currentDate.setDate(currentDate.getDate() + 1);
  478 â”‚       }
  479 â”‚       
  480 â”‚       console.log(`Bloqueando ${dates.length} dias para quarto ${roomId}`);
  481 â”‚       
  482 â”‚       // Atualizar disponibilidade para cada data
  483 â”‚       const availabilityUpdates: {[date: string]: boolean} = {};
  484 â”‚       
  485 â”‚       dates.forEach(date => {
  486 â”‚         const dateString = date.toISOString().split('T')[0]; // formato YYYY-MM-DD
  487 â”‚         availabilityUpdates[dateString] = false; // false significa indisponÃ­vel
  488 â”‚       });
  489 â”‚       
  490 â”‚       // Atualizar disponibilidade do quarto
  491 â”‚       if (Object.keys(availabilityUpdates).length > 0) {
  492 â”‚         try {
  493 â”‚           // Obter o documento do quarto
  494 â”‚           const roomRef = doc(db, 'rooms', roomId);
  495 â”‚           const roomSnap = await getDoc(roomRef);
  496 â”‚           
  497 â”‚           if (roomSnap.exists()) {
  498 â”‚             const roomData = roomSnap.data();
  499 â”‚             const currentAvailability = roomData.availabilityDates || {};
  500 â”‚             
  501 â”‚             // Mesclar a disponibilidade atual com as novas atualizaÃ§Ãµes
  502 â”‚             const updatedAvailability = {
  503 â”‚               ...currentAvailability,
  504 â”‚               ...availabilityUpdates
  505 â”‚             };
  506 â”‚             
  507 â”‚             // Atualizar o documento do quarto
  508 â”‚             await updateDoc(roomRef, {
  509 â”‚               availabilityDates: updatedAvailability,
  510 â”‚               updatedAt: serverTimestamp()
  511 â”‚             });
  512 â”‚             
  513 â”‚             console.log(`Disponibilidade atualizada com sucesso para quarto ${roomId}`);
  514 â”‚             
  515 â”‚             // Criar log da reserva
  516 â”‚             await addDoc(collection(db, 'bookingLogs'), {
  517 â”‚               bookingId,
  518 â”‚               roomId,
  519 â”‚               action: 'status_updated',
  520 â”‚               previousStatus: bookingData.status,
  521 â”‚               newStatus,
  522 â”‚               previousPaymentStatus: bookingData.paymentStatus,
  523 â”‚               newPaymentStatus,
  524 â”‚               datesBlocked: Object.keys(availabilityUpdates),
  525 â”‚               timestamp: serverTimestamp(),
  526 â”‚               userId: bookingData.userId || 'system'
  527 â”‚             });
  528 â”‚           } else {
  529 â”‚             console.error(`Quarto ${roomId} nÃ£o encontrado ao atualizar disponibilidade`);
  530 â”‚           }
  531 â”‚         } catch (error) {
  532 â”‚           console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  533 â”‚         }
  534 â”‚       }
  535 â”‚     }
  536 â”‚     
  537 â”‚     return true;
  538 â”‚   } catch (error) {
  539 â”‚     console.error(`Erro ao atualizar status da reserva ${bookingId}:`, error);
  540 â”‚     return false;
  541 â”‚   }
  542 â”‚ }
  543 â”‚ 
  544 â”‚ export const getUserBookings = async (userId: string): Promise<Booking[]> => {
  545 â”‚   return getDocuments<Booking>('bookings', [
  546 â”‚     where('userId', '==', userId),
  547 â”‚     orderBy('createdAt', 'desc')
  548 â”‚   ])
  549 â”‚ }
  550 â”‚ 
  551 â”‚ export const getRecentBookings = async (count = 5): Promise<Booking[]> => {
  552 â”‚   return getDocuments<Booking>('bookings', [
  553 â”‚     orderBy('createdAt', 'desc'),
  554 â”‚     limit(count)
  555 â”‚   ])
  556 â”‚ }
  557 â”‚ 
  558 â”‚ export const getRoomBookings = async (roomId: string): Promise<Booking[]> => {
  559 â”‚   try {
  560 â”‚     const constraints: QueryConstraint[] = [
  561 â”‚       where('roomId', '==', roomId),
  562 â”‚       orderBy('checkIn', 'asc')
  563 â”‚     ];
  564 â”‚     
  565 â”‚     return await getDocuments<Booking>('bookings', constraints);
  566 â”‚   } catch (error) {
  567 â”‚     console.error(`Erro ao buscar reservas do quarto ${roomId}:`, error);
  568 â”‚     return [];
  569 â”‚   }
  570 â”‚ };
  571 â”‚ 
  572 â”‚ // FunÃ§Ãµes especÃ­ficas para contatos
  573 â”‚ export const createContactMessage = async (contactData: Contact) => {
  574 â”‚   try {
  575 â”‚     const contactsCollection = collection(db, 'contacts')
  576 â”‚     
  577 â”‚     // Garantir que o status seja 'new' para novos contatos
  578 â”‚     const contactWithDefaults = {
  579 â”‚       ...contactData,
  580 â”‚       status: contactData.status || 'new',
  581 â”‚       createdAt: contactData.createdAt || Timestamp.now()
  582 â”‚     }
  583 â”‚     
  584 â”‚     // Se tiver detalhes de reserva, adicionar metadados
  585 â”‚     if (contactWithDefaults.reservationDetails) {
  586 â”‚       // Ajustar subject para indicar que Ã© relacionado a reserva
  587 â”‚       if (!contactWithDefaults.subject.includes('Reserva')) {
  588 â”‚         contactWithDefaults.subject = `Reserva: ${contactWithDefaults.subject}`;
  589 â”‚       }
  590 â”‚     }
  591 â”‚     
  592 â”‚     const docRef = await addDoc(contactsCollection, contactWithDefaults)
  593 â”‚     return docRef
  594 â”‚   } catch (error) {
  595 â”‚     console.error('Erro ao criar mensagem de contato:', error)
  596 â”‚     throw error
  597 â”‚   }
  598 â”‚ }
  599 â”‚ 
  600 â”‚ export const getNewContactMessages = async (): Promise<Contact[]> => {
  601 â”‚   return getDocuments<Contact>('contacts', [
  602 â”‚     where('status', '==', 'new'),
  603 â”‚     orderBy('createdAt', 'desc')
  604 â”‚   ])
  605 â”‚ }
  606 â”‚ 
  607 â”‚ // FunÃ§Ãµes para Dashboard com dados reais
  608 â”‚ 
  609 â”‚ export const getDashboardStats = async () => {
  610 â”‚   try {
  611 â”‚     const [totalBookings, totalRevenue, occupancyRate, bookingsByPlatform] = await Promise.all([
  612 â”‚       getTotalBookings(),
  613 â”‚       getMonthlyRevenue(),
  614 â”‚       getOccupancyRate(),
  615 â”‚       getBookingsByPlatform()
  616 â”‚     ]);
  617 â”‚ 
  618 â”‚     return {
  619 â”‚       totalBookings,
  620 â”‚       totalRevenue,
  621 â”‚       occupancyRate,
  622 â”‚       bookingsByPlatform
  623 â”‚     };
  624 â”‚   } catch (error) {
  625 â”‚     console.error('Erro ao obter estatÃ­sticas do dashboard:', error);
  626 â”‚     throw error;
  627 â”‚   }
  628 â”‚ };
  629 â”‚ 
  630 â”‚ // Obter total de reservas
  631 â”‚ export const getTotalBookings = async () => {
  632 â”‚   try {
  633 â”‚     // Obter todas as reservas
  634 â”‚     const bookings = await getDocuments<Booking>('bookings');
  635 â”‚     
  636 â”‚     // Contar reservas por status
  637 â”‚     const confirmed = bookings.filter(b => b.status === 'confirmed').length;
  638 â”‚     const pending = bookings.filter(b => b.status === 'pending').length;
  639 â”‚     const cancelled = bookings.filter(b => b.status === 'cancelled').length;
  640 â”‚     const completed = bookings.filter(b => b.status === 'completed').length;
  641 â”‚     
  642 â”‚     // Calcular crescimento em relaÃ§Ã£o ao mÃªs anterior (simulado por enquanto)
  643 â”‚     // Em uma implementaÃ§Ã£o real, vocÃª compararia com dados do mÃªs anterior
  644 â”‚     const growth = ((confirmed + completed) / (bookings.length || 1) * 100) - 50;
  645 â”‚     
  646 â”‚     return {
  647 â”‚       total: bookings.length,
  648 â”‚       confirmed,
  649 â”‚       pending,
  650 â”‚       cancelled,
  651 â”‚       completed,
  652 â”‚       growth: Math.round(growth) // Arredonda para nÃºmero inteiro
  653 â”‚     };
  654 â”‚   } catch (error) {
  655 â”‚     console.error('Erro ao obter total de reservas:', error);
  656 â”‚     return {
  657 â”‚       total: 0,
  658 â”‚       confirmed: 0,
  659 â”‚       pending: 0, 
  660 â”‚       cancelled: 0,
  661 â”‚       completed: 0,
  662 â”‚       growth: 0
  663 â”‚     };
  664 â”‚   }
  665 â”‚ };
  666 â”‚ 
  667 â”‚ // Obter receita mensal
  668 â”‚ export const getMonthlyRevenue = async () => {
  669 â”‚   try {
  670 â”‚     const bookings = await getDocuments<Booking>('bookings');
  671 â”‚     
  672 â”‚     // Filtrar reservas confirmadas e concluÃ­das
  673 â”‚     const validBookings = bookings.filter(b => 
  674 â”‚       b.status === 'confirmed' || b.status === 'completed'
  675 â”‚     );
  676 â”‚     
  677 â”‚     // Calcular receita total
  678 â”‚     const totalRevenue = validBookings.reduce((acc, booking) => acc + booking.totalPrice, 0);
  679 â”‚     
  680 â”‚     // Agrupar receita por mÃªs
  681 â”‚     const revenueByMonth = validBookings.reduce((acc, booking) => {
  682 â”‚       const date = booking.checkIn.toDate();
  683 â”‚       const month = date.getMonth(); // 0-11
  684 â”‚       const year = date.getFullYear();
  685 â”‚       const key = `${year}-${month}`;
  686 â”‚       
  687 â”‚       if (!acc[key]) {
  688 â”‚         acc[key] = 0;
  689 â”‚       }
  690 â”‚       acc[key] += booking.totalPrice;
  691 â”‚       return acc;
  692 â”‚     }, {} as Record<string, number>);
  693 â”‚     
  694 â”‚     // Converter para formato de array para grÃ¡fico
  695 â”‚     const monthNames = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
  696 â”‚     
  697 â”‚     const currentDate = new Date();
  698 â”‚     const currentMonth = currentDate.getMonth();
  699 â”‚     const currentYear = currentDate.getFullYear();
  700 â”‚     
  701 â”‚     const revenueData = [];
  702 â”‚     
  703 â”‚     // Gerar dados dos Ãºltimos 12 meses
  704 â”‚     for (let i = 0; i < 12; i++) {
  705 â”‚       const month = (currentMonth - i + 12) % 12;
  706 â”‚       const year = currentMonth - i < 0 ? currentYear - 1 : currentYear;
  707 â”‚       const key = `${year}-${month}`;
  708 â”‚       
  709 â”‚       revenueData.unshift({
  710 â”‚         month: monthNames[month],
  711 â”‚         value: revenueByMonth[key] || 0
  712 â”‚       });
  713 â”‚     }
  714 â”‚     
  715 â”‚     // Calcular crescimento em relaÃ§Ã£o ao mÃªs anterior
  716 â”‚     const lastMonthRevenue = revenueData[revenueData.length - 2]?.value || 0;
  717 â”‚     const currentMonthRevenue = revenueData[revenueData.length - 1]?.value || 0;
  718 â”‚     
  719 â”‚     const growth = lastMonthRevenue ? ((currentMonthRevenue - lastMonthRevenue) / lastMonthRevenue) * 100 : 0;
  720 â”‚     
  721 â”‚     return {
  722 â”‚       monthly: currentMonthRevenue,
  723 â”‚       total: totalRevenue,
  724 â”‚       growth: Math.round(growth),
  725 â”‚       revenueData
  726 â”‚     };
  727 â”‚   } catch (error) {
  728 â”‚     console.error('Erro ao obter receita mensal:', error);
  729 â”‚     return {
  730 â”‚       monthly: 0,
  731 â”‚       total: 0,
  732 â”‚       growth: 0,
  733 â”‚       revenueData: []
  734 â”‚     };
  735 â”‚   }
  736 â”‚ };
  737 â”‚ 
  738 â”‚ // Calcular taxa de ocupaÃ§Ã£o
  739 â”‚ export const getOccupancyRate = async () => {
  740 â”‚   try {
  741 â”‚     // Obter todos os quartos
  742 â”‚     const rooms = await getDocuments<Room>('rooms');
  743 â”‚     const totalRooms = rooms.length;
  744 â”‚     
  745 â”‚     if (totalRooms === 0) {
  746 â”‚       return { rate: 0, growth: 0 };
  747 â”‚     }
  748 â”‚     
  749 â”‚     // Obter todas as reservas
  750 â”‚     const bookings = await getDocuments<Booking>('bookings');
  751 â”‚     
  752 â”‚     // Filtrar reservas confirmadas e concluÃ­das para o mÃªs atual
  753 â”‚     const currentDate = new Date();
  754 â”‚     const currentMonth = currentDate.getMonth();
  755 â”‚     const currentYear = currentDate.getFullYear();
  756 â”‚     
  757 â”‚     const currentMonthBookings = bookings.filter(booking => {
  758 â”‚       const checkInDate = booking.checkIn.toDate();
  759 â”‚       return (
  760 â”‚         (booking.status === 'confirmed' || booking.status === 'completed') &&
  761 â”‚         checkInDate.getMonth() === currentMonth &&
  762 â”‚         checkInDate.getFullYear() === currentYear
  763 â”‚       );
  764 â”‚     });
  765 â”‚     
  766 â”‚     // Calcular dias ocupados por quarto
  767 â”‚     const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
  768 â”‚     const totalPossibleRoomDays = totalRooms * daysInMonth;
  769 â”‚     
  770 â”‚     // Contar dias ocupados (simplificado - em produÃ§Ã£o seria mais complexo)
  771 â”‚     let occupiedDays = 0;
  772 â”‚     
  773 â”‚     currentMonthBookings.forEach(booking => {
  774 â”‚       const checkIn = booking.checkIn.toDate();
  775 â”‚       const checkOut = booking.checkOut.toDate();
  776 â”‚       
  777 â”‚       // Ajustar datas para considerar apenas o mÃªs atual
  778 â”‚       const startDate = new Date(Math.max(
  779 â”‚         checkIn.getTime(),
  780 â”‚         new Date(currentYear, currentMonth, 1).getTime()
  781 â”‚       ));
  782 â”‚       const endDate = new Date(Math.min(
  783 â”‚         checkOut.getTime(),
  784 â”‚         new Date(currentYear, currentMonth + 1, 0).getTime()
  785 â”‚       ));
  786 â”‚       
  787 â”‚       // Calcular dias entre datas (incluindo check-in, excluindo check-out)
  788 â”‚       const days = Math.max(0, Math.floor((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)));
  789 â”‚       occupiedDays += days;
  790 â”‚     });
  791 â”‚     
  792 â”‚     const occupancyRate = (occupiedDays / totalPossibleRoomDays) * 100;
  793 â”‚     
  794 â”‚     // SimulaÃ§Ã£o de crescimento (em produÃ§Ã£o, compararia com mÃªs anterior)
  795 â”‚     const growth = occupancyRate > 50 ? 5 : -3;
  796 â”‚     
  797 â”‚     return {
  798 â”‚       rate: Math.round(occupancyRate),
  799 â”‚       growth: Math.round(growth)
  800 â”‚     };
  801 â”‚   } catch (error) {
  802 â”‚     console.error('Erro ao calcular taxa de ocupaÃ§Ã£o:', error);
  803 â”‚     return { rate: 0, growth: 0 };
  804 â”‚   }
  805 â”‚ };
  806 â”‚ 
  807 â”‚ // Obter reservas agrupadas por plataforma
  808 â”‚ export const getBookingsByPlatform = async () => {
  809 â”‚   try {
  810 â”‚     const bookings = await getDocuments<Booking>('bookings');
  811 â”‚     
  812 â”‚     // Categorizar reservas por origem
  813 â”‚     const platforms = [
  814 â”‚       { 
  815 â”‚         platform: "Booking.com", 
  816 â”‚         color: "#003580", 
  817 â”‚         icon: "Globe",
  818 â”‚         bookings: []
  819 â”‚       },
  820 â”‚       { 
  821 â”‚         platform: "Airbnb", 
  822 â”‚         color: "#FF5A5F", 
  823 â”‚         icon: "Heart",
  824 â”‚         bookings: []
  825 â”‚       },
  826 â”‚       { 
  827 â”‚         platform: "Direto", 
  828 â”‚         color: "#4CAF50", 
  829 â”‚         icon: "Home",
  830 â”‚         bookings: []
  831 â”‚       }
  832 â”‚     ];
  833 â”‚     
  834 â”‚     // Para fins de demonstraÃ§Ã£o, colocar todas as reservas como "Direto" por enquanto
  835 â”‚     // Em produÃ§Ã£o, usaria um campo "platformOrigin" ou similar na tabela de reservas
  836 â”‚     const platformIndex = 2; // Ãndice da plataforma "Direto"
  837 â”‚     
  838 â”‚     bookings.forEach(booking => {
  839 â”‚       // Transformar para o formato esperado pelo componente
  840 â”‚       const transformedBooking = {
  841 â”‚         id: booking.id || '',
  842 â”‚         guestName: booking.guestName,
  843 â”‚         roomName: booking.roomName,
  844 â”‚         checkIn: booking.checkIn.toDate().toLocaleDateString('pt-PT'),
  845 â”‚         checkOut: booking.checkOut.toDate().toLocaleDateString('pt-PT'),
  846 â”‚         status: booking.status,
  847 â”‚         value: new Intl.NumberFormat('pt-PT', {
  848 â”‚           style: 'currency',
  849 â”‚           currency: 'EUR'
  850 â”‚         }).format(booking.totalPrice)
  851 â”‚       };
  852 â”‚       
  853 â”‚       // Adicionar Ã  plataforma "Direto"
  854 â”‚       (platforms[platformIndex] as any).bookings.push(transformedBooking);
  855 â”‚     });
  856 â”‚     
  857 â”‚     return platforms;
  858 â”‚   } catch (error) {
  859 â”‚     console.error('Erro ao obter reservas por plataforma:', error);
  860 â”‚     return [];
  861 â”‚   }
  862 â”‚ };
  863 â”‚ 
  864 â”‚ // FunÃ§Ã£o para obter o preÃ§o de um quarto para uma data especÃ­fica
  865 â”‚ export const getRoomPriceForDate = async (roomId: string, date: Date): Promise<number> => {
  866 â”‚   try {
  867 â”‚     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  868 â”‚     
  869 â”‚     if (!roomDoc.exists()) {
  870 â”‚       throw new Error("Quarto nÃ£o encontrado");
  871 â”‚     }
  872 â”‚     
  873 â”‚     const roomData = roomDoc.data() as Room;
  874 â”‚     const basePrice = roomData.price;
  875 â”‚     
  876 â”‚     if (!roomData.seasonalPrices || roomData.seasonalPrices.length === 0) {
  877 â”‚       return basePrice;
  878 â”‚     }
  879 â”‚     
  880 â”‚     // Verificar se a data estÃ¡ dentro de algum perÃ­odo sazonal
  881 â”‚     for (const seasonalPrice of roomData.seasonalPrices) {
  882 â”‚       const startDate = new Date(seasonalPrice.startDate);
  883 â”‚       const endDate = new Date(seasonalPrice.endDate);
  884 â”‚       
  885 â”‚       if (date >= startDate && date <= endDate) {
  886 â”‚         return seasonalPrice.price;
  887 â”‚       }
  888 â”‚     }
  889 â”‚     
  890 â”‚     // Se nÃ£o cair em nenhum perÃ­odo sazonal, retorna o preÃ§o base
  891 â”‚     return basePrice;
  892 â”‚   } catch (error) {
  893 â”‚     console.error("Erro ao obter preÃ§o do quarto:", error);
  894 â”‚     throw error;
  895 â”‚   }
  896 â”‚ }
  897 â”‚ 
  898 â”‚ // FunÃ§Ã£o para calcular o preÃ§o total de uma estadia
  899 â”‚ export const calculateStayPrice = async (
  900 â”‚   roomId: string, 
  901 â”‚   checkIn: Date, 
  902 â”‚   checkOut: Date
  903 â”‚ ): Promise<{
  904 â”‚   totalPrice: number;
  905 â”‚   nightlyPrices: { date: string; price: number }[];
  906 â”‚   serviceFee: number;
  907 â”‚   totalWithFee: number;
  908 â”‚ }> => {
  909 â”‚   try {
  910 â”‚     console.log(`ğŸ” Iniciando cÃ¡lculo de preÃ§o para estadia: ${checkIn.toISOString().split('T')[0]} atÃ© ${checkOut.toISOString().split('T')[0]}`);
  911 â”‚     
  912 â”‚     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  913 â”‚     
  914 â”‚     if (!roomDoc.exists()) {
  915 â”‚       throw new Error("Quarto nÃ£o encontrado");
  916 â”‚     }
  917 â”‚     
  918 â”‚     const roomData = roomDoc.data() as Room;
  919 â”‚     console.log(`ğŸ“ Dados do quarto ${roomId}:`, {
  920 â”‚       nome: roomData.name,
  921 â”‚       precoBase: roomData.price,
  922 â”‚       taxaServico: roomData.serviceFeePct || 0,
  923 â”‚       temPrecosSazonais: !!roomData.seasonalPrices?.length
  924 â”‚     });
  925 â”‚     
  926 â”‚     const nightlyPrices: { date: string; price: number }[] = [];
  927 â”‚     let totalPrice = 0;
  928 â”‚     
  929 â”‚     // Calcular o nÃºmero de noites - corrigido para usar o mÃ©todo correto de cÃ¡lculo
  930 â”‚     // O nÃºmero de noites Ã© a diferenÃ§a em dias (estadia = checkout - checkin)
  931 â”‚     const noites = differenceInDays(checkOut, checkIn);
  932 â”‚     console.log(`ğŸ—“ï¸ NÃºmero de noites calculado: ${noites}`);
  933 â”‚     
  934 â”‚     if (noites <= 0) {
  935 â”‚       console.error(`âš ï¸ Erro: nÃºmero de noites invÃ¡lido (${noites})`);
  936 â”‚       throw new Error("Data de check-out deve ser posterior Ã  data de check-in");
  937 â”‚     }
  938 â”‚     
  939 â”‚     // Para cada noite, verificar o preÃ§o aplicÃ¡vel (preÃ§o base ou sazonal)
  940 â”‚     // ComeÃ§amos exatamente do dia de check-in
  941 â”‚     const currentDate = new Date(checkIn);
  942 â”‚     currentDate.setHours(0, 0, 0, 0); // Normalizar para meia-noite
  943 â”‚     
  944 â”‚     // Processamos cada dia de estadia (noite)
  945 â”‚     console.log(`ğŸ“Š Calculando preÃ§os por noite:`);
  946 â”‚     for (let i = 0; i < noites; i++) {
  947 â”‚       // Obtemos o preÃ§o para esta data
  948 â”‚       const dateCopy = new Date(currentDate);
  949 â”‚       const priceForDate = await getRoomPriceForDate(roomId, dateCopy);
  950 â”‚       const dateString = dateCopy.toISOString().split('T')[0]; // YYYY-MM-DD
  951 â”‚       
  952 â”‚       console.log(`   - ${dateString}: â‚¬${priceForDate}`);
  953 â”‚       
  954 â”‚       nightlyPrices.push({
  955 â”‚         date: dateString,
  956 â”‚         price: priceForDate
  957 â”‚       });
  958 â”‚       
  959 â”‚       totalPrice += priceForDate;
  960 â”‚       
  961 â”‚       // AvanÃ§amos para o prÃ³ximo dia
  962 â”‚       currentDate.setDate(currentDate.getDate() + 1);
  963 â”‚     }
  964 â”‚     
  965 â”‚     // VerificaÃ§Ã£o de seguranÃ§a para o cÃ¡lculo do totalPrice
  966 â”‚     const manualTotal = nightlyPrices.reduce((sum, night) => sum + night.price, 0);
  967 â”‚     if (Math.abs(totalPrice - manualTotal) > 1) {
  968 â”‚       console.error(`âš ï¸ DiscrepÃ¢ncia detectada no cÃ¡lculo do preÃ§o total!`);
  969 â”‚       console.error(`   - Total calculado iterativamente: â‚¬${totalPrice}`);
  970 â”‚       console.error(`   - Total calculado via reduce: â‚¬${manualTotal}`);
  971 â”‚       console.error(`   - Usando o valor recalculado para seguranÃ§a!`);
  972 â”‚       totalPrice = manualTotal;
  973 â”‚     }
  974 â”‚     
  975 â”‚     // Calcular taxa de serviÃ§o
  976 â”‚     const serviceFee = (totalPrice * (roomData.serviceFeePct || 0)) / 100;
  977 â”‚     const totalWithFee = totalPrice + serviceFee;
  978 â”‚     
  979 â”‚     console.log(`ğŸ’° Resumo do cÃ¡lculo:`);
  980 â”‚     console.log(`   - Total das diÃ¡rias: â‚¬${totalPrice}`);
  981 â”‚     console.log(`   - Taxa de serviÃ§o (${roomData.serviceFeePct || 0}%): â‚¬${serviceFee}`);
  982 â”‚     console.log(`   - Total com taxas: â‚¬${totalWithFee}`);
  983 â”‚     
  984 â”‚     return {
  985 â”‚       totalPrice,
  986 â”‚       nightlyPrices,
  987 â”‚       serviceFee,
  988 â”‚       totalWithFee
  989 â”‚     };
  990 â”‚   } catch (error) {
  991 â”‚     console.error("âŒ Erro ao calcular preÃ§o da estadia:", error);
  992 â”‚     throw error;
  993 â”‚   }
  994 â”‚ } 
  995 â”‚ import { 
  996 â”‚   collection, 
  997 â”‚   getDocs, 
  998 â”‚   getDoc, 
  999 â”‚   doc, 
      Â·   â”€â”¬â”€
      Â·    â•°â”€â”€ `doc` redefined here
 1000 â”‚   setDoc, 
 1001 â”‚   addDoc, 
 1002 â”‚   updateDoc, 
      â•°â”€â”€â”€â”€

  Ã— the name `setDoc` is defined multiple times
      â•­â”€[/home/runner/workspace/lib/firebase/firestore.ts:1:1]
    1 â”‚ import {
    2 â”‚   collection,
    3 â”‚   doc,
    4 â”‚   setDoc,
      Â·   â”€â”€â”€â”¬â”€â”€
      Â·      â•°â”€â”€ previous definition of `setDoc` here
    5 â”‚   addDoc,
    6 â”‚   getDoc,
    7 â”‚   getDocs,
    8 â”‚   updateDoc,
    9 â”‚   deleteDoc,
   10 â”‚   query,
   11 â”‚   where,
   12 â”‚   orderBy,
   13 â”‚   limit,
   14 â”‚   DocumentData,
   15 â”‚   QueryConstraint,
   16 â”‚   Timestamp,
   17 â”‚   serverTimestamp
   18 â”‚ } from 'firebase/firestore'
   19 â”‚ import { db } from './config'
   20 â”‚ import { Room, SeasonalPrice } from '@/lib/types'
   21 â”‚ import { differenceInDays } from 'date-fns'
   22 â”‚ 
   23 â”‚ // Tipos de dados
   24 â”‚ export interface Booking {
   25 â”‚   id?: string
   26 â”‚   userId?: string
   27 â”‚   guestName: string
   28 â”‚   guestEmail: string
   29 â”‚   guestPhone: string
   30 â”‚   roomId: string
   31 â”‚   roomName: string
   32 â”‚   checkIn: Timestamp
   33 â”‚   checkOut: Timestamp
   34 â”‚   adults: number
   35 â”‚   children: number
   36 â”‚   totalPrice: number
   37 â”‚   status: 'pending' | 'confirmed' | 'cancelled' | 'completed'
   38 â”‚   paymentStatus: 'pending' | 'paid' | 'refunded'
   39 â”‚   specialRequests?: string
   40 â”‚   createdAt?: Timestamp
   41 â”‚   updatedAt?: Timestamp
   42 â”‚ }
   43 â”‚ 
   44 â”‚ export interface Contact {
   45 â”‚   id?: string
   46 â”‚   name: string
   47 â”‚   email: string
   48 â”‚   phone?: string
   49 â”‚   subject: string
   50 â”‚   message: string
   51 â”‚   status: 'new' | 'read' | 'replied'
   52 â”‚   createdAt: Timestamp
   53 â”‚   updatedAt?: Timestamp
   54 â”‚   repliedAt?: Timestamp
   55 â”‚   replyContent?: string
   56 â”‚   reservationDetails?: {
   57 â”‚     checkIn?: Timestamp
   58 â”‚     checkOut?: Timestamp
   59 â”‚     roomId?: string
   60 â”‚     roomName?: string
   61 â”‚     totalGuests?: number
   62 â”‚     totalPrice?: number
   63 â”‚   }
   64 â”‚ }
   65 â”‚ 
   66 â”‚ // FunÃ§Ãµes genÃ©ricas para CRUD
   67 â”‚ export const createDocument = async <T extends DocumentData>(
   68 â”‚   collectionName: string,
   69 â”‚   data: T
   70 â”‚ ): Promise<string> => {
   71 â”‚   const docRef = await addDoc(collection(db, collectionName), {
   72 â”‚     ...data,
   73 â”‚     createdAt: serverTimestamp(),
   74 â”‚     updatedAt: serverTimestamp()
   75 â”‚   })
   76 â”‚   return docRef.id
   77 â”‚ }
   78 â”‚ 
   79 â”‚ export const createDocumentWithId = async <T extends DocumentData>(
   80 â”‚   collectionName: string,
   81 â”‚   id: string,
   82 â”‚   data: T
   83 â”‚ ): Promise<void> => {
   84 â”‚   await setDoc(doc(db, collectionName, id), {
   85 â”‚     ...data,
   86 â”‚     createdAt: serverTimestamp(),
   87 â”‚     updatedAt: serverTimestamp()
   88 â”‚   })
   89 â”‚ }
   90 â”‚ 
   91 â”‚ export const getDocument = async <T>(
   92 â”‚   collectionName: string,
   93 â”‚   id: string
   94 â”‚ ): Promise<T | null> => {
   95 â”‚   const docRef = doc(db, collectionName, id)
   96 â”‚   const docSnap = await getDoc(docRef)
   97 â”‚   
   98 â”‚   if (docSnap.exists()) {
   99 â”‚     const data = docSnap.data();
  100 â”‚     console.log("Dados brutos recuperados do Firestore para quarto:", id, data);
  101 â”‚     
  102 â”‚     if (data?.serviceFeePct !== undefined) {
  103 â”‚       console.log("serviceFeePct antes da conversÃ£o:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
  104 â”‚       // Garantir que serviceFeePct seja um nÃºmero
  105 â”‚       data.serviceFeePct = Number(data.serviceFeePct);
  106 â”‚       console.log("serviceFeePct apÃ³s conversÃ£o:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
  107 â”‚     }
  108 â”‚     
  109 â”‚     return { id: docSnap.id, ...data } as T
  110 â”‚   } else {
  111 â”‚     return null
  112 â”‚   }
  113 â”‚ }
  114 â”‚ 
  115 â”‚ export const getDocuments = async <T>(
  116 â”‚   collectionName: string,
  117 â”‚   constraints: QueryConstraint[] = [],
  118 â”‚   forceRefresh = false
  119 â”‚ ): Promise<T[]> => {
  120 â”‚   try {
  121 â”‚     const collectionRef = collection(db, collectionName)
  122 â”‚     const q = query(collectionRef, ...constraints)
  123 â”‚     
  124 â”‚     // Se forceRefresh for verdadeiro, adicionar opÃ§Ãµes que forÃ§am uma nova consulta ao Firestore
  125 â”‚     const querySnapshot = await getDocs(q)
  126 â”‚     
  127 â”‚     console.log(`Buscando documentos na coleÃ§Ã£o ${collectionName} - ForÃ§a atualizaÃ§Ã£o: ${forceRefresh}`);
  128 â”‚     
  129 â”‚     return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }) as T)
  130 â”‚   } catch (error) {
  131 â”‚     console.error(`Erro ao buscar documentos da coleÃ§Ã£o ${collectionName}:`, error);
  132 â”‚     return [];
  133 â”‚   }
  134 â”‚ }
  135 â”‚ 
  136 â”‚ export const updateDocument = async <T extends DocumentData>(
  137 â”‚   collectionName: string,
  138 â”‚   id: string,
  139 â”‚   data: Partial<T>
  140 â”‚ ): Promise<void> => {
  141 â”‚   const docRef = doc(db, collectionName, id)
  142 â”‚   await updateDoc(docRef, {
  143 â”‚     ...data,
  144 â”‚     updatedAt: serverTimestamp()
  145 â”‚   })
  146 â”‚ }
  147 â”‚ 
  148 â”‚ export const deleteDocument = async (
  149 â”‚   collectionName: string,
  150 â”‚   id: string
  151 â”‚ ): Promise<boolean> => {
  152 â”‚   const docRef = doc(db, collectionName, id)
  153 â”‚   await deleteDoc(docRef)
  154 â”‚   return true
  155 â”‚ }
  156 â”‚ 
  157 â”‚ // FunÃ§Ãµes para gerenciar quartos
  158 â”‚ export const getRooms = async (forceRefresh = false): Promise<Room[]> => {
  159 â”‚   try {
  160 â”‚     const constraints: QueryConstraint[] = []
  161 â”‚     
  162 â”‚     constraints.push(orderBy('name', 'asc'))
  163 â”‚     
  164 â”‚     const rooms = await getDocuments<Room>('rooms', constraints, forceRefresh)
  165 â”‚     
  166 â”‚     // Garantir que todos os campos necessÃ¡rios estejam presentes
  167 â”‚     return rooms.map(room => {
  168 â”‚       console.log(`Firebase - Quarto ${room.id} dados brutos:`, room);
  169 â”‚       
  170 â”‚       // Garantir que serviceFeePct seja um nÃºmero
  171 â”‚       const serviceFeePct = room.serviceFeePct !== undefined 
  172 â”‚         ? Number(room.serviceFeePct) 
  173 â”‚         : 10;
  174 â”‚         
  175 â”‚       console.log(`Firebase - Quarto ${room.id} serviceFeePct:`, {
  176 â”‚         original: room.serviceFeePct,
  177 â”‚         tipo: typeof room.serviceFeePct,
  178 â”‚         convertido: serviceFeePct
  179 â”‚       });
  180 â”‚       
  181 â”‚       return {
  182 â”‚         id: room.id,
  183 â”‚         name: room.name || '',
  184 â”‚         type: room.type || 'standard',
  185 â”‚         description: room.description || '',
  186 â”‚         price: room.price || 0,
  187 â”‚         capacity: room.capacity || 2,
  188 â”‚         size: room.size || 0,
  189 â”‚         available: room.available !== undefined ? room.available : true,
  190 â”‚         serviceFeePct: serviceFeePct,
  191 â”‚         images: room.images || [],
  192 â”‚         amenities: room.amenities || [],
  193 â”‚         additionalServices: room.additionalServices || [],
  194 â”‚         highlights: room.highlights || [],
  195 â”‚         createdAt: room.createdAt,
  196 â”‚         updatedAt: room.updatedAt
  197 â”‚       };
  198 â”‚     });
  199 â”‚   } catch (error) {
  200 â”‚     console.error('Erro ao buscar quartos:', error)
  201 â”‚     return []
  202 â”‚   }
  203 â”‚ }
  204 â”‚ 
  205 â”‚ export const getAvailableRooms = async (
  206 â”‚   checkIn: Date,
  207 â”‚   checkOut: Date
  208 â”‚ ): Promise<Room[]> => {
  209 â”‚   try {
  210 â”‚     // Buscar todos os quartos que estÃ£o marcados como disponÃ­veis em geral
  211 â”‚     const constraints: QueryConstraint[] = [
  212 â”‚       where('available', '==', true)
  213 â”‚     ]
  214 â”‚     
  215 â”‚     const rooms = await getDocuments<Room>('rooms', constraints);
  216 â”‚     
  217 â”‚     // Filtrar os quartos que estÃ£o disponÃ­veis nas datas especÃ­ficas
  218 â”‚     return filterAvailableRoomsByDate(rooms, checkIn, checkOut);
  219 â”‚   } catch (error) {
  220 â”‚     console.error('Erro ao buscar quartos disponÃ­veis:', error)
  221 â”‚     return []
  222 â”‚   }
  223 â”‚ }
  224 â”‚ 
  225 â”‚ // FunÃ§Ã£o auxiliar para verificar disponibilidade entre datas
  226 â”‚ export const filterAvailableRoomsByDate = (
  227 â”‚   rooms: Room[],
  228 â”‚   checkIn: Date,
  229 â”‚   checkOut: Date
  230 â”‚ ): Room[] => {
  231 â”‚   // Converter checkIn e checkOut para ISO strings
  232 â”‚   const dateStrings = getDatesInRange(checkIn, checkOut);
  233 â”‚   
  234 â”‚   return rooms.filter(room => {
  235 â”‚     // Se nÃ£o tiver controle de disponibilidade especÃ­fico, considera disponÃ­vel
  236 â”‚     if (!room.availabilityDates) return true;
  237 â”‚     
  238 â”‚     // Verificar se alguma data no intervalo estÃ¡ indisponÃ­vel
  239 â”‚     return !dateStrings.some(dateStr => 
  240 â”‚       room.availabilityDates?.[dateStr] === false
  241 â”‚     );
  242 â”‚   });
  243 â”‚ };
  244 â”‚ 
  245 â”‚ // FunÃ§Ã£o para obter disponibilidade de um quarto especÃ­fico
  246 â”‚ export const getRoomAvailability = async (
  247 â”‚   roomId: string, 
  248 â”‚   startDate: Date, 
  249 â”‚   endDate: Date
  250 â”‚ ): Promise<{[date: string]: boolean}> => {
  251 â”‚   try {
  252 â”‚     const room = await getRoomById(roomId);
  253 â”‚     if (!room) throw new Error(`Quarto com ID ${roomId} nÃ£o encontrado`);
  254 â”‚     
  255 â”‚     // Gerar datas no intervalo
  256 â”‚     const dateStrings = getDatesInRange(startDate, endDate);
  257 â”‚     
  258 â”‚     // Se nÃ£o tiver configuraÃ§Ã£o de disponibilidade especÃ­fica, assume tudo disponÃ­vel
  259 â”‚     if (!room.availabilityDates) {
  260 â”‚       return dateStrings.reduce((acc, date) => {
  261 â”‚         acc[date] = true;
  262 â”‚         return acc;
  263 â”‚       }, {} as {[date: string]: boolean});
  264 â”‚     }
  265 â”‚     
  266 â”‚     // Preencher com os dados de disponibilidade existentes
  267 â”‚     return dateStrings.reduce((acc, date) => {
  268 â”‚       acc[date] = room.availabilityDates?.[date] !== false; // disponÃ­vel por padrÃ£o se nÃ£o estiver explicitamente indisponÃ­vel
  269 â”‚       return acc;
  270 â”‚     }, {} as {[date: string]: boolean});
  271 â”‚   } catch (error) {
  272 â”‚     console.error(`Erro ao verificar disponibilidade do quarto ${roomId}:`, error);
  273 â”‚     throw error;
  274 â”‚   }
  275 â”‚ };
  276 â”‚ 
  277 â”‚ // FunÃ§Ã£o para atualizar disponibilidade de um quarto
  278 â”‚ export const updateRoomAvailability = async (
  279 â”‚   roomId: string,
  280 â”‚   availabilityDates: {[date: string]: boolean}
  281 â”‚ ): Promise<boolean> => {
  282 â”‚   try {
  283 â”‚     await updateDocument('rooms', roomId, {
  284 â”‚       availabilityDates,
  285 â”‚       updatedAt: serverTimestamp()
  286 â”‚     });
  287 â”‚     return true;
  288 â”‚   } catch (error) {
  289 â”‚     console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  290 â”‚     return false;
  291 â”‚   }
  292 â”‚ };
  293 â”‚ 
  294 â”‚ // FunÃ§Ã£o auxiliar para gerar array de strings de data entre um intervalo
  295 â”‚ export const getDatesInRange = (startDate: Date, endDate: Date): string[] => {
  296 â”‚   const dates: string[] = [];
  297 â”‚   const currentDate = new Date(startDate);
  298 â”‚   
  299 â”‚   // Normalizar para meia-noite no fuso horÃ¡rio local
  300 â”‚   currentDate.setHours(0, 0, 0, 0);
  301 â”‚   const endDateNormalized = new Date(endDate);
  302 â”‚   endDateNormalized.setHours(0, 0, 0, 0);
  303 â”‚   
  304 â”‚   // Adicionar cada data no intervalo EXCETO o dia de checkout
  305 â”‚   // Usando < em vez de <= para nÃ£o incluir o dia de checkout
  306 â”‚   while (currentDate < endDateNormalized) {
  307 â”‚     dates.push(currentDate.toISOString().split('T')[0]); // Formato YYYY-MM-DD
  308 â”‚     currentDate.setDate(currentDate.getDate() + 1);
  309 â”‚   }
  310 â”‚   
  311 â”‚   return dates;
  312 â”‚ };
  313 â”‚ 
  314 â”‚ export const getRoomById = async (id: string): Promise<Room | null> => {
  315 â”‚   try {
  316 â”‚     const room = await getDocument<Room>('rooms', id);
  317 â”‚     
  318 â”‚     if (!room) return null;
  319 â”‚     
  320 â”‚     console.log(`Firebase - getRoomById ${id} dados brutos:`, room);
  321 â”‚     
  322 â”‚     // Log especÃ­fico para serviceFeePct
  323 â”‚     console.log(`serviceFeePct no Firestore:`, room.serviceFeePct);
  324 â”‚     
  325 â”‚     // Garantir que todos os campos necessÃ¡rios estejam presentes
  326 â”‚     return {
  327 â”‚       ...room,
  328 â”‚       name: room.name || '',
  329 â”‚       type: room.type || 'standard',
  330 â”‚       description: room.description || '',
  331 â”‚       price: room.price || 0,
  332 â”‚       capacity: room.capacity || 2,
  333 â”‚       size: room.size || 0,
  334 â”‚       available: room.available !== undefined ? room.available : true,
  335 â”‚       serviceFeePct: room.serviceFeePct !== undefined ? room.serviceFeePct : 10,
  336 â”‚       images: room.images || [],
  337 â”‚       amenities: room.amenities || [],
  338 â”‚       additionalServices: room.additionalServices || [],
  339 â”‚       highlights: room.highlights || []
  340 â”‚     };
  341 â”‚   } catch (error) {
  342 â”‚     console.error(`Erro ao buscar quarto com ID ${id}:`, error);
  343 â”‚     return null;
  344 â”‚   }
  345 â”‚ }
  346 â”‚ 
  347 â”‚ export const createRoom = async (roomData: Omit<Room, 'id' | 'createdAt' | 'updatedAt'>): Promise<Room> => {
  348 â”‚   try {
  349 â”‚     console.log("createRoom - Dados recebidos:", roomData);
  350 â”‚     
  351 â”‚     const roomWithTimestamps = {
  352 â”‚       ...roomData,
  353 â”‚       available: roomData.available !== undefined ? roomData.available : true,
  354 â”‚       featured: roomData.featured || false,
  355 â”‚       amenities: roomData.amenities || [],
  356 â”‚       additionalServices: roomData.additionalServices || [],
  357 â”‚       highlights: roomData.highlights || [],
  358 â”‚       createdAt: serverTimestamp(),
  359 â”‚       updatedAt: serverTimestamp()
  360 â”‚     }
  361 â”‚     
  362 â”‚     console.log("createRoom - Dados a serem salvos:", roomWithTimestamps);
  363 â”‚     
  364 â”‚     const id = await createDocument('rooms', roomWithTimestamps)
  365 â”‚     
  366 â”‚     return {
  367 â”‚       id,
  368 â”‚       ...roomData,
  369 â”‚       amenities: roomData.amenities || [],
  370 â”‚       additionalServices: roomData.additionalServices || [],
  371 â”‚       highlights: roomData.highlights || [],
  372 â”‚       createdAt: Timestamp.now(),
  373 â”‚       updatedAt: Timestamp.now()
  374 â”‚     }
  375 â”‚   } catch (error) {
  376 â”‚     console.error('Erro ao criar quarto:', error)
  377 â”‚     throw error
  378 â”‚   }
  379 â”‚ }
  380 â”‚ 
  381 â”‚ export const updateRoom = async (id: string, roomData: Partial<Omit<Room, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Room> => {
  382 â”‚   try {
  383 â”‚     console.log(`updateRoom - ID: ${id}, Dados recebidos:`, roomData);
  384 â”‚     
  385 â”‚     // Garantir que estamos lidando explicitamente com o serviceFeePct se ele for 0
  386 â”‚     if (roomData.serviceFeePct === 0) {
  387 â”‚       console.log("updateRoom - Detectado serviceFeePct com valor 0, salvando explicitamente.", roomData.serviceFeePct);
  388 â”‚     }
  389 â”‚     
  390 â”‚     // Adicionar timestamp de atualizaÃ§Ã£o
  391 â”‚     const roomWithTimestamp = {
  392 â”‚       ...roomData,
  393 â”‚       amenities: roomData.amenities || [],
  394 â”‚       additionalServices: roomData.additionalServices || [],
  395 â”‚       highlights: roomData.highlights || [],
  396 â”‚       updatedAt: serverTimestamp()
  397 â”‚     }
  398 â”‚     
  399 â”‚     console.log(`updateRoom - Dados a serem salvos:`, roomWithTimestamp);
  400 â”‚     
  401 â”‚     await updateDocument('rooms', id, roomWithTimestamp)
  402 â”‚     
  403 â”‚     const updatedRoom = await getRoomById(id)
  404 â”‚     if (!updatedRoom) {
  405 â”‚       throw new Error(`Quarto com ID ${id} nÃ£o encontrado apÃ³s atualizaÃ§Ã£o`)
  406 â”‚     }
  407 â”‚     
  408 â”‚     return updatedRoom
  409 â”‚   } catch (error) {
  410 â”‚     console.error('Erro ao atualizar quarto:', error)
  411 â”‚     throw error
  412 â”‚   }
  413 â”‚ }
  414 â”‚ 
  415 â”‚ export const deleteRoom = async (id: string): Promise<boolean> => {
  416 â”‚   return await deleteDocument('rooms', id)
  417 â”‚ }
  418 â”‚ 
  419 â”‚ // FunÃ§Ãµes especÃ­ficas para reservas
  420 â”‚ export const createBooking = async (bookingData: any) => {
  421 â”‚   try {
  422 â”‚     const bookingsCollection = collection(db, 'bookings');
  423 â”‚     const docRef = await addDoc(bookingsCollection, bookingData);
  424 â”‚     
  425 â”‚     // CORREÃ‡ÃƒO: NÃ£o bloquear a data no momento da criaÃ§Ã£o da reserva
  426 â”‚     // O bloqueio serÃ¡ feito apenas quando o pagamento for confirmado
  427 â”‚     // atravÃ©s da funÃ§Ã£o updateBookingStatus
  428 â”‚     
  429 â”‚     return docRef;
  430 â”‚   } catch (error) {
  431 â”‚     console.error('Erro ao criar reserva:', error);
  432 â”‚     throw error;
  433 â”‚   }
  434 â”‚ };
  435 â”‚ 
  436 â”‚ // Nova funÃ§Ã£o para atualizar status da reserva e bloquear as datas da estadia
  437 â”‚ export const updateBookingStatus = async (
  438 â”‚   bookingId: string, 
  439 â”‚   newStatus: 'pending' | 'confirmed' | 'cancelled' | 'completed',
  440 â”‚   newPaymentStatus: 'pending' | 'paid' | 'refunded'
  441 â”‚ ): Promise<boolean> => {
  442 â”‚   try {
  443 â”‚     // ReferÃªncia ao documento da reserva
  444 â”‚     const bookingRef = doc(db, 'bookings', bookingId);
  445 â”‚     const bookingSnap = await getDoc(bookingRef);
  446 â”‚     
  447 â”‚     if (!bookingSnap.exists()) {
  448 â”‚       console.error(`Booking ${bookingId} nÃ£o existe ao atualizar status`);
  449 â”‚       return false;
  450 â”‚     }
  451 â”‚     
  452 â”‚     const bookingData = bookingSnap.data();
  453 â”‚     
  454 â”‚     // Atualizar o status da reserva
  455 â”‚     await updateDoc(bookingRef, {
  456 â”‚       status: newStatus,
  457 â”‚       paymentStatus: newPaymentStatus,
  458 â”‚       updatedAt: serverTimestamp(),
  459 â”‚       ...(newStatus === 'confirmed' && { confirmedAt: serverTimestamp() })
  460 â”‚     });
  461 â”‚     
  462 â”‚     // Se a reserva estÃ¡ sendo confirmada, precisamos bloquear as datas
  463 â”‚     if (newStatus === 'confirmed') {
  464 â”‚       console.log(`Atualizando disponibilidade para reserva confirmada: ${bookingId}`);
  465 â”‚       
  466 â”‚       // Recuperar datas de check-in e check-out
  467 â”‚       const checkIn = bookingData.checkIn.toDate();
  468 â”‚       const checkOut = bookingData.checkOut.toDate();
  469 â”‚       const roomId = bookingData.roomId;
  470 â”‚       
  471 â”‚       // Obter todas as datas entre check-in e check-out
  472 â”‚       const dates: Date[] = [];
  473 â”‚       const currentDate = new Date(checkIn);
  474 â”‚       
  475 â”‚       while (currentDate < checkOut) {
  476 â”‚         dates.push(new Date(currentDate));
  477 â”‚         currentDate.setDate(currentDate.getDate() + 1);
  478 â”‚       }
  479 â”‚       
  480 â”‚       console.log(`Bloqueando ${dates.length} dias para quarto ${roomId}`);
  481 â”‚       
  482 â”‚       // Atualizar disponibilidade para cada data
  483 â”‚       const availabilityUpdates: {[date: string]: boolean} = {};
  484 â”‚       
  485 â”‚       dates.forEach(date => {
  486 â”‚         const dateString = date.toISOString().split('T')[0]; // formato YYYY-MM-DD
  487 â”‚         availabilityUpdates[dateString] = false; // false significa indisponÃ­vel
  488 â”‚       });
  489 â”‚       
  490 â”‚       // Atualizar disponibilidade do quarto
  491 â”‚       if (Object.keys(availabilityUpdates).length > 0) {
  492 â”‚         try {
  493 â”‚           // Obter o documento do quarto
  494 â”‚           const roomRef = doc(db, 'rooms', roomId);
  495 â”‚           const roomSnap = await getDoc(roomRef);
  496 â”‚           
  497 â”‚           if (roomSnap.exists()) {
  498 â”‚             const roomData = roomSnap.data();
  499 â”‚             const currentAvailability = roomData.availabilityDates || {};
  500 â”‚             
  501 â”‚             // Mesclar a disponibilidade atual com as novas atualizaÃ§Ãµes
  502 â”‚             const updatedAvailability = {
  503 â”‚               ...currentAvailability,
  504 â”‚               ...availabilityUpdates
  505 â”‚             };
  506 â”‚             
  507 â”‚             // Atualizar o documento do quarto
  508 â”‚             await updateDoc(roomRef, {
  509 â”‚               availabilityDates: updatedAvailability,
  510 â”‚               updatedAt: serverTimestamp()
  511 â”‚             });
  512 â”‚             
  513 â”‚             console.log(`Disponibilidade atualizada com sucesso para quarto ${roomId}`);
  514 â”‚             
  515 â”‚             // Criar log da reserva
  516 â”‚             await addDoc(collection(db, 'bookingLogs'), {
  517 â”‚               bookingId,
  518 â”‚               roomId,
  519 â”‚               action: 'status_updated',
  520 â”‚               previousStatus: bookingData.status,
  521 â”‚               newStatus,
  522 â”‚               previousPaymentStatus: bookingData.paymentStatus,
  523 â”‚               newPaymentStatus,
  524 â”‚               datesBlocked: Object.keys(availabilityUpdates),
  525 â”‚               timestamp: serverTimestamp(),
  526 â”‚               userId: bookingData.userId || 'system'
  527 â”‚             });
  528 â”‚           } else {
  529 â”‚             console.error(`Quarto ${roomId} nÃ£o encontrado ao atualizar disponibilidade`);
  530 â”‚           }
  531 â”‚         } catch (error) {
  532 â”‚           console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  533 â”‚         }
  534 â”‚       }
  535 â”‚     }
  536 â”‚     
  537 â”‚     return true;
  538 â”‚   } catch (error) {
  539 â”‚     console.error(`Erro ao atualizar status da reserva ${bookingId}:`, error);
  540 â”‚     return false;
  541 â”‚   }
  542 â”‚ }
  543 â”‚ 
  544 â”‚ export const getUserBookings = async (userId: string): Promise<Booking[]> => {
  545 â”‚   return getDocuments<Booking>('bookings', [
  546 â”‚     where('userId', '==', userId),
  547 â”‚     orderBy('createdAt', 'desc')
  548 â”‚   ])
  549 â”‚ }
  550 â”‚ 
  551 â”‚ export const getRecentBookings = async (count = 5): Promise<Booking[]> => {
  552 â”‚   return getDocuments<Booking>('bookings', [
  553 â”‚     orderBy('createdAt', 'desc'),
  554 â”‚     limit(count)
  555 â”‚   ])
  556 â”‚ }
  557 â”‚ 
  558 â”‚ export const getRoomBookings = async (roomId: string): Promise<Booking[]> => {
  559 â”‚   try {
  560 â”‚     const constraints: QueryConstraint[] = [
  561 â”‚       where('roomId', '==', roomId),
  562 â”‚       orderBy('checkIn', 'asc')
  563 â”‚     ];
  564 â”‚     
  565 â”‚     return await getDocuments<Booking>('bookings', constraints);
  566 â”‚   } catch (error) {
  567 â”‚     console.error(`Erro ao buscar reservas do quarto ${roomId}:`, error);
  568 â”‚     return [];
  569 â”‚   }
  570 â”‚ };
  571 â”‚ 
  572 â”‚ // FunÃ§Ãµes especÃ­ficas para contatos
  573 â”‚ export const createContactMessage = async (contactData: Contact) => {
  574 â”‚   try {
  575 â”‚     const contactsCollection = collection(db, 'contacts')
  576 â”‚     
  577 â”‚     // Garantir que o status seja 'new' para novos contatos
  578 â”‚     const contactWithDefaults = {
  579 â”‚       ...contactData,
  580 â”‚       status: contactData.status || 'new',
  581 â”‚       createdAt: contactData.createdAt || Timestamp.now()
  582 â”‚     }
  583 â”‚     
  584 â”‚     // Se tiver detalhes de reserva, adicionar metadados
  585 â”‚     if (contactWithDefaults.reservationDetails) {
  586 â”‚       // Ajustar subject para indicar que Ã© relacionado a reserva
  587 â”‚       if (!contactWithDefaults.subject.includes('Reserva')) {
  588 â”‚         contactWithDefaults.subject = `Reserva: ${contactWithDefaults.subject}`;
  589 â”‚       }
  590 â”‚     }
  591 â”‚     
  592 â”‚     const docRef = await addDoc(contactsCollection, contactWithDefaults)
  593 â”‚     return docRef
  594 â”‚   } catch (error) {
  595 â”‚     console.error('Erro ao criar mensagem de contato:', error)
  596 â”‚     throw error
  597 â”‚   }
  598 â”‚ }
  599 â”‚ 
  600 â”‚ export const getNewContactMessages = async (): Promise<Contact[]> => {
  601 â”‚   return getDocuments<Contact>('contacts', [
  602 â”‚     where('status', '==', 'new'),
  603 â”‚     orderBy('createdAt', 'desc')
  604 â”‚   ])
  605 â”‚ }
  606 â”‚ 
  607 â”‚ // FunÃ§Ãµes para Dashboard com dados reais
  608 â”‚ 
  609 â”‚ export const getDashboardStats = async () => {
  610 â”‚   try {
  611 â”‚     const [totalBookings, totalRevenue, occupancyRate, bookingsByPlatform] = await Promise.all([
  612 â”‚       getTotalBookings(),
  613 â”‚       getMonthlyRevenue(),
  614 â”‚       getOccupancyRate(),
  615 â”‚       getBookingsByPlatform()
  616 â”‚     ]);
  617 â”‚ 
  618 â”‚     return {
  619 â”‚       totalBookings,
  620 â”‚       totalRevenue,
  621 â”‚       occupancyRate,
  622 â”‚       bookingsByPlatform
  623 â”‚     };
  624 â”‚   } catch (error) {
  625 â”‚     console.error('Erro ao obter estatÃ­sticas do dashboard:', error);
  626 â”‚     throw error;
  627 â”‚   }
  628 â”‚ };
  629 â”‚ 
  630 â”‚ // Obter total de reservas
  631 â”‚ export const getTotalBookings = async () => {
  632 â”‚   try {
  633 â”‚     // Obter todas as reservas
  634 â”‚     const bookings = await getDocuments<Booking>('bookings');
  635 â”‚     
  636 â”‚     // Contar reservas por status
  637 â”‚     const confirmed = bookings.filter(b => b.status === 'confirmed').length;
  638 â”‚     const pending = bookings.filter(b => b.status === 'pending').length;
  639 â”‚     const cancelled = bookings.filter(b => b.status === 'cancelled').length;
  640 â”‚     const completed = bookings.filter(b => b.status === 'completed').length;
  641 â”‚     
  642 â”‚     // Calcular crescimento em relaÃ§Ã£o ao mÃªs anterior (simulado por enquanto)
  643 â”‚     // Em uma implementaÃ§Ã£o real, vocÃª compararia com dados do mÃªs anterior
  644 â”‚     const growth = ((confirmed + completed) / (bookings.length || 1) * 100) - 50;
  645 â”‚     
  646 â”‚     return {
  647 â”‚       total: bookings.length,
  648 â”‚       confirmed,
  649 â”‚       pending,
  650 â”‚       cancelled,
  651 â”‚       completed,
  652 â”‚       growth: Math.round(growth) // Arredonda para nÃºmero inteiro
  653 â”‚     };
  654 â”‚   } catch (error) {
  655 â”‚     console.error('Erro ao obter total de reservas:', error);
  656 â”‚     return {
  657 â”‚       total: 0,
  658 â”‚       confirmed: 0,
  659 â”‚       pending: 0, 
  660 â”‚       cancelled: 0,
  661 â”‚       completed: 0,
  662 â”‚       growth: 0
  663 â”‚     };
  664 â”‚   }
  665 â”‚ };
  666 â”‚ 
  667 â”‚ // Obter receita mensal
  668 â”‚ export const getMonthlyRevenue = async () => {
  669 â”‚   try {
  670 â”‚     const bookings = await getDocuments<Booking>('bookings');
  671 â”‚     
  672 â”‚     // Filtrar reservas confirmadas e concluÃ­das
  673 â”‚     const validBookings = bookings.filter(b => 
  674 â”‚       b.status === 'confirmed' || b.status === 'completed'
  675 â”‚     );
  676 â”‚     
  677 â”‚     // Calcular receita total
  678 â”‚     const totalRevenue = validBookings.reduce((acc, booking) => acc + booking.totalPrice, 0);
  679 â”‚     
  680 â”‚     // Agrupar receita por mÃªs
  681 â”‚     const revenueByMonth = validBookings.reduce((acc, booking) => {
  682 â”‚       const date = booking.checkIn.toDate();
  683 â”‚       const month = date.getMonth(); // 0-11
  684 â”‚       const year = date.getFullYear();
  685 â”‚       const key = `${year}-${month}`;
  686 â”‚       
  687 â”‚       if (!acc[key]) {
  688 â”‚         acc[key] = 0;
  689 â”‚       }
  690 â”‚       acc[key] += booking.totalPrice;
  691 â”‚       return acc;
  692 â”‚     }, {} as Record<string, number>);
  693 â”‚     
  694 â”‚     // Converter para formato de array para grÃ¡fico
  695 â”‚     const monthNames = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
  696 â”‚     
  697 â”‚     const currentDate = new Date();
  698 â”‚     const currentMonth = currentDate.getMonth();
  699 â”‚     const currentYear = currentDate.getFullYear();
  700 â”‚     
  701 â”‚     const revenueData = [];
  702 â”‚     
  703 â”‚     // Gerar dados dos Ãºltimos 12 meses
  704 â”‚     for (let i = 0; i < 12; i++) {
  705 â”‚       const month = (currentMonth - i + 12) % 12;
  706 â”‚       const year = currentMonth - i < 0 ? currentYear - 1 : currentYear;
  707 â”‚       const key = `${year}-${month}`;
  708 â”‚       
  709 â”‚       revenueData.unshift({
  710 â”‚         month: monthNames[month],
  711 â”‚         value: revenueByMonth[key] || 0
  712 â”‚       });
  713 â”‚     }
  714 â”‚     
  715 â”‚     // Calcular crescimento em relaÃ§Ã£o ao mÃªs anterior
  716 â”‚     const lastMonthRevenue = revenueData[revenueData.length - 2]?.value || 0;
  717 â”‚     const currentMonthRevenue = revenueData[revenueData.length - 1]?.value || 0;
  718 â”‚     
  719 â”‚     const growth = lastMonthRevenue ? ((currentMonthRevenue - lastMonthRevenue) / lastMonthRevenue) * 100 : 0;
  720 â”‚     
  721 â”‚     return {
  722 â”‚       monthly: currentMonthRevenue,
  723 â”‚       total: totalRevenue,
  724 â”‚       growth: Math.round(growth),
  725 â”‚       revenueData
  726 â”‚     };
  727 â”‚   } catch (error) {
  728 â”‚     console.error('Erro ao obter receita mensal:', error);
  729 â”‚     return {
  730 â”‚       monthly: 0,
  731 â”‚       total: 0,
  732 â”‚       growth: 0,
  733 â”‚       revenueData: []
  734 â”‚     };
  735 â”‚   }
  736 â”‚ };
  737 â”‚ 
  738 â”‚ // Calcular taxa de ocupaÃ§Ã£o
  739 â”‚ export const getOccupancyRate = async () => {
  740 â”‚   try {
  741 â”‚     // Obter todos os quartos
  742 â”‚     const rooms = await getDocuments<Room>('rooms');
  743 â”‚     const totalRooms = rooms.length;
  744 â”‚     
  745 â”‚     if (totalRooms === 0) {
  746 â”‚       return { rate: 0, growth: 0 };
  747 â”‚     }
  748 â”‚     
  749 â”‚     // Obter todas as reservas
  750 â”‚     const bookings = await getDocuments<Booking>('bookings');
  751 â”‚     
  752 â”‚     // Filtrar reservas confirmadas e concluÃ­das para o mÃªs atual
  753 â”‚     const currentDate = new Date();
  754 â”‚     const currentMonth = currentDate.getMonth();
  755 â”‚     const currentYear = currentDate.getFullYear();
  756 â”‚     
  757 â”‚     const currentMonthBookings = bookings.filter(booking => {
  758 â”‚       const checkInDate = booking.checkIn.toDate();
  759 â”‚       return (
  760 â”‚         (booking.status === 'confirmed' || booking.status === 'completed') &&
  761 â”‚         checkInDate.getMonth() === currentMonth &&
  762 â”‚         checkInDate.getFullYear() === currentYear
  763 â”‚       );
  764 â”‚     });
  765 â”‚     
  766 â”‚     // Calcular dias ocupados por quarto
  767 â”‚     const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
  768 â”‚     const totalPossibleRoomDays = totalRooms * daysInMonth;
  769 â”‚     
  770 â”‚     // Contar dias ocupados (simplificado - em produÃ§Ã£o seria mais complexo)
  771 â”‚     let occupiedDays = 0;
  772 â”‚     
  773 â”‚     currentMonthBookings.forEach(booking => {
  774 â”‚       const checkIn = booking.checkIn.toDate();
  775 â”‚       const checkOut = booking.checkOut.toDate();
  776 â”‚       
  777 â”‚       // Ajustar datas para considerar apenas o mÃªs atual
  778 â”‚       const startDate = new Date(Math.max(
  779 â”‚         checkIn.getTime(),
  780 â”‚         new Date(currentYear, currentMonth, 1).getTime()
  781 â”‚       ));
  782 â”‚       const endDate = new Date(Math.min(
  783 â”‚         checkOut.getTime(),
  784 â”‚         new Date(currentYear, currentMonth + 1, 0).getTime()
  785 â”‚       ));
  786 â”‚       
  787 â”‚       // Calcular dias entre datas (incluindo check-in, excluindo check-out)
  788 â”‚       const days = Math.max(0, Math.floor((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)));
  789 â”‚       occupiedDays += days;
  790 â”‚     });
  791 â”‚     
  792 â”‚     const occupancyRate = (occupiedDays / totalPossibleRoomDays) * 100;
  793 â”‚     
  794 â”‚     // SimulaÃ§Ã£o de crescimento (em produÃ§Ã£o, compararia com mÃªs anterior)
  795 â”‚     const growth = occupancyRate > 50 ? 5 : -3;
  796 â”‚     
  797 â”‚     return {
  798 â”‚       rate: Math.round(occupancyRate),
  799 â”‚       growth: Math.round(growth)
  800 â”‚     };
  801 â”‚   } catch (error) {
  802 â”‚     console.error('Erro ao calcular taxa de ocupaÃ§Ã£o:', error);
  803 â”‚     return { rate: 0, growth: 0 };
  804 â”‚   }
  805 â”‚ };
  806 â”‚ 
  807 â”‚ // Obter reservas agrupadas por plataforma
  808 â”‚ export const getBookingsByPlatform = async () => {
  809 â”‚   try {
  810 â”‚     const bookings = await getDocuments<Booking>('bookings');
  811 â”‚     
  812 â”‚     // Categorizar reservas por origem
  813 â”‚     const platforms = [
  814 â”‚       { 
  815 â”‚         platform: "Booking.com", 
  816 â”‚         color: "#003580", 
  817 â”‚         icon: "Globe",
  818 â”‚         bookings: []
  819 â”‚       },
  820 â”‚       { 
  821 â”‚         platform: "Airbnb", 
  822 â”‚         color: "#FF5A5F", 
  823 â”‚         icon: "Heart",
  824 â”‚         bookings: []
  825 â”‚       },
  826 â”‚       { 
  827 â”‚         platform: "Direto", 
  828 â”‚         color: "#4CAF50", 
  829 â”‚         icon: "Home",
  830 â”‚         bookings: []
  831 â”‚       }
  832 â”‚     ];
  833 â”‚     
  834 â”‚     // Para fins de demonstraÃ§Ã£o, colocar todas as reservas como "Direto" por enquanto
  835 â”‚     // Em produÃ§Ã£o, usaria um campo "platformOrigin" ou similar na tabela de reservas
  836 â”‚     const platformIndex = 2; // Ãndice da plataforma "Direto"
  837 â”‚     
  838 â”‚     bookings.forEach(booking => {
  839 â”‚       // Transformar para o formato esperado pelo componente
  840 â”‚       const transformedBooking = {
  841 â”‚         id: booking.id || '',
  842 â”‚         guestName: booking.guestName,
  843 â”‚         roomName: booking.roomName,
  844 â”‚         checkIn: booking.checkIn.toDate().toLocaleDateString('pt-PT'),
  845 â”‚         checkOut: booking.checkOut.toDate().toLocaleDateString('pt-PT'),
  846 â”‚         status: booking.status,
  847 â”‚         value: new Intl.NumberFormat('pt-PT', {
  848 â”‚           style: 'currency',
  849 â”‚           currency: 'EUR'
  850 â”‚         }).format(booking.totalPrice)
  851 â”‚       };
  852 â”‚       
  853 â”‚       // Adicionar Ã  plataforma "Direto"
  854 â”‚       (platforms[platformIndex] as any).bookings.push(transformedBooking);
  855 â”‚     });
  856 â”‚     
  857 â”‚     return platforms;
  858 â”‚   } catch (error) {
  859 â”‚     console.error('Erro ao obter reservas por plataforma:', error);
  860 â”‚     return [];
  861 â”‚   }
  862 â”‚ };
  863 â”‚ 
  864 â”‚ // FunÃ§Ã£o para obter o preÃ§o de um quarto para uma data especÃ­fica
  865 â”‚ export const getRoomPriceForDate = async (roomId: string, date: Date): Promise<number> => {
  866 â”‚   try {
  867 â”‚     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  868 â”‚     
  869 â”‚     if (!roomDoc.exists()) {
  870 â”‚       throw new Error("Quarto nÃ£o encontrado");
  871 â”‚     }
  872 â”‚     
  873 â”‚     const roomData = roomDoc.data() as Room;
  874 â”‚     const basePrice = roomData.price;
  875 â”‚     
  876 â”‚     if (!roomData.seasonalPrices || roomData.seasonalPrices.length === 0) {
  877 â”‚       return basePrice;
  878 â”‚     }
  879 â”‚     
  880 â”‚     // Verificar se a data estÃ¡ dentro de algum perÃ­odo sazonal
  881 â”‚     for (const seasonalPrice of roomData.seasonalPrices) {
  882 â”‚       const startDate = new Date(seasonalPrice.startDate);
  883 â”‚       const endDate = new Date(seasonalPrice.endDate);
  884 â”‚       
  885 â”‚       if (date >= startDate && date <= endDate) {
  886 â”‚         return seasonalPrice.price;
  887 â”‚       }
  888 â”‚     }
  889 â”‚     
  890 â”‚     // Se nÃ£o cair em nenhum perÃ­odo sazonal, retorna o preÃ§o base
  891 â”‚     return basePrice;
  892 â”‚   } catch (error) {
  893 â”‚     console.error("Erro ao obter preÃ§o do quarto:", error);
  894 â”‚     throw error;
  895 â”‚   }
  896 â”‚ }
  897 â”‚ 
  898 â”‚ // FunÃ§Ã£o para calcular o preÃ§o total de uma estadia
  899 â”‚ export const calculateStayPrice = async (
  900 â”‚   roomId: string, 
  901 â”‚   checkIn: Date, 
  902 â”‚   checkOut: Date
  903 â”‚ ): Promise<{
  904 â”‚   totalPrice: number;
  905 â”‚   nightlyPrices: { date: string; price: number }[];
  906 â”‚   serviceFee: number;
  907 â”‚   totalWithFee: number;
  908 â”‚ }> => {
  909 â”‚   try {
  910 â”‚     console.log(`ğŸ” Iniciando cÃ¡lculo de preÃ§o para estadia: ${checkIn.toISOString().split('T')[0]} atÃ© ${checkOut.toISOString().split('T')[0]}`);
  911 â”‚     
  912 â”‚     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  913 â”‚     
  914 â”‚     if (!roomDoc.exists()) {
  915 â”‚       throw new Error("Quarto nÃ£o encontrado");
  916 â”‚     }
  917 â”‚     
  918 â”‚     const roomData = roomDoc.data() as Room;
  919 â”‚     console.log(`ğŸ“ Dados do quarto ${roomId}:`, {
  920 â”‚       nome: roomData.name,
  921 â”‚       precoBase: roomData.price,
  922 â”‚       taxaServico: roomData.serviceFeePct || 0,
  923 â”‚       temPrecosSazonais: !!roomData.seasonalPrices?.length
  924 â”‚     });
  925 â”‚     
  926 â”‚     const nightlyPrices: { date: string; price: number }[] = [];
  927 â”‚     let totalPrice = 0;
  928 â”‚     
  929 â”‚     // Calcular o nÃºmero de noites - corrigido para usar o mÃ©todo correto de cÃ¡lculo
  930 â”‚     // O nÃºmero de noites Ã© a diferenÃ§a em dias (estadia = checkout - checkin)
  931 â”‚     const noites = differenceInDays(checkOut, checkIn);
  932 â”‚     console.log(`ğŸ—“ï¸ NÃºmero de noites calculado: ${noites}`);
  933 â”‚     
  934 â”‚     if (noites <= 0) {
  935 â”‚       console.error(`âš ï¸ Erro: nÃºmero de noites invÃ¡lido (${noites})`);
  936 â”‚       throw new Error("Data de check-out deve ser posterior Ã  data de check-in");
  937 â”‚     }
  938 â”‚     
  939 â”‚     // Para cada noite, verificar o preÃ§o aplicÃ¡vel (preÃ§o base ou sazonal)
  940 â”‚     // ComeÃ§amos exatamente do dia de check-in
  941 â”‚     const currentDate = new Date(checkIn);
  942 â”‚     currentDate.setHours(0, 0, 0, 0); // Normalizar para meia-noite
  943 â”‚     
  944 â”‚     // Processamos cada dia de estadia (noite)
  945 â”‚     console.log(`ğŸ“Š Calculando preÃ§os por noite:`);
  946 â”‚     for (let i = 0; i < noites; i++) {
  947 â”‚       // Obtemos o preÃ§o para esta data
  948 â”‚       const dateCopy = new Date(currentDate);
  949 â”‚       const priceForDate = await getRoomPriceForDate(roomId, dateCopy);
  950 â”‚       const dateString = dateCopy.toISOString().split('T')[0]; // YYYY-MM-DD
  951 â”‚       
  952 â”‚       console.log(`   - ${dateString}: â‚¬${priceForDate}`);
  953 â”‚       
  954 â”‚       nightlyPrices.push({
  955 â”‚         date: dateString,
  956 â”‚         price: priceForDate
  957 â”‚       });
  958 â”‚       
  959 â”‚       totalPrice += priceForDate;
  960 â”‚       
  961 â”‚       // AvanÃ§amos para o prÃ³ximo dia
  962 â”‚       currentDate.setDate(currentDate.getDate() + 1);
  963 â”‚     }
  964 â”‚     
  965 â”‚     // VerificaÃ§Ã£o de seguranÃ§a para o cÃ¡lculo do totalPrice
  966 â”‚     const manualTotal = nightlyPrices.reduce((sum, night) => sum + night.price, 0);
  967 â”‚     if (Math.abs(totalPrice - manualTotal) > 1) {
  968 â”‚       console.error(`âš ï¸ DiscrepÃ¢ncia detectada no cÃ¡lculo do preÃ§o total!`);
  969 â”‚       console.error(`   - Total calculado iterativamente: â‚¬${totalPrice}`);
  970 â”‚       console.error(`   - Total calculado via reduce: â‚¬${manualTotal}`);
  971 â”‚       console.error(`   - Usando o valor recalculado para seguranÃ§a!`);
  972 â”‚       totalPrice = manualTotal;
  973 â”‚     }
  974 â”‚     
  975 â”‚     // Calcular taxa de serviÃ§o
  976 â”‚     const serviceFee = (totalPrice * (roomData.serviceFeePct || 0)) / 100;
  977 â”‚     const totalWithFee = totalPrice + serviceFee;
  978 â”‚     
  979 â”‚     console.log(`ğŸ’° Resumo do cÃ¡lculo:`);
  980 â”‚     console.log(`   - Total das diÃ¡rias: â‚¬${totalPrice}`);
  981 â”‚     console.log(`   - Taxa de serviÃ§o (${roomData.serviceFeePct || 0}%): â‚¬${serviceFee}`);
  982 â”‚     console.log(`   - Total com taxas: â‚¬${totalWithFee}`);
  983 â”‚     
  984 â”‚     return {
  985 â”‚       totalPrice,
  986 â”‚       nightlyPrices,
  987 â”‚       serviceFee,
  988 â”‚       totalWithFee
  989 â”‚     };
  990 â”‚   } catch (error) {
  991 â”‚     console.error("âŒ Erro ao calcular preÃ§o da estadia:", error);
  992 â”‚     throw error;
  993 â”‚   }
  994 â”‚ } 
  995 â”‚ import { 
  996 â”‚   collection, 
  997 â”‚   getDocs, 
  998 â”‚   getDoc, 
  999 â”‚   doc, 
 1000 â”‚   setDoc, 
      Â·   â”€â”€â”€â”¬â”€â”€
      Â·      â•°â”€â”€ `setDoc` redefined here
 1001 â”‚   addDoc, 
 1002 â”‚   updateDoc, 
 1003 â”‚   deleteDoc,
      â•°â”€â”€â”€â”€

  Ã— the name `addDoc` is defined multiple times
      â•­â”€[/home/runner/workspace/lib/firebase/firestore.ts:2:1]
    2 â”‚   collection,
    3 â”‚   doc,
    4 â”‚   setDoc,
    5 â”‚   addDoc,
      Â·   â”€â”€â”€â”¬â”€â”€
      Â·      â•°â”€â”€ previous definition of `addDoc` here
    6 â”‚   getDoc,
    7 â”‚   getDocs,
    8 â”‚   updateDoc,
    9 â”‚   deleteDoc,
   10 â”‚   query,
   11 â”‚   where,
   12 â”‚   orderBy,
   13 â”‚   limit,
   14 â”‚   DocumentData,
   15 â”‚   QueryConstraint,
   16 â”‚   Timestamp,
   17 â”‚   serverTimestamp
   18 â”‚ } from 'firebase/firestore'
   19 â”‚ import { db } from './config'
   20 â”‚ import { Room, SeasonalPrice } from '@/lib/types'
   21 â”‚ import { differenceInDays } from 'date-fns'
   22 â”‚ 
   23 â”‚ // Tipos de dados
   24 â”‚ export interface Booking {
   25 â”‚   id?: string
   26 â”‚   userId?: string
   27 â”‚   guestName: string
   28 â”‚   guestEmail: string
   29 â”‚   guestPhone: string
   30 â”‚   roomId: string
   31 â”‚   roomName: string
   32 â”‚   checkIn: Timestamp
   33 â”‚   checkOut: Timestamp
   34 â”‚   adults: number
   35 â”‚   children: number
   36 â”‚   totalPrice: number
   37 â”‚   status: 'pending' | 'confirmed' | 'cancelled' | 'completed'
   38 â”‚   paymentStatus: 'pending' | 'paid' | 'refunded'
   39 â”‚   specialRequests?: string
   40 â”‚   createdAt?: Timestamp
   41 â”‚   updatedAt?: Timestamp
   42 â”‚ }
   43 â”‚ 
   44 â”‚ export interface Contact {
   45 â”‚   id?: string
   46 â”‚   name: string
   47 â”‚   email: string
   48 â”‚   phone?: string
   49 â”‚   subject: string
   50 â”‚   message: string
   51 â”‚   status: 'new' | 'read' | 'replied'
   52 â”‚   createdAt: Timestamp
   53 â”‚   updatedAt?: Timestamp
   54 â”‚   repliedAt?: Timestamp
   55 â”‚   replyContent?: string
   56 â”‚   reservationDetails?: {
   57 â”‚     checkIn?: Timestamp
   58 â”‚     checkOut?: Timestamp
   59 â”‚     roomId?: string
   60 â”‚     roomName?: string
   61 â”‚     totalGuests?: number
   62 â”‚     totalPrice?: number
   63 â”‚   }
   64 â”‚ }
   65 â”‚ 
   66 â”‚ // FunÃ§Ãµes genÃ©ricas para CRUD
   67 â”‚ export const createDocument = async <T extends DocumentData>(
   68 â”‚   collectionName: string,
   69 â”‚   data: T
   70 â”‚ ): Promise<string> => {
   71 â”‚   const docRef = await addDoc(collection(db, collectionName), {
   72 â”‚     ...data,
   73 â”‚     createdAt: serverTimestamp(),
   74 â”‚     updatedAt: serverTimestamp()
   75 â”‚   })
   76 â”‚   return docRef.id
   77 â”‚ }
   78 â”‚ 
   79 â”‚ export const createDocumentWithId = async <T extends DocumentData>(
   80 â”‚   collectionName: string,
   81 â”‚   id: string,
   82 â”‚   data: T
   83 â”‚ ): Promise<void> => {
   84 â”‚   await setDoc(doc(db, collectionName, id), {
   85 â”‚     ...data,
   86 â”‚     createdAt: serverTimestamp(),
   87 â”‚     updatedAt: serverTimestamp()
   88 â”‚   })
   89 â”‚ }
   90 â”‚ 
   91 â”‚ export const getDocument = async <T>(
   92 â”‚   collectionName: string,
   93 â”‚   id: string
   94 â”‚ ): Promise<T | null> => {
   95 â”‚   const docRef = doc(db, collectionName, id)
   96 â”‚   const docSnap = await getDoc(docRef)
   97 â”‚   
   98 â”‚   if (docSnap.exists()) {
   99 â”‚     const data = docSnap.data();
  100 â”‚     console.log("Dados brutos recuperados do Firestore para quarto:", id, data);
  101 â”‚     
  102 â”‚     if (data?.serviceFeePct !== undefined) {
  103 â”‚       console.log("serviceFeePct antes da conversÃ£o:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
  104 â”‚       // Garantir que serviceFeePct seja um nÃºmero
  105 â”‚       data.serviceFeePct = Number(data.serviceFeePct);
  106 â”‚       console.log("serviceFeePct apÃ³s conversÃ£o:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
  107 â”‚     }
  108 â”‚     
  109 â”‚     return { id: docSnap.id, ...data } as T
  110 â”‚   } else {
  111 â”‚     return null
  112 â”‚   }
  113 â”‚ }
  114 â”‚ 
  115 â”‚ export const getDocuments = async <T>(
  116 â”‚   collectionName: string,
  117 â”‚   constraints: QueryConstraint[] = [],
  118 â”‚   forceRefresh = false
  119 â”‚ ): Promise<T[]> => {
  120 â”‚   try {
  121 â”‚     const collectionRef = collection(db, collectionName)
  122 â”‚     const q = query(collectionRef, ...constraints)
  123 â”‚     
  124 â”‚     // Se forceRefresh for verdadeiro, adicionar opÃ§Ãµes que forÃ§am uma nova consulta ao Firestore
  125 â”‚     const querySnapshot = await getDocs(q)
  126 â”‚     
  127 â”‚     console.log(`Buscando documentos na coleÃ§Ã£o ${collectionName} - ForÃ§a atualizaÃ§Ã£o: ${forceRefresh}`);
  128 â”‚     
  129 â”‚     return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }) as T)
  130 â”‚   } catch (error) {
  131 â”‚     console.error(`Erro ao buscar documentos da coleÃ§Ã£o ${collectionName}:`, error);
  132 â”‚     return [];
  133 â”‚   }
  134 â”‚ }
  135 â”‚ 
  136 â”‚ export const updateDocument = async <T extends DocumentData>(
  137 â”‚   collectionName: string,
  138 â”‚   id: string,
  139 â”‚   data: Partial<T>
  140 â”‚ ): Promise<void> => {
  141 â”‚   const docRef = doc(db, collectionName, id)
  142 â”‚   await updateDoc(docRef, {
  143 â”‚     ...data,
  144 â”‚     updatedAt: serverTimestamp()
  145 â”‚   })
  146 â”‚ }
  147 â”‚ 
  148 â”‚ export const deleteDocument = async (
  149 â”‚   collectionName: string,
  150 â”‚   id: string
  151 â”‚ ): Promise<boolean> => {
  152 â”‚   const docRef = doc(db, collectionName, id)
  153 â”‚   await deleteDoc(docRef)
  154 â”‚   return true
  155 â”‚ }
  156 â”‚ 
  157 â”‚ // FunÃ§Ãµes para gerenciar quartos
  158 â”‚ export const getRooms = async (forceRefresh = false): Promise<Room[]> => {
  159 â”‚   try {
  160 â”‚     const constraints: QueryConstraint[] = []
  161 â”‚     
  162 â”‚     constraints.push(orderBy('name', 'asc'))
  163 â”‚     
  164 â”‚     const rooms = await getDocuments<Room>('rooms', constraints, forceRefresh)
  165 â”‚     
  166 â”‚     // Garantir que todos os campos necessÃ¡rios estejam presentes
  167 â”‚     return rooms.map(room => {
  168 â”‚       console.log(`Firebase - Quarto ${room.id} dados brutos:`, room);
  169 â”‚       
  170 â”‚       // Garantir que serviceFeePct seja um nÃºmero
  171 â”‚       const serviceFeePct = room.serviceFeePct !== undefined 
  172 â”‚         ? Number(room.serviceFeePct) 
  173 â”‚         : 10;
  174 â”‚         
  175 â”‚       console.log(`Firebase - Quarto ${room.id} serviceFeePct:`, {
  176 â”‚         original: room.serviceFeePct,
  177 â”‚         tipo: typeof room.serviceFeePct,
  178 â”‚         convertido: serviceFeePct
  179 â”‚       });
  180 â”‚       
  181 â”‚       return {
  182 â”‚         id: room.id,
  183 â”‚         name: room.name || '',
  184 â”‚         type: room.type || 'standard',
  185 â”‚         description: room.description || '',
  186 â”‚         price: room.price || 0,
  187 â”‚         capacity: room.capacity || 2,
  188 â”‚         size: room.size || 0,
  189 â”‚         available: room.available !== undefined ? room.available : true,
  190 â”‚         serviceFeePct: serviceFeePct,
  191 â”‚         images: room.images || [],
  192 â”‚         amenities: room.amenities || [],
  193 â”‚         additionalServices: room.additionalServices || [],
  194 â”‚         highlights: room.highlights || [],
  195 â”‚         createdAt: room.createdAt,
  196 â”‚         updatedAt: room.updatedAt
  197 â”‚       };
  198 â”‚     });
  199 â”‚   } catch (error) {
  200 â”‚     console.error('Erro ao buscar quartos:', error)
  201 â”‚     return []
  202 â”‚   }
  203 â”‚ }
  204 â”‚ 
  205 â”‚ export const getAvailableRooms = async (
  206 â”‚   checkIn: Date,
  207 â”‚   checkOut: Date
  208 â”‚ ): Promise<Room[]> => {
  209 â”‚   try {
  210 â”‚     // Buscar todos os quartos que estÃ£o marcados como disponÃ­veis em geral
  211 â”‚     const constraints: QueryConstraint[] = [
  212 â”‚       where('available', '==', true)
  213 â”‚     ]
  214 â”‚     
  215 â”‚     const rooms = await getDocuments<Room>('rooms', constraints);
  216 â”‚     
  217 â”‚     // Filtrar os quartos que estÃ£o disponÃ­veis nas datas especÃ­ficas
  218 â”‚     return filterAvailableRoomsByDate(rooms, checkIn, checkOut);
  219 â”‚   } catch (error) {
  220 â”‚     console.error('Erro ao buscar quartos disponÃ­veis:', error)
  221 â”‚     return []
  222 â”‚   }
  223 â”‚ }
  224 â”‚ 
  225 â”‚ // FunÃ§Ã£o auxiliar para verificar disponibilidade entre datas
  226 â”‚ export const filterAvailableRoomsByDate = (
  227 â”‚   rooms: Room[],
  228 â”‚   checkIn: Date,
  229 â”‚   checkOut: Date
  230 â”‚ ): Room[] => {
  231 â”‚   // Converter checkIn e checkOut para ISO strings
  232 â”‚   const dateStrings = getDatesInRange(checkIn, checkOut);
  233 â”‚   
  234 â”‚   return rooms.filter(room => {
  235 â”‚     // Se nÃ£o tiver controle de disponibilidade especÃ­fico, considera disponÃ­vel
  236 â”‚     if (!room.availabilityDates) return true;
  237 â”‚     
  238 â”‚     // Verificar se alguma data no intervalo estÃ¡ indisponÃ­vel
  239 â”‚     return !dateStrings.some(dateStr => 
  240 â”‚       room.availabilityDates?.[dateStr] === false
  241 â”‚     );
  242 â”‚   });
  243 â”‚ };
  244 â”‚ 
  245 â”‚ // FunÃ§Ã£o para obter disponibilidade de um quarto especÃ­fico
  246 â”‚ export const getRoomAvailability = async (
  247 â”‚   roomId: string, 
  248 â”‚   startDate: Date, 
  249 â”‚   endDate: Date
  250 â”‚ ): Promise<{[date: string]: boolean}> => {
  251 â”‚   try {
  252 â”‚     const room = await getRoomById(roomId);
  253 â”‚     if (!room) throw new Error(`Quarto com ID ${roomId} nÃ£o encontrado`);
  254 â”‚     
  255 â”‚     // Gerar datas no intervalo
  256 â”‚     const dateStrings = getDatesInRange(startDate, endDate);
  257 â”‚     
  258 â”‚     // Se nÃ£o tiver configuraÃ§Ã£o de disponibilidade especÃ­fica, assume tudo disponÃ­vel
  259 â”‚     if (!room.availabilityDates) {
  260 â”‚       return dateStrings.reduce((acc, date) => {
  261 â”‚         acc[date] = true;
  262 â”‚         return acc;
  263 â”‚       }, {} as {[date: string]: boolean});
  264 â”‚     }
  265 â”‚     
  266 â”‚     // Preencher com os dados de disponibilidade existentes
  267 â”‚     return dateStrings.reduce((acc, date) => {
  268 â”‚       acc[date] = room.availabilityDates?.[date] !== false; // disponÃ­vel por padrÃ£o se nÃ£o estiver explicitamente indisponÃ­vel
  269 â”‚       return acc;
  270 â”‚     }, {} as {[date: string]: boolean});
  271 â”‚   } catch (error) {
  272 â”‚     console.error(`Erro ao verificar disponibilidade do quarto ${roomId}:`, error);
  273 â”‚     throw error;
  274 â”‚   }
  275 â”‚ };
  276 â”‚ 
  277 â”‚ // FunÃ§Ã£o para atualizar disponibilidade de um quarto
  278 â”‚ export const updateRoomAvailability = async (
  279 â”‚   roomId: string,
  280 â”‚   availabilityDates: {[date: string]: boolean}
  281 â”‚ ): Promise<boolean> => {
  282 â”‚   try {
  283 â”‚     await updateDocument('rooms', roomId, {
  284 â”‚       availabilityDates,
  285 â”‚       updatedAt: serverTimestamp()
  286 â”‚     });
  287 â”‚     return true;
  288 â”‚   } catch (error) {
  289 â”‚     console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  290 â”‚     return false;
  291 â”‚   }
  292 â”‚ };
  293 â”‚ 
  294 â”‚ // FunÃ§Ã£o auxiliar para gerar array de strings de data entre um intervalo
  295 â”‚ export const getDatesInRange = (startDate: Date, endDate: Date): string[] => {
  296 â”‚   const dates: string[] = [];
  297 â”‚   const currentDate = new Date(startDate);
  298 â”‚   
  299 â”‚   // Normalizar para meia-noite no fuso horÃ¡rio local
  300 â”‚   currentDate.setHours(0, 0, 0, 0);
  301 â”‚   const endDateNormalized = new Date(endDate);
  302 â”‚   endDateNormalized.setHours(0, 0, 0, 0);
  303 â”‚   
  304 â”‚   // Adicionar cada data no intervalo EXCETO o dia de checkout
  305 â”‚   // Usando < em vez de <= para nÃ£o incluir o dia de checkout
  306 â”‚   while (currentDate < endDateNormalized) {
  307 â”‚     dates.push(currentDate.toISOString().split('T')[0]); // Formato YYYY-MM-DD
  308 â”‚     currentDate.setDate(currentDate.getDate() + 1);
  309 â”‚   }
  310 â”‚   
  311 â”‚   return dates;
  312 â”‚ };
  313 â”‚ 
  314 â”‚ export const getRoomById = async (id: string): Promise<Room | null> => {
  315 â”‚   try {
  316 â”‚     const room = await getDocument<Room>('rooms', id);
  317 â”‚     
  318 â”‚     if (!room) return null;
  319 â”‚     
  320 â”‚     console.log(`Firebase - getRoomById ${id} dados brutos:`, room);
  321 â”‚     
  322 â”‚     // Log especÃ­fico para serviceFeePct
  323 â”‚     console.log(`serviceFeePct no Firestore:`, room.serviceFeePct);
  324 â”‚     
  325 â”‚     // Garantir que todos os campos necessÃ¡rios estejam presentes
  326 â”‚     return {
  327 â”‚       ...room,
  328 â”‚       name: room.name || '',
  329 â”‚       type: room.type || 'standard',
  330 â”‚       description: room.description || '',
  331 â”‚       price: room.price || 0,
  332 â”‚       capacity: room.capacity || 2,
  333 â”‚       size: room.size || 0,
  334 â”‚       available: room.available !== undefined ? room.available : true,
  335 â”‚       serviceFeePct: room.serviceFeePct !== undefined ? room.serviceFeePct : 10,
  336 â”‚       images: room.images || [],
  337 â”‚       amenities: room.amenities || [],
  338 â”‚       additionalServices: room.additionalServices || [],
  339 â”‚       highlights: room.highlights || []
  340 â”‚     };
  341 â”‚   } catch (error) {
  342 â”‚     console.error(`Erro ao buscar quarto com ID ${id}:`, error);
  343 â”‚     return null;
  344 â”‚   }
  345 â”‚ }
  346 â”‚ 
  347 â”‚ export const createRoom = async (roomData: Omit<Room, 'id' | 'createdAt' | 'updatedAt'>): Promise<Room> => {
  348 â”‚   try {
  349 â”‚     console.log("createRoom - Dados recebidos:", roomData);
  350 â”‚     
  351 â”‚     const roomWithTimestamps = {
  352 â”‚       ...roomData,
  353 â”‚       available: roomData.available !== undefined ? roomData.available : true,
  354 â”‚       featured: roomData.featured || false,
  355 â”‚       amenities: roomData.amenities || [],
  356 â”‚       additionalServices: roomData.additionalServices || [],
  357 â”‚       highlights: roomData.highlights || [],
  358 â”‚       createdAt: serverTimestamp(),
  359 â”‚       updatedAt: serverTimestamp()
  360 â”‚     }
  361 â”‚     
  362 â”‚     console.log("createRoom - Dados a serem salvos:", roomWithTimestamps);
  363 â”‚     
  364 â”‚     const id = await createDocument('rooms', roomWithTimestamps)
  365 â”‚     
  366 â”‚     return {
  367 â”‚       id,
  368 â”‚       ...roomData,
  369 â”‚       amenities: roomData.amenities || [],
  370 â”‚       additionalServices: roomData.additionalServices || [],
  371 â”‚       highlights: roomData.highlights || [],
  372 â”‚       createdAt: Timestamp.now(),
  373 â”‚       updatedAt: Timestamp.now()
  374 â”‚     }
  375 â”‚   } catch (error) {
  376 â”‚     console.error('Erro ao criar quarto:', error)
  377 â”‚     throw error
  378 â”‚   }
  379 â”‚ }
  380 â”‚ 
  381 â”‚ export const updateRoom = async (id: string, roomData: Partial<Omit<Room, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Room> => {
  382 â”‚   try {
  383 â”‚     console.log(`updateRoom - ID: ${id}, Dados recebidos:`, roomData);
  384 â”‚     
  385 â”‚     // Garantir que estamos lidando explicitamente com o serviceFeePct se ele for 0
  386 â”‚     if (roomData.serviceFeePct === 0) {
  387 â”‚       console.log("updateRoom - Detectado serviceFeePct com valor 0, salvando explicitamente.", roomData.serviceFeePct);
  388 â”‚     }
  389 â”‚     
  390 â”‚     // Adicionar timestamp de atualizaÃ§Ã£o
  391 â”‚     const roomWithTimestamp = {
  392 â”‚       ...roomData,
  393 â”‚       amenities: roomData.amenities || [],
  394 â”‚       additionalServices: roomData.additionalServices || [],
  395 â”‚       highlights: roomData.highlights || [],
  396 â”‚       updatedAt: serverTimestamp()
  397 â”‚     }
  398 â”‚     
  399 â”‚     console.log(`updateRoom - Dados a serem salvos:`, roomWithTimestamp);
  400 â”‚     
  401 â”‚     await updateDocument('rooms', id, roomWithTimestamp)
  402 â”‚     
  403 â”‚     const updatedRoom = await getRoomById(id)
  404 â”‚     if (!updatedRoom) {
  405 â”‚       throw new Error(`Quarto com ID ${id} nÃ£o encontrado apÃ³s atualizaÃ§Ã£o`)
  406 â”‚     }
  407 â”‚     
  408 â”‚     return updatedRoom
  409 â”‚   } catch (error) {
  410 â”‚     console.error('Erro ao atualizar quarto:', error)
  411 â”‚     throw error
  412 â”‚   }
  413 â”‚ }
  414 â”‚ 
  415 â”‚ export const deleteRoom = async (id: string): Promise<boolean> => {
  416 â”‚   return await deleteDocument('rooms', id)
  417 â”‚ }
  418 â”‚ 
  419 â”‚ // FunÃ§Ãµes especÃ­ficas para reservas
  420 â”‚ export const createBooking = async (bookingData: any) => {
  421 â”‚   try {
  422 â”‚     const bookingsCollection = collection(db, 'bookings');
  423 â”‚     const docRef = await addDoc(bookingsCollection, bookingData);
  424 â”‚     
  425 â”‚     // CORREÃ‡ÃƒO: NÃ£o bloquear a data no momento da criaÃ§Ã£o da reserva
  426 â”‚     // O bloqueio serÃ¡ feito apenas quando o pagamento for confirmado
  427 â”‚     // atravÃ©s da funÃ§Ã£o updateBookingStatus
  428 â”‚     
  429 â”‚     return docRef;
  430 â”‚   } catch (error) {
  431 â”‚     console.error('Erro ao criar reserva:', error);
  432 â”‚     throw error;
  433 â”‚   }
  434 â”‚ };
  435 â”‚ 
  436 â”‚ // Nova funÃ§Ã£o para atualizar status da reserva e bloquear as datas da estadia
  437 â”‚ export const updateBookingStatus = async (
  438 â”‚   bookingId: string, 
  439 â”‚   newStatus: 'pending' | 'confirmed' | 'cancelled' | 'completed',
  440 â”‚   newPaymentStatus: 'pending' | 'paid' | 'refunded'
  441 â”‚ ): Promise<boolean> => {
  442 â”‚   try {
  443 â”‚     // ReferÃªncia ao documento da reserva
  444 â”‚     const bookingRef = doc(db, 'bookings', bookingId);
  445 â”‚     const bookingSnap = await getDoc(bookingRef);
  446 â”‚     
  447 â”‚     if (!bookingSnap.exists()) {
  448 â”‚       console.error(`Booking ${bookingId} nÃ£o existe ao atualizar status`);
  449 â”‚       return false;
  450 â”‚     }
  451 â”‚     
  452 â”‚     const bookingData = bookingSnap.data();
  453 â”‚     
  454 â”‚     // Atualizar o status da reserva
  455 â”‚     await updateDoc(bookingRef, {
  456 â”‚       status: newStatus,
  457 â”‚       paymentStatus: newPaymentStatus,
  458 â”‚       updatedAt: serverTimestamp(),
  459 â”‚       ...(newStatus === 'confirmed' && { confirmedAt: serverTimestamp() })
  460 â”‚     });
  461 â”‚     
  462 â”‚     // Se a reserva estÃ¡ sendo confirmada, precisamos bloquear as datas
  463 â”‚     if (newStatus === 'confirmed') {
  464 â”‚       console.log(`Atualizando disponibilidade para reserva confirmada: ${bookingId}`);
  465 â”‚       
  466 â”‚       // Recuperar datas de check-in e check-out
  467 â”‚       const checkIn = bookingData.checkIn.toDate();
  468 â”‚       const checkOut = bookingData.checkOut.toDate();
  469 â”‚       const roomId = bookingData.roomId;
  470 â”‚       
  471 â”‚       // Obter todas as datas entre check-in e check-out
  472 â”‚       const dates: Date[] = [];
  473 â”‚       const currentDate = new Date(checkIn);
  474 â”‚       
  475 â”‚       while (currentDate < checkOut) {
  476 â”‚         dates.push(new Date(currentDate));
  477 â”‚         currentDate.setDate(currentDate.getDate() + 1);
  478 â”‚       }
  479 â”‚       
  480 â”‚       console.log(`Bloqueando ${dates.length} dias para quarto ${roomId}`);
  481 â”‚       
  482 â”‚       // Atualizar disponibilidade para cada data
  483 â”‚       const availabilityUpdates: {[date: string]: boolean} = {};
  484 â”‚       
  485 â”‚       dates.forEach(date => {
  486 â”‚         const dateString = date.toISOString().split('T')[0]; // formato YYYY-MM-DD
  487 â”‚         availabilityUpdates[dateString] = false; // false significa indisponÃ­vel
  488 â”‚       });
  489 â”‚       
  490 â”‚       // Atualizar disponibilidade do quarto
  491 â”‚       if (Object.keys(availabilityUpdates).length > 0) {
  492 â”‚         try {
  493 â”‚           // Obter o documento do quarto
  494 â”‚           const roomRef = doc(db, 'rooms', roomId);
  495 â”‚           const roomSnap = await getDoc(roomRef);
  496 â”‚           
  497 â”‚           if (roomSnap.exists()) {
  498 â”‚             const roomData = roomSnap.data();
  499 â”‚             const currentAvailability = roomData.availabilityDates || {};
  500 â”‚             
  501 â”‚             // Mesclar a disponibilidade atual com as novas atualizaÃ§Ãµes
  502 â”‚             const updatedAvailability = {
  503 â”‚               ...currentAvailability,
  504 â”‚               ...availabilityUpdates
  505 â”‚             };
  506 â”‚             
  507 â”‚             // Atualizar o documento do quarto
  508 â”‚             await updateDoc(roomRef, {
  509 â”‚               availabilityDates: updatedAvailability,
  510 â”‚               updatedAt: serverTimestamp()
  511 â”‚             });
  512 â”‚             
  513 â”‚             console.log(`Disponibilidade atualizada com sucesso para quarto ${roomId}`);
  514 â”‚             
  515 â”‚             // Criar log da reserva
  516 â”‚             await addDoc(collection(db, 'bookingLogs'), {
  517 â”‚               bookingId,
  518 â”‚               roomId,
  519 â”‚               action: 'status_updated',
  520 â”‚               previousStatus: bookingData.status,
  521 â”‚               newStatus,
  522 â”‚               previousPaymentStatus: bookingData.paymentStatus,
  523 â”‚               newPaymentStatus,
  524 â”‚               datesBlocked: Object.keys(availabilityUpdates),
  525 â”‚               timestamp: serverTimestamp(),
  526 â”‚               userId: bookingData.userId || 'system'
  527 â”‚             });
  528 â”‚           } else {
  529 â”‚             console.error(`Quarto ${roomId} nÃ£o encontrado ao atualizar disponibilidade`);
  530 â”‚           }
  531 â”‚         } catch (error) {
  532 â”‚           console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  533 â”‚         }
  534 â”‚       }
  535 â”‚     }
  536 â”‚     
  537 â”‚     return true;
  538 â”‚   } catch (error) {
  539 â”‚     console.error(`Erro ao atualizar status da reserva ${bookingId}:`, error);
  540 â”‚     return false;
  541 â”‚   }
  542 â”‚ }
  543 â”‚ 
  544 â”‚ export const getUserBookings = async (userId: string): Promise<Booking[]> => {
  545 â”‚   return getDocuments<Booking>('bookings', [
  546 â”‚     where('userId', '==', userId),
  547 â”‚     orderBy('createdAt', 'desc')
  548 â”‚   ])
  549 â”‚ }
  550 â”‚ 
  551 â”‚ export const getRecentBookings = async (count = 5): Promise<Booking[]> => {
  552 â”‚   return getDocuments<Booking>('bookings', [
  553 â”‚     orderBy('createdAt', 'desc'),
  554 â”‚     limit(count)
  555 â”‚   ])
  556 â”‚ }
  557 â”‚ 
  558 â”‚ export const getRoomBookings = async (roomId: string): Promise<Booking[]> => {
  559 â”‚   try {
  560 â”‚     const constraints: QueryConstraint[] = [
  561 â”‚       where('roomId', '==', roomId),
  562 â”‚       orderBy('checkIn', 'asc')
  563 â”‚     ];
  564 â”‚     
  565 â”‚     return await getDocuments<Booking>('bookings', constraints);
  566 â”‚   } catch (error) {
  567 â”‚     console.error(`Erro ao buscar reservas do quarto ${roomId}:`, error);
  568 â”‚     return [];
  569 â”‚   }
  570 â”‚ };
  571 â”‚ 
  572 â”‚ // FunÃ§Ãµes especÃ­ficas para contatos
  573 â”‚ export const createContactMessage = async (contactData: Contact) => {
  574 â”‚   try {
  575 â”‚     const contactsCollection = collection(db, 'contacts')
  576 â”‚     
  577 â”‚     // Garantir que o status seja 'new' para novos contatos
  578 â”‚     const contactWithDefaults = {
  579 â”‚       ...contactData,
  580 â”‚       status: contactData.status || 'new',
  581 â”‚       createdAt: contactData.createdAt || Timestamp.now()
  582 â”‚     }
  583 â”‚     
  584 â”‚     // Se tiver detalhes de reserva, adicionar metadados
  585 â”‚     if (contactWithDefaults.reservationDetails) {
  586 â”‚       // Ajustar subject para indicar que Ã© relacionado a reserva
  587 â”‚       if (!contactWithDefaults.subject.includes('Reserva')) {
  588 â”‚         contactWithDefaults.subject = `Reserva: ${contactWithDefaults.subject}`;
  589 â”‚       }
  590 â”‚     }
  591 â”‚     
  592 â”‚     const docRef = await addDoc(contactsCollection, contactWithDefaults)
  593 â”‚     return docRef
  594 â”‚   } catch (error) {
  595 â”‚     console.error('Erro ao criar mensagem de contato:', error)
  596 â”‚     throw error
  597 â”‚   }
  598 â”‚ }
  599 â”‚ 
  600 â”‚ export const getNewContactMessages = async (): Promise<Contact[]> => {
  601 â”‚   return getDocuments<Contact>('contacts', [
  602 â”‚     where('status', '==', 'new'),
  603 â”‚     orderBy('createdAt', 'desc')
  604 â”‚   ])
  605 â”‚ }
  606 â”‚ 
  607 â”‚ // FunÃ§Ãµes para Dashboard com dados reais
  608 â”‚ 
  609 â”‚ export const getDashboardStats = async () => {
  610 â”‚   try {
  611 â”‚     const [totalBookings, totalRevenue, occupancyRate, bookingsByPlatform] = await Promise.all([
  612 â”‚       getTotalBookings(),
  613 â”‚       getMonthlyRevenue(),
  614 â”‚       getOccupancyRate(),
  615 â”‚       getBookingsByPlatform()
  616 â”‚     ]);
  617 â”‚ 
  618 â”‚     return {
  619 â”‚       totalBookings,
  620 â”‚       totalRevenue,
  621 â”‚       occupancyRate,
  622 â”‚       bookingsByPlatform
  623 â”‚     };
  624 â”‚   } catch (error) {
  625 â”‚     console.error('Erro ao obter estatÃ­sticas do dashboard:', error);
  626 â”‚     throw error;
  627 â”‚   }
  628 â”‚ };
  629 â”‚ 
  630 â”‚ // Obter total de reservas
  631 â”‚ export const getTotalBookings = async () => {
  632 â”‚   try {
  633 â”‚     // Obter todas as reservas
  634 â”‚     const bookings = await getDocuments<Booking>('bookings');
  635 â”‚     
  636 â”‚     // Contar reservas por status
  637 â”‚     const confirmed = bookings.filter(b => b.status === 'confirmed').length;
  638 â”‚     const pending = bookings.filter(b => b.status === 'pending').length;
  639 â”‚     const cancelled = bookings.filter(b => b.status === 'cancelled').length;
  640 â”‚     const completed = bookings.filter(b => b.status === 'completed').length;
  641 â”‚     
  642 â”‚     // Calcular crescimento em relaÃ§Ã£o ao mÃªs anterior (simulado por enquanto)
  643 â”‚     // Em uma implementaÃ§Ã£o real, vocÃª compararia com dados do mÃªs anterior
  644 â”‚     const growth = ((confirmed + completed) / (bookings.length || 1) * 100) - 50;
  645 â”‚     
  646 â”‚     return {
  647 â”‚       total: bookings.length,
  648 â”‚       confirmed,
  649 â”‚       pending,
  650 â”‚       cancelled,
  651 â”‚       completed,
  652 â”‚       growth: Math.round(growth) // Arredonda para nÃºmero inteiro
  653 â”‚     };
  654 â”‚   } catch (error) {
  655 â”‚     console.error('Erro ao obter total de reservas:', error);
  656 â”‚     return {
  657 â”‚       total: 0,
  658 â”‚       confirmed: 0,
  659 â”‚       pending: 0, 
  660 â”‚       cancelled: 0,
  661 â”‚       completed: 0,
  662 â”‚       growth: 0
  663 â”‚     };
  664 â”‚   }
  665 â”‚ };
  666 â”‚ 
  667 â”‚ // Obter receita mensal
  668 â”‚ export const getMonthlyRevenue = async () => {
  669 â”‚   try {
  670 â”‚     const bookings = await getDocuments<Booking>('bookings');
  671 â”‚     
  672 â”‚     // Filtrar reservas confirmadas e concluÃ­das
  673 â”‚     const validBookings = bookings.filter(b => 
  674 â”‚       b.status === 'confirmed' || b.status === 'completed'
  675 â”‚     );
  676 â”‚     
  677 â”‚     // Calcular receita total
  678 â”‚     const totalRevenue = validBookings.reduce((acc, booking) => acc + booking.totalPrice, 0);
  679 â”‚     
  680 â”‚     // Agrupar receita por mÃªs
  681 â”‚     const revenueByMonth = validBookings.reduce((acc, booking) => {
  682 â”‚       const date = booking.checkIn.toDate();
  683 â”‚       const month = date.getMonth(); // 0-11
  684 â”‚       const year = date.getFullYear();
  685 â”‚       const key = `${year}-${month}`;
  686 â”‚       
  687 â”‚       if (!acc[key]) {
  688 â”‚         acc[key] = 0;
  689 â”‚       }
  690 â”‚       acc[key] += booking.totalPrice;
  691 â”‚       return acc;
  692 â”‚     }, {} as Record<string, number>);
  693 â”‚     
  694 â”‚     // Converter para formato de array para grÃ¡fico
  695 â”‚     const monthNames = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
  696 â”‚     
  697 â”‚     const currentDate = new Date();
  698 â”‚     const currentMonth = currentDate.getMonth();
  699 â”‚     const currentYear = currentDate.getFullYear();
  700 â”‚     
  701 â”‚     const revenueData = [];
  702 â”‚     
  703 â”‚     // Gerar dados dos Ãºltimos 12 meses
  704 â”‚     for (let i = 0; i < 12; i++) {
  705 â”‚       const month = (currentMonth - i + 12) % 12;
  706 â”‚       const year = currentMonth - i < 0 ? currentYear - 1 : currentYear;
  707 â”‚       const key = `${year}-${month}`;
  708 â”‚       
  709 â”‚       revenueData.unshift({
  710 â”‚         month: monthNames[month],
  711 â”‚         value: revenueByMonth[key] || 0
  712 â”‚       });
  713 â”‚     }
  714 â”‚     
  715 â”‚     // Calcular crescimento em relaÃ§Ã£o ao mÃªs anterior
  716 â”‚     const lastMonthRevenue = revenueData[revenueData.length - 2]?.value || 0;
  717 â”‚     const currentMonthRevenue = revenueData[revenueData.length - 1]?.value || 0;
  718 â”‚     
  719 â”‚     const growth = lastMonthRevenue ? ((currentMonthRevenue - lastMonthRevenue) / lastMonthRevenue) * 100 : 0;
  720 â”‚     
  721 â”‚     return {
  722 â”‚       monthly: currentMonthRevenue,
  723 â”‚       total: totalRevenue,
  724 â”‚       growth: Math.round(growth),
  725 â”‚       revenueData
  726 â”‚     };
  727 â”‚   } catch (error) {
  728 â”‚     console.error('Erro ao obter receita mensal:', error);
  729 â”‚     return {
  730 â”‚       monthly: 0,
  731 â”‚       total: 0,
  732 â”‚       growth: 0,
  733 â”‚       revenueData: []
  734 â”‚     };
  735 â”‚   }
  736 â”‚ };
  737 â”‚ 
  738 â”‚ // Calcular taxa de ocupaÃ§Ã£o
  739 â”‚ export const getOccupancyRate = async () => {
  740 â”‚   try {
  741 â”‚     // Obter todos os quartos
  742 â”‚     const rooms = await getDocuments<Room>('rooms');
  743 â”‚     const totalRooms = rooms.length;
  744 â”‚     
  745 â”‚     if (totalRooms === 0) {
  746 â”‚       return { rate: 0, growth: 0 };
  747 â”‚     }
  748 â”‚     
  749 â”‚     // Obter todas as reservas
  750 â”‚     const bookings = await getDocuments<Booking>('bookings');
  751 â”‚     
  752 â”‚     // Filtrar reservas confirmadas e concluÃ­das para o mÃªs atual
  753 â”‚     const currentDate = new Date();
  754 â”‚     const currentMonth = currentDate.getMonth();
  755 â”‚     const currentYear = currentDate.getFullYear();
  756 â”‚     
  757 â”‚     const currentMonthBookings = bookings.filter(booking => {
  758 â”‚       const checkInDate = booking.checkIn.toDate();
  759 â”‚       return (
  760 â”‚         (booking.status === 'confirmed' || booking.status === 'completed') &&
  761 â”‚         checkInDate.getMonth() === currentMonth &&
  762 â”‚         checkInDate.getFullYear() === currentYear
  763 â”‚       );
  764 â”‚     });
  765 â”‚     
  766 â”‚     // Calcular dias ocupados por quarto
  767 â”‚     const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
  768 â”‚     const totalPossibleRoomDays = totalRooms * daysInMonth;
  769 â”‚     
  770 â”‚     // Contar dias ocupados (simplificado - em produÃ§Ã£o seria mais complexo)
  771 â”‚     let occupiedDays = 0;
  772 â”‚     
  773 â”‚     currentMonthBookings.forEach(booking => {
  774 â”‚       const checkIn = booking.checkIn.toDate();
  775 â”‚       const checkOut = booking.checkOut.toDate();
  776 â”‚       
  777 â”‚       // Ajustar datas para considerar apenas o mÃªs atual
  778 â”‚       const startDate = new Date(Math.max(
  779 â”‚         checkIn.getTime(),
  780 â”‚         new Date(currentYear, currentMonth, 1).getTime()
  781 â”‚       ));
  782 â”‚       const endDate = new Date(Math.min(
  783 â”‚         checkOut.getTime(),
  784 â”‚         new Date(currentYear, currentMonth + 1, 0).getTime()
  785 â”‚       ));
  786 â”‚       
  787 â”‚       // Calcular dias entre datas (incluindo check-in, excluindo check-out)
  788 â”‚       const days = Math.max(0, Math.floor((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)));
  789 â”‚       occupiedDays += days;
  790 â”‚     });
  791 â”‚     
  792 â”‚     const occupancyRate = (occupiedDays / totalPossibleRoomDays) * 100;
  793 â”‚     
  794 â”‚     // SimulaÃ§Ã£o de crescimento (em produÃ§Ã£o, compararia com mÃªs anterior)
  795 â”‚     const growth = occupancyRate > 50 ? 5 : -3;
  796 â”‚     
  797 â”‚     return {
  798 â”‚       rate: Math.round(occupancyRate),
  799 â”‚       growth: Math.round(growth)
  800 â”‚     };
  801 â”‚   } catch (error) {
  802 â”‚     console.error('Erro ao calcular taxa de ocupaÃ§Ã£o:', error);
  803 â”‚     return { rate: 0, growth: 0 };
  804 â”‚   }
  805 â”‚ };
  806 â”‚ 
  807 â”‚ // Obter reservas agrupadas por plataforma
  808 â”‚ export const getBookingsByPlatform = async () => {
  809 â”‚   try {
  810 â”‚     const bookings = await getDocuments<Booking>('bookings');
  811 â”‚     
  812 â”‚     // Categorizar reservas por origem
  813 â”‚     const platforms = [
  814 â”‚       { 
  815 â”‚         platform: "Booking.com", 
  816 â”‚         color: "#003580", 
  817 â”‚         icon: "Globe",
  818 â”‚         bookings: []
  819 â”‚       },
  820 â”‚       { 
  821 â”‚         platform: "Airbnb", 
  822 â”‚         color: "#FF5A5F", 
  823 â”‚         icon: "Heart",
  824 â”‚         bookings: []
  825 â”‚       },
  826 â”‚       { 
  827 â”‚         platform: "Direto", 
  828 â”‚         color: "#4CAF50", 
  829 â”‚         icon: "Home",
  830 â”‚         bookings: []
  831 â”‚       }
  832 â”‚     ];
  833 â”‚     
  834 â”‚     // Para fins de demonstraÃ§Ã£o, colocar todas as reservas como "Direto" por enquanto
  835 â”‚     // Em produÃ§Ã£o, usaria um campo "platformOrigin" ou similar na tabela de reservas
  836 â”‚     const platformIndex = 2; // Ãndice da plataforma "Direto"
  837 â”‚     
  838 â”‚     bookings.forEach(booking => {
  839 â”‚       // Transformar para o formato esperado pelo componente
  840 â”‚       const transformedBooking = {
  841 â”‚         id: booking.id || '',
  842 â”‚         guestName: booking.guestName,
  843 â”‚         roomName: booking.roomName,
  844 â”‚         checkIn: booking.checkIn.toDate().toLocaleDateString('pt-PT'),
  845 â”‚         checkOut: booking.checkOut.toDate().toLocaleDateString('pt-PT'),
  846 â”‚         status: booking.status,
  847 â”‚         value: new Intl.NumberFormat('pt-PT', {
  848 â”‚           style: 'currency',
  849 â”‚           currency: 'EUR'
  850 â”‚         }).format(booking.totalPrice)
  851 â”‚       };
  852 â”‚       
  853 â”‚       // Adicionar Ã  plataforma "Direto"
  854 â”‚       (platforms[platformIndex] as any).bookings.push(transformedBooking);
  855 â”‚     });
  856 â”‚     
  857 â”‚     return platforms;
  858 â”‚   } catch (error) {
  859 â”‚     console.error('Erro ao obter reservas por plataforma:', error);
  860 â”‚     return [];
  861 â”‚   }
  862 â”‚ };
  863 â”‚ 
  864 â”‚ // FunÃ§Ã£o para obter o preÃ§o de um quarto para uma data especÃ­fica
  865 â”‚ export const getRoomPriceForDate = async (roomId: string, date: Date): Promise<number> => {
  866 â”‚   try {
  867 â”‚     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  868 â”‚     
  869 â”‚     if (!roomDoc.exists()) {
  870 â”‚       throw new Error("Quarto nÃ£o encontrado");
  871 â”‚     }
  872 â”‚     
  873 â”‚     const roomData = roomDoc.data() as Room;
  874 â”‚     const basePrice = roomData.price;
  875 â”‚     
  876 â”‚     if (!roomData.seasonalPrices || roomData.seasonalPrices.length === 0) {
  877 â”‚       return basePrice;
  878 â”‚     }
  879 â”‚     
  880 â”‚     // Verificar se a data estÃ¡ dentro de algum perÃ­odo sazonal
  881 â”‚     for (const seasonalPrice of roomData.seasonalPrices) {
  882 â”‚       const startDate = new Date(seasonalPrice.startDate);
  883 â”‚       const endDate = new Date(seasonalPrice.endDate);
  884 â”‚       
  885 â”‚       if (date >= startDate && date <= endDate) {
  886 â”‚         return seasonalPrice.price;
  887 â”‚       }
  888 â”‚     }
  889 â”‚     
  890 â”‚     // Se nÃ£o cair em nenhum perÃ­odo sazonal, retorna o preÃ§o base
  891 â”‚     return basePrice;
  892 â”‚   } catch (error) {
  893 â”‚     console.error("Erro ao obter preÃ§o do quarto:", error);
  894 â”‚     throw error;
  895 â”‚   }
  896 â”‚ }
  897 â”‚ 
  898 â”‚ // FunÃ§Ã£o para calcular o preÃ§o total de uma estadia
  899 â”‚ export const calculateStayPrice = async (
  900 â”‚   roomId: string, 
  901 â”‚   checkIn: Date, 
  902 â”‚   checkOut: Date
  903 â”‚ ): Promise<{
  904 â”‚   totalPrice: number;
  905 â”‚   nightlyPrices: { date: string; price: number }[];
  906 â”‚   serviceFee: number;
  907 â”‚   totalWithFee: number;
  908 â”‚ }> => {
  909 â”‚   try {
  910 â”‚     console.log(`ğŸ” Iniciando cÃ¡lculo de preÃ§o para estadia: ${checkIn.toISOString().split('T')[0]} atÃ© ${checkOut.toISOString().split('T')[0]}`);
  911 â”‚     
  912 â”‚     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  913 â”‚     
  914 â”‚     if (!roomDoc.exists()) {
  915 â”‚       throw new Error("Quarto nÃ£o encontrado");
  916 â”‚     }
  917 â”‚     
  918 â”‚     const roomData = roomDoc.data() as Room;
  919 â”‚     console.log(`ğŸ“ Dados do quarto ${roomId}:`, {
  920 â”‚       nome: roomData.name,
  921 â”‚       precoBase: roomData.price,
  922 â”‚       taxaServico: roomData.serviceFeePct || 0,
  923 â”‚       temPrecosSazonais: !!roomData.seasonalPrices?.length
  924 â”‚     });
  925 â”‚     
  926 â”‚     const nightlyPrices: { date: string; price: number }[] = [];
  927 â”‚     let totalPrice = 0;
  928 â”‚     
  929 â”‚     // Calcular o nÃºmero de noites - corrigido para usar o mÃ©todo correto de cÃ¡lculo
  930 â”‚     // O nÃºmero de noites Ã© a diferenÃ§a em dias (estadia = checkout - checkin)
  931 â”‚     const noites = differenceInDays(checkOut, checkIn);
  932 â”‚     console.log(`ğŸ—“ï¸ NÃºmero de noites calculado: ${noites}`);
  933 â”‚     
  934 â”‚     if (noites <= 0) {
  935 â”‚       console.error(`âš ï¸ Erro: nÃºmero de noites invÃ¡lido (${noites})`);
  936 â”‚       throw new Error("Data de check-out deve ser posterior Ã  data de check-in");
  937 â”‚     }
  938 â”‚     
  939 â”‚     // Para cada noite, verificar o preÃ§o aplicÃ¡vel (preÃ§o base ou sazonal)
  940 â”‚     // ComeÃ§amos exatamente do dia de check-in
  941 â”‚     const currentDate = new Date(checkIn);
  942 â”‚     currentDate.setHours(0, 0, 0, 0); // Normalizar para meia-noite
  943 â”‚     
  944 â”‚     // Processamos cada dia de estadia (noite)
  945 â”‚     console.log(`ğŸ“Š Calculando preÃ§os por noite:`);
  946 â”‚     for (let i = 0; i < noites; i++) {
  947 â”‚       // Obtemos o preÃ§o para esta data
  948 â”‚       const dateCopy = new Date(currentDate);
  949 â”‚       const priceForDate = await getRoomPriceForDate(roomId, dateCopy);
  950 â”‚       const dateString = dateCopy.toISOString().split('T')[0]; // YYYY-MM-DD
  951 â”‚       
  952 â”‚       console.log(`   - ${dateString}: â‚¬${priceForDate}`);
  953 â”‚       
  954 â”‚       nightlyPrices.push({
  955 â”‚         date: dateString,
  956 â”‚         price: priceForDate
  957 â”‚       });
  958 â”‚       
  959 â”‚       totalPrice += priceForDate;
  960 â”‚       
  961 â”‚       // AvanÃ§amos para o prÃ³ximo dia
  962 â”‚       currentDate.setDate(currentDate.getDate() + 1);
  963 â”‚     }
  964 â”‚     
  965 â”‚     // VerificaÃ§Ã£o de seguranÃ§a para o cÃ¡lculo do totalPrice
  966 â”‚     const manualTotal = nightlyPrices.reduce((sum, night) => sum + night.price, 0);
  967 â”‚     if (Math.abs(totalPrice - manualTotal) > 1) {
  968 â”‚       console.error(`âš ï¸ DiscrepÃ¢ncia detectada no cÃ¡lculo do preÃ§o total!`);
  969 â”‚       console.error(`   - Total calculado iterativamente: â‚¬${totalPrice}`);
  970 â”‚       console.error(`   - Total calculado via reduce: â‚¬${manualTotal}`);
  971 â”‚       console.error(`   - Usando o valor recalculado para seguranÃ§a!`);
  972 â”‚       totalPrice = manualTotal;
  973 â”‚     }
  974 â”‚     
  975 â”‚     // Calcular taxa de serviÃ§o
  976 â”‚     const serviceFee = (totalPrice * (roomData.serviceFeePct || 0)) / 100;
  977 â”‚     const totalWithFee = totalPrice + serviceFee;
  978 â”‚     
  979 â”‚     console.log(`ğŸ’° Resumo do cÃ¡lculo:`);
  980 â”‚     console.log(`   - Total das diÃ¡rias: â‚¬${totalPrice}`);
  981 â”‚     console.log(`   - Taxa de serviÃ§o (${roomData.serviceFeePct || 0}%): â‚¬${serviceFee}`);
  982 â”‚     console.log(`   - Total com taxas: â‚¬${totalWithFee}`);
  983 â”‚     
  984 â”‚     return {
  985 â”‚       totalPrice,
  986 â”‚       nightlyPrices,
  987 â”‚       serviceFee,
  988 â”‚       totalWithFee
  989 â”‚     };
  990 â”‚   } catch (error) {
  991 â”‚     console.error("âŒ Erro ao calcular preÃ§o da estadia:", error);
  992 â”‚     throw error;
  993 â”‚   }
  994 â”‚ } 
  995 â”‚ import { 
  996 â”‚   collection, 
  997 â”‚   getDocs, 
  998 â”‚   getDoc, 
  999 â”‚   doc, 
 1000 â”‚   setDoc, 
 1001 â”‚   addDoc, 
      Â·   â”€â”€â”€â”¬â”€â”€
      Â·      â•°â”€â”€ `addDoc` redefined here
 1002 â”‚   updateDoc, 
 1003 â”‚   deleteDoc,
 1004 â”‚   query,
      â•°â”€â”€â”€â”€

  Ã— the name `updateDoc` is defined multiple times
      â•­â”€[/home/runner/workspace/lib/firebase/firestore.ts:5:1]
    5 â”‚   addDoc,
    6 â”‚   getDoc,
    7 â”‚   getDocs,
    8 â”‚   updateDoc,
      Â·   â”€â”€â”€â”€â”¬â”€â”€â”€â”€
      Â·       â•°â”€â”€ previous definition of `updateDoc` here
    9 â”‚   deleteDoc,
   10 â”‚   query,
   11 â”‚   where,
   12 â”‚   orderBy,
   13 â”‚   limit,
   14 â”‚   DocumentData,
   15 â”‚   QueryConstraint,
   16 â”‚   Timestamp,
   17 â”‚   serverTimestamp
   18 â”‚ } from 'firebase/firestore'
   19 â”‚ import { db } from './config'
   20 â”‚ import { Room, SeasonalPrice } from '@/lib/types'
   21 â”‚ import { differenceInDays } from 'date-fns'
   22 â”‚ 
   23 â”‚ // Tipos de dados
   24 â”‚ export interface Booking {
   25 â”‚   id?: string
   26 â”‚   userId?: string
   27 â”‚   guestName: string
   28 â”‚   guestEmail: string
   29 â”‚   guestPhone: string
   30 â”‚   roomId: string
   31 â”‚   roomName: string
   32 â”‚   checkIn: Timestamp
   33 â”‚   checkOut: Timestamp
   34 â”‚   adults: number
   35 â”‚   children: number
   36 â”‚   totalPrice: number
   37 â”‚   status: 'pending' | 'confirmed' | 'cancelled' | 'completed'
   38 â”‚   paymentStatus: 'pending' | 'paid' | 'refunded'
   39 â”‚   specialRequests?: string
   40 â”‚   createdAt?: Timestamp
   41 â”‚   updatedAt?: Timestamp
   42 â”‚ }
   43 â”‚ 
   44 â”‚ export interface Contact {
   45 â”‚   id?: string
   46 â”‚   name: string
   47 â”‚   email: string
   48 â”‚   phone?: string
   49 â”‚   subject: string
   50 â”‚   message: string
   51 â”‚   status: 'new' | 'read' | 'replied'
   52 â”‚   createdAt: Timestamp
   53 â”‚   updatedAt?: Timestamp
   54 â”‚   repliedAt?: Timestamp
   55 â”‚   replyContent?: string
   56 â”‚   reservationDetails?: {
   57 â”‚     checkIn?: Timestamp
   58 â”‚     checkOut?: Timestamp
   59 â”‚     roomId?: string
   60 â”‚     roomName?: string
   61 â”‚     totalGuests?: number
   62 â”‚     totalPrice?: number
   63 â”‚   }
   64 â”‚ }
   65 â”‚ 
   66 â”‚ // FunÃ§Ãµes genÃ©ricas para CRUD
   67 â”‚ export const createDocument = async <T extends DocumentData>(
   68 â”‚   collectionName: string,
   69 â”‚   data: T
   70 â”‚ ): Promise<string> => {
   71 â”‚   const docRef = await addDoc(collection(db, collectionName), {
   72 â”‚     ...data,
   73 â”‚     createdAt: serverTimestamp(),
   74 â”‚     updatedAt: serverTimestamp()
   75 â”‚   })
   76 â”‚   return docRef.id
   77 â”‚ }
   78 â”‚ 
   79 â”‚ export const createDocumentWithId = async <T extends DocumentData>(
   80 â”‚   collectionName: string,
   81 â”‚   id: string,
   82 â”‚   data: T
   83 â”‚ ): Promise<void> => {
   84 â”‚   await setDoc(doc(db, collectionName, id), {
   85 â”‚     ...data,
   86 â”‚     createdAt: serverTimestamp(),
   87 â”‚     updatedAt: serverTimestamp()
   88 â”‚   })
   89 â”‚ }
   90 â”‚ 
   91 â”‚ export const getDocument = async <T>(
   92 â”‚   collectionName: string,
   93 â”‚   id: string
   94 â”‚ ): Promise<T | null> => {
   95 â”‚   const docRef = doc(db, collectionName, id)
   96 â”‚   const docSnap = await getDoc(docRef)
   97 â”‚   
   98 â”‚   if (docSnap.exists()) {
   99 â”‚     const data = docSnap.data();
  100 â”‚     console.log("Dados brutos recuperados do Firestore para quarto:", id, data);
  101 â”‚     
  102 â”‚     if (data?.serviceFeePct !== undefined) {
  103 â”‚       console.log("serviceFeePct antes da conversÃ£o:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
  104 â”‚       // Garantir que serviceFeePct seja um nÃºmero
  105 â”‚       data.serviceFeePct = Number(data.serviceFeePct);
  106 â”‚       console.log("serviceFeePct apÃ³s conversÃ£o:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
  107 â”‚     }
  108 â”‚     
  109 â”‚     return { id: docSnap.id, ...data } as T
  110 â”‚   } else {
  111 â”‚     return null
  112 â”‚   }
  113 â”‚ }
  114 â”‚ 
  115 â”‚ export const getDocuments = async <T>(
  116 â”‚   collectionName: string,
  117 â”‚   constraints: QueryConstraint[] = [],
  118 â”‚   forceRefresh = false
  119 â”‚ ): Promise<T[]> => {
  120 â”‚   try {
  121 â”‚     const collectionRef = collection(db, collectionName)
  122 â”‚     const q = query(collectionRef, ...constraints)
  123 â”‚     
  124 â”‚     // Se forceRefresh for verdadeiro, adicionar opÃ§Ãµes que forÃ§am uma nova consulta ao Firestore
  125 â”‚     const querySnapshot = await getDocs(q)
  126 â”‚     
  127 â”‚     console.log(`Buscando documentos na coleÃ§Ã£o ${collectionName} - ForÃ§a atualizaÃ§Ã£o: ${forceRefresh}`);
  128 â”‚     
  129 â”‚     return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }) as T)
  130 â”‚   } catch (error) {
  131 â”‚     console.error(`Erro ao buscar documentos da coleÃ§Ã£o ${collectionName}:`, error);
  132 â”‚     return [];
  133 â”‚   }
  134 â”‚ }
  135 â”‚ 
  136 â”‚ export const updateDocument = async <T extends DocumentData>(
  137 â”‚   collectionName: string,
  138 â”‚   id: string,
  139 â”‚   data: Partial<T>
  140 â”‚ ): Promise<void> => {
  141 â”‚   const docRef = doc(db, collectionName, id)
  142 â”‚   await updateDoc(docRef, {
  143 â”‚     ...data,
  144 â”‚     updatedAt: serverTimestamp()
  145 â”‚   })
  146 â”‚ }
  147 â”‚ 
  148 â”‚ export const deleteDocument = async (
  149 â”‚   collectionName: string,
  150 â”‚   id: string
  151 â”‚ ): Promise<boolean> => {
  152 â”‚   const docRef = doc(db, collectionName, id)
  153 â”‚   await deleteDoc(docRef)
  154 â”‚   return true
  155 â”‚ }
  156 â”‚ 
  157 â”‚ // FunÃ§Ãµes para gerenciar quartos
  158 â”‚ export const getRooms = async (forceRefresh = false): Promise<Room[]> => {
  159 â”‚   try {
  160 â”‚     const constraints: QueryConstraint[] = []
  161 â”‚     
  162 â”‚     constraints.push(orderBy('name', 'asc'))
  163 â”‚     
  164 â”‚     const rooms = await getDocuments<Room>('rooms', constraints, forceRefresh)
  165 â”‚     
  166 â”‚     // Garantir que todos os campos necessÃ¡rios estejam presentes
  167 â”‚     return rooms.map(room => {
  168 â”‚       console.log(`Firebase - Quarto ${room.id} dados brutos:`, room);
  169 â”‚       
  170 â”‚       // Garantir que serviceFeePct seja um nÃºmero
  171 â”‚       const serviceFeePct = room.serviceFeePct !== undefined 
  172 â”‚         ? Number(room.serviceFeePct) 
  173 â”‚         : 10;
  174 â”‚         
  175 â”‚       console.log(`Firebase - Quarto ${room.id} serviceFeePct:`, {
  176 â”‚         original: room.serviceFeePct,
  177 â”‚         tipo: typeof room.serviceFeePct,
  178 â”‚         convertido: serviceFeePct
  179 â”‚       });
  180 â”‚       
  181 â”‚       return {
  182 â”‚         id: room.id,
  183 â”‚         name: room.name || '',
  184 â”‚         type: room.type || 'standard',
  185 â”‚         description: room.description || '',
  186 â”‚         price: room.price || 0,
  187 â”‚         capacity: room.capacity || 2,
  188 â”‚         size: room.size || 0,
  189 â”‚         available: room.available !== undefined ? room.available : true,
  190 â”‚         serviceFeePct: serviceFeePct,
  191 â”‚         images: room.images || [],
  192 â”‚         amenities: room.amenities || [],
  193 â”‚         additionalServices: room.additionalServices || [],
  194 â”‚         highlights: room.highlights || [],
  195 â”‚         createdAt: room.createdAt,
  196 â”‚         updatedAt: room.updatedAt
  197 â”‚       };
  198 â”‚     });
  199 â”‚   } catch (error) {
  200 â”‚     console.error('Erro ao buscar quartos:', error)
  201 â”‚     return []
  202 â”‚   }
  203 â”‚ }
  204 â”‚ 
  205 â”‚ export const getAvailableRooms = async (
  206 â”‚   checkIn: Date,
  207 â”‚   checkOut: Date
  208 â”‚ ): Promise<Room[]> => {
  209 â”‚   try {
  210 â”‚     // Buscar todos os quartos que estÃ£o marcados como disponÃ­veis em geral
  211 â”‚     const constraints: QueryConstraint[] = [
  212 â”‚       where('available', '==', true)
  213 â”‚     ]
  214 â”‚     
  215 â”‚     const rooms = await getDocuments<Room>('rooms', constraints);
  216 â”‚     
  217 â”‚     // Filtrar os quartos que estÃ£o disponÃ­veis nas datas especÃ­ficas
  218 â”‚     return filterAvailableRoomsByDate(rooms, checkIn, checkOut);
  219 â”‚   } catch (error) {
  220 â”‚     console.error('Erro ao buscar quartos disponÃ­veis:', error)
  221 â”‚     return []
  222 â”‚   }
  223 â”‚ }
  224 â”‚ 
  225 â”‚ // FunÃ§Ã£o auxiliar para verificar disponibilidade entre datas
  226 â”‚ export const filterAvailableRoomsByDate = (
  227 â”‚   rooms: Room[],
  228 â”‚   checkIn: Date,
  229 â”‚   checkOut: Date
  230 â”‚ ): Room[] => {
  231 â”‚   // Converter checkIn e checkOut para ISO strings
  232 â”‚   const dateStrings = getDatesInRange(checkIn, checkOut);
  233 â”‚   
  234 â”‚   return rooms.filter(room => {
  235 â”‚     // Se nÃ£o tiver controle de disponibilidade especÃ­fico, considera disponÃ­vel
  236 â”‚     if (!room.availabilityDates) return true;
  237 â”‚     
  238 â”‚     // Verificar se alguma data no intervalo estÃ¡ indisponÃ­vel
  239 â”‚     return !dateStrings.some(dateStr => 
  240 â”‚       room.availabilityDates?.[dateStr] === false
  241 â”‚     );
  242 â”‚   });
  243 â”‚ };
  244 â”‚ 
  245 â”‚ // FunÃ§Ã£o para obter disponibilidade de um quarto especÃ­fico
  246 â”‚ export const getRoomAvailability = async (
  247 â”‚   roomId: string, 
  248 â”‚   startDate: Date, 
  249 â”‚   endDate: Date
  250 â”‚ ): Promise<{[date: string]: boolean}> => {
  251 â”‚   try {
  252 â”‚     const room = await getRoomById(roomId);
  253 â”‚     if (!room) throw new Error(`Quarto com ID ${roomId} nÃ£o encontrado`);
  254 â”‚     
  255 â”‚     // Gerar datas no intervalo
  256 â”‚     const dateStrings = getDatesInRange(startDate, endDate);
  257 â”‚     
  258 â”‚     // Se nÃ£o tiver configuraÃ§Ã£o de disponibilidade especÃ­fica, assume tudo disponÃ­vel
  259 â”‚     if (!room.availabilityDates) {
  260 â”‚       return dateStrings.reduce((acc, date) => {
  261 â”‚         acc[date] = true;
  262 â”‚         return acc;
  263 â”‚       }, {} as {[date: string]: boolean});
  264 â”‚     }
  265 â”‚     
  266 â”‚     // Preencher com os dados de disponibilidade existentes
  267 â”‚     return dateStrings.reduce((acc, date) => {
  268 â”‚       acc[date] = room.availabilityDates?.[date] !== false; // disponÃ­vel por padrÃ£o se nÃ£o estiver explicitamente indisponÃ­vel
  269 â”‚       return acc;
  270 â”‚     }, {} as {[date: string]: boolean});
  271 â”‚   } catch (error) {
  272 â”‚     console.error(`Erro ao verificar disponibilidade do quarto ${roomId}:`, error);
  273 â”‚     throw error;
  274 â”‚   }
  275 â”‚ };
  276 â”‚ 
  277 â”‚ // FunÃ§Ã£o para atualizar disponibilidade de um quarto
  278 â”‚ export const updateRoomAvailability = async (
  279 â”‚   roomId: string,
  280 â”‚   availabilityDates: {[date: string]: boolean}
  281 â”‚ ): Promise<boolean> => {
  282 â”‚   try {
  283 â”‚     await updateDocument('rooms', roomId, {
  284 â”‚       availabilityDates,
  285 â”‚       updatedAt: serverTimestamp()
  286 â”‚     });
  287 â”‚     return true;
  288 â”‚   } catch (error) {
  289 â”‚     console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  290 â”‚     return false;
  291 â”‚   }
  292 â”‚ };
  293 â”‚ 
  294 â”‚ // FunÃ§Ã£o auxiliar para gerar array de strings de data entre um intervalo
  295 â”‚ export const getDatesInRange = (startDate: Date, endDate: Date): string[] => {
  296 â”‚   const dates: string[] = [];
  297 â”‚   const currentDate = new Date(startDate);
  298 â”‚   
  299 â”‚   // Normalizar para meia-noite no fuso horÃ¡rio local
  300 â”‚   currentDate.setHours(0, 0, 0, 0);
  301 â”‚   const endDateNormalized = new Date(endDate);
  302 â”‚   endDateNormalized.setHours(0, 0, 0, 0);
  303 â”‚   
  304 â”‚   // Adicionar cada data no intervalo EXCETO o dia de checkout
  305 â”‚   // Usando < em vez de <= para nÃ£o incluir o dia de checkout
  306 â”‚   while (currentDate < endDateNormalized) {
  307 â”‚     dates.push(currentDate.toISOString().split('T')[0]); // Formato YYYY-MM-DD
  308 â”‚     currentDate.setDate(currentDate.getDate() + 1);
  309 â”‚   }
  310 â”‚   
  311 â”‚   return dates;
  312 â”‚ };
  313 â”‚ 
  314 â”‚ export const getRoomById = async (id: string): Promise<Room | null> => {
  315 â”‚   try {
  316 â”‚     const room = await getDocument<Room>('rooms', id);
  317 â”‚     
  318 â”‚     if (!room) return null;
  319 â”‚     
  320 â”‚     console.log(`Firebase - getRoomById ${id} dados brutos:`, room);
  321 â”‚     
  322 â”‚     // Log especÃ­fico para serviceFeePct
  323 â”‚     console.log(`serviceFeePct no Firestore:`, room.serviceFeePct);
  324 â”‚     
  325 â”‚     // Garantir que todos os campos necessÃ¡rios estejam presentes
  326 â”‚     return {
  327 â”‚       ...room,
  328 â”‚       name: room.name || '',
  329 â”‚       type: room.type || 'standard',
  330 â”‚       description: room.description || '',
  331 â”‚       price: room.price || 0,
  332 â”‚       capacity: room.capacity || 2,
  333 â”‚       size: room.size || 0,
  334 â”‚       available: room.available !== undefined ? room.available : true,
  335 â”‚       serviceFeePct: room.serviceFeePct !== undefined ? room.serviceFeePct : 10,
  336 â”‚       images: room.images || [],
  337 â”‚       amenities: room.amenities || [],
  338 â”‚       additionalServices: room.additionalServices || [],
  339 â”‚       highlights: room.highlights || []
  340 â”‚     };
  341 â”‚   } catch (error) {
  342 â”‚     console.error(`Erro ao buscar quarto com ID ${id}:`, error);
  343 â”‚     return null;
  344 â”‚   }
  345 â”‚ }
  346 â”‚ 
  347 â”‚ export const createRoom = async (roomData: Omit<Room, 'id' | 'createdAt' | 'updatedAt'>): Promise<Room> => {
  348 â”‚   try {
  349 â”‚     console.log("createRoom - Dados recebidos:", roomData);
  350 â”‚     
  351 â”‚     const roomWithTimestamps = {
  352 â”‚       ...roomData,
  353 â”‚       available: roomData.available !== undefined ? roomData.available : true,
  354 â”‚       featured: roomData.featured || false,
  355 â”‚       amenities: roomData.amenities || [],
  356 â”‚       additionalServices: roomData.additionalServices || [],
  357 â”‚       highlights: roomData.highlights || [],
  358 â”‚       createdAt: serverTimestamp(),
  359 â”‚       updatedAt: serverTimestamp()
  360 â”‚     }
  361 â”‚     
  362 â”‚     console.log("createRoom - Dados a serem salvos:", roomWithTimestamps);
  363 â”‚     
  364 â”‚     const id = await createDocument('rooms', roomWithTimestamps)
  365 â”‚     
  366 â”‚     return {
  367 â”‚       id,
  368 â”‚       ...roomData,
  369 â”‚       amenities: roomData.amenities || [],
  370 â”‚       additionalServices: roomData.additionalServices || [],
  371 â”‚       highlights: roomData.highlights || [],
  372 â”‚       createdAt: Timestamp.now(),
  373 â”‚       updatedAt: Timestamp.now()
  374 â”‚     }
  375 â”‚   } catch (error) {
  376 â”‚     console.error('Erro ao criar quarto:', error)
  377 â”‚     throw error
  378 â”‚   }
  379 â”‚ }
  380 â”‚ 
  381 â”‚ export const updateRoom = async (id: string, roomData: Partial<Omit<Room, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Room> => {
  382 â”‚   try {
  383 â”‚     console.log(`updateRoom - ID: ${id}, Dados recebidos:`, roomData);
  384 â”‚     
  385 â”‚     // Garantir que estamos lidando explicitamente com o serviceFeePct se ele for 0
  386 â”‚     if (roomData.serviceFeePct === 0) {
  387 â”‚       console.log("updateRoom - Detectado serviceFeePct com valor 0, salvando explicitamente.", roomData.serviceFeePct);
  388 â”‚     }
  389 â”‚     
  390 â”‚     // Adicionar timestamp de atualizaÃ§Ã£o
  391 â”‚     const roomWithTimestamp = {
  392 â”‚       ...roomData,
  393 â”‚       amenities: roomData.amenities || [],
  394 â”‚       additionalServices: roomData.additionalServices || [],
  395 â”‚       highlights: roomData.highlights || [],
  396 â”‚       updatedAt: serverTimestamp()
  397 â”‚     }
  398 â”‚     
  399 â”‚     console.log(`updateRoom - Dados a serem salvos:`, roomWithTimestamp);
  400 â”‚     
  401 â”‚     await updateDocument('rooms', id, roomWithTimestamp)
  402 â”‚     
  403 â”‚     const updatedRoom = await getRoomById(id)
  404 â”‚     if (!updatedRoom) {
  405 â”‚       throw new Error(`Quarto com ID ${id} nÃ£o encontrado apÃ³s atualizaÃ§Ã£o`)
  406 â”‚     }
  407 â”‚     
  408 â”‚     return updatedRoom
  409 â”‚   } catch (error) {
  410 â”‚     console.error('Erro ao atualizar quarto:', error)
  411 â”‚     throw error
  412 â”‚   }
  413 â”‚ }
  414 â”‚ 
  415 â”‚ export const deleteRoom = async (id: string): Promise<boolean> => {
  416 â”‚   return await deleteDocument('rooms', id)
  417 â”‚ }
  418 â”‚ 
  419 â”‚ // FunÃ§Ãµes especÃ­ficas para reservas
  420 â”‚ export const createBooking = async (bookingData: any) => {
  421 â”‚   try {
  422 â”‚     const bookingsCollection = collection(db, 'bookings');
  423 â”‚     const docRef = await addDoc(bookingsCollection, bookingData);
  424 â”‚     
  425 â”‚     // CORREÃ‡ÃƒO: NÃ£o bloquear a data no momento da criaÃ§Ã£o da reserva
  426 â”‚     // O bloqueio serÃ¡ feito apenas quando o pagamento for confirmado
  427 â”‚     // atravÃ©s da funÃ§Ã£o updateBookingStatus
  428 â”‚     
  429 â”‚     return docRef;
  430 â”‚   } catch (error) {
  431 â”‚     console.error('Erro ao criar reserva:', error);
  432 â”‚     throw error;
  433 â”‚   }
  434 â”‚ };
  435 â”‚ 
  436 â”‚ // Nova funÃ§Ã£o para atualizar status da reserva e bloquear as datas da estadia
  437 â”‚ export const updateBookingStatus = async (
  438 â”‚   bookingId: string, 
  439 â”‚   newStatus: 'pending' | 'confirmed' | 'cancelled' | 'completed',
  440 â”‚   newPaymentStatus: 'pending' | 'paid' | 'refunded'
  441 â”‚ ): Promise<boolean> => {
  442 â”‚   try {
  443 â”‚     // ReferÃªncia ao documento da reserva
  444 â”‚     const bookingRef = doc(db, 'bookings', bookingId);
  445 â”‚     const bookingSnap = await getDoc(bookingRef);
  446 â”‚     
  447 â”‚     if (!bookingSnap.exists()) {
  448 â”‚       console.error(`Booking ${bookingId} nÃ£o existe ao atualizar status`);
  449 â”‚       return false;
  450 â”‚     }
  451 â”‚     
  452 â”‚     const bookingData = bookingSnap.data();
  453 â”‚     
  454 â”‚     // Atualizar o status da reserva
  455 â”‚     await updateDoc(bookingRef, {
  456 â”‚       status: newStatus,
  457 â”‚       paymentStatus: newPaymentStatus,
  458 â”‚       updatedAt: serverTimestamp(),
  459 â”‚       ...(newStatus === 'confirmed' && { confirmedAt: serverTimestamp() })
  460 â”‚     });
  461 â”‚     
  462 â”‚     // Se a reserva estÃ¡ sendo confirmada, precisamos bloquear as datas
  463 â”‚     if (newStatus === 'confirmed') {
  464 â”‚       console.log(`Atualizando disponibilidade para reserva confirmada: ${bookingId}`);
  465 â”‚       
  466 â”‚       // Recuperar datas de check-in e check-out
  467 â”‚       const checkIn = bookingData.checkIn.toDate();
  468 â”‚       const checkOut = bookingData.checkOut.toDate();
  469 â”‚       const roomId = bookingData.roomId;
  470 â”‚       
  471 â”‚       // Obter todas as datas entre check-in e check-out
  472 â”‚       const dates: Date[] = [];
  473 â”‚       const currentDate = new Date(checkIn);
  474 â”‚       
  475 â”‚       while (currentDate < checkOut) {
  476 â”‚         dates.push(new Date(currentDate));
  477 â”‚         currentDate.setDate(currentDate.getDate() + 1);
  478 â”‚       }
  479 â”‚       
  480 â”‚       console.log(`Bloqueando ${dates.length} dias para quarto ${roomId}`);
  481 â”‚       
  482 â”‚       // Atualizar disponibilidade para cada data
  483 â”‚       const availabilityUpdates: {[date: string]: boolean} = {};
  484 â”‚       
  485 â”‚       dates.forEach(date => {
  486 â”‚         const dateString = date.toISOString().split('T')[0]; // formato YYYY-MM-DD
  487 â”‚         availabilityUpdates[dateString] = false; // false significa indisponÃ­vel
  488 â”‚       });
  489 â”‚       
  490 â”‚       // Atualizar disponibilidade do quarto
  491 â”‚       if (Object.keys(availabilityUpdates).length > 0) {
  492 â”‚         try {
  493 â”‚           // Obter o documento do quarto
  494 â”‚           const roomRef = doc(db, 'rooms', roomId);
  495 â”‚           const roomSnap = await getDoc(roomRef);
  496 â”‚           
  497 â”‚           if (roomSnap.exists()) {
  498 â”‚             const roomData = roomSnap.data();
  499 â”‚             const currentAvailability = roomData.availabilityDates || {};
  500 â”‚             
  501 â”‚             // Mesclar a disponibilidade atual com as novas atualizaÃ§Ãµes
  502 â”‚             const updatedAvailability = {
  503 â”‚               ...currentAvailability,
  504 â”‚               ...availabilityUpdates
  505 â”‚             };
  506 â”‚             
  507 â”‚             // Atualizar o documento do quarto
  508 â”‚             await updateDoc(roomRef, {
  509 â”‚               availabilityDates: updatedAvailability,
  510 â”‚               updatedAt: serverTimestamp()
  511 â”‚             });
  512 â”‚             
  513 â”‚             console.log(`Disponibilidade atualizada com sucesso para quarto ${roomId}`);
  514 â”‚             
  515 â”‚             // Criar log da reserva
  516 â”‚             await addDoc(collection(db, 'bookingLogs'), {
  517 â”‚               bookingId,
  518 â”‚               roomId,
  519 â”‚               action: 'status_updated',
  520 â”‚               previousStatus: bookingData.status,
  521 â”‚               newStatus,
  522 â”‚               previousPaymentStatus: bookingData.paymentStatus,
  523 â”‚               newPaymentStatus,
  524 â”‚               datesBlocked: Object.keys(availabilityUpdates),
  525 â”‚               timestamp: serverTimestamp(),
  526 â”‚               userId: bookingData.userId || 'system'
  527 â”‚             });
  528 â”‚           } else {
  529 â”‚             console.error(`Quarto ${roomId} nÃ£o encontrado ao atualizar disponibilidade`);
  530 â”‚           }
  531 â”‚         } catch (error) {
  532 â”‚           console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  533 â”‚         }
  534 â”‚       }
  535 â”‚     }
  536 â”‚     
  537 â”‚     return true;
  538 â”‚   } catch (error) {
  539 â”‚     console.error(`Erro ao atualizar status da reserva ${bookingId}:`, error);
  540 â”‚     return false;
  541 â”‚   }
  542 â”‚ }
  543 â”‚ 
  544 â”‚ export const getUserBookings = async (userId: string): Promise<Booking[]> => {
  545 â”‚   return getDocuments<Booking>('bookings', [
  546 â”‚     where('userId', '==', userId),
  547 â”‚     orderBy('createdAt', 'desc')
  548 â”‚   ])
  549 â”‚ }
  550 â”‚ 
  551 â”‚ export const getRecentBookings = async (count = 5): Promise<Booking[]> => {
  552 â”‚   return getDocuments<Booking>('bookings', [
  553 â”‚     orderBy('createdAt', 'desc'),
  554 â”‚     limit(count)
  555 â”‚   ])
  556 â”‚ }
  557 â”‚ 
  558 â”‚ export const getRoomBookings = async (roomId: string): Promise<Booking[]> => {
  559 â”‚   try {
  560 â”‚     const constraints: QueryConstraint[] = [
  561 â”‚       where('roomId', '==', roomId),
  562 â”‚       orderBy('checkIn', 'asc')
  563 â”‚     ];
  564 â”‚     
  565 â”‚     return await getDocuments<Booking>('bookings', constraints);
  566 â”‚   } catch (error) {
  567 â”‚     console.error(`Erro ao buscar reservas do quarto ${roomId}:`, error);
  568 â”‚     return [];
  569 â”‚   }
  570 â”‚ };
  571 â”‚ 
  572 â”‚ // FunÃ§Ãµes especÃ­ficas para contatos
  573 â”‚ export const createContactMessage = async (contactData: Contact) => {
  574 â”‚   try {
  575 â”‚     const contactsCollection = collection(db, 'contacts')
  576 â”‚     
  577 â”‚     // Garantir que o status seja 'new' para novos contatos
  578 â”‚     const contactWithDefaults = {
  579 â”‚       ...contactData,
  580 â”‚       status: contactData.status || 'new',
  581 â”‚       createdAt: contactData.createdAt || Timestamp.now()
  582 â”‚     }
  583 â”‚     
  584 â”‚     // Se tiver detalhes de reserva, adicionar metadados
  585 â”‚     if (contactWithDefaults.reservationDetails) {
  586 â”‚       // Ajustar subject para indicar que Ã© relacionado a reserva
  587 â”‚       if (!contactWithDefaults.subject.includes('Reserva')) {
  588 â”‚         contactWithDefaults.subject = `Reserva: ${contactWithDefaults.subject}`;
  589 â”‚       }
  590 â”‚     }
  591 â”‚     
  592 â”‚     const docRef = await addDoc(contactsCollection, contactWithDefaults)
  593 â”‚     return docRef
  594 â”‚   } catch (error) {
  595 â”‚     console.error('Erro ao criar mensagem de contato:', error)
  596 â”‚     throw error
  597 â”‚   }
  598 â”‚ }
  599 â”‚ 
  600 â”‚ export const getNewContactMessages = async (): Promise<Contact[]> => {
  601 â”‚   return getDocuments<Contact>('contacts', [
  602 â”‚     where('status', '==', 'new'),
  603 â”‚     orderBy('createdAt', 'desc')
  604 â”‚   ])
  605 â”‚ }
  606 â”‚ 
  607 â”‚ // FunÃ§Ãµes para Dashboard com dados reais
  608 â”‚ 
  609 â”‚ export const getDashboardStats = async () => {
  610 â”‚   try {
  611 â”‚     const [totalBookings, totalRevenue, occupancyRate, bookingsByPlatform] = await Promise.all([
  612 â”‚       getTotalBookings(),
  613 â”‚       getMonthlyRevenue(),
  614 â”‚       getOccupancyRate(),
  615 â”‚       getBookingsByPlatform()
  616 â”‚     ]);
  617 â”‚ 
  618 â”‚     return {
  619 â”‚       totalBookings,
  620 â”‚       totalRevenue,
  621 â”‚       occupancyRate,
  622 â”‚       bookingsByPlatform
  623 â”‚     };
  624 â”‚   } catch (error) {
  625 â”‚     console.error('Erro ao obter estatÃ­sticas do dashboard:', error);
  626 â”‚     throw error;
  627 â”‚   }
  628 â”‚ };
  629 â”‚ 
  630 â”‚ // Obter total de reservas
  631 â”‚ export const getTotalBookings = async () => {
  632 â”‚   try {
  633 â”‚     // Obter todas as reservas
  634 â”‚     const bookings = await getDocuments<Booking>('bookings');
  635 â”‚     
  636 â”‚     // Contar reservas por status
  637 â”‚     const confirmed = bookings.filter(b => b.status === 'confirmed').length;
  638 â”‚     const pending = bookings.filter(b => b.status === 'pending').length;
  639 â”‚     const cancelled = bookings.filter(b => b.status === 'cancelled').length;
  640 â”‚     const completed = bookings.filter(b => b.status === 'completed').length;
  641 â”‚     
  642 â”‚     // Calcular crescimento em relaÃ§Ã£o ao mÃªs anterior (simulado por enquanto)
  643 â”‚     // Em uma implementaÃ§Ã£o real, vocÃª compararia com dados do mÃªs anterior
  644 â”‚     const growth = ((confirmed + completed) / (bookings.length || 1) * 100) - 50;
  645 â”‚     
  646 â”‚     return {
  647 â”‚       total: bookings.length,
  648 â”‚       confirmed,
  649 â”‚       pending,
  650 â”‚       cancelled,
  651 â”‚       completed,
  652 â”‚       growth: Math.round(growth) // Arredonda para nÃºmero inteiro
  653 â”‚     };
  654 â”‚   } catch (error) {
  655 â”‚     console.error('Erro ao obter total de reservas:', error);
  656 â”‚     return {
  657 â”‚       total: 0,
  658 â”‚       confirmed: 0,
  659 â”‚       pending: 0, 
  660 â”‚       cancelled: 0,
  661 â”‚       completed: 0,
  662 â”‚       growth: 0
  663 â”‚     };
  664 â”‚   }
  665 â”‚ };
  666 â”‚ 
  667 â”‚ // Obter receita mensal
  668 â”‚ export const getMonthlyRevenue = async () => {
  669 â”‚   try {
  670 â”‚     const bookings = await getDocuments<Booking>('bookings');
  671 â”‚     
  672 â”‚     // Filtrar reservas confirmadas e concluÃ­das
  673 â”‚     const validBookings = bookings.filter(b => 
  674 â”‚       b.status === 'confirmed' || b.status === 'completed'
  675 â”‚     );
  676 â”‚     
  677 â”‚     // Calcular receita total
  678 â”‚     const totalRevenue = validBookings.reduce((acc, booking) => acc + booking.totalPrice, 0);
  679 â”‚     
  680 â”‚     // Agrupar receita por mÃªs
  681 â”‚     const revenueByMonth = validBookings.reduce((acc, booking) => {
  682 â”‚       const date = booking.checkIn.toDate();
  683 â”‚       const month = date.getMonth(); // 0-11
  684 â”‚       const year = date.getFullYear();
  685 â”‚       const key = `${year}-${month}`;
  686 â”‚       
  687 â”‚       if (!acc[key]) {
  688 â”‚         acc[key] = 0;
  689 â”‚       }
  690 â”‚       acc[key] += booking.totalPrice;
  691 â”‚       return acc;
  692 â”‚     }, {} as Record<string, number>);
  693 â”‚     
  694 â”‚     // Converter para formato de array para grÃ¡fico
  695 â”‚     const monthNames = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
  696 â”‚     
  697 â”‚     const currentDate = new Date();
  698 â”‚     const currentMonth = currentDate.getMonth();
  699 â”‚     const currentYear = currentDate.getFullYear();
  700 â”‚     
  701 â”‚     const revenueData = [];
  702 â”‚     
  703 â”‚     // Gerar dados dos Ãºltimos 12 meses
  704 â”‚     for (let i = 0; i < 12; i++) {
  705 â”‚       const month = (currentMonth - i + 12) % 12;
  706 â”‚       const year = currentMonth - i < 0 ? currentYear - 1 : currentYear;
  707 â”‚       const key = `${year}-${month}`;
  708 â”‚       
  709 â”‚       revenueData.unshift({
  710 â”‚         month: monthNames[month],
  711 â”‚         value: revenueByMonth[key] || 0
  712 â”‚       });
  713 â”‚     }
  714 â”‚     
  715 â”‚     // Calcular crescimento em relaÃ§Ã£o ao mÃªs anterior
  716 â”‚     const lastMonthRevenue = revenueData[revenueData.length - 2]?.value || 0;
  717 â”‚     const currentMonthRevenue = revenueData[revenueData.length - 1]?.value || 0;
  718 â”‚     
  719 â”‚     const growth = lastMonthRevenue ? ((currentMonthRevenue - lastMonthRevenue) / lastMonthRevenue) * 100 : 0;
  720 â”‚     
  721 â”‚     return {
  722 â”‚       monthly: currentMonthRevenue,
  723 â”‚       total: totalRevenue,
  724 â”‚       growth: Math.round(growth),
  725 â”‚       revenueData
  726 â”‚     };
  727 â”‚   } catch (error) {
  728 â”‚     console.error('Erro ao obter receita mensal:', error);
  729 â”‚     return {
  730 â”‚       monthly: 0,
  731 â”‚       total: 0,
  732 â”‚       growth: 0,
  733 â”‚       revenueData: []
  734 â”‚     };
  735 â”‚   }
  736 â”‚ };
  737 â”‚ 
  738 â”‚ // Calcular taxa de ocupaÃ§Ã£o
  739 â”‚ export const getOccupancyRate = async () => {
  740 â”‚   try {
  741 â”‚     // Obter todos os quartos
  742 â”‚     const rooms = await getDocuments<Room>('rooms');
  743 â”‚     const totalRooms = rooms.length;
  744 â”‚     
  745 â”‚     if (totalRooms === 0) {
  746 â”‚       return { rate: 0, growth: 0 };
  747 â”‚     }
  748 â”‚     
  749 â”‚     // Obter todas as reservas
  750 â”‚     const bookings = await getDocuments<Booking>('bookings');
  751 â”‚     
  752 â”‚     // Filtrar reservas confirmadas e concluÃ­das para o mÃªs atual
  753 â”‚     const currentDate = new Date();
  754 â”‚     const currentMonth = currentDate.getMonth();
  755 â”‚     const currentYear = currentDate.getFullYear();
  756 â”‚     
  757 â”‚     const currentMonthBookings = bookings.filter(booking => {
  758 â”‚       const checkInDate = booking.checkIn.toDate();
  759 â”‚       return (
  760 â”‚         (booking.status === 'confirmed' || booking.status === 'completed') &&
  761 â”‚         checkInDate.getMonth() === currentMonth &&
  762 â”‚         checkInDate.getFullYear() === currentYear
  763 â”‚       );
  764 â”‚     });
  765 â”‚     
  766 â”‚     // Calcular dias ocupados por quarto
  767 â”‚     const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
  768 â”‚     const totalPossibleRoomDays = totalRooms * daysInMonth;
  769 â”‚     
  770 â”‚     // Contar dias ocupados (simplificado - em produÃ§Ã£o seria mais complexo)
  771 â”‚     let occupiedDays = 0;
  772 â”‚     
  773 â”‚     currentMonthBookings.forEach(booking => {
  774 â”‚       const checkIn = booking.checkIn.toDate();
  775 â”‚       const checkOut = booking.checkOut.toDate();
  776 â”‚       
  777 â”‚       // Ajustar datas para considerar apenas o mÃªs atual
  778 â”‚       const startDate = new Date(Math.max(
  779 â”‚         checkIn.getTime(),
  780 â”‚         new Date(currentYear, currentMonth, 1).getTime()
  781 â”‚       ));
  782 â”‚       const endDate = new Date(Math.min(
  783 â”‚         checkOut.getTime(),
  784 â”‚         new Date(currentYear, currentMonth + 1, 0).getTime()
  785 â”‚       ));
  786 â”‚       
  787 â”‚       // Calcular dias entre datas (incluindo check-in, excluindo check-out)
  788 â”‚       const days = Math.max(0, Math.floor((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)));
  789 â”‚       occupiedDays += days;
  790 â”‚     });
  791 â”‚     
  792 â”‚     const occupancyRate = (occupiedDays / totalPossibleRoomDays) * 100;
  793 â”‚     
  794 â”‚     // SimulaÃ§Ã£o de crescimento (em produÃ§Ã£o, compararia com mÃªs anterior)
  795 â”‚     const growth = occupancyRate > 50 ? 5 : -3;
  796 â”‚     
  797 â”‚     return {
  798 â”‚       rate: Math.round(occupancyRate),
  799 â”‚       growth: Math.round(growth)
  800 â”‚     };
  801 â”‚   } catch (error) {
  802 â”‚     console.error('Erro ao calcular taxa de ocupaÃ§Ã£o:', error);
  803 â”‚     return { rate: 0, growth: 0 };
  804 â”‚   }
  805 â”‚ };
  806 â”‚ 
  807 â”‚ // Obter reservas agrupadas por plataforma
  808 â”‚ export const getBookingsByPlatform = async () => {
  809 â”‚   try {
  810 â”‚     const bookings = await getDocuments<Booking>('bookings');
  811 â”‚     
  812 â”‚     // Categorizar reservas por origem
  813 â”‚     const platforms = [
  814 â”‚       { 
  815 â”‚         platform: "Booking.com", 
  816 â”‚         color: "#003580", 
  817 â”‚         icon: "Globe",
  818 â”‚         bookings: []
  819 â”‚       },
  820 â”‚       { 
  821 â”‚         platform: "Airbnb", 
  822 â”‚         color: "#FF5A5F", 
  823 â”‚         icon: "Heart",
  824 â”‚         bookings: []
  825 â”‚       },
  826 â”‚       { 
  827 â”‚         platform: "Direto", 
  828 â”‚         color: "#4CAF50", 
  829 â”‚         icon: "Home",
  830 â”‚         bookings: []
  831 â”‚       }
  832 â”‚     ];
  833 â”‚     
  834 â”‚     // Para fins de demonstraÃ§Ã£o, colocar todas as reservas como "Direto" por enquanto
  835 â”‚     // Em produÃ§Ã£o, usaria um campo "platformOrigin" ou similar na tabela de reservas
  836 â”‚     const platformIndex = 2; // Ãndice da plataforma "Direto"
  837 â”‚     
  838 â”‚     bookings.forEach(booking => {
  839 â”‚       // Transformar para o formato esperado pelo componente
  840 â”‚       const transformedBooking = {
  841 â”‚         id: booking.id || '',
  842 â”‚         guestName: booking.guestName,
  843 â”‚         roomName: booking.roomName,
  844 â”‚         checkIn: booking.checkIn.toDate().toLocaleDateString('pt-PT'),
  845 â”‚         checkOut: booking.checkOut.toDate().toLocaleDateString('pt-PT'),
  846 â”‚         status: booking.status,
  847 â”‚         value: new Intl.NumberFormat('pt-PT', {
  848 â”‚           style: 'currency',
  849 â”‚           currency: 'EUR'
  850 â”‚         }).format(booking.totalPrice)
  851 â”‚       };
  852 â”‚       
  853 â”‚       // Adicionar Ã  plataforma "Direto"
  854 â”‚       (platforms[platformIndex] as any).bookings.push(transformedBooking);
  855 â”‚     });
  856 â”‚     
  857 â”‚     return platforms;
  858 â”‚   } catch (error) {
  859 â”‚     console.error('Erro ao obter reservas por plataforma:', error);
  860 â”‚     return [];
  861 â”‚   }
  862 â”‚ };
  863 â”‚ 
  864 â”‚ // FunÃ§Ã£o para obter o preÃ§o de um quarto para uma data especÃ­fica
  865 â”‚ export const getRoomPriceForDate = async (roomId: string, date: Date): Promise<number> => {
  866 â”‚   try {
  867 â”‚     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  868 â”‚     
  869 â”‚     if (!roomDoc.exists()) {
  870 â”‚       throw new Error("Quarto nÃ£o encontrado");
  871 â”‚     }
  872 â”‚     
  873 â”‚     const roomData = roomDoc.data() as Room;
  874 â”‚     const basePrice = roomData.price;
  875 â”‚     
  876 â”‚     if (!roomData.seasonalPrices || roomData.seasonalPrices.length === 0) {
  877 â”‚       return basePrice;
  878 â”‚     }
  879 â”‚     
  880 â”‚     // Verificar se a data estÃ¡ dentro de algum perÃ­odo sazonal
  881 â”‚     for (const seasonalPrice of roomData.seasonalPrices) {
  882 â”‚       const startDate = new Date(seasonalPrice.startDate);
  883 â”‚       const endDate = new Date(seasonalPrice.endDate);
  884 â”‚       
  885 â”‚       if (date >= startDate && date <= endDate) {
  886 â”‚         return seasonalPrice.price;
  887 â”‚       }
  888 â”‚     }
  889 â”‚     
  890 â”‚     // Se nÃ£o cair em nenhum perÃ­odo sazonal, retorna o preÃ§o base
  891 â”‚     return basePrice;
  892 â”‚   } catch (error) {
  893 â”‚     console.error("Erro ao obter preÃ§o do quarto:", error);
  894 â”‚     throw error;
  895 â”‚   }
  896 â”‚ }
  897 â”‚ 
  898 â”‚ // FunÃ§Ã£o para calcular o preÃ§o total de uma estadia
  899 â”‚ export const calculateStayPrice = async (
  900 â”‚   roomId: string, 
  901 â”‚   checkIn: Date, 
  902 â”‚   checkOut: Date
  903 â”‚ ): Promise<{
  904 â”‚   totalPrice: number;
  905 â”‚   nightlyPrices: { date: string; price: number }[];
  906 â”‚   serviceFee: number;
  907 â”‚   totalWithFee: number;
  908 â”‚ }> => {
  909 â”‚   try {
  910 â”‚     console.log(`ğŸ” Iniciando cÃ¡lculo de preÃ§o para estadia: ${checkIn.toISOString().split('T')[0]} atÃ© ${checkOut.toISOString().split('T')[0]}`);
  911 â”‚     
  912 â”‚     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  913 â”‚     
  914 â”‚     if (!roomDoc.exists()) {
  915 â”‚       throw new Error("Quarto nÃ£o encontrado");
  916 â”‚     }
  917 â”‚     
  918 â”‚     const roomData = roomDoc.data() as Room;
  919 â”‚     console.log(`ğŸ“ Dados do quarto ${roomId}:`, {
  920 â”‚       nome: roomData.name,
  921 â”‚       precoBase: roomData.price,
  922 â”‚       taxaServico: roomData.serviceFeePct || 0,
  923 â”‚       temPrecosSazonais: !!roomData.seasonalPrices?.length
  924 â”‚     });
  925 â”‚     
  926 â”‚     const nightlyPrices: { date: string; price: number }[] = [];
  927 â”‚     let totalPrice = 0;
  928 â”‚     
  929 â”‚     // Calcular o nÃºmero de noites - corrigido para usar o mÃ©todo correto de cÃ¡lculo
  930 â”‚     // O nÃºmero de noites Ã© a diferenÃ§a em dias (estadia = checkout - checkin)
  931 â”‚     const noites = differenceInDays(checkOut, checkIn);
  932 â”‚     console.log(`ğŸ—“ï¸ NÃºmero de noites calculado: ${noites}`);
  933 â”‚     
  934 â”‚     if (noites <= 0) {
  935 â”‚       console.error(`âš ï¸ Erro: nÃºmero de noites invÃ¡lido (${noites})`);
  936 â”‚       throw new Error("Data de check-out deve ser posterior Ã  data de check-in");
  937 â”‚     }
  938 â”‚     
  939 â”‚     // Para cada noite, verificar o preÃ§o aplicÃ¡vel (preÃ§o base ou sazonal)
  940 â”‚     // ComeÃ§amos exatamente do dia de check-in
  941 â”‚     const currentDate = new Date(checkIn);
  942 â”‚     currentDate.setHours(0, 0, 0, 0); // Normalizar para meia-noite
  943 â”‚     
  944 â”‚     // Processamos cada dia de estadia (noite)
  945 â”‚     console.log(`ğŸ“Š Calculando preÃ§os por noite:`);
  946 â”‚     for (let i = 0; i < noites; i++) {
  947 â”‚       // Obtemos o preÃ§o para esta data
  948 â”‚       const dateCopy = new Date(currentDate);
  949 â”‚       const priceForDate = await getRoomPriceForDate(roomId, dateCopy);
  950 â”‚       const dateString = dateCopy.toISOString().split('T')[0]; // YYYY-MM-DD
  951 â”‚       
  952 â”‚       console.log(`   - ${dateString}: â‚¬${priceForDate}`);
  953 â”‚       
  954 â”‚       nightlyPrices.push({
  955 â”‚         date: dateString,
  956 â”‚         price: priceForDate
  957 â”‚       });
  958 â”‚       
  959 â”‚       totalPrice += priceForDate;
  960 â”‚       
  961 â”‚       // AvanÃ§amos para o prÃ³ximo dia
  962 â”‚       currentDate.setDate(currentDate.getDate() + 1);
  963 â”‚     }
  964 â”‚     
  965 â”‚     // VerificaÃ§Ã£o de seguranÃ§a para o cÃ¡lculo do totalPrice
  966 â”‚     const manualTotal = nightlyPrices.reduce((sum, night) => sum + night.price, 0);
  967 â”‚     if (Math.abs(totalPrice - manualTotal) > 1) {
  968 â”‚       console.error(`âš ï¸ DiscrepÃ¢ncia detectada no cÃ¡lculo do preÃ§o total!`);
  969 â”‚       console.error(`   - Total calculado iterativamente: â‚¬${totalPrice}`);
  970 â”‚       console.error(`   - Total calculado via reduce: â‚¬${manualTotal}`);
  971 â”‚       console.error(`   - Usando o valor recalculado para seguranÃ§a!`);
  972 â”‚       totalPrice = manualTotal;
  973 â”‚     }
  974 â”‚     
  975 â”‚     // Calcular taxa de serviÃ§o
  976 â”‚     const serviceFee = (totalPrice * (roomData.serviceFeePct || 0)) / 100;
  977 â”‚     const totalWithFee = totalPrice + serviceFee;
  978 â”‚     
  979 â”‚     console.log(`ğŸ’° Resumo do cÃ¡lculo:`);
  980 â”‚     console.log(`   - Total das diÃ¡rias: â‚¬${totalPrice}`);
  981 â”‚     console.log(`   - Taxa de serviÃ§o (${roomData.serviceFeePct || 0}%): â‚¬${serviceFee}`);
  982 â”‚     console.log(`   - Total com taxas: â‚¬${totalWithFee}`);
  983 â”‚     
  984 â”‚     return {
  985 â”‚       totalPrice,
  986 â”‚       nightlyPrices,
  987 â”‚       serviceFee,
  988 â”‚       totalWithFee
  989 â”‚     };
  990 â”‚   } catch (error) {
  991 â”‚     console.error("âŒ Erro ao calcular preÃ§o da estadia:", error);
  992 â”‚     throw error;
  993 â”‚   }
  994 â”‚ } 
  995 â”‚ import { 
  996 â”‚   collection, 
  997 â”‚   getDocs, 
  998 â”‚   getDoc, 
  999 â”‚   doc, 
 1000 â”‚   setDoc, 
 1001 â”‚   addDoc, 
 1002 â”‚   updateDoc, 
      Â·   â”€â”€â”€â”€â”¬â”€â”€â”€â”€
      Â·       â•°â”€â”€ `updateDoc` redefined here
 1003 â”‚   deleteDoc,
 1004 â”‚   query,
 1005 â”‚   where,
      â•°â”€â”€â”€â”€

  Ã— the name `deleteDoc` is defined multiple times
      â•­â”€[/home/runner/workspace/lib/firebase/firestore.ts:6:1]
    6 â”‚   getDoc,
    7 â”‚   getDocs,
    8 â”‚   updateDoc,
    9 â”‚   deleteDoc,
      Â·   â”€â”€â”€â”€â”¬â”€â”€â”€â”€
      Â·       â•°â”€â”€ previous definition of `deleteDoc` here
   10 â”‚   query,
   11 â”‚   where,
   12 â”‚   orderBy,
   13 â”‚   limit,
   14 â”‚   DocumentData,
   15 â”‚   QueryConstraint,
   16 â”‚   Timestamp,
   17 â”‚   serverTimestamp
   18 â”‚ } from 'firebase/firestore'
   19 â”‚ import { db } from './config'
   20 â”‚ import { Room, SeasonalPrice } from '@/lib/types'
   21 â”‚ import { differenceInDays } from 'date-fns'
   22 â”‚ 
   23 â”‚ // Tipos de dados
   24 â”‚ export interface Booking {
   25 â”‚   id?: string
   26 â”‚   userId?: string
   27 â”‚   guestName: string
   28 â”‚   guestEmail: string
   29 â”‚   guestPhone: string
   30 â”‚   roomId: string
   31 â”‚   roomName: string
   32 â”‚   checkIn: Timestamp
   33 â”‚   checkOut: Timestamp
   34 â”‚   adults: number
   35 â”‚   children: number
   36 â”‚   totalPrice: number
   37 â”‚   status: 'pending' | 'confirmed' | 'cancelled' | 'completed'
   38 â”‚   paymentStatus: 'pending' | 'paid' | 'refunded'
   39 â”‚   specialRequests?: string
   40 â”‚   createdAt?: Timestamp
   41 â”‚   updatedAt?: Timestamp
   42 â”‚ }
   43 â”‚ 
   44 â”‚ export interface Contact {
   45 â”‚   id?: string
   46 â”‚   name: string
   47 â”‚   email: string
   48 â”‚   phone?: string
   49 â”‚   subject: string
   50 â”‚   message: string
   51 â”‚   status: 'new' | 'read' | 'replied'
   52 â”‚   createdAt: Timestamp
   53 â”‚   updatedAt?: Timestamp
   54 â”‚   repliedAt?: Timestamp
   55 â”‚   replyContent?: string
   56 â”‚   reservationDetails?: {
   57 â”‚     checkIn?: Timestamp
   58 â”‚     checkOut?: Timestamp
   59 â”‚     roomId?: string
   60 â”‚     roomName?: string
   61 â”‚     totalGuests?: number
   62 â”‚     totalPrice?: number
   63 â”‚   }
   64 â”‚ }
   65 â”‚ 
   66 â”‚ // FunÃ§Ãµes genÃ©ricas para CRUD
   67 â”‚ export const createDocument = async <T extends DocumentData>(
   68 â”‚   collectionName: string,
   69 â”‚   data: T
   70 â”‚ ): Promise<string> => {
   71 â”‚   const docRef = await addDoc(collection(db, collectionName), {
   72 â”‚     ...data,
   73 â”‚     createdAt: serverTimestamp(),
   74 â”‚     updatedAt: serverTimestamp()
   75 â”‚   })
   76 â”‚   return docRef.id
   77 â”‚ }
   78 â”‚ 
   79 â”‚ export const createDocumentWithId = async <T extends DocumentData>(
   80 â”‚   collectionName: string,
   81 â”‚   id: string,
   82 â”‚   data: T
   83 â”‚ ): Promise<void> => {
   84 â”‚   await setDoc(doc(db, collectionName, id), {
   85 â”‚     ...data,
   86 â”‚     createdAt: serverTimestamp(),
   87 â”‚     updatedAt: serverTimestamp()
   88 â”‚   })
   89 â”‚ }
   90 â”‚ 
   91 â”‚ export const getDocument = async <T>(
   92 â”‚   collectionName: string,
   93 â”‚   id: string
   94 â”‚ ): Promise<T | null> => {
   95 â”‚   const docRef = doc(db, collectionName, id)
   96 â”‚   const docSnap = await getDoc(docRef)
   97 â”‚   
   98 â”‚   if (docSnap.exists()) {
   99 â”‚     const data = docSnap.data();
  100 â”‚     console.log("Dados brutos recuperados do Firestore para quarto:", id, data);
  101 â”‚     
  102 â”‚     if (data?.serviceFeePct !== undefined) {
  103 â”‚       console.log("serviceFeePct antes da conversÃ£o:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
  104 â”‚       // Garantir que serviceFeePct seja um nÃºmero
  105 â”‚       data.serviceFeePct = Number(data.serviceFeePct);
  106 â”‚       console.log("serviceFeePct apÃ³s conversÃ£o:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
  107 â”‚     }
  108 â”‚     
  109 â”‚     return { id: docSnap.id, ...data } as T
  110 â”‚   } else {
  111 â”‚     return null
  112 â”‚   }
  113 â”‚ }
  114 â”‚ 
  115 â”‚ export const getDocuments = async <T>(
  116 â”‚   collectionName: string,
  117 â”‚   constraints: QueryConstraint[] = [],
  118 â”‚   forceRefresh = false
  119 â”‚ ): Promise<T[]> => {
  120 â”‚   try {
  121 â”‚     const collectionRef = collection(db, collectionName)
  122 â”‚     const q = query(collectionRef, ...constraints)
  123 â”‚     
  124 â”‚     // Se forceRefresh for verdadeiro, adicionar opÃ§Ãµes que forÃ§am uma nova consulta ao Firestore
  125 â”‚     const querySnapshot = await getDocs(q)
  126 â”‚     
  127 â”‚     console.log(`Buscando documentos na coleÃ§Ã£o ${collectionName} - ForÃ§a atualizaÃ§Ã£o: ${forceRefresh}`);
  128 â”‚     
  129 â”‚     return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }) as T)
  130 â”‚   } catch (error) {
  131 â”‚     console.error(`Erro ao buscar documentos da coleÃ§Ã£o ${collectionName}:`, error);
  132 â”‚     return [];
  133 â”‚   }
  134 â”‚ }
  135 â”‚ 
  136 â”‚ export const updateDocument = async <T extends DocumentData>(
  137 â”‚   collectionName: string,
  138 â”‚   id: string,
  139 â”‚   data: Partial<T>
  140 â”‚ ): Promise<void> => {
  141 â”‚   const docRef = doc(db, collectionName, id)
  142 â”‚   await updateDoc(docRef, {
  143 â”‚     ...data,
  144 â”‚     updatedAt: serverTimestamp()
  145 â”‚   })
  146 â”‚ }
  147 â”‚ 
  148 â”‚ export const deleteDocument = async (
  149 â”‚   collectionName: string,
  150 â”‚   id: string
  151 â”‚ ): Promise<boolean> => {
  152 â”‚   const docRef = doc(db, collectionName, id)
  153 â”‚   await deleteDoc(docRef)
  154 â”‚   return true
  155 â”‚ }
  156 â”‚ 
  157 â”‚ // FunÃ§Ãµes para gerenciar quartos
  158 â”‚ export const getRooms = async (forceRefresh = false): Promise<Room[]> => {
  159 â”‚   try {
  160 â”‚     const constraints: QueryConstraint[] = []
  161 â”‚     
  162 â”‚     constraints.push(orderBy('name', 'asc'))
  163 â”‚     
  164 â”‚     const rooms = await getDocuments<Room>('rooms', constraints, forceRefresh)
  165 â”‚     
  166 â”‚     // Garantir que todos os campos necessÃ¡rios estejam presentes
  167 â”‚     return rooms.map(room => {
  168 â”‚       console.log(`Firebase - Quarto ${room.id} dados brutos:`, room);
  169 â”‚       
  170 â”‚       // Garantir que serviceFeePct seja um nÃºmero
  171 â”‚       const serviceFeePct = room.serviceFeePct !== undefined 
  172 â”‚         ? Number(room.serviceFeePct) 
  173 â”‚         : 10;
  174 â”‚         
  175 â”‚       console.log(`Firebase - Quarto ${room.id} serviceFeePct:`, {
  176 â”‚         original: room.serviceFeePct,
  177 â”‚         tipo: typeof room.serviceFeePct,
  178 â”‚         convertido: serviceFeePct
  179 â”‚       });
  180 â”‚       
  181 â”‚       return {
  182 â”‚         id: room.id,
  183 â”‚         name: room.name || '',
  184 â”‚         type: room.type || 'standard',
  185 â”‚         description: room.description || '',
  186 â”‚         price: room.price || 0,
  187 â”‚         capacity: room.capacity || 2,
  188 â”‚         size: room.size || 0,
  189 â”‚         available: room.available !== undefined ? room.available : true,
  190 â”‚         serviceFeePct: serviceFeePct,
  191 â”‚         images: room.images || [],
  192 â”‚         amenities: room.amenities || [],
  193 â”‚         additionalServices: room.additionalServices || [],
  194 â”‚         highlights: room.highlights || [],
  195 â”‚         createdAt: room.createdAt,
  196 â”‚         updatedAt: room.updatedAt
  197 â”‚       };
  198 â”‚     });
  199 â”‚   } catch (error) {
  200 â”‚     console.error('Erro ao buscar quartos:', error)
  201 â”‚     return []
  202 â”‚   }
  203 â”‚ }
  204 â”‚ 
  205 â”‚ export const getAvailableRooms = async (
  206 â”‚   checkIn: Date,
  207 â”‚   checkOut: Date
  208 â”‚ ): Promise<Room[]> => {
  209 â”‚   try {
  210 â”‚     // Buscar todos os quartos que estÃ£o marcados como disponÃ­veis em geral
  211 â”‚     const constraints: QueryConstraint[] = [
  212 â”‚       where('available', '==', true)
  213 â”‚     ]
  214 â”‚     
  215 â”‚     const rooms = await getDocuments<Room>('rooms', constraints);
  216 â”‚     
  217 â”‚     // Filtrar os quartos que estÃ£o disponÃ­veis nas datas especÃ­ficas
  218 â”‚     return filterAvailableRoomsByDate(rooms, checkIn, checkOut);
  219 â”‚   } catch (error) {
  220 â”‚     console.error('Erro ao buscar quartos disponÃ­veis:', error)
  221 â”‚     return []
  222 â”‚   }
  223 â”‚ }
  224 â”‚ 
  225 â”‚ // FunÃ§Ã£o auxiliar para verificar disponibilidade entre datas
  226 â”‚ export const filterAvailableRoomsByDate = (
  227 â”‚   rooms: Room[],
  228 â”‚   checkIn: Date,
  229 â”‚   checkOut: Date
  230 â”‚ ): Room[] => {
  231 â”‚   // Converter checkIn e checkOut para ISO strings
  232 â”‚   const dateStrings = getDatesInRange(checkIn, checkOut);
  233 â”‚   
  234 â”‚   return rooms.filter(room => {
  235 â”‚     // Se nÃ£o tiver controle de disponibilidade especÃ­fico, considera disponÃ­vel
  236 â”‚     if (!room.availabilityDates) return true;
  237 â”‚     
  238 â”‚     // Verificar se alguma data no intervalo estÃ¡ indisponÃ­vel
  239 â”‚     return !dateStrings.some(dateStr => 
  240 â”‚       room.availabilityDates?.[dateStr] === false
  241 â”‚     );
  242 â”‚   });
  243 â”‚ };
  244 â”‚ 
  245 â”‚ // FunÃ§Ã£o para obter disponibilidade de um quarto especÃ­fico
  246 â”‚ export const getRoomAvailability = async (
  247 â”‚   roomId: string, 
  248 â”‚   startDate: Date, 
  249 â”‚   endDate: Date
  250 â”‚ ): Promise<{[date: string]: boolean}> => {
  251 â”‚   try {
  252 â”‚     const room = await getRoomById(roomId);
  253 â”‚     if (!room) throw new Error(`Quarto com ID ${roomId} nÃ£o encontrado`);
  254 â”‚     
  255 â”‚     // Gerar datas no intervalo
  256 â”‚     const dateStrings = getDatesInRange(startDate, endDate);
  257 â”‚     
  258 â”‚     // Se nÃ£o tiver configuraÃ§Ã£o de disponibilidade especÃ­fica, assume tudo disponÃ­vel
  259 â”‚     if (!room.availabilityDates) {
  260 â”‚       return dateStrings.reduce((acc, date) => {
  261 â”‚         acc[date] = true;
  262 â”‚         return acc;
  263 â”‚       }, {} as {[date: string]: boolean});
  264 â”‚     }
  265 â”‚     
  266 â”‚     // Preencher com os dados de disponibilidade existentes
  267 â”‚     return dateStrings.reduce((acc, date) => {
  268 â”‚       acc[date] = room.availabilityDates?.[date] !== false; // disponÃ­vel por padrÃ£o se nÃ£o estiver explicitamente indisponÃ­vel
  269 â”‚       return acc;
  270 â”‚     }, {} as {[date: string]: boolean});
  271 â”‚   } catch (error) {
  272 â”‚     console.error(`Erro ao verificar disponibilidade do quarto ${roomId}:`, error);
  273 â”‚     throw error;
  274 â”‚   }
  275 â”‚ };
  276 â”‚ 
  277 â”‚ // FunÃ§Ã£o para atualizar disponibilidade de um quarto
  278 â”‚ export const updateRoomAvailability = async (
  279 â”‚   roomId: string,
  280 â”‚   availabilityDates: {[date: string]: boolean}
  281 â”‚ ): Promise<boolean> => {
  282 â”‚   try {
  283 â”‚     await updateDocument('rooms', roomId, {
  284 â”‚       availabilityDates,
  285 â”‚       updatedAt: serverTimestamp()
  286 â”‚     });
  287 â”‚     return true;
  288 â”‚   } catch (error) {
  289 â”‚     console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  290 â”‚     return false;
  291 â”‚   }
  292 â”‚ };
  293 â”‚ 
  294 â”‚ // FunÃ§Ã£o auxiliar para gerar array de strings de data entre um intervalo
  295 â”‚ export const getDatesInRange = (startDate: Date, endDate: Date): string[] => {
  296 â”‚   const dates: string[] = [];
  297 â”‚   const currentDate = new Date(startDate);
  298 â”‚   
  299 â”‚   // Normalizar para meia-noite no fuso horÃ¡rio local
  300 â”‚   currentDate.setHours(0, 0, 0, 0);
  301 â”‚   const endDateNormalized = new Date(endDate);
  302 â”‚   endDateNormalized.setHours(0, 0, 0, 0);
  303 â”‚   
  304 â”‚   // Adicionar cada data no intervalo EXCETO o dia de checkout
  305 â”‚   // Usando < em vez de <= para nÃ£o incluir o dia de checkout
  306 â”‚   while (currentDate < endDateNormalized) {
  307 â”‚     dates.push(currentDate.toISOString().split('T')[0]); // Formato YYYY-MM-DD
  308 â”‚     currentDate.setDate(currentDate.getDate() + 1);
  309 â”‚   }
  310 â”‚   
  311 â”‚   return dates;
  312 â”‚ };
  313 â”‚ 
  314 â”‚ export const getRoomById = async (id: string): Promise<Room | null> => {
  315 â”‚   try {
  316 â”‚     const room = await getDocument<Room>('rooms', id);
  317 â”‚     
  318 â”‚     if (!room) return null;
  319 â”‚     
  320 â”‚     console.log(`Firebase - getRoomById ${id} dados brutos:`, room);
  321 â”‚     
  322 â”‚     // Log especÃ­fico para serviceFeePct
  323 â”‚     console.log(`serviceFeePct no Firestore:`, room.serviceFeePct);
  324 â”‚     
  325 â”‚     // Garantir que todos os campos necessÃ¡rios estejam presentes
  326 â”‚     return {
  327 â”‚       ...room,
  328 â”‚       name: room.name || '',
  329 â”‚       type: room.type || 'standard',
  330 â”‚       description: room.description || '',
  331 â”‚       price: room.price || 0,
  332 â”‚       capacity: room.capacity || 2,
  333 â”‚       size: room.size || 0,
  334 â”‚       available: room.available !== undefined ? room.available : true,
  335 â”‚       serviceFeePct: room.serviceFeePct !== undefined ? room.serviceFeePct : 10,
  336 â”‚       images: room.images || [],
  337 â”‚       amenities: room.amenities || [],
  338 â”‚       additionalServices: room.additionalServices || [],
  339 â”‚       highlights: room.highlights || []
  340 â”‚     };
  341 â”‚   } catch (error) {
  342 â”‚     console.error(`Erro ao buscar quarto com ID ${id}:`, error);
  343 â”‚     return null;
  344 â”‚   }
  345 â”‚ }
  346 â”‚ 
  347 â”‚ export const createRoom = async (roomData: Omit<Room, 'id' | 'createdAt' | 'updatedAt'>): Promise<Room> => {
  348 â”‚   try {
  349 â”‚     console.log("createRoom - Dados recebidos:", roomData);
  350 â”‚     
  351 â”‚     const roomWithTimestamps = {
  352 â”‚       ...roomData,
  353 â”‚       available: roomData.available !== undefined ? roomData.available : true,
  354 â”‚       featured: roomData.featured || false,
  355 â”‚       amenities: roomData.amenities || [],
  356 â”‚       additionalServices: roomData.additionalServices || [],
  357 â”‚       highlights: roomData.highlights || [],
  358 â”‚       createdAt: serverTimestamp(),
  359 â”‚       updatedAt: serverTimestamp()
  360 â”‚     }
  361 â”‚     
  362 â”‚     console.log("createRoom - Dados a serem salvos:", roomWithTimestamps);
  363 â”‚     
  364 â”‚     const id = await createDocument('rooms', roomWithTimestamps)
  365 â”‚     
  366 â”‚     return {
  367 â”‚       id,
  368 â”‚       ...roomData,
  369 â”‚       amenities: roomData.amenities || [],
  370 â”‚       additionalServices: roomData.additionalServices || [],
  371 â”‚       highlights: roomData.highlights || [],
  372 â”‚       createdAt: Timestamp.now(),
  373 â”‚       updatedAt: Timestamp.now()
  374 â”‚     }
  375 â”‚   } catch (error) {
  376 â”‚     console.error('Erro ao criar quarto:', error)
  377 â”‚     throw error
  378 â”‚   }
  379 â”‚ }
  380 â”‚ 
  381 â”‚ export const updateRoom = async (id: string, roomData: Partial<Omit<Room, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Room> => {
  382 â”‚   try {
  383 â”‚     console.log(`updateRoom - ID: ${id}, Dados recebidos:`, roomData);
  384 â”‚     
  385 â”‚     // Garantir que estamos lidando explicitamente com o serviceFeePct se ele for 0
  386 â”‚     if (roomData.serviceFeePct === 0) {
  387 â”‚       console.log("updateRoom - Detectado serviceFeePct com valor 0, salvando explicitamente.", roomData.serviceFeePct);
  388 â”‚     }
  389 â”‚     
  390 â”‚     // Adicionar timestamp de atualizaÃ§Ã£o
  391 â”‚     const roomWithTimestamp = {
  392 â”‚       ...roomData,
  393 â”‚       amenities: roomData.amenities || [],
  394 â”‚       additionalServices: roomData.additionalServices || [],
  395 â”‚       highlights: roomData.highlights || [],
  396 â”‚       updatedAt: serverTimestamp()
  397 â”‚     }
  398 â”‚     
  399 â”‚     console.log(`updateRoom - Dados a serem salvos:`, roomWithTimestamp);
  400 â”‚     
  401 â”‚     await updateDocument('rooms', id, roomWithTimestamp)
  402 â”‚     
  403 â”‚     const updatedRoom = await getRoomById(id)
  404 â”‚     if (!updatedRoom) {
  405 â”‚       throw new Error(`Quarto com ID ${id} nÃ£o encontrado apÃ³s atualizaÃ§Ã£o`)
  406 â”‚     }
  407 â”‚     
  408 â”‚     return updatedRoom
  409 â”‚   } catch (error) {
  410 â”‚     console.error('Erro ao atualizar quarto:', error)
  411 â”‚     throw error
  412 â”‚   }
  413 â”‚ }
  414 â”‚ 
  415 â”‚ export const deleteRoom = async (id: string): Promise<boolean> => {
  416 â”‚   return await deleteDocument('rooms', id)
  417 â”‚ }
  418 â”‚ 
  419 â”‚ // FunÃ§Ãµes especÃ­ficas para reservas
  420 â”‚ export const createBooking = async (bookingData: any) => {
  421 â”‚   try {
  422 â”‚     const bookingsCollection = collection(db, 'bookings');
  423 â”‚     const docRef = await addDoc(bookingsCollection, bookingData);
  424 â”‚     
  425 â”‚     // CORREÃ‡ÃƒO: NÃ£o bloquear a data no momento da criaÃ§Ã£o da reserva
  426 â”‚     // O bloqueio serÃ¡ feito apenas quando o pagamento for confirmado
  427 â”‚     // atravÃ©s da funÃ§Ã£o updateBookingStatus
  428 â”‚     
  429 â”‚     return docRef;
  430 â”‚   } catch (error) {
  431 â”‚     console.error('Erro ao criar reserva:', error);
  432 â”‚     throw error;
  433 â”‚   }
  434 â”‚ };
  435 â”‚ 
  436 â”‚ // Nova funÃ§Ã£o para atualizar status da reserva e bloquear as datas da estadia
  437 â”‚ export const updateBookingStatus = async (
  438 â”‚   bookingId: string, 
  439 â”‚   newStatus: 'pending' | 'confirmed' | 'cancelled' | 'completed',
  440 â”‚   newPaymentStatus: 'pending' | 'paid' | 'refunded'
  441 â”‚ ): Promise<boolean> => {
  442 â”‚   try {
  443 â”‚     // ReferÃªncia ao documento da reserva
  444 â”‚     const bookingRef = doc(db, 'bookings', bookingId);
  445 â”‚     const bookingSnap = await getDoc(bookingRef);
  446 â”‚     
  447 â”‚     if (!bookingSnap.exists()) {
  448 â”‚       console.error(`Booking ${bookingId} nÃ£o existe ao atualizar status`);
  449 â”‚       return false;
  450 â”‚     }
  451 â”‚     
  452 â”‚     const bookingData = bookingSnap.data();
  453 â”‚     
  454 â”‚     // Atualizar o status da reserva
  455 â”‚     await updateDoc(bookingRef, {
  456 â”‚       status: newStatus,
  457 â”‚       paymentStatus: newPaymentStatus,
  458 â”‚       updatedAt: serverTimestamp(),
  459 â”‚       ...(newStatus === 'confirmed' && { confirmedAt: serverTimestamp() })
  460 â”‚     });
  461 â”‚     
  462 â”‚     // Se a reserva estÃ¡ sendo confirmada, precisamos bloquear as datas
  463 â”‚     if (newStatus === 'confirmed') {
  464 â”‚       console.log(`Atualizando disponibilidade para reserva confirmada: ${bookingId}`);
  465 â”‚       
  466 â”‚       // Recuperar datas de check-in e check-out
  467 â”‚       const checkIn = bookingData.checkIn.toDate();
  468 â”‚       const checkOut = bookingData.checkOut.toDate();
  469 â”‚       const roomId = bookingData.roomId;
  470 â”‚       
  471 â”‚       // Obter todas as datas entre check-in e check-out
  472 â”‚       const dates: Date[] = [];
  473 â”‚       const currentDate = new Date(checkIn);
  474 â”‚       
  475 â”‚       while (currentDate < checkOut) {
  476 â”‚         dates.push(new Date(currentDate));
  477 â”‚         currentDate.setDate(currentDate.getDate() + 1);
  478 â”‚       }
  479 â”‚       
  480 â”‚       console.log(`Bloqueando ${dates.length} dias para quarto ${roomId}`);
  481 â”‚       
  482 â”‚       // Atualizar disponibilidade para cada data
  483 â”‚       const availabilityUpdates: {[date: string]: boolean} = {};
  484 â”‚       
  485 â”‚       dates.forEach(date => {
  486 â”‚         const dateString = date.toISOString().split('T')[0]; // formato YYYY-MM-DD
  487 â”‚         availabilityUpdates[dateString] = false; // false significa indisponÃ­vel
  488 â”‚       });
  489 â”‚       
  490 â”‚       // Atualizar disponibilidade do quarto
  491 â”‚       if (Object.keys(availabilityUpdates).length > 0) {
  492 â”‚         try {
  493 â”‚           // Obter o documento do quarto
  494 â”‚           const roomRef = doc(db, 'rooms', roomId);
  495 â”‚           const roomSnap = await getDoc(roomRef);
  496 â”‚           
  497 â”‚           if (roomSnap.exists()) {
  498 â”‚             const roomData = roomSnap.data();
  499 â”‚             const currentAvailability = roomData.availabilityDates || {};
  500 â”‚             
  501 â”‚             // Mesclar a disponibilidade atual com as novas atualizaÃ§Ãµes
  502 â”‚             const updatedAvailability = {
  503 â”‚               ...currentAvailability,
  504 â”‚               ...availabilityUpdates
  505 â”‚             };
  506 â”‚             
  507 â”‚             // Atualizar o documento do quarto
  508 â”‚             await updateDoc(roomRef, {
  509 â”‚               availabilityDates: updatedAvailability,
  510 â”‚               updatedAt: serverTimestamp()
  511 â”‚             });
  512 â”‚             
  513 â”‚             console.log(`Disponibilidade atualizada com sucesso para quarto ${roomId}`);
  514 â”‚             
  515 â”‚             // Criar log da reserva
  516 â”‚             await addDoc(collection(db, 'bookingLogs'), {
  517 â”‚               bookingId,
  518 â”‚               roomId,
  519 â”‚               action: 'status_updated',
  520 â”‚               previousStatus: bookingData.status,
  521 â”‚               newStatus,
  522 â”‚               previousPaymentStatus: bookingData.paymentStatus,
  523 â”‚               newPaymentStatus,
  524 â”‚               datesBlocked: Object.keys(availabilityUpdates),
  525 â”‚               timestamp: serverTimestamp(),
  526 â”‚               userId: bookingData.userId || 'system'
  527 â”‚             });
  528 â”‚           } else {
  529 â”‚             console.error(`Quarto ${roomId} nÃ£o encontrado ao atualizar disponibilidade`);
  530 â”‚           }
  531 â”‚         } catch (error) {
  532 â”‚           console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  533 â”‚         }
  534 â”‚       }
  535 â”‚     }
  536 â”‚     
  537 â”‚     return true;
  538 â”‚   } catch (error) {
  539 â”‚     console.error(`Erro ao atualizar status da reserva ${bookingId}:`, error);
  540 â”‚     return false;
  541 â”‚   }
  542 â”‚ }
  543 â”‚ 
  544 â”‚ export const getUserBookings = async (userId: string): Promise<Booking[]> => {
  545 â”‚   return getDocuments<Booking>('bookings', [
  546 â”‚     where('userId', '==', userId),
  547 â”‚     orderBy('createdAt', 'desc')
  548 â”‚   ])
  549 â”‚ }
  550 â”‚ 
  551 â”‚ export const getRecentBookings = async (count = 5): Promise<Booking[]> => {
  552 â”‚   return getDocuments<Booking>('bookings', [
  553 â”‚     orderBy('createdAt', 'desc'),
  554 â”‚     limit(count)
  555 â”‚   ])
  556 â”‚ }
  557 â”‚ 
  558 â”‚ export const getRoomBookings = async (roomId: string): Promise<Booking[]> => {
  559 â”‚   try {
  560 â”‚     const constraints: QueryConstraint[] = [
  561 â”‚       where('roomId', '==', roomId),
  562 â”‚       orderBy('checkIn', 'asc')
  563 â”‚     ];
  564 â”‚     
  565 â”‚     return await getDocuments<Booking>('bookings', constraints);
  566 â”‚   } catch (error) {
  567 â”‚     console.error(`Erro ao buscar reservas do quarto ${roomId}:`, error);
  568 â”‚     return [];
  569 â”‚   }
  570 â”‚ };
  571 â”‚ 
  572 â”‚ // FunÃ§Ãµes especÃ­ficas para contatos
  573 â”‚ export const createContactMessage = async (contactData: Contact) => {
  574 â”‚   try {
  575 â”‚     const contactsCollection = collection(db, 'contacts')
  576 â”‚     
  577 â”‚     // Garantir que o status seja 'new' para novos contatos
  578 â”‚     const contactWithDefaults = {
  579 â”‚       ...contactData,
  580 â”‚       status: contactData.status || 'new',
  581 â”‚       createdAt: contactData.createdAt || Timestamp.now()
  582 â”‚     }
  583 â”‚     
  584 â”‚     // Se tiver detalhes de reserva, adicionar metadados
  585 â”‚     if (contactWithDefaults.reservationDetails) {
  586 â”‚       // Ajustar subject para indicar que Ã© relacionado a reserva
  587 â”‚       if (!contactWithDefaults.subject.includes('Reserva')) {
  588 â”‚         contactWithDefaults.subject = `Reserva: ${contactWithDefaults.subject}`;
  589 â”‚       }
  590 â”‚     }
  591 â”‚     
  592 â”‚     const docRef = await addDoc(contactsCollection, contactWithDefaults)
  593 â”‚     return docRef
  594 â”‚   } catch (error) {
  595 â”‚     console.error('Erro ao criar mensagem de contato:', error)
  596 â”‚     throw error
  597 â”‚   }
  598 â”‚ }
  599 â”‚ 
  600 â”‚ export const getNewContactMessages = async (): Promise<Contact[]> => {
  601 â”‚   return getDocuments<Contact>('contacts', [
  602 â”‚     where('status', '==', 'new'),
  603 â”‚     orderBy('createdAt', 'desc')
  604 â”‚   ])
  605 â”‚ }
  606 â”‚ 
  607 â”‚ // FunÃ§Ãµes para Dashboard com dados reais
  608 â”‚ 
  609 â”‚ export const getDashboardStats = async () => {
  610 â”‚   try {
  611 â”‚     const [totalBookings, totalRevenue, occupancyRate, bookingsByPlatform] = await Promise.all([
  612 â”‚       getTotalBookings(),
  613 â”‚       getMonthlyRevenue(),
  614 â”‚       getOccupancyRate(),
  615 â”‚       getBookingsByPlatform()
  616 â”‚     ]);
  617 â”‚ 
  618 â”‚     return {
  619 â”‚       totalBookings,
  620 â”‚       totalRevenue,
  621 â”‚       occupancyRate,
  622 â”‚       bookingsByPlatform
  623 â”‚     };
  624 â”‚   } catch (error) {
  625 â”‚     console.error('Erro ao obter estatÃ­sticas do dashboard:', error);
  626 â”‚     throw error;
  627 â”‚   }
  628 â”‚ };
  629 â”‚ 
  630 â”‚ // Obter total de reservas
  631 â”‚ export const getTotalBookings = async () => {
  632 â”‚   try {
  633 â”‚     // Obter todas as reservas
  634 â”‚     const bookings = await getDocuments<Booking>('bookings');
  635 â”‚     
  636 â”‚     // Contar reservas por status
  637 â”‚     const confirmed = bookings.filter(b => b.status === 'confirmed').length;
  638 â”‚     const pending = bookings.filter(b => b.status === 'pending').length;
  639 â”‚     const cancelled = bookings.filter(b => b.status === 'cancelled').length;
  640 â”‚     const completed = bookings.filter(b => b.status === 'completed').length;
  641 â”‚     
  642 â”‚     // Calcular crescimento em relaÃ§Ã£o ao mÃªs anterior (simulado por enquanto)
  643 â”‚     // Em uma implementaÃ§Ã£o real, vocÃª compararia com dados do mÃªs anterior
  644 â”‚     const growth = ((confirmed + completed) / (bookings.length || 1) * 100) - 50;
  645 â”‚     
  646 â”‚     return {
  647 â”‚       total: bookings.length,
  648 â”‚       confirmed,
  649 â”‚       pending,
  650 â”‚       cancelled,
  651 â”‚       completed,
  652 â”‚       growth: Math.round(growth) // Arredonda para nÃºmero inteiro
  653 â”‚     };
  654 â”‚   } catch (error) {
  655 â”‚     console.error('Erro ao obter total de reservas:', error);
  656 â”‚     return {
  657 â”‚       total: 0,
  658 â”‚       confirmed: 0,
  659 â”‚       pending: 0, 
  660 â”‚       cancelled: 0,
  661 â”‚       completed: 0,
  662 â”‚       growth: 0
  663 â”‚     };
  664 â”‚   }
  665 â”‚ };
  666 â”‚ 
  667 â”‚ // Obter receita mensal
  668 â”‚ export const getMonthlyRevenue = async () => {
  669 â”‚   try {
  670 â”‚     const bookings = await getDocuments<Booking>('bookings');
  671 â”‚     
  672 â”‚     // Filtrar reservas confirmadas e concluÃ­das
  673 â”‚     const validBookings = bookings.filter(b => 
  674 â”‚       b.status === 'confirmed' || b.status === 'completed'
  675 â”‚     );
  676 â”‚     
  677 â”‚     // Calcular receita total
  678 â”‚     const totalRevenue = validBookings.reduce((acc, booking) => acc + booking.totalPrice, 0);
  679 â”‚     
  680 â”‚     // Agrupar receita por mÃªs
  681 â”‚     const revenueByMonth = validBookings.reduce((acc, booking) => {
  682 â”‚       const date = booking.checkIn.toDate();
  683 â”‚       const month = date.getMonth(); // 0-11
  684 â”‚       const year = date.getFullYear();
  685 â”‚       const key = `${year}-${month}`;
  686 â”‚       
  687 â”‚       if (!acc[key]) {
  688 â”‚         acc[key] = 0;
  689 â”‚       }
  690 â”‚       acc[key] += booking.totalPrice;
  691 â”‚       return acc;
  692 â”‚     }, {} as Record<string, number>);
  693 â”‚     
  694 â”‚     // Converter para formato de array para grÃ¡fico
  695 â”‚     const monthNames = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
  696 â”‚     
  697 â”‚     const currentDate = new Date();
  698 â”‚     const currentMonth = currentDate.getMonth();
  699 â”‚     const currentYear = currentDate.getFullYear();
  700 â”‚     
  701 â”‚     const revenueData = [];
  702 â”‚     
  703 â”‚     // Gerar dados dos Ãºltimos 12 meses
  704 â”‚     for (let i = 0; i < 12; i++) {
  705 â”‚       const month = (currentMonth - i + 12) % 12;
  706 â”‚       const year = currentMonth - i < 0 ? currentYear - 1 : currentYear;
  707 â”‚       const key = `${year}-${month}`;
  708 â”‚       
  709 â”‚       revenueData.unshift({
  710 â”‚         month: monthNames[month],
  711 â”‚         value: revenueByMonth[key] || 0
  712 â”‚       });
  713 â”‚     }
  714 â”‚     
  715 â”‚     // Calcular crescimento em relaÃ§Ã£o ao mÃªs anterior
  716 â”‚     const lastMonthRevenue = revenueData[revenueData.length - 2]?.value || 0;
  717 â”‚     const currentMonthRevenue = revenueData[revenueData.length - 1]?.value || 0;
  718 â”‚     
  719 â”‚     const growth = lastMonthRevenue ? ((currentMonthRevenue - lastMonthRevenue) / lastMonthRevenue) * 100 : 0;
  720 â”‚     
  721 â”‚     return {
  722 â”‚       monthly: currentMonthRevenue,
  723 â”‚       total: totalRevenue,
  724 â”‚       growth: Math.round(growth),
  725 â”‚       revenueData
  726 â”‚     };
  727 â”‚   } catch (error) {
  728 â”‚     console.error('Erro ao obter receita mensal:', error);
  729 â”‚     return {
  730 â”‚       monthly: 0,
  731 â”‚       total: 0,
  732 â”‚       growth: 0,
  733 â”‚       revenueData: []
  734 â”‚     };
  735 â”‚   }
  736 â”‚ };
  737 â”‚ 
  738 â”‚ // Calcular taxa de ocupaÃ§Ã£o
  739 â”‚ export const getOccupancyRate = async () => {
  740 â”‚   try {
  741 â”‚     // Obter todos os quartos
  742 â”‚     const rooms = await getDocuments<Room>('rooms');
  743 â”‚     const totalRooms = rooms.length;
  744 â”‚     
  745 â”‚     if (totalRooms === 0) {
  746 â”‚       return { rate: 0, growth: 0 };
  747 â”‚     }
  748 â”‚     
  749 â”‚     // Obter todas as reservas
  750 â”‚     const bookings = await getDocuments<Booking>('bookings');
  751 â”‚     
  752 â”‚     // Filtrar reservas confirmadas e concluÃ­das para o mÃªs atual
  753 â”‚     const currentDate = new Date();
  754 â”‚     const currentMonth = currentDate.getMonth();
  755 â”‚     const currentYear = currentDate.getFullYear();
  756 â”‚     
  757 â”‚     const currentMonthBookings = bookings.filter(booking => {
  758 â”‚       const checkInDate = booking.checkIn.toDate();
  759 â”‚       return (
  760 â”‚         (booking.status === 'confirmed' || booking.status === 'completed') &&
  761 â”‚         checkInDate.getMonth() === currentMonth &&
  762 â”‚         checkInDate.getFullYear() === currentYear
  763 â”‚       );
  764 â”‚     });
  765 â”‚     
  766 â”‚     // Calcular dias ocupados por quarto
  767 â”‚     const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
  768 â”‚     const totalPossibleRoomDays = totalRooms * daysInMonth;
  769 â”‚     
  770 â”‚     // Contar dias ocupados (simplificado - em produÃ§Ã£o seria mais complexo)
  771 â”‚     let occupiedDays = 0;
  772 â”‚     
  773 â”‚     currentMonthBookings.forEach(booking => {
  774 â”‚       const checkIn = booking.checkIn.toDate();
  775 â”‚       const checkOut = booking.checkOut.toDate();
  776 â”‚       
  777 â”‚       // Ajustar datas para considerar apenas o mÃªs atual
  778 â”‚       const startDate = new Date(Math.max(
  779 â”‚         checkIn.getTime(),
  780 â”‚         new Date(currentYear, currentMonth, 1).getTime()
  781 â”‚       ));
  782 â”‚       const endDate = new Date(Math.min(
  783 â”‚         checkOut.getTime(),
  784 â”‚         new Date(currentYear, currentMonth + 1, 0).getTime()
  785 â”‚       ));
  786 â”‚       
  787 â”‚       // Calcular dias entre datas (incluindo check-in, excluindo check-out)
  788 â”‚       const days = Math.max(0, Math.floor((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)));
  789 â”‚       occupiedDays += days;
  790 â”‚     });
  791 â”‚     
  792 â”‚     const occupancyRate = (occupiedDays / totalPossibleRoomDays) * 100;
  793 â”‚     
  794 â”‚     // SimulaÃ§Ã£o de crescimento (em produÃ§Ã£o, compararia com mÃªs anterior)
  795 â”‚     const growth = occupancyRate > 50 ? 5 : -3;
  796 â”‚     
  797 â”‚     return {
  798 â”‚       rate: Math.round(occupancyRate),
  799 â”‚       growth: Math.round(growth)
  800 â”‚     };
  801 â”‚   } catch (error) {
  802 â”‚     console.error('Erro ao calcular taxa de ocupaÃ§Ã£o:', error);
  803 â”‚     return { rate: 0, growth: 0 };
  804 â”‚   }
  805 â”‚ };
  806 â”‚ 
  807 â”‚ // Obter reservas agrupadas por plataforma
  808 â”‚ export const getBookingsByPlatform = async () => {
  809 â”‚   try {
  810 â”‚     const bookings = await getDocuments<Booking>('bookings');
  811 â”‚     
  812 â”‚     // Categorizar reservas por origem
  813 â”‚     const platforms = [
  814 â”‚       { 
  815 â”‚         platform: "Booking.com", 
  816 â”‚         color: "#003580", 
  817 â”‚         icon: "Globe",
  818 â”‚         bookings: []
  819 â”‚       },
  820 â”‚       { 
  821 â”‚         platform: "Airbnb", 
  822 â”‚         color: "#FF5A5F", 
  823 â”‚         icon: "Heart",
  824 â”‚         bookings: []
  825 â”‚       },
  826 â”‚       { 
  827 â”‚         platform: "Direto", 
  828 â”‚         color: "#4CAF50", 
  829 â”‚         icon: "Home",
  830 â”‚         bookings: []
  831 â”‚       }
  832 â”‚     ];
  833 â”‚     
  834 â”‚     // Para fins de demonstraÃ§Ã£o, colocar todas as reservas como "Direto" por enquanto
  835 â”‚     // Em produÃ§Ã£o, usaria um campo "platformOrigin" ou similar na tabela de reservas
  836 â”‚     const platformIndex = 2; // Ãndice da plataforma "Direto"
  837 â”‚     
  838 â”‚     bookings.forEach(booking => {
  839 â”‚       // Transformar para o formato esperado pelo componente
  840 â”‚       const transformedBooking = {
  841 â”‚         id: booking.id || '',
  842 â”‚         guestName: booking.guestName,
  843 â”‚         roomName: booking.roomName,
  844 â”‚         checkIn: booking.checkIn.toDate().toLocaleDateString('pt-PT'),
  845 â”‚         checkOut: booking.checkOut.toDate().toLocaleDateString('pt-PT'),
  846 â”‚         status: booking.status,
  847 â”‚         value: new Intl.NumberFormat('pt-PT', {
  848 â”‚           style: 'currency',
  849 â”‚           currency: 'EUR'
  850 â”‚         }).format(booking.totalPrice)
  851 â”‚       };
  852 â”‚       
  853 â”‚       // Adicionar Ã  plataforma "Direto"
  854 â”‚       (platforms[platformIndex] as any).bookings.push(transformedBooking);
  855 â”‚     });
  856 â”‚     
  857 â”‚     return platforms;
  858 â”‚   } catch (error) {
  859 â”‚     console.error('Erro ao obter reservas por plataforma:', error);
  860 â”‚     return [];
  861 â”‚   }
  862 â”‚ };
  863 â”‚ 
  864 â”‚ // FunÃ§Ã£o para obter o preÃ§o de um quarto para uma data especÃ­fica
  865 â”‚ export const getRoomPriceForDate = async (roomId: string, date: Date): Promise<number> => {
  866 â”‚   try {
  867 â”‚     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  868 â”‚     
  869 â”‚     if (!roomDoc.exists()) {
  870 â”‚       throw new Error("Quarto nÃ£o encontrado");
  871 â”‚     }
  872 â”‚     
  873 â”‚     const roomData = roomDoc.data() as Room;
  874 â”‚     const basePrice = roomData.price;
  875 â”‚     
  876 â”‚     if (!roomData.seasonalPrices || roomData.seasonalPrices.length === 0) {
  877 â”‚       return basePrice;
  878 â”‚     }
  879 â”‚     
  880 â”‚     // Verificar se a data estÃ¡ dentro de algum perÃ­odo sazonal
  881 â”‚     for (const seasonalPrice of roomData.seasonalPrices) {
  882 â”‚       const startDate = new Date(seasonalPrice.startDate);
  883 â”‚       const endDate = new Date(seasonalPrice.endDate);
  884 â”‚       
  885 â”‚       if (date >= startDate && date <= endDate) {
  886 â”‚         return seasonalPrice.price;
  887 â”‚       }
  888 â”‚     }
  889 â”‚     
  890 â”‚     // Se nÃ£o cair em nenhum perÃ­odo sazonal, retorna o preÃ§o base
  891 â”‚     return basePrice;
  892 â”‚   } catch (error) {
  893 â”‚     console.error("Erro ao obter preÃ§o do quarto:", error);
  894 â”‚     throw error;
  895 â”‚   }
  896 â”‚ }
  897 â”‚ 
  898 â”‚ // FunÃ§Ã£o para calcular o preÃ§o total de uma estadia
  899 â”‚ export const calculateStayPrice = async (
  900 â”‚   roomId: string, 
  901 â”‚   checkIn: Date, 
  902 â”‚   checkOut: Date
  903 â”‚ ): Promise<{
  904 â”‚   totalPrice: number;
  905 â”‚   nightlyPrices: { date: string; price: number }[];
  906 â”‚   serviceFee: number;
  907 â”‚   totalWithFee: number;
  908 â”‚ }> => {
  909 â”‚   try {
  910 â”‚     console.log(`ğŸ” Iniciando cÃ¡lculo de preÃ§o para estadia: ${checkIn.toISOString().split('T')[0]} atÃ© ${checkOut.toISOString().split('T')[0]}`);
  911 â”‚     
  912 â”‚     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  913 â”‚     
  914 â”‚     if (!roomDoc.exists()) {
  915 â”‚       throw new Error("Quarto nÃ£o encontrado");
  916 â”‚     }
  917 â”‚     
  918 â”‚     const roomData = roomDoc.data() as Room;
  919 â”‚     console.log(`ğŸ“ Dados do quarto ${roomId}:`, {
  920 â”‚       nome: roomData.name,
  921 â”‚       precoBase: roomData.price,
  922 â”‚       taxaServico: roomData.serviceFeePct || 0,
  923 â”‚       temPrecosSazonais: !!roomData.seasonalPrices?.length
  924 â”‚     });
  925 â”‚     
  926 â”‚     const nightlyPrices: { date: string; price: number }[] = [];
  927 â”‚     let totalPrice = 0;
  928 â”‚     
  929 â”‚     // Calcular o nÃºmero de noites - corrigido para usar o mÃ©todo correto de cÃ¡lculo
  930 â”‚     // O nÃºmero de noites Ã© a diferenÃ§a em dias (estadia = checkout - checkin)
  931 â”‚     const noites = differenceInDays(checkOut, checkIn);
  932 â”‚     console.log(`ğŸ—“ï¸ NÃºmero de noites calculado: ${noites}`);
  933 â”‚     
  934 â”‚     if (noites <= 0) {
  935 â”‚       console.error(`âš ï¸ Erro: nÃºmero de noites invÃ¡lido (${noites})`);
  936 â”‚       throw new Error("Data de check-out deve ser posterior Ã  data de check-in");
  937 â”‚     }
  938 â”‚     
  939 â”‚     // Para cada noite, verificar o preÃ§o aplicÃ¡vel (preÃ§o base ou sazonal)
  940 â”‚     // ComeÃ§amos exatamente do dia de check-in
  941 â”‚     const currentDate = new Date(checkIn);
  942 â”‚     currentDate.setHours(0, 0, 0, 0); // Normalizar para meia-noite
  943 â”‚     
  944 â”‚     // Processamos cada dia de estadia (noite)
  945 â”‚     console.log(`ğŸ“Š Calculando preÃ§os por noite:`);
  946 â”‚     for (let i = 0; i < noites; i++) {
  947 â”‚       // Obtemos o preÃ§o para esta data
  948 â”‚       const dateCopy = new Date(currentDate);
  949 â”‚       const priceForDate = await getRoomPriceForDate(roomId, dateCopy);
  950 â”‚       const dateString = dateCopy.toISOString().split('T')[0]; // YYYY-MM-DD
  951 â”‚       
  952 â”‚       console.log(`   - ${dateString}: â‚¬${priceForDate}`);
  953 â”‚       
  954 â”‚       nightlyPrices.push({
  955 â”‚         date: dateString,
  956 â”‚         price: priceForDate
  957 â”‚       });
  958 â”‚       
  959 â”‚       totalPrice += priceForDate;
  960 â”‚       
  961 â”‚       // AvanÃ§amos para o prÃ³ximo dia
  962 â”‚       currentDate.setDate(currentDate.getDate() + 1);
  963 â”‚     }
  964 â”‚     
  965 â”‚     // VerificaÃ§Ã£o de seguranÃ§a para o cÃ¡lculo do totalPrice
  966 â”‚     const manualTotal = nightlyPrices.reduce((sum, night) => sum + night.price, 0);
  967 â”‚     if (Math.abs(totalPrice - manualTotal) > 1) {
  968 â”‚       console.error(`âš ï¸ DiscrepÃ¢ncia detectada no cÃ¡lculo do preÃ§o total!`);
  969 â”‚       console.error(`   - Total calculado iterativamente: â‚¬${totalPrice}`);
  970 â”‚       console.error(`   - Total calculado via reduce: â‚¬${manualTotal}`);
  971 â”‚       console.error(`   - Usando o valor recalculado para seguranÃ§a!`);
  972 â”‚       totalPrice = manualTotal;
  973 â”‚     }
  974 â”‚     
  975 â”‚     // Calcular taxa de serviÃ§o
  976 â”‚     const serviceFee = (totalPrice * (roomData.serviceFeePct || 0)) / 100;
  977 â”‚     const totalWithFee = totalPrice + serviceFee;
  978 â”‚     
  979 â”‚     console.log(`ğŸ’° Resumo do cÃ¡lculo:`);
  980 â”‚     console.log(`   - Total das diÃ¡rias: â‚¬${totalPrice}`);
  981 â”‚     console.log(`   - Taxa de serviÃ§o (${roomData.serviceFeePct || 0}%): â‚¬${serviceFee}`);
  982 â”‚     console.log(`   - Total com taxas: â‚¬${totalWithFee}`);
  983 â”‚     
  984 â”‚     return {
  985 â”‚       totalPrice,
  986 â”‚       nightlyPrices,
  987 â”‚       serviceFee,
  988 â”‚       totalWithFee
  989 â”‚     };
  990 â”‚   } catch (error) {
  991 â”‚     console.error("âŒ Erro ao calcular preÃ§o da estadia:", error);
  992 â”‚     throw error;
  993 â”‚   }
  994 â”‚ } 
  995 â”‚ import { 
  996 â”‚   collection, 
  997 â”‚   getDocs, 
  998 â”‚   getDoc, 
  999 â”‚   doc, 
 1000 â”‚   setDoc, 
 1001 â”‚   addDoc, 
 1002 â”‚   updateDoc, 
 1003 â”‚   deleteDoc,
      Â·   â”€â”€â”€â”€â”¬â”€â”€â”€â”€
      Â·       â•°â”€â”€ `deleteDoc` redefined here
 1004 â”‚   query,
 1005 â”‚   where,
 1006 â”‚   orderBy,
      â•°â”€â”€â”€â”€

  Ã— the name `query` is defined multiple times
      â•­â”€[/home/runner/workspace/lib/firebase/firestore.ts:7:1]
    7 â”‚   getDocs,
    8 â”‚   updateDoc,
    9 â”‚   deleteDoc,
   10 â”‚   query,
      Â·   â”€â”€â”¬â”€â”€
      Â·     â•°â”€â”€ previous definition of `query` here
   11 â”‚   where,
   12 â”‚   orderBy,
   13 â”‚   limit,
   14 â”‚   DocumentData,
   15 â”‚   QueryConstraint,
   16 â”‚   Timestamp,
   17 â”‚   serverTimestamp
   18 â”‚ } from 'firebase/firestore'
   19 â”‚ import { db } from './config'
   20 â”‚ import { Room, SeasonalPrice } from '@/lib/types'
   21 â”‚ import { differenceInDays } from 'date-fns'
   22 â”‚ 
   23 â”‚ // Tipos de dados
   24 â”‚ export interface Booking {
   25 â”‚   id?: string
   26 â”‚   userId?: string
   27 â”‚   guestName: string
   28 â”‚   guestEmail: string
   29 â”‚   guestPhone: string
   30 â”‚   roomId: string
   31 â”‚   roomName: string
   32 â”‚   checkIn: Timestamp
   33 â”‚   checkOut: Timestamp
   34 â”‚   adults: number
   35 â”‚   children: number
   36 â”‚   totalPrice: number
   37 â”‚   status: 'pending' | 'confirmed' | 'cancelled' | 'completed'
   38 â”‚   paymentStatus: 'pending' | 'paid' | 'refunded'
   39 â”‚   specialRequests?: string
   40 â”‚   createdAt?: Timestamp
   41 â”‚   updatedAt?: Timestamp
   42 â”‚ }
   43 â”‚ 
   44 â”‚ export interface Contact {
   45 â”‚   id?: string
   46 â”‚   name: string
   47 â”‚   email: string
   48 â”‚   phone?: string
   49 â”‚   subject: string
   50 â”‚   message: string
   51 â”‚   status: 'new' | 'read' | 'replied'
   52 â”‚   createdAt: Timestamp
   53 â”‚   updatedAt?: Timestamp
   54 â”‚   repliedAt?: Timestamp
   55 â”‚   replyContent?: string
   56 â”‚   reservationDetails?: {
   57 â”‚     checkIn?: Timestamp
   58 â”‚     checkOut?: Timestamp
   59 â”‚     roomId?: string
   60 â”‚     roomName?: string
   61 â”‚     totalGuests?: number
   62 â”‚     totalPrice?: number
   63 â”‚   }
   64 â”‚ }
   65 â”‚ 
   66 â”‚ // FunÃ§Ãµes genÃ©ricas para CRUD
   67 â”‚ export const createDocument = async <T extends DocumentData>(
   68 â”‚   collectionName: string,
   69 â”‚   data: T
   70 â”‚ ): Promise<string> => {
   71 â”‚   const docRef = await addDoc(collection(db, collectionName), {
   72 â”‚     ...data,
   73 â”‚     createdAt: serverTimestamp(),
   74 â”‚     updatedAt: serverTimestamp()
   75 â”‚   })
   76 â”‚   return docRef.id
   77 â”‚ }
   78 â”‚ 
   79 â”‚ export const createDocumentWithId = async <T extends DocumentData>(
   80 â”‚   collectionName: string,
   81 â”‚   id: string,
   82 â”‚   data: T
   83 â”‚ ): Promise<void> => {
   84 â”‚   await setDoc(doc(db, collectionName, id), {
   85 â”‚     ...data,
   86 â”‚     createdAt: serverTimestamp(),
   87 â”‚     updatedAt: serverTimestamp()
   88 â”‚   })
   89 â”‚ }
   90 â”‚ 
   91 â”‚ export const getDocument = async <T>(
   92 â”‚   collectionName: string,
   93 â”‚   id: string
   94 â”‚ ): Promise<T | null> => {
   95 â”‚   const docRef = doc(db, collectionName, id)
   96 â”‚   const docSnap = await getDoc(docRef)
   97 â”‚   
   98 â”‚   if (docSnap.exists()) {
   99 â”‚     const data = docSnap.data();
  100 â”‚     console.log("Dados brutos recuperados do Firestore para quarto:", id, data);
  101 â”‚     
  102 â”‚     if (data?.serviceFeePct !== undefined) {
  103 â”‚       console.log("serviceFeePct antes da conversÃ£o:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
  104 â”‚       // Garantir que serviceFeePct seja um nÃºmero
  105 â”‚       data.serviceFeePct = Number(data.serviceFeePct);
  106 â”‚       console.log("serviceFeePct apÃ³s conversÃ£o:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
  107 â”‚     }
  108 â”‚     
  109 â”‚     return { id: docSnap.id, ...data } as T
  110 â”‚   } else {
  111 â”‚     return null
  112 â”‚   }
  113 â”‚ }
  114 â”‚ 
  115 â”‚ export const getDocuments = async <T>(
  116 â”‚   collectionName: string,
  117 â”‚   constraints: QueryConstraint[] = [],
  118 â”‚   forceRefresh = false
  119 â”‚ ): Promise<T[]> => {
  120 â”‚   try {
  121 â”‚     const collectionRef = collection(db, collectionName)
  122 â”‚     const q = query(collectionRef, ...constraints)
  123 â”‚     
  124 â”‚     // Se forceRefresh for verdadeiro, adicionar opÃ§Ãµes que forÃ§am uma nova consulta ao Firestore
  125 â”‚     const querySnapshot = await getDocs(q)
  126 â”‚     
  127 â”‚     console.log(`Buscando documentos na coleÃ§Ã£o ${collectionName} - ForÃ§a atualizaÃ§Ã£o: ${forceRefresh}`);
  128 â”‚     
  129 â”‚     return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }) as T)
  130 â”‚   } catch (error) {
  131 â”‚     console.error(`Erro ao buscar documentos da coleÃ§Ã£o ${collectionName}:`, error);
  132 â”‚     return [];
  133 â”‚   }
  134 â”‚ }
  135 â”‚ 
  136 â”‚ export const updateDocument = async <T extends DocumentData>(
  137 â”‚   collectionName: string,
  138 â”‚   id: string,
  139 â”‚   data: Partial<T>
  140 â”‚ ): Promise<void> => {
  141 â”‚   const docRef = doc(db, collectionName, id)
  142 â”‚   await updateDoc(docRef, {
  143 â”‚     ...data,
  144 â”‚     updatedAt: serverTimestamp()
  145 â”‚   })
  146 â”‚ }
  147 â”‚ 
  148 â”‚ export const deleteDocument = async (
  149 â”‚   collectionName: string,
  150 â”‚   id: string
  151 â”‚ ): Promise<boolean> => {
  152 â”‚   const docRef = doc(db, collectionName, id)
  153 â”‚   await deleteDoc(docRef)
  154 â”‚   return true
  155 â”‚ }
  156 â”‚ 
  157 â”‚ // FunÃ§Ãµes para gerenciar quartos
  158 â”‚ export const getRooms = async (forceRefresh = false): Promise<Room[]> => {
  159 â”‚   try {
  160 â”‚     const constraints: QueryConstraint[] = []
  161 â”‚     
  162 â”‚     constraints.push(orderBy('name', 'asc'))
  163 â”‚     
  164 â”‚     const rooms = await getDocuments<Room>('rooms', constraints, forceRefresh)
  165 â”‚     
  166 â”‚     // Garantir que todos os campos necessÃ¡rios estejam presentes
  167 â”‚     return rooms.map(room => {
  168 â”‚       console.log(`Firebase - Quarto ${room.id} dados brutos:`, room);
  169 â”‚       
  170 â”‚       // Garantir que serviceFeePct seja um nÃºmero
  171 â”‚       const serviceFeePct = room.serviceFeePct !== undefined 
  172 â”‚         ? Number(room.serviceFeePct) 
  173 â”‚         : 10;
  174 â”‚         
  175 â”‚       console.log(`Firebase - Quarto ${room.id} serviceFeePct:`, {
  176 â”‚         original: room.serviceFeePct,
  177 â”‚         tipo: typeof room.serviceFeePct,
  178 â”‚         convertido: serviceFeePct
  179 â”‚       });
  180 â”‚       
  181 â”‚       return {
  182 â”‚         id: room.id,
  183 â”‚         name: room.name || '',
  184 â”‚         type: room.type || 'standard',
  185 â”‚         description: room.description || '',
  186 â”‚         price: room.price || 0,
  187 â”‚         capacity: room.capacity || 2,
  188 â”‚         size: room.size || 0,
  189 â”‚         available: room.available !== undefined ? room.available : true,
  190 â”‚         serviceFeePct: serviceFeePct,
  191 â”‚         images: room.images || [],
  192 â”‚         amenities: room.amenities || [],
  193 â”‚         additionalServices: room.additionalServices || [],
  194 â”‚         highlights: room.highlights || [],
  195 â”‚         createdAt: room.createdAt,
  196 â”‚         updatedAt: room.updatedAt
  197 â”‚       };
  198 â”‚     });
  199 â”‚   } catch (error) {
  200 â”‚     console.error('Erro ao buscar quartos:', error)
  201 â”‚     return []
  202 â”‚   }
  203 â”‚ }
  204 â”‚ 
  205 â”‚ export const getAvailableRooms = async (
  206 â”‚   checkIn: Date,
  207 â”‚   checkOut: Date
  208 â”‚ ): Promise<Room[]> => {
  209 â”‚   try {
  210 â”‚     // Buscar todos os quartos que estÃ£o marcados como disponÃ­veis em geral
  211 â”‚     const constraints: QueryConstraint[] = [
  212 â”‚       where('available', '==', true)
  213 â”‚     ]
  214 â”‚     
  215 â”‚     const rooms = await getDocuments<Room>('rooms', constraints);
  216 â”‚     
  217 â”‚     // Filtrar os quartos que estÃ£o disponÃ­veis nas datas especÃ­ficas
  218 â”‚     return filterAvailableRoomsByDate(rooms, checkIn, checkOut);
  219 â”‚   } catch (error) {
  220 â”‚     console.error('Erro ao buscar quartos disponÃ­veis:', error)
  221 â”‚     return []
  222 â”‚   }
  223 â”‚ }
  224 â”‚ 
  225 â”‚ // FunÃ§Ã£o auxiliar para verificar disponibilidade entre datas
  226 â”‚ export const filterAvailableRoomsByDate = (
  227 â”‚   rooms: Room[],
  228 â”‚   checkIn: Date,
  229 â”‚   checkOut: Date
  230 â”‚ ): Room[] => {
  231 â”‚   // Converter checkIn e checkOut para ISO strings
  232 â”‚   const dateStrings = getDatesInRange(checkIn, checkOut);
  233 â”‚   
  234 â”‚   return rooms.filter(room => {
  235 â”‚     // Se nÃ£o tiver controle de disponibilidade especÃ­fico, considera disponÃ­vel
  236 â”‚     if (!room.availabilityDates) return true;
  237 â”‚     
  238 â”‚     // Verificar se alguma data no intervalo estÃ¡ indisponÃ­vel
  239 â”‚     return !dateStrings.some(dateStr => 
  240 â”‚       room.availabilityDates?.[dateStr] === false
  241 â”‚     );
  242 â”‚   });
  243 â”‚ };
  244 â”‚ 
  245 â”‚ // FunÃ§Ã£o para obter disponibilidade de um quarto especÃ­fico
  246 â”‚ export const getRoomAvailability = async (
  247 â”‚   roomId: string, 
  248 â”‚   startDate: Date, 
  249 â”‚   endDate: Date
  250 â”‚ ): Promise<{[date: string]: boolean}> => {
  251 â”‚   try {
  252 â”‚     const room = await getRoomById(roomId);
  253 â”‚     if (!room) throw new Error(`Quarto com ID ${roomId} nÃ£o encontrado`);
  254 â”‚     
  255 â”‚     // Gerar datas no intervalo
  256 â”‚     const dateStrings = getDatesInRange(startDate, endDate);
  257 â”‚     
  258 â”‚     // Se nÃ£o tiver configuraÃ§Ã£o de disponibilidade especÃ­fica, assume tudo disponÃ­vel
  259 â”‚     if (!room.availabilityDates) {
  260 â”‚       return dateStrings.reduce((acc, date) => {
  261 â”‚         acc[date] = true;
  262 â”‚         return acc;
  263 â”‚       }, {} as {[date: string]: boolean});
  264 â”‚     }
  265 â”‚     
  266 â”‚     // Preencher com os dados de disponibilidade existentes
  267 â”‚     return dateStrings.reduce((acc, date) => {
  268 â”‚       acc[date] = room.availabilityDates?.[date] !== false; // disponÃ­vel por padrÃ£o se nÃ£o estiver explicitamente indisponÃ­vel
  269 â”‚       return acc;
  270 â”‚     }, {} as {[date: string]: boolean});
  271 â”‚   } catch (error) {
  272 â”‚     console.error(`Erro ao verificar disponibilidade do quarto ${roomId}:`, error);
  273 â”‚     throw error;
  274 â”‚   }
  275 â”‚ };
  276 â”‚ 
  277 â”‚ // FunÃ§Ã£o para atualizar disponibilidade de um quarto
  278 â”‚ export const updateRoomAvailability = async (
  279 â”‚   roomId: string,
  280 â”‚   availabilityDates: {[date: string]: boolean}
  281 â”‚ ): Promise<boolean> => {
  282 â”‚   try {
  283 â”‚     await updateDocument('rooms', roomId, {
  284 â”‚       availabilityDates,
  285 â”‚       updatedAt: serverTimestamp()
  286 â”‚     });
  287 â”‚     return true;
  288 â”‚   } catch (error) {
  289 â”‚     console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  290 â”‚     return false;
  291 â”‚   }
  292 â”‚ };
  293 â”‚ 
  294 â”‚ // FunÃ§Ã£o auxiliar para gerar array de strings de data entre um intervalo
  295 â”‚ export const getDatesInRange = (startDate: Date, endDate: Date): string[] => {
  296 â”‚   const dates: string[] = [];
  297 â”‚   const currentDate = new Date(startDate);
  298 â”‚   
  299 â”‚   // Normalizar para meia-noite no fuso horÃ¡rio local
  300 â”‚   currentDate.setHours(0, 0, 0, 0);
  301 â”‚   const endDateNormalized = new Date(endDate);
  302 â”‚   endDateNormalized.setHours(0, 0, 0, 0);
  303 â”‚   
  304 â”‚   // Adicionar cada data no intervalo EXCETO o dia de checkout
  305 â”‚   // Usando < em vez de <= para nÃ£o incluir o dia de checkout
  306 â”‚   while (currentDate < endDateNormalized) {
  307 â”‚     dates.push(currentDate.toISOString().split('T')[0]); // Formato YYYY-MM-DD
  308 â”‚     currentDate.setDate(currentDate.getDate() + 1);
  309 â”‚   }
  310 â”‚   
  311 â”‚   return dates;
  312 â”‚ };
  313 â”‚ 
  314 â”‚ export const getRoomById = async (id: string): Promise<Room | null> => {
  315 â”‚   try {
  316 â”‚     const room = await getDocument<Room>('rooms', id);
  317 â”‚     
  318 â”‚     if (!room) return null;
  319 â”‚     
  320 â”‚     console.log(`Firebase - getRoomById ${id} dados brutos:`, room);
  321 â”‚     
  322 â”‚     // Log especÃ­fico para serviceFeePct
  323 â”‚     console.log(`serviceFeePct no Firestore:`, room.serviceFeePct);
  324 â”‚     
  325 â”‚     // Garantir que todos os campos necessÃ¡rios estejam presentes
  326 â”‚     return {
  327 â”‚       ...room,
  328 â”‚       name: room.name || '',
  329 â”‚       type: room.type || 'standard',
  330 â”‚       description: room.description || '',
  331 â”‚       price: room.price || 0,
  332 â”‚       capacity: room.capacity || 2,
  333 â”‚       size: room.size || 0,
  334 â”‚       available: room.available !== undefined ? room.available : true,
  335 â”‚       serviceFeePct: room.serviceFeePct !== undefined ? room.serviceFeePct : 10,
  336 â”‚       images: room.images || [],
  337 â”‚       amenities: room.amenities || [],
  338 â”‚       additionalServices: room.additionalServices || [],
  339 â”‚       highlights: room.highlights || []
  340 â”‚     };
  341 â”‚   } catch (error) {
  342 â”‚     console.error(`Erro ao buscar quarto com ID ${id}:`, error);
  343 â”‚     return null;
  344 â”‚   }
  345 â”‚ }
  346 â”‚ 
  347 â”‚ export const createRoom = async (roomData: Omit<Room, 'id' | 'createdAt' | 'updatedAt'>): Promise<Room> => {
  348 â”‚   try {
  349 â”‚     console.log("createRoom - Dados recebidos:", roomData);
  350 â”‚     
  351 â”‚     const roomWithTimestamps = {
  352 â”‚       ...roomData,
  353 â”‚       available: roomData.available !== undefined ? roomData.available : true,
  354 â”‚       featured: roomData.featured || false,
  355 â”‚       amenities: roomData.amenities || [],
  356 â”‚       additionalServices: roomData.additionalServices || [],
  357 â”‚       highlights: roomData.highlights || [],
  358 â”‚       createdAt: serverTimestamp(),
  359 â”‚       updatedAt: serverTimestamp()
  360 â”‚     }
  361 â”‚     
  362 â”‚     console.log("createRoom - Dados a serem salvos:", roomWithTimestamps);
  363 â”‚     
  364 â”‚     const id = await createDocument('rooms', roomWithTimestamps)
  365 â”‚     
  366 â”‚     return {
  367 â”‚       id,
  368 â”‚       ...roomData,
  369 â”‚       amenities: roomData.amenities || [],
  370 â”‚       additionalServices: roomData.additionalServices || [],
  371 â”‚       highlights: roomData.highlights || [],
  372 â”‚       createdAt: Timestamp.now(),
  373 â”‚       updatedAt: Timestamp.now()
  374 â”‚     }
  375 â”‚   } catch (error) {
  376 â”‚     console.error('Erro ao criar quarto:', error)
  377 â”‚     throw error
  378 â”‚   }
  379 â”‚ }
  380 â”‚ 
  381 â”‚ export const updateRoom = async (id: string, roomData: Partial<Omit<Room, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Room> => {
  382 â”‚   try {
  383 â”‚     console.log(`updateRoom - ID: ${id}, Dados recebidos:`, roomData);
  384 â”‚     
  385 â”‚     // Garantir que estamos lidando explicitamente com o serviceFeePct se ele for 0
  386 â”‚     if (roomData.serviceFeePct === 0) {
  387 â”‚       console.log("updateRoom - Detectado serviceFeePct com valor 0, salvando explicitamente.", roomData.serviceFeePct);
  388 â”‚     }
  389 â”‚     
  390 â”‚     // Adicionar timestamp de atualizaÃ§Ã£o
  391 â”‚     const roomWithTimestamp = {
  392 â”‚       ...roomData,
  393 â”‚       amenities: roomData.amenities || [],
  394 â”‚       additionalServices: roomData.additionalServices || [],
  395 â”‚       highlights: roomData.highlights || [],
  396 â”‚       updatedAt: serverTimestamp()
  397 â”‚     }
  398 â”‚     
  399 â”‚     console.log(`updateRoom - Dados a serem salvos:`, roomWithTimestamp);
  400 â”‚     
  401 â”‚     await updateDocument('rooms', id, roomWithTimestamp)
  402 â”‚     
  403 â”‚     const updatedRoom = await getRoomById(id)
  404 â”‚     if (!updatedRoom) {
  405 â”‚       throw new Error(`Quarto com ID ${id} nÃ£o encontrado apÃ³s atualizaÃ§Ã£o`)
  406 â”‚     }
  407 â”‚     
  408 â”‚     return updatedRoom
  409 â”‚   } catch (error) {
  410 â”‚     console.error('Erro ao atualizar quarto:', error)
  411 â”‚     throw error
  412 â”‚   }
  413 â”‚ }
  414 â”‚ 
  415 â”‚ export const deleteRoom = async (id: string): Promise<boolean> => {
  416 â”‚   return await deleteDocument('rooms', id)
  417 â”‚ }
  418 â”‚ 
  419 â”‚ // FunÃ§Ãµes especÃ­ficas para reservas
  420 â”‚ export const createBooking = async (bookingData: any) => {
  421 â”‚   try {
  422 â”‚     const bookingsCollection = collection(db, 'bookings');
  423 â”‚     const docRef = await addDoc(bookingsCollection, bookingData);
  424 â”‚     
  425 â”‚     // CORREÃ‡ÃƒO: NÃ£o bloquear a data no momento da criaÃ§Ã£o da reserva
  426 â”‚     // O bloqueio serÃ¡ feito apenas quando o pagamento for confirmado
  427 â”‚     // atravÃ©s da funÃ§Ã£o updateBookingStatus
  428 â”‚     
  429 â”‚     return docRef;
  430 â”‚   } catch (error) {
  431 â”‚     console.error('Erro ao criar reserva:', error);
  432 â”‚     throw error;
  433 â”‚   }
  434 â”‚ };
  435 â”‚ 
  436 â”‚ // Nova funÃ§Ã£o para atualizar status da reserva e bloquear as datas da estadia
  437 â”‚ export const updateBookingStatus = async (
  438 â”‚   bookingId: string, 
  439 â”‚   newStatus: 'pending' | 'confirmed' | 'cancelled' | 'completed',
  440 â”‚   newPaymentStatus: 'pending' | 'paid' | 'refunded'
  441 â”‚ ): Promise<boolean> => {
  442 â”‚   try {
  443 â”‚     // ReferÃªncia ao documento da reserva
  444 â”‚     const bookingRef = doc(db, 'bookings', bookingId);
  445 â”‚     const bookingSnap = await getDoc(bookingRef);
  446 â”‚     
  447 â”‚     if (!bookingSnap.exists()) {
  448 â”‚       console.error(`Booking ${bookingId} nÃ£o existe ao atualizar status`);
  449 â”‚       return false;
  450 â”‚     }
  451 â”‚     
  452 â”‚     const bookingData = bookingSnap.data();
  453 â”‚     
  454 â”‚     // Atualizar o status da reserva
  455 â”‚     await updateDoc(bookingRef, {
  456 â”‚       status: newStatus,
  457 â”‚       paymentStatus: newPaymentStatus,
  458 â”‚       updatedAt: serverTimestamp(),
  459 â”‚       ...(newStatus === 'confirmed' && { confirmedAt: serverTimestamp() })
  460 â”‚     });
  461 â”‚     
  462 â”‚     // Se a reserva estÃ¡ sendo confirmada, precisamos bloquear as datas
  463 â”‚     if (newStatus === 'confirmed') {
  464 â”‚       console.log(`Atualizando disponibilidade para reserva confirmada: ${bookingId}`);
  465 â”‚       
  466 â”‚       // Recuperar datas de check-in e check-out
  467 â”‚       const checkIn = bookingData.checkIn.toDate();
  468 â”‚       const checkOut = bookingData.checkOut.toDate();
  469 â”‚       const roomId = bookingData.roomId;
  470 â”‚       
  471 â”‚       // Obter todas as datas entre check-in e check-out
  472 â”‚       const dates: Date[] = [];
  473 â”‚       const currentDate = new Date(checkIn);
  474 â”‚       
  475 â”‚       while (currentDate < checkOut) {
  476 â”‚         dates.push(new Date(currentDate));
  477 â”‚         currentDate.setDate(currentDate.getDate() + 1);
  478 â”‚       }
  479 â”‚       
  480 â”‚       console.log(`Bloqueando ${dates.length} dias para quarto ${roomId}`);
  481 â”‚       
  482 â”‚       // Atualizar disponibilidade para cada data
  483 â”‚       const availabilityUpdates: {[date: string]: boolean} = {};
  484 â”‚       
  485 â”‚       dates.forEach(date => {
  486 â”‚         const dateString = date.toISOString().split('T')[0]; // formato YYYY-MM-DD
  487 â”‚         availabilityUpdates[dateString] = false; // false significa indisponÃ­vel
  488 â”‚       });
  489 â”‚       
  490 â”‚       // Atualizar disponibilidade do quarto
  491 â”‚       if (Object.keys(availabilityUpdates).length > 0) {
  492 â”‚         try {
  493 â”‚           // Obter o documento do quarto
  494 â”‚           const roomRef = doc(db, 'rooms', roomId);
  495 â”‚           const roomSnap = await getDoc(roomRef);
  496 â”‚           
  497 â”‚           if (roomSnap.exists()) {
  498 â”‚             const roomData = roomSnap.data();
  499 â”‚             const currentAvailability = roomData.availabilityDates || {};
  500 â”‚             
  501 â”‚             // Mesclar a disponibilidade atual com as novas atualizaÃ§Ãµes
  502 â”‚             const updatedAvailability = {
  503 â”‚               ...currentAvailability,
  504 â”‚               ...availabilityUpdates
  505 â”‚             };
  506 â”‚             
  507 â”‚             // Atualizar o documento do quarto
  508 â”‚             await updateDoc(roomRef, {
  509 â”‚               availabilityDates: updatedAvailability,
  510 â”‚               updatedAt: serverTimestamp()
  511 â”‚             });
  512 â”‚             
  513 â”‚             console.log(`Disponibilidade atualizada com sucesso para quarto ${roomId}`);
  514 â”‚             
  515 â”‚             // Criar log da reserva
  516 â”‚             await addDoc(collection(db, 'bookingLogs'), {
  517 â”‚               bookingId,
  518 â”‚               roomId,
  519 â”‚               action: 'status_updated',
  520 â”‚               previousStatus: bookingData.status,
  521 â”‚               newStatus,
  522 â”‚               previousPaymentStatus: bookingData.paymentStatus,
  523 â”‚               newPaymentStatus,
  524 â”‚               datesBlocked: Object.keys(availabilityUpdates),
  525 â”‚               timestamp: serverTimestamp(),
  526 â”‚               userId: bookingData.userId || 'system'
  527 â”‚             });
  528 â”‚           } else {
  529 â”‚             console.error(`Quarto ${roomId} nÃ£o encontrado ao atualizar disponibilidade`);
  530 â”‚           }
  531 â”‚         } catch (error) {
  532 â”‚           console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  533 â”‚         }
  534 â”‚       }
  535 â”‚     }
  536 â”‚     
  537 â”‚     return true;
  538 â”‚   } catch (error) {
  539 â”‚     console.error(`Erro ao atualizar status da reserva ${bookingId}:`, error);
  540 â”‚     return false;
  541 â”‚   }
  542 â”‚ }
  543 â”‚ 
  544 â”‚ export const getUserBookings = async (userId: string): Promise<Booking[]> => {
  545 â”‚   return getDocuments<Booking>('bookings', [
  546 â”‚     where('userId', '==', userId),
  547 â”‚     orderBy('createdAt', 'desc')
  548 â”‚   ])
  549 â”‚ }
  550 â”‚ 
  551 â”‚ export const getRecentBookings = async (count = 5): Promise<Booking[]> => {
  552 â”‚   return getDocuments<Booking>('bookings', [
  553 â”‚     orderBy('createdAt', 'desc'),
  554 â”‚     limit(count)
  555 â”‚   ])
  556 â”‚ }
  557 â”‚ 
  558 â”‚ export const getRoomBookings = async (roomId: string): Promise<Booking[]> => {
  559 â”‚   try {
  560 â”‚     const constraints: QueryConstraint[] = [
  561 â”‚       where('roomId', '==', roomId),
  562 â”‚       orderBy('checkIn', 'asc')
  563 â”‚     ];
  564 â”‚     
  565 â”‚     return await getDocuments<Booking>('bookings', constraints);
  566 â”‚   } catch (error) {
  567 â”‚     console.error(`Erro ao buscar reservas do quarto ${roomId}:`, error);
  568 â”‚     return [];
  569 â”‚   }
  570 â”‚ };
  571 â”‚ 
  572 â”‚ // FunÃ§Ãµes especÃ­ficas para contatos
  573 â”‚ export const createContactMessage = async (contactData: Contact) => {
  574 â”‚   try {
  575 â”‚     const contactsCollection = collection(db, 'contacts')
  576 â”‚     
  577 â”‚     // Garantir que o status seja 'new' para novos contatos
  578 â”‚     const contactWithDefaults = {
  579 â”‚       ...contactData,
  580 â”‚       status: contactData.status || 'new',
  581 â”‚       createdAt: contactData.createdAt || Timestamp.now()
  582 â”‚     }
  583 â”‚     
  584 â”‚     // Se tiver detalhes de reserva, adicionar metadados
  585 â”‚     if (contactWithDefaults.reservationDetails) {
  586 â”‚       // Ajustar subject para indicar que Ã© relacionado a reserva
  587 â”‚       if (!contactWithDefaults.subject.includes('Reserva')) {
  588 â”‚         contactWithDefaults.subject = `Reserva: ${contactWithDefaults.subject}`;
  589 â”‚       }
  590 â”‚     }
  591 â”‚     
  592 â”‚     const docRef = await addDoc(contactsCollection, contactWithDefaults)
  593 â”‚     return docRef
  594 â”‚   } catch (error) {
  595 â”‚     console.error('Erro ao criar mensagem de contato:', error)
  596 â”‚     throw error
  597 â”‚   }
  598 â”‚ }
  599 â”‚ 
  600 â”‚ export const getNewContactMessages = async (): Promise<Contact[]> => {
  601 â”‚   return getDocuments<Contact>('contacts', [
  602 â”‚     where('status', '==', 'new'),
  603 â”‚     orderBy('createdAt', 'desc')
  604 â”‚   ])
  605 â”‚ }
  606 â”‚ 
  607 â”‚ // FunÃ§Ãµes para Dashboard com dados reais
  608 â”‚ 
  609 â”‚ export const getDashboardStats = async () => {
  610 â”‚   try {
  611 â”‚     const [totalBookings, totalRevenue, occupancyRate, bookingsByPlatform] = await Promise.all([
  612 â”‚       getTotalBookings(),
  613 â”‚       getMonthlyRevenue(),
  614 â”‚       getOccupancyRate(),
  615 â”‚       getBookingsByPlatform()
  616 â”‚     ]);
  617 â”‚ 
  618 â”‚     return {
  619 â”‚       totalBookings,
  620 â”‚       totalRevenue,
  621 â”‚       occupancyRate,
  622 â”‚       bookingsByPlatform
  623 â”‚     };
  624 â”‚   } catch (error) {
  625 â”‚     console.error('Erro ao obter estatÃ­sticas do dashboard:', error);
  626 â”‚     throw error;
  627 â”‚   }
  628 â”‚ };
  629 â”‚ 
  630 â”‚ // Obter total de reservas
  631 â”‚ export const getTotalBookings = async () => {
  632 â”‚   try {
  633 â”‚     // Obter todas as reservas
  634 â”‚     const bookings = await getDocuments<Booking>('bookings');
  635 â”‚     
  636 â”‚     // Contar reservas por status
  637 â”‚     const confirmed = bookings.filter(b => b.status === 'confirmed').length;
  638 â”‚     const pending = bookings.filter(b => b.status === 'pending').length;
  639 â”‚     const cancelled = bookings.filter(b => b.status === 'cancelled').length;
  640 â”‚     const completed = bookings.filter(b => b.status === 'completed').length;
  641 â”‚     
  642 â”‚     // Calcular crescimento em relaÃ§Ã£o ao mÃªs anterior (simulado por enquanto)
  643 â”‚     // Em uma implementaÃ§Ã£o real, vocÃª compararia com dados do mÃªs anterior
  644 â”‚     const growth = ((confirmed + completed) / (bookings.length || 1) * 100) - 50;
  645 â”‚     
  646 â”‚     return {
  647 â”‚       total: bookings.length,
  648 â”‚       confirmed,
  649 â”‚       pending,
  650 â”‚       cancelled,
  651 â”‚       completed,
  652 â”‚       growth: Math.round(growth) // Arredonda para nÃºmero inteiro
  653 â”‚     };
  654 â”‚   } catch (error) {
  655 â”‚     console.error('Erro ao obter total de reservas:', error);
  656 â”‚     return {
  657 â”‚       total: 0,
  658 â”‚       confirmed: 0,
  659 â”‚       pending: 0, 
  660 â”‚       cancelled: 0,
  661 â”‚       completed: 0,
  662 â”‚       growth: 0
  663 â”‚     };
  664 â”‚   }
  665 â”‚ };
  666 â”‚ 
  667 â”‚ // Obter receita mensal
  668 â”‚ export const getMonthlyRevenue = async () => {
  669 â”‚   try {
  670 â”‚     const bookings = await getDocuments<Booking>('bookings');
  671 â”‚     
  672 â”‚     // Filtrar reservas confirmadas e concluÃ­das
  673 â”‚     const validBookings = bookings.filter(b => 
  674 â”‚       b.status === 'confirmed' || b.status === 'completed'
  675 â”‚     );
  676 â”‚     
  677 â”‚     // Calcular receita total
  678 â”‚     const totalRevenue = validBookings.reduce((acc, booking) => acc + booking.totalPrice, 0);
  679 â”‚     
  680 â”‚     // Agrupar receita por mÃªs
  681 â”‚     const revenueByMonth = validBookings.reduce((acc, booking) => {
  682 â”‚       const date = booking.checkIn.toDate();
  683 â”‚       const month = date.getMonth(); // 0-11
  684 â”‚       const year = date.getFullYear();
  685 â”‚       const key = `${year}-${month}`;
  686 â”‚       
  687 â”‚       if (!acc[key]) {
  688 â”‚         acc[key] = 0;
  689 â”‚       }
  690 â”‚       acc[key] += booking.totalPrice;
  691 â”‚       return acc;
  692 â”‚     }, {} as Record<string, number>);
  693 â”‚     
  694 â”‚     // Converter para formato de array para grÃ¡fico
  695 â”‚     const monthNames = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
  696 â”‚     
  697 â”‚     const currentDate = new Date();
  698 â”‚     const currentMonth = currentDate.getMonth();
  699 â”‚     const currentYear = currentDate.getFullYear();
  700 â”‚     
  701 â”‚     const revenueData = [];
  702 â”‚     
  703 â”‚     // Gerar dados dos Ãºltimos 12 meses
  704 â”‚     for (let i = 0; i < 12; i++) {
  705 â”‚       const month = (currentMonth - i + 12) % 12;
  706 â”‚       const year = currentMonth - i < 0 ? currentYear - 1 : currentYear;
  707 â”‚       const key = `${year}-${month}`;
  708 â”‚       
  709 â”‚       revenueData.unshift({
  710 â”‚         month: monthNames[month],
  711 â”‚         value: revenueByMonth[key] || 0
  712 â”‚       });
  713 â”‚     }
  714 â”‚     
  715 â”‚     // Calcular crescimento em relaÃ§Ã£o ao mÃªs anterior
  716 â”‚     const lastMonthRevenue = revenueData[revenueData.length - 2]?.value || 0;
  717 â”‚     const currentMonthRevenue = revenueData[revenueData.length - 1]?.value || 0;
  718 â”‚     
  719 â”‚     const growth = lastMonthRevenue ? ((currentMonthRevenue - lastMonthRevenue) / lastMonthRevenue) * 100 : 0;
  720 â”‚     
  721 â”‚     return {
  722 â”‚       monthly: currentMonthRevenue,
  723 â”‚       total: totalRevenue,
  724 â”‚       growth: Math.round(growth),
  725 â”‚       revenueData
  726 â”‚     };
  727 â”‚   } catch (error) {
  728 â”‚     console.error('Erro ao obter receita mensal:', error);
  729 â”‚     return {
  730 â”‚       monthly: 0,
  731 â”‚       total: 0,
  732 â”‚       growth: 0,
  733 â”‚       revenueData: []
  734 â”‚     };
  735 â”‚   }
  736 â”‚ };
  737 â”‚ 
  738 â”‚ // Calcular taxa de ocupaÃ§Ã£o
  739 â”‚ export const getOccupancyRate = async () => {
  740 â”‚   try {
  741 â”‚     // Obter todos os quartos
  742 â”‚     const rooms = await getDocuments<Room>('rooms');
  743 â”‚     const totalRooms = rooms.length;
  744 â”‚     
  745 â”‚     if (totalRooms === 0) {
  746 â”‚       return { rate: 0, growth: 0 };
  747 â”‚     }
  748 â”‚     
  749 â”‚     // Obter todas as reservas
  750 â”‚     const bookings = await getDocuments<Booking>('bookings');
  751 â”‚     
  752 â”‚     // Filtrar reservas confirmadas e concluÃ­das para o mÃªs atual
  753 â”‚     const currentDate = new Date();
  754 â”‚     const currentMonth = currentDate.getMonth();
  755 â”‚     const currentYear = currentDate.getFullYear();
  756 â”‚     
  757 â”‚     const currentMonthBookings = bookings.filter(booking => {
  758 â”‚       const checkInDate = booking.checkIn.toDate();
  759 â”‚       return (
  760 â”‚         (booking.status === 'confirmed' || booking.status === 'completed') &&
  761 â”‚         checkInDate.getMonth() === currentMonth &&
  762 â”‚         checkInDate.getFullYear() === currentYear
  763 â”‚       );
  764 â”‚     });
  765 â”‚     
  766 â”‚     // Calcular dias ocupados por quarto
  767 â”‚     const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
  768 â”‚     const totalPossibleRoomDays = totalRooms * daysInMonth;
  769 â”‚     
  770 â”‚     // Contar dias ocupados (simplificado - em produÃ§Ã£o seria mais complexo)
  771 â”‚     let occupiedDays = 0;
  772 â”‚     
  773 â”‚     currentMonthBookings.forEach(booking => {
  774 â”‚       const checkIn = booking.checkIn.toDate();
  775 â”‚       const checkOut = booking.checkOut.toDate();
  776 â”‚       
  777 â”‚       // Ajustar datas para considerar apenas o mÃªs atual
  778 â”‚       const startDate = new Date(Math.max(
  779 â”‚         checkIn.getTime(),
  780 â”‚         new Date(currentYear, currentMonth, 1).getTime()
  781 â”‚       ));
  782 â”‚       const endDate = new Date(Math.min(
  783 â”‚         checkOut.getTime(),
  784 â”‚         new Date(currentYear, currentMonth + 1, 0).getTime()
  785 â”‚       ));
  786 â”‚       
  787 â”‚       // Calcular dias entre datas (incluindo check-in, excluindo check-out)
  788 â”‚       const days = Math.max(0, Math.floor((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)));
  789 â”‚       occupiedDays += days;
  790 â”‚     });
  791 â”‚     
  792 â”‚     const occupancyRate = (occupiedDays / totalPossibleRoomDays) * 100;
  793 â”‚     
  794 â”‚     // SimulaÃ§Ã£o de crescimento (em produÃ§Ã£o, compararia com mÃªs anterior)
  795 â”‚     const growth = occupancyRate > 50 ? 5 : -3;
  796 â”‚     
  797 â”‚     return {
  798 â”‚       rate: Math.round(occupancyRate),
  799 â”‚       growth: Math.round(growth)
  800 â”‚     };
  801 â”‚   } catch (error) {
  802 â”‚     console.error('Erro ao calcular taxa de ocupaÃ§Ã£o:', error);
  803 â”‚     return { rate: 0, growth: 0 };
  804 â”‚   }
  805 â”‚ };
  806 â”‚ 
  807 â”‚ // Obter reservas agrupadas por plataforma
  808 â”‚ export const getBookingsByPlatform = async () => {
  809 â”‚   try {
  810 â”‚     const bookings = await getDocuments<Booking>('bookings');
  811 â”‚     
  812 â”‚     // Categorizar reservas por origem
  813 â”‚     const platforms = [
  814 â”‚       { 
  815 â”‚         platform: "Booking.com", 
  816 â”‚         color: "#003580", 
  817 â”‚         icon: "Globe",
  818 â”‚         bookings: []
  819 â”‚       },
  820 â”‚       { 
  821 â”‚         platform: "Airbnb", 
  822 â”‚         color: "#FF5A5F", 
  823 â”‚         icon: "Heart",
  824 â”‚         bookings: []
  825 â”‚       },
  826 â”‚       { 
  827 â”‚         platform: "Direto", 
  828 â”‚         color: "#4CAF50", 
  829 â”‚         icon: "Home",
  830 â”‚         bookings: []
  831 â”‚       }
  832 â”‚     ];
  833 â”‚     
  834 â”‚     // Para fins de demonstraÃ§Ã£o, colocar todas as reservas como "Direto" por enquanto
  835 â”‚     // Em produÃ§Ã£o, usaria um campo "platformOrigin" ou similar na tabela de reservas
  836 â”‚     const platformIndex = 2; // Ãndice da plataforma "Direto"
  837 â”‚     
  838 â”‚     bookings.forEach(booking => {
  839 â”‚       // Transformar para o formato esperado pelo componente
  840 â”‚       const transformedBooking = {
  841 â”‚         id: booking.id || '',
  842 â”‚         guestName: booking.guestName,
  843 â”‚         roomName: booking.roomName,
  844 â”‚         checkIn: booking.checkIn.toDate().toLocaleDateString('pt-PT'),
  845 â”‚         checkOut: booking.checkOut.toDate().toLocaleDateString('pt-PT'),
  846 â”‚         status: booking.status,
  847 â”‚         value: new Intl.NumberFormat('pt-PT', {
  848 â”‚           style: 'currency',
  849 â”‚           currency: 'EUR'
  850 â”‚         }).format(booking.totalPrice)
  851 â”‚       };
  852 â”‚       
  853 â”‚       // Adicionar Ã  plataforma "Direto"
  854 â”‚       (platforms[platformIndex] as any).bookings.push(transformedBooking);
  855 â”‚     });
  856 â”‚     
  857 â”‚     return platforms;
  858 â”‚   } catch (error) {
  859 â”‚     console.error('Erro ao obter reservas por plataforma:', error);
  860 â”‚     return [];
  861 â”‚   }
  862 â”‚ };
  863 â”‚ 
  864 â”‚ // FunÃ§Ã£o para obter o preÃ§o de um quarto para uma data especÃ­fica
  865 â”‚ export const getRoomPriceForDate = async (roomId: string, date: Date): Promise<number> => {
  866 â”‚   try {
  867 â”‚     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  868 â”‚     
  869 â”‚     if (!roomDoc.exists()) {
  870 â”‚       throw new Error("Quarto nÃ£o encontrado");
  871 â”‚     }
  872 â”‚     
  873 â”‚     const roomData = roomDoc.data() as Room;
  874 â”‚     const basePrice = roomData.price;
  875 â”‚     
  876 â”‚     if (!roomData.seasonalPrices || roomData.seasonalPrices.length === 0) {
  877 â”‚       return basePrice;
  878 â”‚     }
  879 â”‚     
  880 â”‚     // Verificar se a data estÃ¡ dentro de algum perÃ­odo sazonal
  881 â”‚     for (const seasonalPrice of roomData.seasonalPrices) {
  882 â”‚       const startDate = new Date(seasonalPrice.startDate);
  883 â”‚       const endDate = new Date(seasonalPrice.endDate);
  884 â”‚       
  885 â”‚       if (date >= startDate && date <= endDate) {
  886 â”‚         return seasonalPrice.price;
  887 â”‚       }
  888 â”‚     }
  889 â”‚     
  890 â”‚     // Se nÃ£o cair em nenhum perÃ­odo sazonal, retorna o preÃ§o base
  891 â”‚     return basePrice;
  892 â”‚   } catch (error) {
  893 â”‚     console.error("Erro ao obter preÃ§o do quarto:", error);
  894 â”‚     throw error;
  895 â”‚   }
  896 â”‚ }
  897 â”‚ 
  898 â”‚ // FunÃ§Ã£o para calcular o preÃ§o total de uma estadia
  899 â”‚ export const calculateStayPrice = async (
  900 â”‚   roomId: string, 
  901 â”‚   checkIn: Date, 
  902 â”‚   checkOut: Date
  903 â”‚ ): Promise<{
  904 â”‚   totalPrice: number;
  905 â”‚   nightlyPrices: { date: string; price: number }[];
  906 â”‚   serviceFee: number;
  907 â”‚   totalWithFee: number;
  908 â”‚ }> => {
  909 â”‚   try {
  910 â”‚     console.log(`ğŸ” Iniciando cÃ¡lculo de preÃ§o para estadia: ${checkIn.toISOString().split('T')[0]} atÃ© ${checkOut.toISOString().split('T')[0]}`);
  911 â”‚     
  912 â”‚     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  913 â”‚     
  914 â”‚     if (!roomDoc.exists()) {
  915 â”‚       throw new Error("Quarto nÃ£o encontrado");
  916 â”‚     }
  917 â”‚     
  918 â”‚     const roomData = roomDoc.data() as Room;
  919 â”‚     console.log(`ğŸ“ Dados do quarto ${roomId}:`, {
  920 â”‚       nome: roomData.name,
  921 â”‚       precoBase: roomData.price,
  922 â”‚       taxaServico: roomData.serviceFeePct || 0,
  923 â”‚       temPrecosSazonais: !!roomData.seasonalPrices?.length
  924 â”‚     });
  925 â”‚     
  926 â”‚     const nightlyPrices: { date: string; price: number }[] = [];
  927 â”‚     let totalPrice = 0;
  928 â”‚     
  929 â”‚     // Calcular o nÃºmero de noites - corrigido para usar o mÃ©todo correto de cÃ¡lculo
  930 â”‚     // O nÃºmero de noites Ã© a diferenÃ§a em dias (estadia = checkout - checkin)
  931 â”‚     const noites = differenceInDays(checkOut, checkIn);
  932 â”‚     console.log(`ğŸ—“ï¸ NÃºmero de noites calculado: ${noites}`);
  933 â”‚     
  934 â”‚     if (noites <= 0) {
  935 â”‚       console.error(`âš ï¸ Erro: nÃºmero de noites invÃ¡lido (${noites})`);
  936 â”‚       throw new Error("Data de check-out deve ser posterior Ã  data de check-in");
  937 â”‚     }
  938 â”‚     
  939 â”‚     // Para cada noite, verificar o preÃ§o aplicÃ¡vel (preÃ§o base ou sazonal)
  940 â”‚     // ComeÃ§amos exatamente do dia de check-in
  941 â”‚     const currentDate = new Date(checkIn);
  942 â”‚     currentDate.setHours(0, 0, 0, 0); // Normalizar para meia-noite
  943 â”‚     
  944 â”‚     // Processamos cada dia de estadia (noite)
  945 â”‚     console.log(`ğŸ“Š Calculando preÃ§os por noite:`);
  946 â”‚     for (let i = 0; i < noites; i++) {
  947 â”‚       // Obtemos o preÃ§o para esta data
  948 â”‚       const dateCopy = new Date(currentDate);
  949 â”‚       const priceForDate = await getRoomPriceForDate(roomId, dateCopy);
  950 â”‚       const dateString = dateCopy.toISOString().split('T')[0]; // YYYY-MM-DD
  951 â”‚       
  952 â”‚       console.log(`   - ${dateString}: â‚¬${priceForDate}`);
  953 â”‚       
  954 â”‚       nightlyPrices.push({
  955 â”‚         date: dateString,
  956 â”‚         price: priceForDate
  957 â”‚       });
  958 â”‚       
  959 â”‚       totalPrice += priceForDate;
  960 â”‚       
  961 â”‚       // AvanÃ§amos para o prÃ³ximo dia
  962 â”‚       currentDate.setDate(currentDate.getDate() + 1);
  963 â”‚     }
  964 â”‚     
  965 â”‚     // VerificaÃ§Ã£o de seguranÃ§a para o cÃ¡lculo do totalPrice
  966 â”‚     const manualTotal = nightlyPrices.reduce((sum, night) => sum + night.price, 0);
  967 â”‚     if (Math.abs(totalPrice - manualTotal) > 1) {
  968 â”‚       console.error(`âš ï¸ DiscrepÃ¢ncia detectada no cÃ¡lculo do preÃ§o total!`);
  969 â”‚       console.error(`   - Total calculado iterativamente: â‚¬${totalPrice}`);
  970 â”‚       console.error(`   - Total calculado via reduce: â‚¬${manualTotal}`);
  971 â”‚       console.error(`   - Usando o valor recalculado para seguranÃ§a!`);
  972 â”‚       totalPrice = manualTotal;
  973 â”‚     }
  974 â”‚     
  975 â”‚     // Calcular taxa de serviÃ§o
  976 â”‚     const serviceFee = (totalPrice * (roomData.serviceFeePct || 0)) / 100;
  977 â”‚     const totalWithFee = totalPrice + serviceFee;
  978 â”‚     
  979 â”‚     console.log(`ğŸ’° Resumo do cÃ¡lculo:`);
  980 â”‚     console.log(`   - Total das diÃ¡rias: â‚¬${totalPrice}`);
  981 â”‚     console.log(`   - Taxa de serviÃ§o (${roomData.serviceFeePct || 0}%): â‚¬${serviceFee}`);
  982 â”‚     console.log(`   - Total com taxas: â‚¬${totalWithFee}`);
  983 â”‚     
  984 â”‚     return {
  985 â”‚       totalPrice,
  986 â”‚       nightlyPrices,
  987 â”‚       serviceFee,
  988 â”‚       totalWithFee
  989 â”‚     };
  990 â”‚   } catch (error) {
  991 â”‚     console.error("âŒ Erro ao calcular preÃ§o da estadia:", error);
  992 â”‚     throw error;
  993 â”‚   }
  994 â”‚ } 
  995 â”‚ import { 
  996 â”‚   collection, 
  997 â”‚   getDocs, 
  998 â”‚   getDoc, 
  999 â”‚   doc, 
 1000 â”‚   setDoc, 
 1001 â”‚   addDoc, 
 1002 â”‚   updateDoc, 
 1003 â”‚   deleteDoc,
 1004 â”‚   query,
      Â·   â”€â”€â”¬â”€â”€
      Â·     â•°â”€â”€ `query` redefined here
 1005 â”‚   where,
 1006 â”‚   orderBy,
 1007 â”‚   limit,
      â•°â”€â”€â”€â”€

  Ã— the name `where` is defined multiple times
      â•­â”€[/home/runner/workspace/lib/firebase/firestore.ts:8:1]
    8 â”‚   updateDoc,
    9 â”‚   deleteDoc,
   10 â”‚   query,
   11 â”‚   where,
      Â·   â”€â”€â”¬â”€â”€
      Â·     â•°â”€â”€ previous definition of `where` here
   12 â”‚   orderBy,
   13 â”‚   limit,
   14 â”‚   DocumentData,
   15 â”‚   QueryConstraint,
   16 â”‚   Timestamp,
   17 â”‚   serverTimestamp
   18 â”‚ } from 'firebase/firestore'
   19 â”‚ import { db } from './config'
   20 â”‚ import { Room, SeasonalPrice } from '@/lib/types'
   21 â”‚ import { differenceInDays } from 'date-fns'
   22 â”‚ 
   23 â”‚ // Tipos de dados
   24 â”‚ export interface Booking {
   25 â”‚   id?: string
   26 â”‚   userId?: string
   27 â”‚   guestName: string
   28 â”‚   guestEmail: string
   29 â”‚   guestPhone: string
   30 â”‚   roomId: string
   31 â”‚   roomName: string
   32 â”‚   checkIn: Timestamp
   33 â”‚   checkOut: Timestamp
   34 â”‚   adults: number
   35 â”‚   children: number
   36 â”‚   totalPrice: number
   37 â”‚   status: 'pending' | 'confirmed' | 'cancelled' | 'completed'
   38 â”‚   paymentStatus: 'pending' | 'paid' | 'refunded'
   39 â”‚   specialRequests?: string
   40 â”‚   createdAt?: Timestamp
   41 â”‚   updatedAt?: Timestamp
   42 â”‚ }
   43 â”‚ 
   44 â”‚ export interface Contact {
   45 â”‚   id?: string
   46 â”‚   name: string
   47 â”‚   email: string
   48 â”‚   phone?: string
   49 â”‚   subject: string
   50 â”‚   message: string
   51 â”‚   status: 'new' | 'read' | 'replied'
   52 â”‚   createdAt: Timestamp
   53 â”‚   updatedAt?: Timestamp
   54 â”‚   repliedAt?: Timestamp
   55 â”‚   replyContent?: string
   56 â”‚   reservationDetails?: {
   57 â”‚     checkIn?: Timestamp
   58 â”‚     checkOut?: Timestamp
   59 â”‚     roomId?: string
   60 â”‚     roomName?: string
   61 â”‚     totalGuests?: number
   62 â”‚     totalPrice?: number
   63 â”‚   }
   64 â”‚ }
   65 â”‚ 
   66 â”‚ // FunÃ§Ãµes genÃ©ricas para CRUD
   67 â”‚ export const createDocument = async <T extends DocumentData>(
   68 â”‚   collectionName: string,
   69 â”‚   data: T
   70 â”‚ ): Promise<string> => {
   71 â”‚   const docRef = await addDoc(collection(db, collectionName), {
   72 â”‚     ...data,
   73 â”‚     createdAt: serverTimestamp(),
   74 â”‚     updatedAt: serverTimestamp()
   75 â”‚   })
   76 â”‚   return docRef.id
   77 â”‚ }
   78 â”‚ 
   79 â”‚ export const createDocumentWithId = async <T extends DocumentData>(
   80 â”‚   collectionName: string,
   81 â”‚   id: string,
   82 â”‚   data: T
   83 â”‚ ): Promise<void> => {
   84 â”‚   await setDoc(doc(db, collectionName, id), {
   85 â”‚     ...data,
   86 â”‚     createdAt: serverTimestamp(),
   87 â”‚     updatedAt: serverTimestamp()
   88 â”‚   })
   89 â”‚ }
   90 â”‚ 
   91 â”‚ export const getDocument = async <T>(
   92 â”‚   collectionName: string,
   93 â”‚   id: string
   94 â”‚ ): Promise<T | null> => {
   95 â”‚   const docRef = doc(db, collectionName, id)
   96 â”‚   const docSnap = await getDoc(docRef)
   97 â”‚   
   98 â”‚   if (docSnap.exists()) {
   99 â”‚     const data = docSnap.data();
  100 â”‚     console.log("Dados brutos recuperados do Firestore para quarto:", id, data);
  101 â”‚     
  102 â”‚     if (data?.serviceFeePct !== undefined) {
  103 â”‚       console.log("serviceFeePct antes da conversÃ£o:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
  104 â”‚       // Garantir que serviceFeePct seja um nÃºmero
  105 â”‚       data.serviceFeePct = Number(data.serviceFeePct);
  106 â”‚       console.log("serviceFeePct apÃ³s conversÃ£o:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
  107 â”‚     }
  108 â”‚     
  109 â”‚     return { id: docSnap.id, ...data } as T
  110 â”‚   } else {
  111 â”‚     return null
  112 â”‚   }
  113 â”‚ }
  114 â”‚ 
  115 â”‚ export const getDocuments = async <T>(
  116 â”‚   collectionName: string,
  117 â”‚   constraints: QueryConstraint[] = [],
  118 â”‚   forceRefresh = false
  119 â”‚ ): Promise<T[]> => {
  120 â”‚   try {
  121 â”‚     const collectionRef = collection(db, collectionName)
  122 â”‚     const q = query(collectionRef, ...constraints)
  123 â”‚     
  124 â”‚     // Se forceRefresh for verdadeiro, adicionar opÃ§Ãµes que forÃ§am uma nova consulta ao Firestore
  125 â”‚     const querySnapshot = await getDocs(q)
  126 â”‚     
  127 â”‚     console.log(`Buscando documentos na coleÃ§Ã£o ${collectionName} - ForÃ§a atualizaÃ§Ã£o: ${forceRefresh}`);
  128 â”‚     
  129 â”‚     return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }) as T)
  130 â”‚   } catch (error) {
  131 â”‚     console.error(`Erro ao buscar documentos da coleÃ§Ã£o ${collectionName}:`, error);
  132 â”‚     return [];
  133 â”‚   }
  134 â”‚ }
  135 â”‚ 
  136 â”‚ export const updateDocument = async <T extends DocumentData>(
  137 â”‚   collectionName: string,
  138 â”‚   id: string,
  139 â”‚   data: Partial<T>
  140 â”‚ ): Promise<void> => {
  141 â”‚   const docRef = doc(db, collectionName, id)
  142 â”‚   await updateDoc(docRef, {
  143 â”‚     ...data,
  144 â”‚     updatedAt: serverTimestamp()
  145 â”‚   })
  146 â”‚ }
  147 â”‚ 
  148 â”‚ export const deleteDocument = async (
  149 â”‚   collectionName: string,
  150 â”‚   id: string
  151 â”‚ ): Promise<boolean> => {
  152 â”‚   const docRef = doc(db, collectionName, id)
  153 â”‚   await deleteDoc(docRef)
  154 â”‚   return true
  155 â”‚ }
  156 â”‚ 
  157 â”‚ // FunÃ§Ãµes para gerenciar quartos
  158 â”‚ export const getRooms = async (forceRefresh = false): Promise<Room[]> => {
  159 â”‚   try {
  160 â”‚     const constraints: QueryConstraint[] = []
  161 â”‚     
  162 â”‚     constraints.push(orderBy('name', 'asc'))
  163 â”‚     
  164 â”‚     const rooms = await getDocuments<Room>('rooms', constraints, forceRefresh)
  165 â”‚     
  166 â”‚     // Garantir que todos os campos necessÃ¡rios estejam presentes
  167 â”‚     return rooms.map(room => {
  168 â”‚       console.log(`Firebase - Quarto ${room.id} dados brutos:`, room);
  169 â”‚       
  170 â”‚       // Garantir que serviceFeePct seja um nÃºmero
  171 â”‚       const serviceFeePct = room.serviceFeePct !== undefined 
  172 â”‚         ? Number(room.serviceFeePct) 
  173 â”‚         : 10;
  174 â”‚         
  175 â”‚       console.log(`Firebase - Quarto ${room.id} serviceFeePct:`, {
  176 â”‚         original: room.serviceFeePct,
  177 â”‚         tipo: typeof room.serviceFeePct,
  178 â”‚         convertido: serviceFeePct
  179 â”‚       });
  180 â”‚       
  181 â”‚       return {
  182 â”‚         id: room.id,
  183 â”‚         name: room.name || '',
  184 â”‚         type: room.type || 'standard',
  185 â”‚         description: room.description || '',
  186 â”‚         price: room.price || 0,
  187 â”‚         capacity: room.capacity || 2,
  188 â”‚         size: room.size || 0,
  189 â”‚         available: room.available !== undefined ? room.available : true,
  190 â”‚         serviceFeePct: serviceFeePct,
  191 â”‚         images: room.images || [],
  192 â”‚         amenities: room.amenities || [],
  193 â”‚         additionalServices: room.additionalServices || [],
  194 â”‚         highlights: room.highlights || [],
  195 â”‚         createdAt: room.createdAt,
  196 â”‚         updatedAt: room.updatedAt
  197 â”‚       };
  198 â”‚     });
  199 â”‚   } catch (error) {
  200 â”‚     console.error('Erro ao buscar quartos:', error)
  201 â”‚     return []
  202 â”‚   }
  203 â”‚ }
  204 â”‚ 
  205 â”‚ export const getAvailableRooms = async (
  206 â”‚   checkIn: Date,
  207 â”‚   checkOut: Date
  208 â”‚ ): Promise<Room[]> => {
  209 â”‚   try {
  210 â”‚     // Buscar todos os quartos que estÃ£o marcados como disponÃ­veis em geral
  211 â”‚     const constraints: QueryConstraint[] = [
  212 â”‚       where('available', '==', true)
  213 â”‚     ]
  214 â”‚     
  215 â”‚     const rooms = await getDocuments<Room>('rooms', constraints);
  216 â”‚     
  217 â”‚     // Filtrar os quartos que estÃ£o disponÃ­veis nas datas especÃ­ficas
  218 â”‚     return filterAvailableRoomsByDate(rooms, checkIn, checkOut);
  219 â”‚   } catch (error) {
  220 â”‚     console.error('Erro ao buscar quartos disponÃ­veis:', error)
  221 â”‚     return []
  222 â”‚   }
  223 â”‚ }
  224 â”‚ 
  225 â”‚ // FunÃ§Ã£o auxiliar para verificar disponibilidade entre datas
  226 â”‚ export const filterAvailableRoomsByDate = (
  227 â”‚   rooms: Room[],
  228 â”‚   checkIn: Date,
  229 â”‚   checkOut: Date
  230 â”‚ ): Room[] => {
  231 â”‚   // Converter checkIn e checkOut para ISO strings
  232 â”‚   const dateStrings = getDatesInRange(checkIn, checkOut);
  233 â”‚   
  234 â”‚   return rooms.filter(room => {
  235 â”‚     // Se nÃ£o tiver controle de disponibilidade especÃ­fico, considera disponÃ­vel
  236 â”‚     if (!room.availabilityDates) return true;
  237 â”‚     
  238 â”‚     // Verificar se alguma data no intervalo estÃ¡ indisponÃ­vel
  239 â”‚     return !dateStrings.some(dateStr => 
  240 â”‚       room.availabilityDates?.[dateStr] === false
  241 â”‚     );
  242 â”‚   });
  243 â”‚ };
  244 â”‚ 
  245 â”‚ // FunÃ§Ã£o para obter disponibilidade de um quarto especÃ­fico
  246 â”‚ export const getRoomAvailability = async (
  247 â”‚   roomId: string, 
  248 â”‚   startDate: Date, 
  249 â”‚   endDate: Date
  250 â”‚ ): Promise<{[date: string]: boolean}> => {
  251 â”‚   try {
  252 â”‚     const room = await getRoomById(roomId);
  253 â”‚     if (!room) throw new Error(`Quarto com ID ${roomId} nÃ£o encontrado`);
  254 â”‚     
  255 â”‚     // Gerar datas no intervalo
  256 â”‚     const dateStrings = getDatesInRange(startDate, endDate);
  257 â”‚     
  258 â”‚     // Se nÃ£o tiver configuraÃ§Ã£o de disponibilidade especÃ­fica, assume tudo disponÃ­vel
  259 â”‚     if (!room.availabilityDates) {
  260 â”‚       return dateStrings.reduce((acc, date) => {
  261 â”‚         acc[date] = true;
  262 â”‚         return acc;
  263 â”‚       }, {} as {[date: string]: boolean});
  264 â”‚     }
  265 â”‚     
  266 â”‚     // Preencher com os dados de disponibilidade existentes
  267 â”‚     return dateStrings.reduce((acc, date) => {
  268 â”‚       acc[date] = room.availabilityDates?.[date] !== false; // disponÃ­vel por padrÃ£o se nÃ£o estiver explicitamente indisponÃ­vel
  269 â”‚       return acc;
  270 â”‚     }, {} as {[date: string]: boolean});
  271 â”‚   } catch (error) {
  272 â”‚     console.error(`Erro ao verificar disponibilidade do quarto ${roomId}:`, error);
  273 â”‚     throw error;
  274 â”‚   }
  275 â”‚ };
  276 â”‚ 
  277 â”‚ // FunÃ§Ã£o para atualizar disponibilidade de um quarto
  278 â”‚ export const updateRoomAvailability = async (
  279 â”‚   roomId: string,
  280 â”‚   availabilityDates: {[date: string]: boolean}
  281 â”‚ ): Promise<boolean> => {
  282 â”‚   try {
  283 â”‚     await updateDocument('rooms', roomId, {
  284 â”‚       availabilityDates,
  285 â”‚       updatedAt: serverTimestamp()
  286 â”‚     });
  287 â”‚     return true;
  288 â”‚   } catch (error) {
  289 â”‚     console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  290 â”‚     return false;
  291 â”‚   }
  292 â”‚ };
  293 â”‚ 
  294 â”‚ // FunÃ§Ã£o auxiliar para gerar array de strings de data entre um intervalo
  295 â”‚ export const getDatesInRange = (startDate: Date, endDate: Date): string[] => {
  296 â”‚   const dates: string[] = [];
  297 â”‚   const currentDate = new Date(startDate);
  298 â”‚   
  299 â”‚   // Normalizar para meia-noite no fuso horÃ¡rio local
  300 â”‚   currentDate.setHours(0, 0, 0, 0);
  301 â”‚   const endDateNormalized = new Date(endDate);
  302 â”‚   endDateNormalized.setHours(0, 0, 0, 0);
  303 â”‚   
  304 â”‚   // Adicionar cada data no intervalo EXCETO o dia de checkout
  305 â”‚   // Usando < em vez de <= para nÃ£o incluir o dia de checkout
  306 â”‚   while (currentDate < endDateNormalized) {
  307 â”‚     dates.push(currentDate.toISOString().split('T')[0]); // Formato YYYY-MM-DD
  308 â”‚     currentDate.setDate(currentDate.getDate() + 1);
  309 â”‚   }
  310 â”‚   
  311 â”‚   return dates;
  312 â”‚ };
  313 â”‚ 
  314 â”‚ export const getRoomById = async (id: string): Promise<Room | null> => {
  315 â”‚   try {
  316 â”‚     const room = await getDocument<Room>('rooms', id);
  317 â”‚     
  318 â”‚     if (!room) return null;
  319 â”‚     
  320 â”‚     console.log(`Firebase - getRoomById ${id} dados brutos:`, room);
  321 â”‚     
  322 â”‚     // Log especÃ­fico para serviceFeePct
  323 â”‚     console.log(`serviceFeePct no Firestore:`, room.serviceFeePct);
  324 â”‚     
  325 â”‚     // Garantir que todos os campos necessÃ¡rios estejam presentes
  326 â”‚     return {
  327 â”‚       ...room,
  328 â”‚       name: room.name || '',
  329 â”‚       type: room.type || 'standard',
  330 â”‚       description: room.description || '',
  331 â”‚       price: room.price || 0,
  332 â”‚       capacity: room.capacity || 2,
  333 â”‚       size: room.size || 0,
  334 â”‚       available: room.available !== undefined ? room.available : true,
  335 â”‚       serviceFeePct: room.serviceFeePct !== undefined ? room.serviceFeePct : 10,
  336 â”‚       images: room.images || [],
  337 â”‚       amenities: room.amenities || [],
  338 â”‚       additionalServices: room.additionalServices || [],
  339 â”‚       highlights: room.highlights || []
  340 â”‚     };
  341 â”‚   } catch (error) {
  342 â”‚     console.error(`Erro ao buscar quarto com ID ${id}:`, error);
  343 â”‚     return null;
  344 â”‚   }
  345 â”‚ }
  346 â”‚ 
  347 â”‚ export const createRoom = async (roomData: Omit<Room, 'id' | 'createdAt' | 'updatedAt'>): Promise<Room> => {
  348 â”‚   try {
  349 â”‚     console.log("createRoom - Dados recebidos:", roomData);
  350 â”‚     
  351 â”‚     const roomWithTimestamps = {
  352 â”‚       ...roomData,
  353 â”‚       available: roomData.available !== undefined ? roomData.available : true,
  354 â”‚       featured: roomData.featured || false,
  355 â”‚       amenities: roomData.amenities || [],
  356 â”‚       additionalServices: roomData.additionalServices || [],
  357 â”‚       highlights: roomData.highlights || [],
  358 â”‚       createdAt: serverTimestamp(),
  359 â”‚       updatedAt: serverTimestamp()
  360 â”‚     }
  361 â”‚     
  362 â”‚     console.log("createRoom - Dados a serem salvos:", roomWithTimestamps);
  363 â”‚     
  364 â”‚     const id = await createDocument('rooms', roomWithTimestamps)
  365 â”‚     
  366 â”‚     return {
  367 â”‚       id,
  368 â”‚       ...roomData,
  369 â”‚       amenities: roomData.amenities || [],
  370 â”‚       additionalServices: roomData.additionalServices || [],
  371 â”‚       highlights: roomData.highlights || [],
  372 â”‚       createdAt: Timestamp.now(),
  373 â”‚       updatedAt: Timestamp.now()
  374 â”‚     }
  375 â”‚   } catch (error) {
  376 â”‚     console.error('Erro ao criar quarto:', error)
  377 â”‚     throw error
  378 â”‚   }
  379 â”‚ }
  380 â”‚ 
  381 â”‚ export const updateRoom = async (id: string, roomData: Partial<Omit<Room, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Room> => {
  382 â”‚   try {
  383 â”‚     console.log(`updateRoom - ID: ${id}, Dados recebidos:`, roomData);
  384 â”‚     
  385 â”‚     // Garantir que estamos lidando explicitamente com o serviceFeePct se ele for 0
  386 â”‚     if (roomData.serviceFeePct === 0) {
  387 â”‚       console.log("updateRoom - Detectado serviceFeePct com valor 0, salvando explicitamente.", roomData.serviceFeePct);
  388 â”‚     }
  389 â”‚     
  390 â”‚     // Adicionar timestamp de atualizaÃ§Ã£o
  391 â”‚     const roomWithTimestamp = {
  392 â”‚       ...roomData,
  393 â”‚       amenities: roomData.amenities || [],
  394 â”‚       additionalServices: roomData.additionalServices || [],
  395 â”‚       highlights: roomData.highlights || [],
  396 â”‚       updatedAt: serverTimestamp()
  397 â”‚     }
  398 â”‚     
  399 â”‚     console.log(`updateRoom - Dados a serem salvos:`, roomWithTimestamp);
  400 â”‚     
  401 â”‚     await updateDocument('rooms', id, roomWithTimestamp)
  402 â”‚     
  403 â”‚     const updatedRoom = await getRoomById(id)
  404 â”‚     if (!updatedRoom) {
  405 â”‚       throw new Error(`Quarto com ID ${id} nÃ£o encontrado apÃ³s atualizaÃ§Ã£o`)
  406 â”‚     }
  407 â”‚     
  408 â”‚     return updatedRoom
  409 â”‚   } catch (error) {
  410 â”‚     console.error('Erro ao atualizar quarto:', error)
  411 â”‚     throw error
  412 â”‚   }
  413 â”‚ }
  414 â”‚ 
  415 â”‚ export const deleteRoom = async (id: string): Promise<boolean> => {
  416 â”‚   return await deleteDocument('rooms', id)
  417 â”‚ }
  418 â”‚ 
  419 â”‚ // FunÃ§Ãµes especÃ­ficas para reservas
  420 â”‚ export const createBooking = async (bookingData: any) => {
  421 â”‚   try {
  422 â”‚     const bookingsCollection = collection(db, 'bookings');
  423 â”‚     const docRef = await addDoc(bookingsCollection, bookingData);
  424 â”‚     
  425 â”‚     // CORREÃ‡ÃƒO: NÃ£o bloquear a data no momento da criaÃ§Ã£o da reserva
  426 â”‚     // O bloqueio serÃ¡ feito apenas quando o pagamento for confirmado
  427 â”‚     // atravÃ©s da funÃ§Ã£o updateBookingStatus
  428 â”‚     
  429 â”‚     return docRef;
  430 â”‚   } catch (error) {
  431 â”‚     console.error('Erro ao criar reserva:', error);
  432 â”‚     throw error;
  433 â”‚   }
  434 â”‚ };
  435 â”‚ 
  436 â”‚ // Nova funÃ§Ã£o para atualizar status da reserva e bloquear as datas da estadia
  437 â”‚ export const updateBookingStatus = async (
  438 â”‚   bookingId: string, 
  439 â”‚   newStatus: 'pending' | 'confirmed' | 'cancelled' | 'completed',
  440 â”‚   newPaymentStatus: 'pending' | 'paid' | 'refunded'
  441 â”‚ ): Promise<boolean> => {
  442 â”‚   try {
  443 â”‚     // ReferÃªncia ao documento da reserva
  444 â”‚     const bookingRef = doc(db, 'bookings', bookingId);
  445 â”‚     const bookingSnap = await getDoc(bookingRef);
  446 â”‚     
  447 â”‚     if (!bookingSnap.exists()) {
  448 â”‚       console.error(`Booking ${bookingId} nÃ£o existe ao atualizar status`);
  449 â”‚       return false;
  450 â”‚     }
  451 â”‚     
  452 â”‚     const bookingData = bookingSnap.data();
  453 â”‚     
  454 â”‚     // Atualizar o status da reserva
  455 â”‚     await updateDoc(bookingRef, {
  456 â”‚       status: newStatus,
  457 â”‚       paymentStatus: newPaymentStatus,
  458 â”‚       updatedAt: serverTimestamp(),
  459 â”‚       ...(newStatus === 'confirmed' && { confirmedAt: serverTimestamp() })
  460 â”‚     });
  461 â”‚     
  462 â”‚     // Se a reserva estÃ¡ sendo confirmada, precisamos bloquear as datas
  463 â”‚     if (newStatus === 'confirmed') {
  464 â”‚       console.log(`Atualizando disponibilidade para reserva confirmada: ${bookingId}`);
  465 â”‚       
  466 â”‚       // Recuperar datas de check-in e check-out
  467 â”‚       const checkIn = bookingData.checkIn.toDate();
  468 â”‚       const checkOut = bookingData.checkOut.toDate();
  469 â”‚       const roomId = bookingData.roomId;
  470 â”‚       
  471 â”‚       // Obter todas as datas entre check-in e check-out
  472 â”‚       const dates: Date[] = [];
  473 â”‚       const currentDate = new Date(checkIn);
  474 â”‚       
  475 â”‚       while (currentDate < checkOut) {
  476 â”‚         dates.push(new Date(currentDate));
  477 â”‚         currentDate.setDate(currentDate.getDate() + 1);
  478 â”‚       }
  479 â”‚       
  480 â”‚       console.log(`Bloqueando ${dates.length} dias para quarto ${roomId}`);
  481 â”‚       
  482 â”‚       // Atualizar disponibilidade para cada data
  483 â”‚       const availabilityUpdates: {[date: string]: boolean} = {};
  484 â”‚       
  485 â”‚       dates.forEach(date => {
  486 â”‚         const dateString = date.toISOString().split('T')[0]; // formato YYYY-MM-DD
  487 â”‚         availabilityUpdates[dateString] = false; // false significa indisponÃ­vel
  488 â”‚       });
  489 â”‚       
  490 â”‚       // Atualizar disponibilidade do quarto
  491 â”‚       if (Object.keys(availabilityUpdates).length > 0) {
  492 â”‚         try {
  493 â”‚           // Obter o documento do quarto
  494 â”‚           const roomRef = doc(db, 'rooms', roomId);
  495 â”‚           const roomSnap = await getDoc(roomRef);
  496 â”‚           
  497 â”‚           if (roomSnap.exists()) {
  498 â”‚             const roomData = roomSnap.data();
  499 â”‚             const currentAvailability = roomData.availabilityDates || {};
  500 â”‚             
  501 â”‚             // Mesclar a disponibilidade atual com as novas atualizaÃ§Ãµes
  502 â”‚             const updatedAvailability = {
  503 â”‚               ...currentAvailability,
  504 â”‚               ...availabilityUpdates
  505 â”‚             };
  506 â”‚             
  507 â”‚             // Atualizar o documento do quarto
  508 â”‚             await updateDoc(roomRef, {
  509 â”‚               availabilityDates: updatedAvailability,
  510 â”‚               updatedAt: serverTimestamp()
  511 â”‚             });
  512 â”‚             
  513 â”‚             console.log(`Disponibilidade atualizada com sucesso para quarto ${roomId}`);
  514 â”‚             
  515 â”‚             // Criar log da reserva
  516 â”‚             await addDoc(collection(db, 'bookingLogs'), {
  517 â”‚               bookingId,
  518 â”‚               roomId,
  519 â”‚               action: 'status_updated',
  520 â”‚               previousStatus: bookingData.status,
  521 â”‚               newStatus,
  522 â”‚               previousPaymentStatus: bookingData.paymentStatus,
  523 â”‚               newPaymentStatus,
  524 â”‚               datesBlocked: Object.keys(availabilityUpdates),
  525 â”‚               timestamp: serverTimestamp(),
  526 â”‚               userId: bookingData.userId || 'system'
  527 â”‚             });
  528 â”‚           } else {
  529 â”‚             console.error(`Quarto ${roomId} nÃ£o encontrado ao atualizar disponibilidade`);
  530 â”‚           }
  531 â”‚         } catch (error) {
  532 â”‚           console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  533 â”‚         }
  534 â”‚       }
  535 â”‚     }
  536 â”‚     
  537 â”‚     return true;
  538 â”‚   } catch (error) {
  539 â”‚     console.error(`Erro ao atualizar status da reserva ${bookingId}:`, error);
  540 â”‚     return false;
  541 â”‚   }
  542 â”‚ }
  543 â”‚ 
  544 â”‚ export const getUserBookings = async (userId: string): Promise<Booking[]> => {
  545 â”‚   return getDocuments<Booking>('bookings', [
  546 â”‚     where('userId', '==', userId),
  547 â”‚     orderBy('createdAt', 'desc')
  548 â”‚   ])
  549 â”‚ }
  550 â”‚ 
  551 â”‚ export const getRecentBookings = async (count = 5): Promise<Booking[]> => {
  552 â”‚   return getDocuments<Booking>('bookings', [
  553 â”‚     orderBy('createdAt', 'desc'),
  554 â”‚     limit(count)
  555 â”‚   ])
  556 â”‚ }
  557 â”‚ 
  558 â”‚ export const getRoomBookings = async (roomId: string): Promise<Booking[]> => {
  559 â”‚   try {
  560 â”‚     const constraints: QueryConstraint[] = [
  561 â”‚       where('roomId', '==', roomId),
  562 â”‚       orderBy('checkIn', 'asc')
  563 â”‚     ];
  564 â”‚     
  565 â”‚     return await getDocuments<Booking>('bookings', constraints);
  566 â”‚   } catch (error) {
  567 â”‚     console.error(`Erro ao buscar reservas do quarto ${roomId}:`, error);
  568 â”‚     return [];
  569 â”‚   }
  570 â”‚ };
  571 â”‚ 
  572 â”‚ // FunÃ§Ãµes especÃ­ficas para contatos
  573 â”‚ export const createContactMessage = async (contactData: Contact) => {
  574 â”‚   try {
  575 â”‚     const contactsCollection = collection(db, 'contacts')
  576 â”‚     
  577 â”‚     // Garantir que o status seja 'new' para novos contatos
  578 â”‚     const contactWithDefaults = {
  579 â”‚       ...contactData,
  580 â”‚       status: contactData.status || 'new',
  581 â”‚       createdAt: contactData.createdAt || Timestamp.now()
  582 â”‚     }
  583 â”‚     
  584 â”‚     // Se tiver detalhes de reserva, adicionar metadados
  585 â”‚     if (contactWithDefaults.reservationDetails) {
  586 â”‚       // Ajustar subject para indicar que Ã© relacionado a reserva
  587 â”‚       if (!contactWithDefaults.subject.includes('Reserva')) {
  588 â”‚         contactWithDefaults.subject = `Reserva: ${contactWithDefaults.subject}`;
  589 â”‚       }
  590 â”‚     }
  591 â”‚     
  592 â”‚     const docRef = await addDoc(contactsCollection, contactWithDefaults)
  593 â”‚     return docRef
  594 â”‚   } catch (error) {
  595 â”‚     console.error('Erro ao criar mensagem de contato:', error)
  596 â”‚     throw error
  597 â”‚   }
  598 â”‚ }
  599 â”‚ 
  600 â”‚ export const getNewContactMessages = async (): Promise<Contact[]> => {
  601 â”‚   return getDocuments<Contact>('contacts', [
  602 â”‚     where('status', '==', 'new'),
  603 â”‚     orderBy('createdAt', 'desc')
  604 â”‚   ])
  605 â”‚ }
  606 â”‚ 
  607 â”‚ // FunÃ§Ãµes para Dashboard com dados reais
  608 â”‚ 
  609 â”‚ export const getDashboardStats = async () => {
  610 â”‚   try {
  611 â”‚     const [totalBookings, totalRevenue, occupancyRate, bookingsByPlatform] = await Promise.all([
  612 â”‚       getTotalBookings(),
  613 â”‚       getMonthlyRevenue(),
  614 â”‚       getOccupancyRate(),
  615 â”‚       getBookingsByPlatform()
  616 â”‚     ]);
  617 â”‚ 
  618 â”‚     return {
  619 â”‚       totalBookings,
  620 â”‚       totalRevenue,
  621 â”‚       occupancyRate,
  622 â”‚       bookingsByPlatform
  623 â”‚     };
  624 â”‚   } catch (error) {
  625 â”‚     console.error('Erro ao obter estatÃ­sticas do dashboard:', error);
  626 â”‚     throw error;
  627 â”‚   }
  628 â”‚ };
  629 â”‚ 
  630 â”‚ // Obter total de reservas
  631 â”‚ export const getTotalBookings = async () => {
  632 â”‚   try {
  633 â”‚     // Obter todas as reservas
  634 â”‚     const bookings = await getDocuments<Booking>('bookings');
  635 â”‚     
  636 â”‚     // Contar reservas por status
  637 â”‚     const confirmed = bookings.filter(b => b.status === 'confirmed').length;
  638 â”‚     const pending = bookings.filter(b => b.status === 'pending').length;
  639 â”‚     const cancelled = bookings.filter(b => b.status === 'cancelled').length;
  640 â”‚     const completed = bookings.filter(b => b.status === 'completed').length;
  641 â”‚     
  642 â”‚     // Calcular crescimento em relaÃ§Ã£o ao mÃªs anterior (simulado por enquanto)
  643 â”‚     // Em uma implementaÃ§Ã£o real, vocÃª compararia com dados do mÃªs anterior
  644 â”‚     const growth = ((confirmed + completed) / (bookings.length || 1) * 100) - 50;
  645 â”‚     
  646 â”‚     return {
  647 â”‚       total: bookings.length,
  648 â”‚       confirmed,
  649 â”‚       pending,
  650 â”‚       cancelled,
  651 â”‚       completed,
  652 â”‚       growth: Math.round(growth) // Arredonda para nÃºmero inteiro
  653 â”‚     };
  654 â”‚   } catch (error) {
  655 â”‚     console.error('Erro ao obter total de reservas:', error);
  656 â”‚     return {
  657 â”‚       total: 0,
  658 â”‚       confirmed: 0,
  659 â”‚       pending: 0, 
  660 â”‚       cancelled: 0,
  661 â”‚       completed: 0,
  662 â”‚       growth: 0
  663 â”‚     };
  664 â”‚   }
  665 â”‚ };
  666 â”‚ 
  667 â”‚ // Obter receita mensal
  668 â”‚ export const getMonthlyRevenue = async () => {
  669 â”‚   try {
  670 â”‚     const bookings = await getDocuments<Booking>('bookings');
  671 â”‚     
  672 â”‚     // Filtrar reservas confirmadas e concluÃ­das
  673 â”‚     const validBookings = bookings.filter(b => 
  674 â”‚       b.status === 'confirmed' || b.status === 'completed'
  675 â”‚     );
  676 â”‚     
  677 â”‚     // Calcular receita total
  678 â”‚     const totalRevenue = validBookings.reduce((acc, booking) => acc + booking.totalPrice, 0);
  679 â”‚     
  680 â”‚     // Agrupar receita por mÃªs
  681 â”‚     const revenueByMonth = validBookings.reduce((acc, booking) => {
  682 â”‚       const date = booking.checkIn.toDate();
  683 â”‚       const month = date.getMonth(); // 0-11
  684 â”‚       const year = date.getFullYear();
  685 â”‚       const key = `${year}-${month}`;
  686 â”‚       
  687 â”‚       if (!acc[key]) {
  688 â”‚         acc[key] = 0;
  689 â”‚       }
  690 â”‚       acc[key] += booking.totalPrice;
  691 â”‚       return acc;
  692 â”‚     }, {} as Record<string, number>);
  693 â”‚     
  694 â”‚     // Converter para formato de array para grÃ¡fico
  695 â”‚     const monthNames = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
  696 â”‚     
  697 â”‚     const currentDate = new Date();
  698 â”‚     const currentMonth = currentDate.getMonth();
  699 â”‚     const currentYear = currentDate.getFullYear();
  700 â”‚     
  701 â”‚     const revenueData = [];
  702 â”‚     
  703 â”‚     // Gerar dados dos Ãºltimos 12 meses
  704 â”‚     for (let i = 0; i < 12; i++) {
  705 â”‚       const month = (currentMonth - i + 12) % 12;
  706 â”‚       const year = currentMonth - i < 0 ? currentYear - 1 : currentYear;
  707 â”‚       const key = `${year}-${month}`;
  708 â”‚       
  709 â”‚       revenueData.unshift({
  710 â”‚         month: monthNames[month],
  711 â”‚         value: revenueByMonth[key] || 0
  712 â”‚       });
  713 â”‚     }
  714 â”‚     
  715 â”‚     // Calcular crescimento em relaÃ§Ã£o ao mÃªs anterior
  716 â”‚     const lastMonthRevenue = revenueData[revenueData.length - 2]?.value || 0;
  717 â”‚     const currentMonthRevenue = revenueData[revenueData.length - 1]?.value || 0;
  718 â”‚     
  719 â”‚     const growth = lastMonthRevenue ? ((currentMonthRevenue - lastMonthRevenue) / lastMonthRevenue) * 100 : 0;
  720 â”‚     
  721 â”‚     return {
  722 â”‚       monthly: currentMonthRevenue,
  723 â”‚       total: totalRevenue,
  724 â”‚       growth: Math.round(growth),
  725 â”‚       revenueData
  726 â”‚     };
  727 â”‚   } catch (error) {
  728 â”‚     console.error('Erro ao obter receita mensal:', error);
  729 â”‚     return {
  730 â”‚       monthly: 0,
  731 â”‚       total: 0,
  732 â”‚       growth: 0,
  733 â”‚       revenueData: []
  734 â”‚     };
  735 â”‚   }
  736 â”‚ };
  737 â”‚ 
  738 â”‚ // Calcular taxa de ocupaÃ§Ã£o
  739 â”‚ export const getOccupancyRate = async () => {
  740 â”‚   try {
  741 â”‚     // Obter todos os quartos
  742 â”‚     const rooms = await getDocuments<Room>('rooms');
  743 â”‚     const totalRooms = rooms.length;
  744 â”‚     
  745 â”‚     if (totalRooms === 0) {
  746 â”‚       return { rate: 0, growth: 0 };
  747 â”‚     }
  748 â”‚     
  749 â”‚     // Obter todas as reservas
  750 â”‚     const bookings = await getDocuments<Booking>('bookings');
  751 â”‚     
  752 â”‚     // Filtrar reservas confirmadas e concluÃ­das para o mÃªs atual
  753 â”‚     const currentDate = new Date();
  754 â”‚     const currentMonth = currentDate.getMonth();
  755 â”‚     const currentYear = currentDate.getFullYear();
  756 â”‚     
  757 â”‚     const currentMonthBookings = bookings.filter(booking => {
  758 â”‚       const checkInDate = booking.checkIn.toDate();
  759 â”‚       return (
  760 â”‚         (booking.status === 'confirmed' || booking.status === 'completed') &&
  761 â”‚         checkInDate.getMonth() === currentMonth &&
  762 â”‚         checkInDate.getFullYear() === currentYear
  763 â”‚       );
  764 â”‚     });
  765 â”‚     
  766 â”‚     // Calcular dias ocupados por quarto
  767 â”‚     const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
  768 â”‚     const totalPossibleRoomDays = totalRooms * daysInMonth;
  769 â”‚     
  770 â”‚     // Contar dias ocupados (simplificado - em produÃ§Ã£o seria mais complexo)
  771 â”‚     let occupiedDays = 0;
  772 â”‚     
  773 â”‚     currentMonthBookings.forEach(booking => {
  774 â”‚       const checkIn = booking.checkIn.toDate();
  775 â”‚       const checkOut = booking.checkOut.toDate();
  776 â”‚       
  777 â”‚       // Ajustar datas para considerar apenas o mÃªs atual
  778 â”‚       const startDate = new Date(Math.max(
  779 â”‚         checkIn.getTime(),
  780 â”‚         new Date(currentYear, currentMonth, 1).getTime()
  781 â”‚       ));
  782 â”‚       const endDate = new Date(Math.min(
  783 â”‚         checkOut.getTime(),
  784 â”‚         new Date(currentYear, currentMonth + 1, 0).getTime()
  785 â”‚       ));
  786 â”‚       
  787 â”‚       // Calcular dias entre datas (incluindo check-in, excluindo check-out)
  788 â”‚       const days = Math.max(0, Math.floor((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)));
  789 â”‚       occupiedDays += days;
  790 â”‚     });
  791 â”‚     
  792 â”‚     const occupancyRate = (occupiedDays / totalPossibleRoomDays) * 100;
  793 â”‚     
  794 â”‚     // SimulaÃ§Ã£o de crescimento (em produÃ§Ã£o, compararia com mÃªs anterior)
  795 â”‚     const growth = occupancyRate > 50 ? 5 : -3;
  796 â”‚     
  797 â”‚     return {
  798 â”‚       rate: Math.round(occupancyRate),
  799 â”‚       growth: Math.round(growth)
  800 â”‚     };
  801 â”‚   } catch (error) {
  802 â”‚     console.error('Erro ao calcular taxa de ocupaÃ§Ã£o:', error);
  803 â”‚     return { rate: 0, growth: 0 };
  804 â”‚   }
  805 â”‚ };
  806 â”‚ 
  807 â”‚ // Obter reservas agrupadas por plataforma
  808 â”‚ export const getBookingsByPlatform = async () => {
  809 â”‚   try {
  810 â”‚     const bookings = await getDocuments<Booking>('bookings');
  811 â”‚     
  812 â”‚     // Categorizar reservas por origem
  813 â”‚     const platforms = [
  814 â”‚       { 
  815 â”‚         platform: "Booking.com", 
  816 â”‚         color: "#003580", 
  817 â”‚         icon: "Globe",
  818 â”‚         bookings: []
  819 â”‚       },
  820 â”‚       { 
  821 â”‚         platform: "Airbnb", 
  822 â”‚         color: "#FF5A5F", 
  823 â”‚         icon: "Heart",
  824 â”‚         bookings: []
  825 â”‚       },
  826 â”‚       { 
  827 â”‚         platform: "Direto", 
  828 â”‚         color: "#4CAF50", 
  829 â”‚         icon: "Home",
  830 â”‚         bookings: []
  831 â”‚       }
  832 â”‚     ];
  833 â”‚     
  834 â”‚     // Para fins de demonstraÃ§Ã£o, colocar todas as reservas como "Direto" por enquanto
  835 â”‚     // Em produÃ§Ã£o, usaria um campo "platformOrigin" ou similar na tabela de reservas
  836 â”‚     const platformIndex = 2; // Ãndice da plataforma "Direto"
  837 â”‚     
  838 â”‚     bookings.forEach(booking => {
  839 â”‚       // Transformar para o formato esperado pelo componente
  840 â”‚       const transformedBooking = {
  841 â”‚         id: booking.id || '',
  842 â”‚         guestName: booking.guestName,
  843 â”‚         roomName: booking.roomName,
  844 â”‚         checkIn: booking.checkIn.toDate().toLocaleDateString('pt-PT'),
  845 â”‚         checkOut: booking.checkOut.toDate().toLocaleDateString('pt-PT'),
  846 â”‚         status: booking.status,
  847 â”‚         value: new Intl.NumberFormat('pt-PT', {
  848 â”‚           style: 'currency',
  849 â”‚           currency: 'EUR'
  850 â”‚         }).format(booking.totalPrice)
  851 â”‚       };
  852 â”‚       
  853 â”‚       // Adicionar Ã  plataforma "Direto"
  854 â”‚       (platforms[platformIndex] as any).bookings.push(transformedBooking);
  855 â”‚     });
  856 â”‚     
  857 â”‚     return platforms;
  858 â”‚   } catch (error) {
  859 â”‚     console.error('Erro ao obter reservas por plataforma:', error);
  860 â”‚     return [];
  861 â”‚   }
  862 â”‚ };
  863 â”‚ 
  864 â”‚ // FunÃ§Ã£o para obter o preÃ§o de um quarto para uma data especÃ­fica
  865 â”‚ export const getRoomPriceForDate = async (roomId: string, date: Date): Promise<number> => {
  866 â”‚   try {
  867 â”‚     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  868 â”‚     
  869 â”‚     if (!roomDoc.exists()) {
  870 â”‚       throw new Error("Quarto nÃ£o encontrado");
  871 â”‚     }
  872 â”‚     
  873 â”‚     const roomData = roomDoc.data() as Room;
  874 â”‚     const basePrice = roomData.price;
  875 â”‚     
  876 â”‚     if (!roomData.seasonalPrices || roomData.seasonalPrices.length === 0) {
  877 â”‚       return basePrice;
  878 â”‚     }
  879 â”‚     
  880 â”‚     // Verificar se a data estÃ¡ dentro de algum perÃ­odo sazonal
  881 â”‚     for (const seasonalPrice of roomData.seasonalPrices) {
  882 â”‚       const startDate = new Date(seasonalPrice.startDate);
  883 â”‚       const endDate = new Date(seasonalPrice.endDate);
  884 â”‚       
  885 â”‚       if (date >= startDate && date <= endDate) {
  886 â”‚         return seasonalPrice.price;
  887 â”‚       }
  888 â”‚     }
  889 â”‚     
  890 â”‚     // Se nÃ£o cair em nenhum perÃ­odo sazonal, retorna o preÃ§o base
  891 â”‚     return basePrice;
  892 â”‚   } catch (error) {
  893 â”‚     console.error("Erro ao obter preÃ§o do quarto:", error);
  894 â”‚     throw error;
  895 â”‚   }
  896 â”‚ }
  897 â”‚ 
  898 â”‚ // FunÃ§Ã£o para calcular o preÃ§o total de uma estadia
  899 â”‚ export const calculateStayPrice = async (
  900 â”‚   roomId: string, 
  901 â”‚   checkIn: Date, 
  902 â”‚   checkOut: Date
  903 â”‚ ): Promise<{
  904 â”‚   totalPrice: number;
  905 â”‚   nightlyPrices: { date: string; price: number }[];
  906 â”‚   serviceFee: number;
  907 â”‚   totalWithFee: number;
  908 â”‚ }> => {
  909 â”‚   try {
  910 â”‚     console.log(`ğŸ” Iniciando cÃ¡lculo de preÃ§o para estadia: ${checkIn.toISOString().split('T')[0]} atÃ© ${checkOut.toISOString().split('T')[0]}`);
  911 â”‚     
  912 â”‚     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  913 â”‚     
  914 â”‚     if (!roomDoc.exists()) {
  915 â”‚       throw new Error("Quarto nÃ£o encontrado");
  916 â”‚     }
  917 â”‚     
  918 â”‚     const roomData = roomDoc.data() as Room;
  919 â”‚     console.log(`ğŸ“ Dados do quarto ${roomId}:`, {
  920 â”‚       nome: roomData.name,
  921 â”‚       precoBase: roomData.price,
  922 â”‚       taxaServico: roomData.serviceFeePct || 0,
  923 â”‚       temPrecosSazonais: !!roomData.seasonalPrices?.length
  924 â”‚     });
  925 â”‚     
  926 â”‚     const nightlyPrices: { date: string; price: number }[] = [];
  927 â”‚     let totalPrice = 0;
  928 â”‚     
  929 â”‚     // Calcular o nÃºmero de noites - corrigido para usar o mÃ©todo correto de cÃ¡lculo
  930 â”‚     // O nÃºmero de noites Ã© a diferenÃ§a em dias (estadia = checkout - checkin)
  931 â”‚     const noites = differenceInDays(checkOut, checkIn);
  932 â”‚     console.log(`ğŸ—“ï¸ NÃºmero de noites calculado: ${noites}`);
  933 â”‚     
  934 â”‚     if (noites <= 0) {
  935 â”‚       console.error(`âš ï¸ Erro: nÃºmero de noites invÃ¡lido (${noites})`);
  936 â”‚       throw new Error("Data de check-out deve ser posterior Ã  data de check-in");
  937 â”‚     }
  938 â”‚     
  939 â”‚     // Para cada noite, verificar o preÃ§o aplicÃ¡vel (preÃ§o base ou sazonal)
  940 â”‚     // ComeÃ§amos exatamente do dia de check-in
  941 â”‚     const currentDate = new Date(checkIn);
  942 â”‚     currentDate.setHours(0, 0, 0, 0); // Normalizar para meia-noite
  943 â”‚     
  944 â”‚     // Processamos cada dia de estadia (noite)
  945 â”‚     console.log(`ğŸ“Š Calculando preÃ§os por noite:`);
  946 â”‚     for (let i = 0; i < noites; i++) {
  947 â”‚       // Obtemos o preÃ§o para esta data
  948 â”‚       const dateCopy = new Date(currentDate);
  949 â”‚       const priceForDate = await getRoomPriceForDate(roomId, dateCopy);
  950 â”‚       const dateString = dateCopy.toISOString().split('T')[0]; // YYYY-MM-DD
  951 â”‚       
  952 â”‚       console.log(`   - ${dateString}: â‚¬${priceForDate}`);
  953 â”‚       
  954 â”‚       nightlyPrices.push({
  955 â”‚         date: dateString,
  956 â”‚         price: priceForDate
  957 â”‚       });
  958 â”‚       
  959 â”‚       totalPrice += priceForDate;
  960 â”‚       
  961 â”‚       // AvanÃ§amos para o prÃ³ximo dia
  962 â”‚       currentDate.setDate(currentDate.getDate() + 1);
  963 â”‚     }
  964 â”‚     
  965 â”‚     // VerificaÃ§Ã£o de seguranÃ§a para o cÃ¡lculo do totalPrice
  966 â”‚     const manualTotal = nightlyPrices.reduce((sum, night) => sum + night.price, 0);
  967 â”‚     if (Math.abs(totalPrice - manualTotal) > 1) {
  968 â”‚       console.error(`âš ï¸ DiscrepÃ¢ncia detectada no cÃ¡lculo do preÃ§o total!`);
  969 â”‚       console.error(`   - Total calculado iterativamente: â‚¬${totalPrice}`);
  970 â”‚       console.error(`   - Total calculado via reduce: â‚¬${manualTotal}`);
  971 â”‚       console.error(`   - Usando o valor recalculado para seguranÃ§a!`);
  972 â”‚       totalPrice = manualTotal;
  973 â”‚     }
  974 â”‚     
  975 â”‚     // Calcular taxa de serviÃ§o
  976 â”‚     const serviceFee = (totalPrice * (roomData.serviceFeePct || 0)) / 100;
  977 â”‚     const totalWithFee = totalPrice + serviceFee;
  978 â”‚     
  979 â”‚     console.log(`ğŸ’° Resumo do cÃ¡lculo:`);
  980 â”‚     console.log(`   - Total das diÃ¡rias: â‚¬${totalPrice}`);
  981 â”‚     console.log(`   - Taxa de serviÃ§o (${roomData.serviceFeePct || 0}%): â‚¬${serviceFee}`);
  982 â”‚     console.log(`   - Total com taxas: â‚¬${totalWithFee}`);
  983 â”‚     
  984 â”‚     return {
  985 â”‚       totalPrice,
  986 â”‚       nightlyPrices,
  987 â”‚       serviceFee,
  988 â”‚       totalWithFee
  989 â”‚     };
  990 â”‚   } catch (error) {
  991 â”‚     console.error("âŒ Erro ao calcular preÃ§o da estadia:", error);
  992 â”‚     throw error;
  993 â”‚   }
  994 â”‚ } 
  995 â”‚ import { 
  996 â”‚   collection, 
  997 â”‚   getDocs, 
  998 â”‚   getDoc, 
  999 â”‚   doc, 
 1000 â”‚   setDoc, 
 1001 â”‚   addDoc, 
 1002 â”‚   updateDoc, 
 1003 â”‚   deleteDoc,
 1004 â”‚   query,
 1005 â”‚   where,
      Â·   â”€â”€â”¬â”€â”€
      Â·     â•°â”€â”€ `where` redefined here
 1006 â”‚   orderBy,
 1007 â”‚   limit,
 1008 â”‚   serverTimestamp
      â•°â”€â”€â”€â”€

  Ã— the name `orderBy` is defined multiple times
      â•­â”€[/home/runner/workspace/lib/firebase/firestore.ts:9:1]
    9 â”‚   deleteDoc,
   10 â”‚   query,
   11 â”‚   where,
   12 â”‚   orderBy,
      Â·   â”€â”€â”€â”¬â”€â”€â”€
      Â·      â•°â”€â”€ previous definition of `orderBy` here
   13 â”‚   limit,
   14 â”‚   DocumentData,
   15 â”‚   QueryConstraint,
   16 â”‚   Timestamp,
   17 â”‚   serverTimestamp
   18 â”‚ } from 'firebase/firestore'
   19 â”‚ import { db } from './config'
   20 â”‚ import { Room, SeasonalPrice } from '@/lib/types'
   21 â”‚ import { differenceInDays } from 'date-fns'
   22 â”‚ 
   23 â”‚ // Tipos de dados
   24 â”‚ export interface Booking {
   25 â”‚   id?: string
   26 â”‚   userId?: string
   27 â”‚   guestName: string
   28 â”‚   guestEmail: string
   29 â”‚   guestPhone: string
   30 â”‚   roomId: string
   31 â”‚   roomName: string
   32 â”‚   checkIn: Timestamp
   33 â”‚   checkOut: Timestamp
   34 â”‚   adults: number
   35 â”‚   children: number
   36 â”‚   totalPrice: number
   37 â”‚   status: 'pending' | 'confirmed' | 'cancelled' | 'completed'
   38 â”‚   paymentStatus: 'pending' | 'paid' | 'refunded'
   39 â”‚   specialRequests?: string
   40 â”‚   createdAt?: Timestamp
   41 â”‚   updatedAt?: Timestamp
   42 â”‚ }
   43 â”‚ 
   44 â”‚ export interface Contact {
   45 â”‚   id?: string
   46 â”‚   name: string
   47 â”‚   email: string
   48 â”‚   phone?: string
   49 â”‚   subject: string
   50 â”‚   message: string
   51 â”‚   status: 'new' | 'read' | 'replied'
   52 â”‚   createdAt: Timestamp
   53 â”‚   updatedAt?: Timestamp
   54 â”‚   repliedAt?: Timestamp
   55 â”‚   replyContent?: string
   56 â”‚   reservationDetails?: {
   57 â”‚     checkIn?: Timestamp
   58 â”‚     checkOut?: Timestamp
   59 â”‚     roomId?: string
   60 â”‚     roomName?: string
   61 â”‚     totalGuests?: number
   62 â”‚     totalPrice?: number
   63 â”‚   }
   64 â”‚ }
   65 â”‚ 
   66 â”‚ // FunÃ§Ãµes genÃ©ricas para CRUD
   67 â”‚ export const createDocument = async <T extends DocumentData>(
   68 â”‚   collectionName: string,
   69 â”‚   data: T
   70 â”‚ ): Promise<string> => {
   71 â”‚   const docRef = await addDoc(collection(db, collectionName), {
   72 â”‚     ...data,
   73 â”‚     createdAt: serverTimestamp(),
   74 â”‚     updatedAt: serverTimestamp()
   75 â”‚   })
   76 â”‚   return docRef.id
   77 â”‚ }
   78 â”‚ 
   79 â”‚ export const createDocumentWithId = async <T extends DocumentData>(
   80 â”‚   collectionName: string,
   81 â”‚   id: string,
   82 â”‚   data: T
   83 â”‚ ): Promise<void> => {
   84 â”‚   await setDoc(doc(db, collectionName, id), {
   85 â”‚     ...data,
   86 â”‚     createdAt: serverTimestamp(),
   87 â”‚     updatedAt: serverTimestamp()
   88 â”‚   })
   89 â”‚ }
   90 â”‚ 
   91 â”‚ export const getDocument = async <T>(
   92 â”‚   collectionName: string,
   93 â”‚   id: string
   94 â”‚ ): Promise<T | null> => {
   95 â”‚   const docRef = doc(db, collectionName, id)
   96 â”‚   const docSnap = await getDoc(docRef)
   97 â”‚   
   98 â”‚   if (docSnap.exists()) {
   99 â”‚     const data = docSnap.data();
  100 â”‚     console.log("Dados brutos recuperados do Firestore para quarto:", id, data);
  101 â”‚     
  102 â”‚     if (data?.serviceFeePct !== undefined) {
  103 â”‚       console.log("serviceFeePct antes da conversÃ£o:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
  104 â”‚       // Garantir que serviceFeePct seja um nÃºmero
  105 â”‚       data.serviceFeePct = Number(data.serviceFeePct);
  106 â”‚       console.log("serviceFeePct apÃ³s conversÃ£o:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
  107 â”‚     }
  108 â”‚     
  109 â”‚     return { id: docSnap.id, ...data } as T
  110 â”‚   } else {
  111 â”‚     return null
  112 â”‚   }
  113 â”‚ }
  114 â”‚ 
  115 â”‚ export const getDocuments = async <T>(
  116 â”‚   collectionName: string,
  117 â”‚   constraints: QueryConstraint[] = [],
  118 â”‚   forceRefresh = false
  119 â”‚ ): Promise<T[]> => {
  120 â”‚   try {
  121 â”‚     const collectionRef = collection(db, collectionName)
  122 â”‚     const q = query(collectionRef, ...constraints)
  123 â”‚     
  124 â”‚     // Se forceRefresh for verdadeiro, adicionar opÃ§Ãµes que forÃ§am uma nova consulta ao Firestore
  125 â”‚     const querySnapshot = await getDocs(q)
  126 â”‚     
  127 â”‚     console.log(`Buscando documentos na coleÃ§Ã£o ${collectionName} - ForÃ§a atualizaÃ§Ã£o: ${forceRefresh}`);
  128 â”‚     
  129 â”‚     return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }) as T)
  130 â”‚   } catch (error) {
  131 â”‚     console.error(`Erro ao buscar documentos da coleÃ§Ã£o ${collectionName}:`, error);
  132 â”‚     return [];
  133 â”‚   }
  134 â”‚ }
  135 â”‚ 
  136 â”‚ export const updateDocument = async <T extends DocumentData>(
  137 â”‚   collectionName: string,
  138 â”‚   id: string,
  139 â”‚   data: Partial<T>
  140 â”‚ ): Promise<void> => {
  141 â”‚   const docRef = doc(db, collectionName, id)
  142 â”‚   await updateDoc(docRef, {
  143 â”‚     ...data,
  144 â”‚     updatedAt: serverTimestamp()
  145 â”‚   })
  146 â”‚ }
  147 â”‚ 
  148 â”‚ export const deleteDocument = async (
  149 â”‚   collectionName: string,
  150 â”‚   id: string
  151 â”‚ ): Promise<boolean> => {
  152 â”‚   const docRef = doc(db, collectionName, id)
  153 â”‚   await deleteDoc(docRef)
  154 â”‚   return true
  155 â”‚ }
  156 â”‚ 
  157 â”‚ // FunÃ§Ãµes para gerenciar quartos
  158 â”‚ export const getRooms = async (forceRefresh = false): Promise<Room[]> => {
  159 â”‚   try {
  160 â”‚     const constraints: QueryConstraint[] = []
  161 â”‚     
  162 â”‚     constraints.push(orderBy('name', 'asc'))
  163 â”‚     
  164 â”‚     const rooms = await getDocuments<Room>('rooms', constraints, forceRefresh)
  165 â”‚     
  166 â”‚     // Garantir que todos os campos necessÃ¡rios estejam presentes
  167 â”‚     return rooms.map(room => {
  168 â”‚       console.log(`Firebase - Quarto ${room.id} dados brutos:`, room);
  169 â”‚       
  170 â”‚       // Garantir que serviceFeePct seja um nÃºmero
  171 â”‚       const serviceFeePct = room.serviceFeePct !== undefined 
  172 â”‚         ? Number(room.serviceFeePct) 
  173 â”‚         : 10;
  174 â”‚         
  175 â”‚       console.log(`Firebase - Quarto ${room.id} serviceFeePct:`, {
  176 â”‚         original: room.serviceFeePct,
  177 â”‚         tipo: typeof room.serviceFeePct,
  178 â”‚         convertido: serviceFeePct
  179 â”‚       });
  180 â”‚       
  181 â”‚       return {
  182 â”‚         id: room.id,
  183 â”‚         name: room.name || '',
  184 â”‚         type: room.type || 'standard',
  185 â”‚         description: room.description || '',
  186 â”‚         price: room.price || 0,
  187 â”‚         capacity: room.capacity || 2,
  188 â”‚         size: room.size || 0,
  189 â”‚         available: room.available !== undefined ? room.available : true,
  190 â”‚         serviceFeePct: serviceFeePct,
  191 â”‚         images: room.images || [],
  192 â”‚         amenities: room.amenities || [],
  193 â”‚         additionalServices: room.additionalServices || [],
  194 â”‚         highlights: room.highlights || [],
  195 â”‚         createdAt: room.createdAt,
  196 â”‚         updatedAt: room.updatedAt
  197 â”‚       };
  198 â”‚     });
  199 â”‚   } catch (error) {
  200 â”‚     console.error('Erro ao buscar quartos:', error)
  201 â”‚     return []
  202 â”‚   }
  203 â”‚ }
  204 â”‚ 
  205 â”‚ export const getAvailableRooms = async (
  206 â”‚   checkIn: Date,
  207 â”‚   checkOut: Date
  208 â”‚ ): Promise<Room[]> => {
  209 â”‚   try {
  210 â”‚     // Buscar todos os quartos que estÃ£o marcados como disponÃ­veis em geral
  211 â”‚     const constraints: QueryConstraint[] = [
  212 â”‚       where('available', '==', true)
  213 â”‚     ]
  214 â”‚     
  215 â”‚     const rooms = await getDocuments<Room>('rooms', constraints);
  216 â”‚     
  217 â”‚     // Filtrar os quartos que estÃ£o disponÃ­veis nas datas especÃ­ficas
  218 â”‚     return filterAvailableRoomsByDate(rooms, checkIn, checkOut);
  219 â”‚   } catch (error) {
  220 â”‚     console.error('Erro ao buscar quartos disponÃ­veis:', error)
  221 â”‚     return []
  222 â”‚   }
  223 â”‚ }
  224 â”‚ 
  225 â”‚ // FunÃ§Ã£o auxiliar para verificar disponibilidade entre datas
  226 â”‚ export const filterAvailableRoomsByDate = (
  227 â”‚   rooms: Room[],
  228 â”‚   checkIn: Date,
  229 â”‚   checkOut: Date
  230 â”‚ ): Room[] => {
  231 â”‚   // Converter checkIn e checkOut para ISO strings
  232 â”‚   const dateStrings = getDatesInRange(checkIn, checkOut);
  233 â”‚   
  234 â”‚   return rooms.filter(room => {
  235 â”‚     // Se nÃ£o tiver controle de disponibilidade especÃ­fico, considera disponÃ­vel
  236 â”‚     if (!room.availabilityDates) return true;
  237 â”‚     
  238 â”‚     // Verificar se alguma data no intervalo estÃ¡ indisponÃ­vel
  239 â”‚     return !dateStrings.some(dateStr => 
  240 â”‚       room.availabilityDates?.[dateStr] === false
  241 â”‚     );
  242 â”‚   });
  243 â”‚ };
  244 â”‚ 
  245 â”‚ // FunÃ§Ã£o para obter disponibilidade de um quarto especÃ­fico
  246 â”‚ export const getRoomAvailability = async (
  247 â”‚   roomId: string, 
  248 â”‚   startDate: Date, 
  249 â”‚   endDate: Date
  250 â”‚ ): Promise<{[date: string]: boolean}> => {
  251 â”‚   try {
  252 â”‚     const room = await getRoomById(roomId);
  253 â”‚     if (!room) throw new Error(`Quarto com ID ${roomId} nÃ£o encontrado`);
  254 â”‚     
  255 â”‚     // Gerar datas no intervalo
  256 â”‚     const dateStrings = getDatesInRange(startDate, endDate);
  257 â”‚     
  258 â”‚     // Se nÃ£o tiver configuraÃ§Ã£o de disponibilidade especÃ­fica, assume tudo disponÃ­vel
  259 â”‚     if (!room.availabilityDates) {
  260 â”‚       return dateStrings.reduce((acc, date) => {
  261 â”‚         acc[date] = true;
  262 â”‚         return acc;
  263 â”‚       }, {} as {[date: string]: boolean});
  264 â”‚     }
  265 â”‚     
  266 â”‚     // Preencher com os dados de disponibilidade existentes
  267 â”‚     return dateStrings.reduce((acc, date) => {
  268 â”‚       acc[date] = room.availabilityDates?.[date] !== false; // disponÃ­vel por padrÃ£o se nÃ£o estiver explicitamente indisponÃ­vel
  269 â”‚       return acc;
  270 â”‚     }, {} as {[date: string]: boolean});
  271 â”‚   } catch (error) {
  272 â”‚     console.error(`Erro ao verificar disponibilidade do quarto ${roomId}:`, error);
  273 â”‚     throw error;
  274 â”‚   }
  275 â”‚ };
  276 â”‚ 
  277 â”‚ // FunÃ§Ã£o para atualizar disponibilidade de um quarto
  278 â”‚ export const updateRoomAvailability = async (
  279 â”‚   roomId: string,
  280 â”‚   availabilityDates: {[date: string]: boolean}
  281 â”‚ ): Promise<boolean> => {
  282 â”‚   try {
  283 â”‚     await updateDocument('rooms', roomId, {
  284 â”‚       availabilityDates,
  285 â”‚       updatedAt: serverTimestamp()
  286 â”‚     });
  287 â”‚     return true;
  288 â”‚   } catch (error) {
  289 â”‚     console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  290 â”‚     return false;
  291 â”‚   }
  292 â”‚ };
  293 â”‚ 
  294 â”‚ // FunÃ§Ã£o auxiliar para gerar array de strings de data entre um intervalo
  295 â”‚ export const getDatesInRange = (startDate: Date, endDate: Date): string[] => {
  296 â”‚   const dates: string[] = [];
  297 â”‚   const currentDate = new Date(startDate);
  298 â”‚   
  299 â”‚   // Normalizar para meia-noite no fuso horÃ¡rio local
  300 â”‚   currentDate.setHours(0, 0, 0, 0);
  301 â”‚   const endDateNormalized = new Date(endDate);
  302 â”‚   endDateNormalized.setHours(0, 0, 0, 0);
  303 â”‚   
  304 â”‚   // Adicionar cada data no intervalo EXCETO o dia de checkout
  305 â”‚   // Usando < em vez de <= para nÃ£o incluir o dia de checkout
  306 â”‚   while (currentDate < endDateNormalized) {
  307 â”‚     dates.push(currentDate.toISOString().split('T')[0]); // Formato YYYY-MM-DD
  308 â”‚     currentDate.setDate(currentDate.getDate() + 1);
  309 â”‚   }
  310 â”‚   
  311 â”‚   return dates;
  312 â”‚ };
  313 â”‚ 
  314 â”‚ export const getRoomById = async (id: string): Promise<Room | null> => {
  315 â”‚   try {
  316 â”‚     const room = await getDocument<Room>('rooms', id);
  317 â”‚     
  318 â”‚     if (!room) return null;
  319 â”‚     
  320 â”‚     console.log(`Firebase - getRoomById ${id} dados brutos:`, room);
  321 â”‚     
  322 â”‚     // Log especÃ­fico para serviceFeePct
  323 â”‚     console.log(`serviceFeePct no Firestore:`, room.serviceFeePct);
  324 â”‚     
  325 â”‚     // Garantir que todos os campos necessÃ¡rios estejam presentes
  326 â”‚     return {
  327 â”‚       ...room,
  328 â”‚       name: room.name || '',
  329 â”‚       type: room.type || 'standard',
  330 â”‚       description: room.description || '',
  331 â”‚       price: room.price || 0,
  332 â”‚       capacity: room.capacity || 2,
  333 â”‚       size: room.size || 0,
  334 â”‚       available: room.available !== undefined ? room.available : true,
  335 â”‚       serviceFeePct: room.serviceFeePct !== undefined ? room.serviceFeePct : 10,
  336 â”‚       images: room.images || [],
  337 â”‚       amenities: room.amenities || [],
  338 â”‚       additionalServices: room.additionalServices || [],
  339 â”‚       highlights: room.highlights || []
  340 â”‚     };
  341 â”‚   } catch (error) {
  342 â”‚     console.error(`Erro ao buscar quarto com ID ${id}:`, error);
  343 â”‚     return null;
  344 â”‚   }
  345 â”‚ }
  346 â”‚ 
  347 â”‚ export const createRoom = async (roomData: Omit<Room, 'id' | 'createdAt' | 'updatedAt'>): Promise<Room> => {
  348 â”‚   try {
  349 â”‚     console.log("createRoom - Dados recebidos:", roomData);
  350 â”‚     
  351 â”‚     const roomWithTimestamps = {
  352 â”‚       ...roomData,
  353 â”‚       available: roomData.available !== undefined ? roomData.available : true,
  354 â”‚       featured: roomData.featured || false,
  355 â”‚       amenities: roomData.amenities || [],
  356 â”‚       additionalServices: roomData.additionalServices || [],
  357 â”‚       highlights: roomData.highlights || [],
  358 â”‚       createdAt: serverTimestamp(),
  359 â”‚       updatedAt: serverTimestamp()
  360 â”‚     }
  361 â”‚     
  362 â”‚     console.log("createRoom - Dados a serem salvos:", roomWithTimestamps);
  363 â”‚     
  364 â”‚     const id = await createDocument('rooms', roomWithTimestamps)
  365 â”‚     
  366 â”‚     return {
  367 â”‚       id,
  368 â”‚       ...roomData,
  369 â”‚       amenities: roomData.amenities || [],
  370 â”‚       additionalServices: roomData.additionalServices || [],
  371 â”‚       highlights: roomData.highlights || [],
  372 â”‚       createdAt: Timestamp.now(),
  373 â”‚       updatedAt: Timestamp.now()
  374 â”‚     }
  375 â”‚   } catch (error) {
  376 â”‚     console.error('Erro ao criar quarto:', error)
  377 â”‚     throw error
  378 â”‚   }
  379 â”‚ }
  380 â”‚ 
  381 â”‚ export const updateRoom = async (id: string, roomData: Partial<Omit<Room, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Room> => {
  382 â”‚   try {
  383 â”‚     console.log(`updateRoom - ID: ${id}, Dados recebidos:`, roomData);
  384 â”‚     
  385 â”‚     // Garantir que estamos lidando explicitamente com o serviceFeePct se ele for 0
  386 â”‚     if (roomData.serviceFeePct === 0) {
  387 â”‚       console.log("updateRoom - Detectado serviceFeePct com valor 0, salvando explicitamente.", roomData.serviceFeePct);
  388 â”‚     }
  389 â”‚     
  390 â”‚     // Adicionar timestamp de atualizaÃ§Ã£o
  391 â”‚     const roomWithTimestamp = {
  392 â”‚       ...roomData,
  393 â”‚       amenities: roomData.amenities || [],
  394 â”‚       additionalServices: roomData.additionalServices || [],
  395 â”‚       highlights: roomData.highlights || [],
  396 â”‚       updatedAt: serverTimestamp()
  397 â”‚     }
  398 â”‚     
  399 â”‚     console.log(`updateRoom - Dados a serem salvos:`, roomWithTimestamp);
  400 â”‚     
  401 â”‚     await updateDocument('rooms', id, roomWithTimestamp)
  402 â”‚     
  403 â”‚     const updatedRoom = await getRoomById(id)
  404 â”‚     if (!updatedRoom) {
  405 â”‚       throw new Error(`Quarto com ID ${id} nÃ£o encontrado apÃ³s atualizaÃ§Ã£o`)
  406 â”‚     }
  407 â”‚     
  408 â”‚     return updatedRoom
  409 â”‚   } catch (error) {
  410 â”‚     console.error('Erro ao atualizar quarto:', error)
  411 â”‚     throw error
  412 â”‚   }
  413 â”‚ }
  414 â”‚ 
  415 â”‚ export const deleteRoom = async (id: string): Promise<boolean> => {
  416 â”‚   return await deleteDocument('rooms', id)
  417 â”‚ }
  418 â”‚ 
  419 â”‚ // FunÃ§Ãµes especÃ­ficas para reservas
  420 â”‚ export const createBooking = async (bookingData: any) => {
  421 â”‚   try {
  422 â”‚     const bookingsCollection = collection(db, 'bookings');
  423 â”‚     const docRef = await addDoc(bookingsCollection, bookingData);
  424 â”‚     
  425 â”‚     // CORREÃ‡ÃƒO: NÃ£o bloquear a data no momento da criaÃ§Ã£o da reserva
  426 â”‚     // O bloqueio serÃ¡ feito apenas quando o pagamento for confirmado
  427 â”‚     // atravÃ©s da funÃ§Ã£o updateBookingStatus
  428 â”‚     
  429 â”‚     return docRef;
  430 â”‚   } catch (error) {
  431 â”‚     console.error('Erro ao criar reserva:', error);
  432 â”‚     throw error;
  433 â”‚   }
  434 â”‚ };
  435 â”‚ 
  436 â”‚ // Nova funÃ§Ã£o para atualizar status da reserva e bloquear as datas da estadia
  437 â”‚ export const updateBookingStatus = async (
  438 â”‚   bookingId: string, 
  439 â”‚   newStatus: 'pending' | 'confirmed' | 'cancelled' | 'completed',
  440 â”‚   newPaymentStatus: 'pending' | 'paid' | 'refunded'
  441 â”‚ ): Promise<boolean> => {
  442 â”‚   try {
  443 â”‚     // ReferÃªncia ao documento da reserva
  444 â”‚     const bookingRef = doc(db, 'bookings', bookingId);
  445 â”‚     const bookingSnap = await getDoc(bookingRef);
  446 â”‚     
  447 â”‚     if (!bookingSnap.exists()) {
  448 â”‚       console.error(`Booking ${bookingId} nÃ£o existe ao atualizar status`);
  449 â”‚       return false;
  450 â”‚     }
  451 â”‚     
  452 â”‚     const bookingData = bookingSnap.data();
  453 â”‚     
  454 â”‚     // Atualizar o status da reserva
  455 â”‚     await updateDoc(bookingRef, {
  456 â”‚       status: newStatus,
  457 â”‚       paymentStatus: newPaymentStatus,
  458 â”‚       updatedAt: serverTimestamp(),
  459 â”‚       ...(newStatus === 'confirmed' && { confirmedAt: serverTimestamp() })
  460 â”‚     });
  461 â”‚     
  462 â”‚     // Se a reserva estÃ¡ sendo confirmada, precisamos bloquear as datas
  463 â”‚     if (newStatus === 'confirmed') {
  464 â”‚       console.log(`Atualizando disponibilidade para reserva confirmada: ${bookingId}`);
  465 â”‚       
  466 â”‚       // Recuperar datas de check-in e check-out
  467 â”‚       const checkIn = bookingData.checkIn.toDate();
  468 â”‚       const checkOut = bookingData.checkOut.toDate();
  469 â”‚       const roomId = bookingData.roomId;
  470 â”‚       
  471 â”‚       // Obter todas as datas entre check-in e check-out
  472 â”‚       const dates: Date[] = [];
  473 â”‚       const currentDate = new Date(checkIn);
  474 â”‚       
  475 â”‚       while (currentDate < checkOut) {
  476 â”‚         dates.push(new Date(currentDate));
  477 â”‚         currentDate.setDate(currentDate.getDate() + 1);
  478 â”‚       }
  479 â”‚       
  480 â”‚       console.log(`Bloqueando ${dates.length} dias para quarto ${roomId}`);
  481 â”‚       
  482 â”‚       // Atualizar disponibilidade para cada data
  483 â”‚       const availabilityUpdates: {[date: string]: boolean} = {};
  484 â”‚       
  485 â”‚       dates.forEach(date => {
  486 â”‚         const dateString = date.toISOString().split('T')[0]; // formato YYYY-MM-DD
  487 â”‚         availabilityUpdates[dateString] = false; // false significa indisponÃ­vel
  488 â”‚       });
  489 â”‚       
  490 â”‚       // Atualizar disponibilidade do quarto
  491 â”‚       if (Object.keys(availabilityUpdates).length > 0) {
  492 â”‚         try {
  493 â”‚           // Obter o documento do quarto
  494 â”‚           const roomRef = doc(db, 'rooms', roomId);
  495 â”‚           const roomSnap = await getDoc(roomRef);
  496 â”‚           
  497 â”‚           if (roomSnap.exists()) {
  498 â”‚             const roomData = roomSnap.data();
  499 â”‚             const currentAvailability = roomData.availabilityDates || {};
  500 â”‚             
  501 â”‚             // Mesclar a disponibilidade atual com as novas atualizaÃ§Ãµes
  502 â”‚             const updatedAvailability = {
  503 â”‚               ...currentAvailability,
  504 â”‚               ...availabilityUpdates
  505 â”‚             };
  506 â”‚             
  507 â”‚             // Atualizar o documento do quarto
  508 â”‚             await updateDoc(roomRef, {
  509 â”‚               availabilityDates: updatedAvailability,
  510 â”‚               updatedAt: serverTimestamp()
  511 â”‚             });
  512 â”‚             
  513 â”‚             console.log(`Disponibilidade atualizada com sucesso para quarto ${roomId}`);
  514 â”‚             
  515 â”‚             // Criar log da reserva
  516 â”‚             await addDoc(collection(db, 'bookingLogs'), {
  517 â”‚               bookingId,
  518 â”‚               roomId,
  519 â”‚               action: 'status_updated',
  520 â”‚               previousStatus: bookingData.status,
  521 â”‚               newStatus,
  522 â”‚               previousPaymentStatus: bookingData.paymentStatus,
  523 â”‚               newPaymentStatus,
  524 â”‚               datesBlocked: Object.keys(availabilityUpdates),
  525 â”‚               timestamp: serverTimestamp(),
  526 â”‚               userId: bookingData.userId || 'system'
  527 â”‚             });
  528 â”‚           } else {
  529 â”‚             console.error(`Quarto ${roomId} nÃ£o encontrado ao atualizar disponibilidade`);
  530 â”‚           }
  531 â”‚         } catch (error) {
  532 â”‚           console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  533 â”‚         }
  534 â”‚       }
  535 â”‚     }
  536 â”‚     
  537 â”‚     return true;
  538 â”‚   } catch (error) {
  539 â”‚     console.error(`Erro ao atualizar status da reserva ${bookingId}:`, error);
  540 â”‚     return false;
  541 â”‚   }
  542 â”‚ }
  543 â”‚ 
  544 â”‚ export const getUserBookings = async (userId: string): Promise<Booking[]> => {
  545 â”‚   return getDocuments<Booking>('bookings', [
  546 â”‚     where('userId', '==', userId),
  547 â”‚     orderBy('createdAt', 'desc')
  548 â”‚   ])
  549 â”‚ }
  550 â”‚ 
  551 â”‚ export const getRecentBookings = async (count = 5): Promise<Booking[]> => {
  552 â”‚   return getDocuments<Booking>('bookings', [
  553 â”‚     orderBy('createdAt', 'desc'),
  554 â”‚     limit(count)
  555 â”‚   ])
  556 â”‚ }
  557 â”‚ 
  558 â”‚ export const getRoomBookings = async (roomId: string): Promise<Booking[]> => {
  559 â”‚   try {
  560 â”‚     const constraints: QueryConstraint[] = [
  561 â”‚       where('roomId', '==', roomId),
  562 â”‚       orderBy('checkIn', 'asc')
  563 â”‚     ];
  564 â”‚     
  565 â”‚     return await getDocuments<Booking>('bookings', constraints);
  566 â”‚   } catch (error) {
  567 â”‚     console.error(`Erro ao buscar reservas do quarto ${roomId}:`, error);
  568 â”‚     return [];
  569 â”‚   }
  570 â”‚ };
  571 â”‚ 
  572 â”‚ // FunÃ§Ãµes especÃ­ficas para contatos
  573 â”‚ export const createContactMessage = async (contactData: Contact) => {
  574 â”‚   try {
  575 â”‚     const contactsCollection = collection(db, 'contacts')
  576 â”‚     
  577 â”‚     // Garantir que o status seja 'new' para novos contatos
  578 â”‚     const contactWithDefaults = {
  579 â”‚       ...contactData,
  580 â”‚       status: contactData.status || 'new',
  581 â”‚       createdAt: contactData.createdAt || Timestamp.now()
  582 â”‚     }
  583 â”‚     
  584 â”‚     // Se tiver detalhes de reserva, adicionar metadados
  585 â”‚     if (contactWithDefaults.reservationDetails) {
  586 â”‚       // Ajustar subject para indicar que Ã© relacionado a reserva
  587 â”‚       if (!contactWithDefaults.subject.includes('Reserva')) {
  588 â”‚         contactWithDefaults.subject = `Reserva: ${contactWithDefaults.subject}`;
  589 â”‚       }
  590 â”‚     }
  591 â”‚     
  592 â”‚     const docRef = await addDoc(contactsCollection, contactWithDefaults)
  593 â”‚     return docRef
  594 â”‚   } catch (error) {
  595 â”‚     console.error('Erro ao criar mensagem de contato:', error)
  596 â”‚     throw error
  597 â”‚   }
  598 â”‚ }
  599 â”‚ 
  600 â”‚ export const getNewContactMessages = async (): Promise<Contact[]> => {
  601 â”‚   return getDocuments<Contact>('contacts', [
  602 â”‚     where('status', '==', 'new'),
  603 â”‚     orderBy('createdAt', 'desc')
  604 â”‚   ])
  605 â”‚ }
  606 â”‚ 
  607 â”‚ // FunÃ§Ãµes para Dashboard com dados reais
  608 â”‚ 
  609 â”‚ export const getDashboardStats = async () => {
  610 â”‚   try {
  611 â”‚     const [totalBookings, totalRevenue, occupancyRate, bookingsByPlatform] = await Promise.all([
  612 â”‚       getTotalBookings(),
  613 â”‚       getMonthlyRevenue(),
  614 â”‚       getOccupancyRate(),
  615 â”‚       getBookingsByPlatform()
  616 â”‚     ]);
  617 â”‚ 
  618 â”‚     return {
  619 â”‚       totalBookings,
  620 â”‚       totalRevenue,
  621 â”‚       occupancyRate,
  622 â”‚       bookingsByPlatform
  623 â”‚     };
  624 â”‚   } catch (error) {
  625 â”‚     console.error('Erro ao obter estatÃ­sticas do dashboard:', error);
  626 â”‚     throw error;
  627 â”‚   }
  628 â”‚ };
  629 â”‚ 
  630 â”‚ // Obter total de reservas
  631 â”‚ export const getTotalBookings = async () => {
  632 â”‚   try {
  633 â”‚     // Obter todas as reservas
  634 â”‚     const bookings = await getDocuments<Booking>('bookings');
  635 â”‚     
  636 â”‚     // Contar reservas por status
  637 â”‚     const confirmed = bookings.filter(b => b.status === 'confirmed').length;
  638 â”‚     const pending = bookings.filter(b => b.status === 'pending').length;
  639 â”‚     const cancelled = bookings.filter(b => b.status === 'cancelled').length;
  640 â”‚     const completed = bookings.filter(b => b.status === 'completed').length;
  641 â”‚     
  642 â”‚     // Calcular crescimento em relaÃ§Ã£o ao mÃªs anterior (simulado por enquanto)
  643 â”‚     // Em uma implementaÃ§Ã£o real, vocÃª compararia com dados do mÃªs anterior
  644 â”‚     const growth = ((confirmed + completed) / (bookings.length || 1) * 100) - 50;
  645 â”‚     
  646 â”‚     return {
  647 â”‚       total: bookings.length,
  648 â”‚       confirmed,
  649 â”‚       pending,
  650 â”‚       cancelled,
  651 â”‚       completed,
  652 â”‚       growth: Math.round(growth) // Arredonda para nÃºmero inteiro
  653 â”‚     };
  654 â”‚   } catch (error) {
  655 â”‚     console.error('Erro ao obter total de reservas:', error);
  656 â”‚     return {
  657 â”‚       total: 0,
  658 â”‚       confirmed: 0,
  659 â”‚       pending: 0, 
  660 â”‚       cancelled: 0,
  661 â”‚       completed: 0,
  662 â”‚       growth: 0
  663 â”‚     };
  664 â”‚   }
  665 â”‚ };
  666 â”‚ 
  667 â”‚ // Obter receita mensal
  668 â”‚ export const getMonthlyRevenue = async () => {
  669 â”‚   try {
  670 â”‚     const bookings = await getDocuments<Booking>('bookings');
  671 â”‚     
  672 â”‚     // Filtrar reservas confirmadas e concluÃ­das
  673 â”‚     const validBookings = bookings.filter(b => 
  674 â”‚       b.status === 'confirmed' || b.status === 'completed'
  675 â”‚     );
  676 â”‚     
  677 â”‚     // Calcular receita total
  678 â”‚     const totalRevenue = validBookings.reduce((acc, booking) => acc + booking.totalPrice, 0);
  679 â”‚     
  680 â”‚     // Agrupar receita por mÃªs
  681 â”‚     const revenueByMonth = validBookings.reduce((acc, booking) => {
  682 â”‚       const date = booking.checkIn.toDate();
  683 â”‚       const month = date.getMonth(); // 0-11
  684 â”‚       const year = date.getFullYear();
  685 â”‚       const key = `${year}-${month}`;
  686 â”‚       
  687 â”‚       if (!acc[key]) {
  688 â”‚         acc[key] = 0;
  689 â”‚       }
  690 â”‚       acc[key] += booking.totalPrice;
  691 â”‚       return acc;
  692 â”‚     }, {} as Record<string, number>);
  693 â”‚     
  694 â”‚     // Converter para formato de array para grÃ¡fico
  695 â”‚     const monthNames = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
  696 â”‚     
  697 â”‚     const currentDate = new Date();
  698 â”‚     const currentMonth = currentDate.getMonth();
  699 â”‚     const currentYear = currentDate.getFullYear();
  700 â”‚     
  701 â”‚     const revenueData = [];
  702 â”‚     
  703 â”‚     // Gerar dados dos Ãºltimos 12 meses
  704 â”‚     for (let i = 0; i < 12; i++) {
  705 â”‚       const month = (currentMonth - i + 12) % 12;
  706 â”‚       const year = currentMonth - i < 0 ? currentYear - 1 : currentYear;
  707 â”‚       const key = `${year}-${month}`;
  708 â”‚       
  709 â”‚       revenueData.unshift({
  710 â”‚         month: monthNames[month],
  711 â”‚         value: revenueByMonth[key] || 0
  712 â”‚       });
  713 â”‚     }
  714 â”‚     
  715 â”‚     // Calcular crescimento em relaÃ§Ã£o ao mÃªs anterior
  716 â”‚     const lastMonthRevenue = revenueData[revenueData.length - 2]?.value || 0;
  717 â”‚     const currentMonthRevenue = revenueData[revenueData.length - 1]?.value || 0;
  718 â”‚     
  719 â”‚     const growth = lastMonthRevenue ? ((currentMonthRevenue - lastMonthRevenue) / lastMonthRevenue) * 100 : 0;
  720 â”‚     
  721 â”‚     return {
  722 â”‚       monthly: currentMonthRevenue,
  723 â”‚       total: totalRevenue,
  724 â”‚       growth: Math.round(growth),
  725 â”‚       revenueData
  726 â”‚     };
  727 â”‚   } catch (error) {
  728 â”‚     console.error('Erro ao obter receita mensal:', error);
  729 â”‚     return {
  730 â”‚       monthly: 0,
  731 â”‚       total: 0,
  732 â”‚       growth: 0,
  733 â”‚       revenueData: []
  734 â”‚     };
  735 â”‚   }
  736 â”‚ };
  737 â”‚ 
  738 â”‚ // Calcular taxa de ocupaÃ§Ã£o
  739 â”‚ export const getOccupancyRate = async () => {
  740 â”‚   try {
  741 â”‚     // Obter todos os quartos
  742 â”‚     const rooms = await getDocuments<Room>('rooms');
  743 â”‚     const totalRooms = rooms.length;
  744 â”‚     
  745 â”‚     if (totalRooms === 0) {
  746 â”‚       return { rate: 0, growth: 0 };
  747 â”‚     }
  748 â”‚     
  749 â”‚     // Obter todas as reservas
  750 â”‚     const bookings = await getDocuments<Booking>('bookings');
  751 â”‚     
  752 â”‚     // Filtrar reservas confirmadas e concluÃ­das para o mÃªs atual
  753 â”‚     const currentDate = new Date();
  754 â”‚     const currentMonth = currentDate.getMonth();
  755 â”‚     const currentYear = currentDate.getFullYear();
  756 â”‚     
  757 â”‚     const currentMonthBookings = bookings.filter(booking => {
  758 â”‚       const checkInDate = booking.checkIn.toDate();
  759 â”‚       return (
  760 â”‚         (booking.status === 'confirmed' || booking.status === 'completed') &&
  761 â”‚         checkInDate.getMonth() === currentMonth &&
  762 â”‚         checkInDate.getFullYear() === currentYear
  763 â”‚       );
  764 â”‚     });
  765 â”‚     
  766 â”‚     // Calcular dias ocupados por quarto
  767 â”‚     const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
  768 â”‚     const totalPossibleRoomDays = totalRooms * daysInMonth;
  769 â”‚     
  770 â”‚     // Contar dias ocupados (simplificado - em produÃ§Ã£o seria mais complexo)
  771 â”‚     let occupiedDays = 0;
  772 â”‚     
  773 â”‚     currentMonthBookings.forEach(booking => {
  774 â”‚       const checkIn = booking.checkIn.toDate();
  775 â”‚       const checkOut = booking.checkOut.toDate();
  776 â”‚       
  777 â”‚       // Ajustar datas para considerar apenas o mÃªs atual
  778 â”‚       const startDate = new Date(Math.max(
  779 â”‚         checkIn.getTime(),
  780 â”‚         new Date(currentYear, currentMonth, 1).getTime()
  781 â”‚       ));
  782 â”‚       const endDate = new Date(Math.min(
  783 â”‚         checkOut.getTime(),
  784 â”‚         new Date(currentYear, currentMonth + 1, 0).getTime()
  785 â”‚       ));
  786 â”‚       
  787 â”‚       // Calcular dias entre datas (incluindo check-in, excluindo check-out)
  788 â”‚       const days = Math.max(0, Math.floor((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)));
  789 â”‚       occupiedDays += days;
  790 â”‚     });
  791 â”‚     
  792 â”‚     const occupancyRate = (occupiedDays / totalPossibleRoomDays) * 100;
  793 â”‚     
  794 â”‚     // SimulaÃ§Ã£o de crescimento (em produÃ§Ã£o, compararia com mÃªs anterior)
  795 â”‚     const growth = occupancyRate > 50 ? 5 : -3;
  796 â”‚     
  797 â”‚     return {
  798 â”‚       rate: Math.round(occupancyRate),
  799 â”‚       growth: Math.round(growth)
  800 â”‚     };
  801 â”‚   } catch (error) {
  802 â”‚     console.error('Erro ao calcular taxa de ocupaÃ§Ã£o:', error);
  803 â”‚     return { rate: 0, growth: 0 };
  804 â”‚   }
  805 â”‚ };
  806 â”‚ 
  807 â”‚ // Obter reservas agrupadas por plataforma
  808 â”‚ export const getBookingsByPlatform = async () => {
  809 â”‚   try {
  810 â”‚     const bookings = await getDocuments<Booking>('bookings');
  811 â”‚     
  812 â”‚     // Categorizar reservas por origem
  813 â”‚     const platforms = [
  814 â”‚       { 
  815 â”‚         platform: "Booking.com", 
  816 â”‚         color: "#003580", 
  817 â”‚         icon: "Globe",
  818 â”‚         bookings: []
  819 â”‚       },
  820 â”‚       { 
  821 â”‚         platform: "Airbnb", 
  822 â”‚         color: "#FF5A5F", 
  823 â”‚         icon: "Heart",
  824 â”‚         bookings: []
  825 â”‚       },
  826 â”‚       { 
  827 â”‚         platform: "Direto", 
  828 â”‚         color: "#4CAF50", 
  829 â”‚         icon: "Home",
  830 â”‚         bookings: []
  831 â”‚       }
  832 â”‚     ];
  833 â”‚     
  834 â”‚     // Para fins de demonstraÃ§Ã£o, colocar todas as reservas como "Direto" por enquanto
  835 â”‚     // Em produÃ§Ã£o, usaria um campo "platformOrigin" ou similar na tabela de reservas
  836 â”‚     const platformIndex = 2; // Ãndice da plataforma "Direto"
  837 â”‚     
  838 â”‚     bookings.forEach(booking => {
  839 â”‚       // Transformar para o formato esperado pelo componente
  840 â”‚       const transformedBooking = {
  841 â”‚         id: booking.id || '',
  842 â”‚         guestName: booking.guestName,
  843 â”‚         roomName: booking.roomName,
  844 â”‚         checkIn: booking.checkIn.toDate().toLocaleDateString('pt-PT'),
  845 â”‚         checkOut: booking.checkOut.toDate().toLocaleDateString('pt-PT'),
  846 â”‚         status: booking.status,
  847 â”‚         value: new Intl.NumberFormat('pt-PT', {
  848 â”‚           style: 'currency',
  849 â”‚           currency: 'EUR'
  850 â”‚         }).format(booking.totalPrice)
  851 â”‚       };
  852 â”‚       
  853 â”‚       // Adicionar Ã  plataforma "Direto"
  854 â”‚       (platforms[platformIndex] as any).bookings.push(transformedBooking);
  855 â”‚     });
  856 â”‚     
  857 â”‚     return platforms;
  858 â”‚   } catch (error) {
  859 â”‚     console.error('Erro ao obter reservas por plataforma:', error);
  860 â”‚     return [];
  861 â”‚   }
  862 â”‚ };
  863 â”‚ 
  864 â”‚ // FunÃ§Ã£o para obter o preÃ§o de um quarto para uma data especÃ­fica
  865 â”‚ export const getRoomPriceForDate = async (roomId: string, date: Date): Promise<number> => {
  866 â”‚   try {
  867 â”‚     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  868 â”‚     
  869 â”‚     if (!roomDoc.exists()) {
  870 â”‚       throw new Error("Quarto nÃ£o encontrado");
  871 â”‚     }
  872 â”‚     
  873 â”‚     const roomData = roomDoc.data() as Room;
  874 â”‚     const basePrice = roomData.price;
  875 â”‚     
  876 â”‚     if (!roomData.seasonalPrices || roomData.seasonalPrices.length === 0) {
  877 â”‚       return basePrice;
  878 â”‚     }
  879 â”‚     
  880 â”‚     // Verificar se a data estÃ¡ dentro de algum perÃ­odo sazonal
  881 â”‚     for (const seasonalPrice of roomData.seasonalPrices) {
  882 â”‚       const startDate = new Date(seasonalPrice.startDate);
  883 â”‚       const endDate = new Date(seasonalPrice.endDate);
  884 â”‚       
  885 â”‚       if (date >= startDate && date <= endDate) {
  886 â”‚         return seasonalPrice.price;
  887 â”‚       }
  888 â”‚     }
  889 â”‚     
  890 â”‚     // Se nÃ£o cair em nenhum perÃ­odo sazonal, retorna o preÃ§o base
  891 â”‚     return basePrice;
  892 â”‚   } catch (error) {
  893 â”‚     console.error("Erro ao obter preÃ§o do quarto:", error);
  894 â”‚     throw error;
  895 â”‚   }
  896 â”‚ }
  897 â”‚ 
  898 â”‚ // FunÃ§Ã£o para calcular o preÃ§o total de uma estadia
  899 â”‚ export const calculateStayPrice = async (
  900 â”‚   roomId: string, 
  901 â”‚   checkIn: Date, 
  902 â”‚   checkOut: Date
  903 â”‚ ): Promise<{
  904 â”‚   totalPrice: number;
  905 â”‚   nightlyPrices: { date: string; price: number }[];
  906 â”‚   serviceFee: number;
  907 â”‚   totalWithFee: number;
  908 â”‚ }> => {
  909 â”‚   try {
  910 â”‚     console.log(`ğŸ” Iniciando cÃ¡lculo de preÃ§o para estadia: ${checkIn.toISOString().split('T')[0]} atÃ© ${checkOut.toISOString().split('T')[0]}`);
  911 â”‚     
  912 â”‚     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  913 â”‚     
  914 â”‚     if (!roomDoc.exists()) {
  915 â”‚       throw new Error("Quarto nÃ£o encontrado");
  916 â”‚     }
  917 â”‚     
  918 â”‚     const roomData = roomDoc.data() as Room;
  919 â”‚     console.log(`ğŸ“ Dados do quarto ${roomId}:`, {
  920 â”‚       nome: roomData.name,
  921 â”‚       precoBase: roomData.price,
  922 â”‚       taxaServico: roomData.serviceFeePct || 0,
  923 â”‚       temPrecosSazonais: !!roomData.seasonalPrices?.length
  924 â”‚     });
  925 â”‚     
  926 â”‚     const nightlyPrices: { date: string; price: number }[] = [];
  927 â”‚     let totalPrice = 0;
  928 â”‚     
  929 â”‚     // Calcular o nÃºmero de noites - corrigido para usar o mÃ©todo correto de cÃ¡lculo
  930 â”‚     // O nÃºmero de noites Ã© a diferenÃ§a em dias (estadia = checkout - checkin)
  931 â”‚     const noites = differenceInDays(checkOut, checkIn);
  932 â”‚     console.log(`ğŸ—“ï¸ NÃºmero de noites calculado: ${noites}`);
  933 â”‚     
  934 â”‚     if (noites <= 0) {
  935 â”‚       console.error(`âš ï¸ Erro: nÃºmero de noites invÃ¡lido (${noites})`);
  936 â”‚       throw new Error("Data de check-out deve ser posterior Ã  data de check-in");
  937 â”‚     }
  938 â”‚     
  939 â”‚     // Para cada noite, verificar o preÃ§o aplicÃ¡vel (preÃ§o base ou sazonal)
  940 â”‚     // ComeÃ§amos exatamente do dia de check-in
  941 â”‚     const currentDate = new Date(checkIn);
  942 â”‚     currentDate.setHours(0, 0, 0, 0); // Normalizar para meia-noite
  943 â”‚     
  944 â”‚     // Processamos cada dia de estadia (noite)
  945 â”‚     console.log(`ğŸ“Š Calculando preÃ§os por noite:`);
  946 â”‚     for (let i = 0; i < noites; i++) {
  947 â”‚       // Obtemos o preÃ§o para esta data
  948 â”‚       const dateCopy = new Date(currentDate);
  949 â”‚       const priceForDate = await getRoomPriceForDate(roomId, dateCopy);
  950 â”‚       const dateString = dateCopy.toISOString().split('T')[0]; // YYYY-MM-DD
  951 â”‚       
  952 â”‚       console.log(`   - ${dateString}: â‚¬${priceForDate}`);
  953 â”‚       
  954 â”‚       nightlyPrices.push({
  955 â”‚         date: dateString,
  956 â”‚         price: priceForDate
  957 â”‚       });
  958 â”‚       
  959 â”‚       totalPrice += priceForDate;
  960 â”‚       
  961 â”‚       // AvanÃ§amos para o prÃ³ximo dia
  962 â”‚       currentDate.setDate(currentDate.getDate() + 1);
  963 â”‚     }
  964 â”‚     
  965 â”‚     // VerificaÃ§Ã£o de seguranÃ§a para o cÃ¡lculo do totalPrice
  966 â”‚     const manualTotal = nightlyPrices.reduce((sum, night) => sum + night.price, 0);
  967 â”‚     if (Math.abs(totalPrice - manualTotal) > 1) {
  968 â”‚       console.error(`âš ï¸ DiscrepÃ¢ncia detectada no cÃ¡lculo do preÃ§o total!`);
  969 â”‚       console.error(`   - Total calculado iterativamente: â‚¬${totalPrice}`);
  970 â”‚       console.error(`   - Total calculado via reduce: â‚¬${manualTotal}`);
  971 â”‚       console.error(`   - Usando o valor recalculado para seguranÃ§a!`);
  972 â”‚       totalPrice = manualTotal;
  973 â”‚     }
  974 â”‚     
  975 â”‚     // Calcular taxa de serviÃ§o
  976 â”‚     const serviceFee = (totalPrice * (roomData.serviceFeePct || 0)) / 100;
  977 â”‚     const totalWithFee = totalPrice + serviceFee;
  978 â”‚     
  979 â”‚     console.log(`ğŸ’° Resumo do cÃ¡lculo:`);
  980 â”‚     console.log(`   - Total das diÃ¡rias: â‚¬${totalPrice}`);
  981 â”‚     console.log(`   - Taxa de serviÃ§o (${roomData.serviceFeePct || 0}%): â‚¬${serviceFee}`);
  982 â”‚     console.log(`   - Total com taxas: â‚¬${totalWithFee}`);
  983 â”‚     
  984 â”‚     return {
  985 â”‚       totalPrice,
  986 â”‚       nightlyPrices,
  987 â”‚       serviceFee,
  988 â”‚       totalWithFee
  989 â”‚     };
  990 â”‚   } catch (error) {
  991 â”‚     console.error("âŒ Erro ao calcular preÃ§o da estadia:", error);
  992 â”‚     throw error;
  993 â”‚   }
  994 â”‚ } 
  995 â”‚ import { 
  996 â”‚   collection, 
  997 â”‚   getDocs, 
  998 â”‚   getDoc, 
  999 â”‚   doc, 
 1000 â”‚   setDoc, 
 1001 â”‚   addDoc, 
 1002 â”‚   updateDoc, 
 1003 â”‚   deleteDoc,
 1004 â”‚   query,
 1005 â”‚   where,
 1006 â”‚   orderBy,
      Â·   â”€â”€â”€â”¬â”€â”€â”€
      Â·      â•°â”€â”€ `orderBy` redefined here
 1007 â”‚   limit,
 1008 â”‚   serverTimestamp
 1009 â”‚ } from 'firebase/firestore';
      â•°â”€â”€â”€â”€

  Ã— the name `limit` is defined multiple times
      â•­â”€[/home/runner/workspace/lib/firebase/firestore.ts:10:1]
   10 â”‚   query,
   11 â”‚   where,
   12 â”‚   orderBy,
   13 â”‚   limit,
      Â·   â”€â”€â”¬â”€â”€
      Â·     â•°â”€â”€ previous definition of `limit` here
   14 â”‚   DocumentData,
   15 â”‚   QueryConstraint,
   16 â”‚   Timestamp,
   17 â”‚   serverTimestamp
   18 â”‚ } from 'firebase/firestore'
   19 â”‚ import { db } from './config'
   20 â”‚ import { Room, SeasonalPrice } from '@/lib/types'
   21 â”‚ import { differenceInDays } from 'date-fns'
   22 â”‚ 
   23 â”‚ // Tipos de dados
   24 â”‚ export interface Booking {
   25 â”‚   id?: string
   26 â”‚   userId?: string
   27 â”‚   guestName: string
   28 â”‚   guestEmail: string
   29 â”‚   guestPhone: string
   30 â”‚   roomId: string
   31 â”‚   roomName: string
   32 â”‚   checkIn: Timestamp
   33 â”‚   checkOut: Timestamp
   34 â”‚   adults: number
   35 â”‚   children: number
   36 â”‚   totalPrice: number
   37 â”‚   status: 'pending' | 'confirmed' | 'cancelled' | 'completed'
   38 â”‚   paymentStatus: 'pending' | 'paid' | 'refunded'
   39 â”‚   specialRequests?: string
   40 â”‚   createdAt?: Timestamp
   41 â”‚   updatedAt?: Timestamp
   42 â”‚ }
   43 â”‚ 
   44 â”‚ export interface Contact {
   45 â”‚   id?: string
   46 â”‚   name: string
   47 â”‚   email: string
   48 â”‚   phone?: string
   49 â”‚   subject: string
   50 â”‚   message: string
   51 â”‚   status: 'new' | 'read' | 'replied'
   52 â”‚   createdAt: Timestamp
   53 â”‚   updatedAt?: Timestamp
   54 â”‚   repliedAt?: Timestamp
   55 â”‚   replyContent?: string
   56 â”‚   reservationDetails?: {
   57 â”‚     checkIn?: Timestamp
   58 â”‚     checkOut?: Timestamp
   59 â”‚     roomId?: string
   60 â”‚     roomName?: string
   61 â”‚     totalGuests?: number
   62 â”‚     totalPrice?: number
   63 â”‚   }
   64 â”‚ }
   65 â”‚ 
   66 â”‚ // FunÃ§Ãµes genÃ©ricas para CRUD
   67 â”‚ export const createDocument = async <T extends DocumentData>(
   68 â”‚   collectionName: string,
   69 â”‚   data: T
   70 â”‚ ): Promise<string> => {
   71 â”‚   const docRef = await addDoc(collection(db, collectionName), {
   72 â”‚     ...data,
   73 â”‚     createdAt: serverTimestamp(),
   74 â”‚     updatedAt: serverTimestamp()
   75 â”‚   })
   76 â”‚   return docRef.id
   77 â”‚ }
   78 â”‚ 
   79 â”‚ export const createDocumentWithId = async <T extends DocumentData>(
   80 â”‚   collectionName: string,
   81 â”‚   id: string,
   82 â”‚   data: T
   83 â”‚ ): Promise<void> => {
   84 â”‚   await setDoc(doc(db, collectionName, id), {
   85 â”‚     ...data,
   86 â”‚     createdAt: serverTimestamp(),
   87 â”‚     updatedAt: serverTimestamp()
   88 â”‚   })
   89 â”‚ }
   90 â”‚ 
   91 â”‚ export const getDocument = async <T>(
   92 â”‚   collectionName: string,
   93 â”‚   id: string
   94 â”‚ ): Promise<T | null> => {
   95 â”‚   const docRef = doc(db, collectionName, id)
   96 â”‚   const docSnap = await getDoc(docRef)
   97 â”‚   
   98 â”‚   if (docSnap.exists()) {
   99 â”‚     const data = docSnap.data();
  100 â”‚     console.log("Dados brutos recuperados do Firestore para quarto:", id, data);
  101 â”‚     
  102 â”‚     if (data?.serviceFeePct !== undefined) {
  103 â”‚       console.log("serviceFeePct antes da conversÃ£o:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
  104 â”‚       // Garantir que serviceFeePct seja um nÃºmero
  105 â”‚       data.serviceFeePct = Number(data.serviceFeePct);
  106 â”‚       console.log("serviceFeePct apÃ³s conversÃ£o:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
  107 â”‚     }
  108 â”‚     
  109 â”‚     return { id: docSnap.id, ...data } as T
  110 â”‚   } else {
  111 â”‚     return null
  112 â”‚   }
  113 â”‚ }
  114 â”‚ 
  115 â”‚ export const getDocuments = async <T>(
  116 â”‚   collectionName: string,
  117 â”‚   constraints: QueryConstraint[] = [],
  118 â”‚   forceRefresh = false
  119 â”‚ ): Promise<T[]> => {
  120 â”‚   try {
  121 â”‚     const collectionRef = collection(db, collectionName)
  122 â”‚     const q = query(collectionRef, ...constraints)
  123 â”‚     
  124 â”‚     // Se forceRefresh for verdadeiro, adicionar opÃ§Ãµes que forÃ§am uma nova consulta ao Firestore
  125 â”‚     const querySnapshot = await getDocs(q)
  126 â”‚     
  127 â”‚     console.log(`Buscando documentos na coleÃ§Ã£o ${collectionName} - ForÃ§a atualizaÃ§Ã£o: ${forceRefresh}`);
  128 â”‚     
  129 â”‚     return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }) as T)
  130 â”‚   } catch (error) {
  131 â”‚     console.error(`Erro ao buscar documentos da coleÃ§Ã£o ${collectionName}:`, error);
  132 â”‚     return [];
  133 â”‚   }
  134 â”‚ }
  135 â”‚ 
  136 â”‚ export const updateDocument = async <T extends DocumentData>(
  137 â”‚   collectionName: string,
  138 â”‚   id: string,
  139 â”‚   data: Partial<T>
  140 â”‚ ): Promise<void> => {
  141 â”‚   const docRef = doc(db, collectionName, id)
  142 â”‚   await updateDoc(docRef, {
  143 â”‚     ...data,
  144 â”‚     updatedAt: serverTimestamp()
  145 â”‚   })
  146 â”‚ }
  147 â”‚ 
  148 â”‚ export const deleteDocument = async (
  149 â”‚   collectionName: string,
  150 â”‚   id: string
  151 â”‚ ): Promise<boolean> => {
  152 â”‚   const docRef = doc(db, collectionName, id)
  153 â”‚   await deleteDoc(docRef)
  154 â”‚   return true
  155 â”‚ }
  156 â”‚ 
  157 â”‚ // FunÃ§Ãµes para gerenciar quartos
  158 â”‚ export const getRooms = async (forceRefresh = false): Promise<Room[]> => {
  159 â”‚   try {
  160 â”‚     const constraints: QueryConstraint[] = []
  161 â”‚     
  162 â”‚     constraints.push(orderBy('name', 'asc'))
  163 â”‚     
  164 â”‚     const rooms = await getDocuments<Room>('rooms', constraints, forceRefresh)
  165 â”‚     
  166 â”‚     // Garantir que todos os campos necessÃ¡rios estejam presentes
  167 â”‚     return rooms.map(room => {
  168 â”‚       console.log(`Firebase - Quarto ${room.id} dados brutos:`, room);
  169 â”‚       
  170 â”‚       // Garantir que serviceFeePct seja um nÃºmero
  171 â”‚       const serviceFeePct = room.serviceFeePct !== undefined 
  172 â”‚         ? Number(room.serviceFeePct) 
  173 â”‚         : 10;
  174 â”‚         
  175 â”‚       console.log(`Firebase - Quarto ${room.id} serviceFeePct:`, {
  176 â”‚         original: room.serviceFeePct,
  177 â”‚         tipo: typeof room.serviceFeePct,
  178 â”‚         convertido: serviceFeePct
  179 â”‚       });
  180 â”‚       
  181 â”‚       return {
  182 â”‚         id: room.id,
  183 â”‚         name: room.name || '',
  184 â”‚         type: room.type || 'standard',
  185 â”‚         description: room.description || '',
  186 â”‚         price: room.price || 0,
  187 â”‚         capacity: room.capacity || 2,
  188 â”‚         size: room.size || 0,
  189 â”‚         available: room.available !== undefined ? room.available : true,
  190 â”‚         serviceFeePct: serviceFeePct,
  191 â”‚         images: room.images || [],
  192 â”‚         amenities: room.amenities || [],
  193 â”‚         additionalServices: room.additionalServices || [],
  194 â”‚         highlights: room.highlights || [],
  195 â”‚         createdAt: room.createdAt,
  196 â”‚         updatedAt: room.updatedAt
  197 â”‚       };
  198 â”‚     });
  199 â”‚   } catch (error) {
  200 â”‚     console.error('Erro ao buscar quartos:', error)
  201 â”‚     return []
  202 â”‚   }
  203 â”‚ }
  204 â”‚ 
  205 â”‚ export const getAvailableRooms = async (
  206 â”‚   checkIn: Date,
  207 â”‚   checkOut: Date
  208 â”‚ ): Promise<Room[]> => {
  209 â”‚   try {
  210 â”‚     // Buscar todos os quartos que estÃ£o marcados como disponÃ­veis em geral
  211 â”‚     const constraints: QueryConstraint[] = [
  212 â”‚       where('available', '==', true)
  213 â”‚     ]
  214 â”‚     
  215 â”‚     const rooms = await getDocuments<Room>('rooms', constraints);
  216 â”‚     
  217 â”‚     // Filtrar os quartos que estÃ£o disponÃ­veis nas datas especÃ­ficas
  218 â”‚     return filterAvailableRoomsByDate(rooms, checkIn, checkOut);
  219 â”‚   } catch (error) {
  220 â”‚     console.error('Erro ao buscar quartos disponÃ­veis:', error)
  221 â”‚     return []
  222 â”‚   }
  223 â”‚ }
  224 â”‚ 
  225 â”‚ // FunÃ§Ã£o auxiliar para verificar disponibilidade entre datas
  226 â”‚ export const filterAvailableRoomsByDate = (
  227 â”‚   rooms: Room[],
  228 â”‚   checkIn: Date,
  229 â”‚   checkOut: Date
  230 â”‚ ): Room[] => {
  231 â”‚   // Converter checkIn e checkOut para ISO strings
  232 â”‚   const dateStrings = getDatesInRange(checkIn, checkOut);
  233 â”‚   
  234 â”‚   return rooms.filter(room => {
  235 â”‚     // Se nÃ£o tiver controle de disponibilidade especÃ­fico, considera disponÃ­vel
  236 â”‚     if (!room.availabilityDates) return true;
  237 â”‚     
  238 â”‚     // Verificar se alguma data no intervalo estÃ¡ indisponÃ­vel
  239 â”‚     return !dateStrings.some(dateStr => 
  240 â”‚       room.availabilityDates?.[dateStr] === false
  241 â”‚     );
  242 â”‚   });
  243 â”‚ };
  244 â”‚ 
  245 â”‚ // FunÃ§Ã£o para obter disponibilidade de um quarto especÃ­fico
  246 â”‚ export const getRoomAvailability = async (
  247 â”‚   roomId: string, 
  248 â”‚   startDate: Date, 
  249 â”‚   endDate: Date
  250 â”‚ ): Promise<{[date: string]: boolean}> => {
  251 â”‚   try {
  252 â”‚     const room = await getRoomById(roomId);
  253 â”‚     if (!room) throw new Error(`Quarto com ID ${roomId} nÃ£o encontrado`);
  254 â”‚     
  255 â”‚     // Gerar datas no intervalo
  256 â”‚     const dateStrings = getDatesInRange(startDate, endDate);
  257 â”‚     
  258 â”‚     // Se nÃ£o tiver configuraÃ§Ã£o de disponibilidade especÃ­fica, assume tudo disponÃ­vel
  259 â”‚     if (!room.availabilityDates) {
  260 â”‚       return dateStrings.reduce((acc, date) => {
  261 â”‚         acc[date] = true;
  262 â”‚         return acc;
  263 â”‚       }, {} as {[date: string]: boolean});
  264 â”‚     }
  265 â”‚     
  266 â”‚     // Preencher com os dados de disponibilidade existentes
  267 â”‚     return dateStrings.reduce((acc, date) => {
  268 â”‚       acc[date] = room.availabilityDates?.[date] !== false; // disponÃ­vel por padrÃ£o se nÃ£o estiver explicitamente indisponÃ­vel
  269 â”‚       return acc;
  270 â”‚     }, {} as {[date: string]: boolean});
  271 â”‚   } catch (error) {
  272 â”‚     console.error(`Erro ao verificar disponibilidade do quarto ${roomId}:`, error);
  273 â”‚     throw error;
  274 â”‚   }
  275 â”‚ };
  276 â”‚ 
  277 â”‚ // FunÃ§Ã£o para atualizar disponibilidade de um quarto
  278 â”‚ export const updateRoomAvailability = async (
  279 â”‚   roomId: string,
  280 â”‚   availabilityDates: {[date: string]: boolean}
  281 â”‚ ): Promise<boolean> => {
  282 â”‚   try {
  283 â”‚     await updateDocument('rooms', roomId, {
  284 â”‚       availabilityDates,
  285 â”‚       updatedAt: serverTimestamp()
  286 â”‚     });
  287 â”‚     return true;
  288 â”‚   } catch (error) {
  289 â”‚     console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  290 â”‚     return false;
  291 â”‚   }
  292 â”‚ };
  293 â”‚ 
  294 â”‚ // FunÃ§Ã£o auxiliar para gerar array de strings de data entre um intervalo
  295 â”‚ export const getDatesInRange = (startDate: Date, endDate: Date): string[] => {
  296 â”‚   const dates: string[] = [];
  297 â”‚   const currentDate = new Date(startDate);
  298 â”‚   
  299 â”‚   // Normalizar para meia-noite no fuso horÃ¡rio local
  300 â”‚   currentDate.setHours(0, 0, 0, 0);
  301 â”‚   const endDateNormalized = new Date(endDate);
  302 â”‚   endDateNormalized.setHours(0, 0, 0, 0);
  303 â”‚   
  304 â”‚   // Adicionar cada data no intervalo EXCETO o dia de checkout
  305 â”‚   // Usando < em vez de <= para nÃ£o incluir o dia de checkout
  306 â”‚   while (currentDate < endDateNormalized) {
  307 â”‚     dates.push(currentDate.toISOString().split('T')[0]); // Formato YYYY-MM-DD
  308 â”‚     currentDate.setDate(currentDate.getDate() + 1);
  309 â”‚   }
  310 â”‚   
  311 â”‚   return dates;
  312 â”‚ };
  313 â”‚ 
  314 â”‚ export const getRoomById = async (id: string): Promise<Room | null> => {
  315 â”‚   try {
  316 â”‚     const room = await getDocument<Room>('rooms', id);
  317 â”‚     
  318 â”‚     if (!room) return null;
  319 â”‚     
  320 â”‚     console.log(`Firebase - getRoomById ${id} dados brutos:`, room);
  321 â”‚     
  322 â”‚     // Log especÃ­fico para serviceFeePct
  323 â”‚     console.log(`serviceFeePct no Firestore:`, room.serviceFeePct);
  324 â”‚     
  325 â”‚     // Garantir que todos os campos necessÃ¡rios estejam presentes
  326 â”‚     return {
  327 â”‚       ...room,
  328 â”‚       name: room.name || '',
  329 â”‚       type: room.type || 'standard',
  330 â”‚       description: room.description || '',
  331 â”‚       price: room.price || 0,
  332 â”‚       capacity: room.capacity || 2,
  333 â”‚       size: room.size || 0,
  334 â”‚       available: room.available !== undefined ? room.available : true,
  335 â”‚       serviceFeePct: room.serviceFeePct !== undefined ? room.serviceFeePct : 10,
  336 â”‚       images: room.images || [],
  337 â”‚       amenities: room.amenities || [],
  338 â”‚       additionalServices: room.additionalServices || [],
  339 â”‚       highlights: room.highlights || []
  340 â”‚     };
  341 â”‚   } catch (error) {
  342 â”‚     console.error(`Erro ao buscar quarto com ID ${id}:`, error);
  343 â”‚     return null;
  344 â”‚   }
  345 â”‚ }
  346 â”‚ 
  347 â”‚ export const createRoom = async (roomData: Omit<Room, 'id' | 'createdAt' | 'updatedAt'>): Promise<Room> => {
  348 â”‚   try {
  349 â”‚     console.log("createRoom - Dados recebidos:", roomData);
  350 â”‚     
  351 â”‚     const roomWithTimestamps = {
  352 â”‚       ...roomData,
  353 â”‚       available: roomData.available !== undefined ? roomData.available : true,
  354 â”‚       featured: roomData.featured || false,
  355 â”‚       amenities: roomData.amenities || [],
  356 â”‚       additionalServices: roomData.additionalServices || [],
  357 â”‚       highlights: roomData.highlights || [],
  358 â”‚       createdAt: serverTimestamp(),
  359 â”‚       updatedAt: serverTimestamp()
  360 â”‚     }
  361 â”‚     
  362 â”‚     console.log("createRoom - Dados a serem salvos:", roomWithTimestamps);
  363 â”‚     
  364 â”‚     const id = await createDocument('rooms', roomWithTimestamps)
  365 â”‚     
  366 â”‚     return {
  367 â”‚       id,
  368 â”‚       ...roomData,
  369 â”‚       amenities: roomData.amenities || [],
  370 â”‚       additionalServices: roomData.additionalServices || [],
  371 â”‚       highlights: roomData.highlights || [],
  372 â”‚       createdAt: Timestamp.now(),
  373 â”‚       updatedAt: Timestamp.now()
  374 â”‚     }
  375 â”‚   } catch (error) {
  376 â”‚     console.error('Erro ao criar quarto:', error)
  377 â”‚     throw error
  378 â”‚   }
  379 â”‚ }
  380 â”‚ 
  381 â”‚ export const updateRoom = async (id: string, roomData: Partial<Omit<Room, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Room> => {
  382 â”‚   try {
  383 â”‚     console.log(`updateRoom - ID: ${id}, Dados recebidos:`, roomData);
  384 â”‚     
  385 â”‚     // Garantir que estamos lidando explicitamente com o serviceFeePct se ele for 0
  386 â”‚     if (roomData.serviceFeePct === 0) {
  387 â”‚       console.log("updateRoom - Detectado serviceFeePct com valor 0, salvando explicitamente.", roomData.serviceFeePct);
  388 â”‚     }
  389 â”‚     
  390 â”‚     // Adicionar timestamp de atualizaÃ§Ã£o
  391 â”‚     const roomWithTimestamp = {
  392 â”‚       ...roomData,
  393 â”‚       amenities: roomData.amenities || [],
  394 â”‚       additionalServices: roomData.additionalServices || [],
  395 â”‚       highlights: roomData.highlights || [],
  396 â”‚       updatedAt: serverTimestamp()
  397 â”‚     }
  398 â”‚     
  399 â”‚     console.log(`updateRoom - Dados a serem salvos:`, roomWithTimestamp);
  400 â”‚     
  401 â”‚     await updateDocument('rooms', id, roomWithTimestamp)
  402 â”‚     
  403 â”‚     const updatedRoom = await getRoomById(id)
  404 â”‚     if (!updatedRoom) {
  405 â”‚       throw new Error(`Quarto com ID ${id} nÃ£o encontrado apÃ³s atualizaÃ§Ã£o`)
  406 â”‚     }
  407 â”‚     
  408 â”‚     return updatedRoom
  409 â”‚   } catch (error) {
  410 â”‚     console.error('Erro ao atualizar quarto:', error)
  411 â”‚     throw error
  412 â”‚   }
  413 â”‚ }
  414 â”‚ 
  415 â”‚ export const deleteRoom = async (id: string): Promise<boolean> => {
  416 â”‚   return await deleteDocument('rooms', id)
  417 â”‚ }
  418 â”‚ 
  419 â”‚ // FunÃ§Ãµes especÃ­ficas para reservas
  420 â”‚ export const createBooking = async (bookingData: any) => {
  421 â”‚   try {
  422 â”‚     const bookingsCollection = collection(db, 'bookings');
  423 â”‚     const docRef = await addDoc(bookingsCollection, bookingData);
  424 â”‚     
  425 â”‚     // CORREÃ‡ÃƒO: NÃ£o bloquear a data no momento da criaÃ§Ã£o da reserva
  426 â”‚     // O bloqueio serÃ¡ feito apenas quando o pagamento for confirmado
  427 â”‚     // atravÃ©s da funÃ§Ã£o updateBookingStatus
  428 â”‚     
  429 â”‚     return docRef;
  430 â”‚   } catch (error) {
  431 â”‚     console.error('Erro ao criar reserva:', error);
  432 â”‚     throw error;
  433 â”‚   }
  434 â”‚ };
  435 â”‚ 
  436 â”‚ // Nova funÃ§Ã£o para atualizar status da reserva e bloquear as datas da estadia
  437 â”‚ export const updateBookingStatus = async (
  438 â”‚   bookingId: string, 
  439 â”‚   newStatus: 'pending' | 'confirmed' | 'cancelled' | 'completed',
  440 â”‚   newPaymentStatus: 'pending' | 'paid' | 'refunded'
  441 â”‚ ): Promise<boolean> => {
  442 â”‚   try {
  443 â”‚     // ReferÃªncia ao documento da reserva
  444 â”‚     const bookingRef = doc(db, 'bookings', bookingId);
  445 â”‚     const bookingSnap = await getDoc(bookingRef);
  446 â”‚     
  447 â”‚     if (!bookingSnap.exists()) {
  448 â”‚       console.error(`Booking ${bookingId} nÃ£o existe ao atualizar status`);
  449 â”‚       return false;
  450 â”‚     }
  451 â”‚     
  452 â”‚     const bookingData = bookingSnap.data();
  453 â”‚     
  454 â”‚     // Atualizar o status da reserva
  455 â”‚     await updateDoc(bookingRef, {
  456 â”‚       status: newStatus,
  457 â”‚       paymentStatus: newPaymentStatus,
  458 â”‚       updatedAt: serverTimestamp(),
  459 â”‚       ...(newStatus === 'confirmed' && { confirmedAt: serverTimestamp() })
  460 â”‚     });
  461 â”‚     
  462 â”‚     // Se a reserva estÃ¡ sendo confirmada, precisamos bloquear as datas
  463 â”‚     if (newStatus === 'confirmed') {
  464 â”‚       console.log(`Atualizando disponibilidade para reserva confirmada: ${bookingId}`);
  465 â”‚       
  466 â”‚       // Recuperar datas de check-in e check-out
  467 â”‚       const checkIn = bookingData.checkIn.toDate();
  468 â”‚       const checkOut = bookingData.checkOut.toDate();
  469 â”‚       const roomId = bookingData.roomId;
  470 â”‚       
  471 â”‚       // Obter todas as datas entre check-in e check-out
  472 â”‚       const dates: Date[] = [];
  473 â”‚       const currentDate = new Date(checkIn);
  474 â”‚       
  475 â”‚       while (currentDate < checkOut) {
  476 â”‚         dates.push(new Date(currentDate));
  477 â”‚         currentDate.setDate(currentDate.getDate() + 1);
  478 â”‚       }
  479 â”‚       
  480 â”‚       console.log(`Bloqueando ${dates.length} dias para quarto ${roomId}`);
  481 â”‚       
  482 â”‚       // Atualizar disponibilidade para cada data
  483 â”‚       const availabilityUpdates: {[date: string]: boolean} = {};
  484 â”‚       
  485 â”‚       dates.forEach(date => {
  486 â”‚         const dateString = date.toISOString().split('T')[0]; // formato YYYY-MM-DD
  487 â”‚         availabilityUpdates[dateString] = false; // false significa indisponÃ­vel
  488 â”‚       });
  489 â”‚       
  490 â”‚       // Atualizar disponibilidade do quarto
  491 â”‚       if (Object.keys(availabilityUpdates).length > 0) {
  492 â”‚         try {
  493 â”‚           // Obter o documento do quarto
  494 â”‚           const roomRef = doc(db, 'rooms', roomId);
  495 â”‚           const roomSnap = await getDoc(roomRef);
  496 â”‚           
  497 â”‚           if (roomSnap.exists()) {
  498 â”‚             const roomData = roomSnap.data();
  499 â”‚             const currentAvailability = roomData.availabilityDates || {};
  500 â”‚             
  501 â”‚             // Mesclar a disponibilidade atual com as novas atualizaÃ§Ãµes
  502 â”‚             const updatedAvailability = {
  503 â”‚               ...currentAvailability,
  504 â”‚               ...availabilityUpdates
  505 â”‚             };
  506 â”‚             
  507 â”‚             // Atualizar o documento do quarto
  508 â”‚             await updateDoc(roomRef, {
  509 â”‚               availabilityDates: updatedAvailability,
  510 â”‚               updatedAt: serverTimestamp()
  511 â”‚             });
  512 â”‚             
  513 â”‚             console.log(`Disponibilidade atualizada com sucesso para quarto ${roomId}`);
  514 â”‚             
  515 â”‚             // Criar log da reserva
  516 â”‚             await addDoc(collection(db, 'bookingLogs'), {
  517 â”‚               bookingId,
  518 â”‚               roomId,
  519 â”‚               action: 'status_updated',
  520 â”‚               previousStatus: bookingData.status,
  521 â”‚               newStatus,
  522 â”‚               previousPaymentStatus: bookingData.paymentStatus,
  523 â”‚               newPaymentStatus,
  524 â”‚               datesBlocked: Object.keys(availabilityUpdates),
  525 â”‚               timestamp: serverTimestamp(),
  526 â”‚               userId: bookingData.userId || 'system'
  527 â”‚             });
  528 â”‚           } else {
  529 â”‚             console.error(`Quarto ${roomId} nÃ£o encontrado ao atualizar disponibilidade`);
  530 â”‚           }
  531 â”‚         } catch (error) {
  532 â”‚           console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  533 â”‚         }
  534 â”‚       }
  535 â”‚     }
  536 â”‚     
  537 â”‚     return true;
  538 â”‚   } catch (error) {
  539 â”‚     console.error(`Erro ao atualizar status da reserva ${bookingId}:`, error);
  540 â”‚     return false;
  541 â”‚   }
  542 â”‚ }
  543 â”‚ 
  544 â”‚ export const getUserBookings = async (userId: string): Promise<Booking[]> => {
  545 â”‚   return getDocuments<Booking>('bookings', [
  546 â”‚     where('userId', '==', userId),
  547 â”‚     orderBy('createdAt', 'desc')
  548 â”‚   ])
  549 â”‚ }
  550 â”‚ 
  551 â”‚ export const getRecentBookings = async (count = 5): Promise<Booking[]> => {
  552 â”‚   return getDocuments<Booking>('bookings', [
  553 â”‚     orderBy('createdAt', 'desc'),
  554 â”‚     limit(count)
  555 â”‚   ])
  556 â”‚ }
  557 â”‚ 
  558 â”‚ export const getRoomBookings = async (roomId: string): Promise<Booking[]> => {
  559 â”‚   try {
  560 â”‚     const constraints: QueryConstraint[] = [
  561 â”‚       where('roomId', '==', roomId),
  562 â”‚       orderBy('checkIn', 'asc')
  563 â”‚     ];
  564 â”‚     
  565 â”‚     return await getDocuments<Booking>('bookings', constraints);
  566 â”‚   } catch (error) {
  567 â”‚     console.error(`Erro ao buscar reservas do quarto ${roomId}:`, error);
  568 â”‚     return [];
  569 â”‚   }
  570 â”‚ };
  571 â”‚ 
  572 â”‚ // FunÃ§Ãµes especÃ­ficas para contatos
  573 â”‚ export const createContactMessage = async (contactData: Contact) => {
  574 â”‚   try {
  575 â”‚     const contactsCollection = collection(db, 'contacts')
  576 â”‚     
  577 â”‚     // Garantir que o status seja 'new' para novos contatos
  578 â”‚     const contactWithDefaults = {
  579 â”‚       ...contactData,
  580 â”‚       status: contactData.status || 'new',
  581 â”‚       createdAt: contactData.createdAt || Timestamp.now()
  582 â”‚     }
  583 â”‚     
  584 â”‚     // Se tiver detalhes de reserva, adicionar metadados
  585 â”‚     if (contactWithDefaults.reservationDetails) {
  586 â”‚       // Ajustar subject para indicar que Ã© relacionado a reserva
  587 â”‚       if (!contactWithDefaults.subject.includes('Reserva')) {
  588 â”‚         contactWithDefaults.subject = `Reserva: ${contactWithDefaults.subject}`;
  589 â”‚       }
  590 â”‚     }
  591 â”‚     
  592 â”‚     const docRef = await addDoc(contactsCollection, contactWithDefaults)
  593 â”‚     return docRef
  594 â”‚   } catch (error) {
  595 â”‚     console.error('Erro ao criar mensagem de contato:', error)
  596 â”‚     throw error
  597 â”‚   }
  598 â”‚ }
  599 â”‚ 
  600 â”‚ export const getNewContactMessages = async (): Promise<Contact[]> => {
  601 â”‚   return getDocuments<Contact>('contacts', [
  602 â”‚     where('status', '==', 'new'),
  603 â”‚     orderBy('createdAt', 'desc')
  604 â”‚   ])
  605 â”‚ }
  606 â”‚ 
  607 â”‚ // FunÃ§Ãµes para Dashboard com dados reais
  608 â”‚ 
  609 â”‚ export const getDashboardStats = async () => {
  610 â”‚   try {
  611 â”‚     const [totalBookings, totalRevenue, occupancyRate, bookingsByPlatform] = await Promise.all([
  612 â”‚       getTotalBookings(),
  613 â”‚       getMonthlyRevenue(),
  614 â”‚       getOccupancyRate(),
  615 â”‚       getBookingsByPlatform()
  616 â”‚     ]);
  617 â”‚ 
  618 â”‚     return {
  619 â”‚       totalBookings,
  620 â”‚       totalRevenue,
  621 â”‚       occupancyRate,
  622 â”‚       bookingsByPlatform
  623 â”‚     };
  624 â”‚   } catch (error) {
  625 â”‚     console.error('Erro ao obter estatÃ­sticas do dashboard:', error);
  626 â”‚     throw error;
  627 â”‚   }
  628 â”‚ };
  629 â”‚ 
  630 â”‚ // Obter total de reservas
  631 â”‚ export const getTotalBookings = async () => {
  632 â”‚   try {
  633 â”‚     // Obter todas as reservas
  634 â”‚     const bookings = await getDocuments<Booking>('bookings');
  635 â”‚     
  636 â”‚     // Contar reservas por status
  637 â”‚     const confirmed = bookings.filter(b => b.status === 'confirmed').length;
  638 â”‚     const pending = bookings.filter(b => b.status === 'pending').length;
  639 â”‚     const cancelled = bookings.filter(b => b.status === 'cancelled').length;
  640 â”‚     const completed = bookings.filter(b => b.status === 'completed').length;
  641 â”‚     
  642 â”‚     // Calcular crescimento em relaÃ§Ã£o ao mÃªs anterior (simulado por enquanto)
  643 â”‚     // Em uma implementaÃ§Ã£o real, vocÃª compararia com dados do mÃªs anterior
  644 â”‚     const growth = ((confirmed + completed) / (bookings.length || 1) * 100) - 50;
  645 â”‚     
  646 â”‚     return {
  647 â”‚       total: bookings.length,
  648 â”‚       confirmed,
  649 â”‚       pending,
  650 â”‚       cancelled,
  651 â”‚       completed,
  652 â”‚       growth: Math.round(growth) // Arredonda para nÃºmero inteiro
  653 â”‚     };
  654 â”‚   } catch (error) {
  655 â”‚     console.error('Erro ao obter total de reservas:', error);
  656 â”‚     return {
  657 â”‚       total: 0,
  658 â”‚       confirmed: 0,
  659 â”‚       pending: 0, 
  660 â”‚       cancelled: 0,
  661 â”‚       completed: 0,
  662 â”‚       growth: 0
  663 â”‚     };
  664 â”‚   }
  665 â”‚ };
  666 â”‚ 
  667 â”‚ // Obter receita mensal
  668 â”‚ export const getMonthlyRevenue = async () => {
  669 â”‚   try {
  670 â”‚     const bookings = await getDocuments<Booking>('bookings');
  671 â”‚     
  672 â”‚     // Filtrar reservas confirmadas e concluÃ­das
  673 â”‚     const validBookings = bookings.filter(b => 
  674 â”‚       b.status === 'confirmed' || b.status === 'completed'
  675 â”‚     );
  676 â”‚     
  677 â”‚     // Calcular receita total
  678 â”‚     const totalRevenue = validBookings.reduce((acc, booking) => acc + booking.totalPrice, 0);
  679 â”‚     
  680 â”‚     // Agrupar receita por mÃªs
  681 â”‚     const revenueByMonth = validBookings.reduce((acc, booking) => {
  682 â”‚       const date = booking.checkIn.toDate();
  683 â”‚       const month = date.getMonth(); // 0-11
  684 â”‚       const year = date.getFullYear();
  685 â”‚       const key = `${year}-${month}`;
  686 â”‚       
  687 â”‚       if (!acc[key]) {
  688 â”‚         acc[key] = 0;
  689 â”‚       }
  690 â”‚       acc[key] += booking.totalPrice;
  691 â”‚       return acc;
  692 â”‚     }, {} as Record<string, number>);
  693 â”‚     
  694 â”‚     // Converter para formato de array para grÃ¡fico
  695 â”‚     const monthNames = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
  696 â”‚     
  697 â”‚     const currentDate = new Date();
  698 â”‚     const currentMonth = currentDate.getMonth();
  699 â”‚     const currentYear = currentDate.getFullYear();
  700 â”‚     
  701 â”‚     const revenueData = [];
  702 â”‚     
  703 â”‚     // Gerar dados dos Ãºltimos 12 meses
  704 â”‚     for (let i = 0; i < 12; i++) {
  705 â”‚       const month = (currentMonth - i + 12) % 12;
  706 â”‚       const year = currentMonth - i < 0 ? currentYear - 1 : currentYear;
  707 â”‚       const key = `${year}-${month}`;
  708 â”‚       
  709 â”‚       revenueData.unshift({
  710 â”‚         month: monthNames[month],
  711 â”‚         value: revenueByMonth[key] || 0
  712 â”‚       });
  713 â”‚     }
  714 â”‚     
  715 â”‚     // Calcular crescimento em relaÃ§Ã£o ao mÃªs anterior
  716 â”‚     const lastMonthRevenue = revenueData[revenueData.length - 2]?.value || 0;
  717 â”‚     const currentMonthRevenue = revenueData[revenueData.length - 1]?.value || 0;
  718 â”‚     
  719 â”‚     const growth = lastMonthRevenue ? ((currentMonthRevenue - lastMonthRevenue) / lastMonthRevenue) * 100 : 0;
  720 â”‚     
  721 â”‚     return {
  722 â”‚       monthly: currentMonthRevenue,
  723 â”‚       total: totalRevenue,
  724 â”‚       growth: Math.round(growth),
  725 â”‚       revenueData
  726 â”‚     };
  727 â”‚   } catch (error) {
  728 â”‚     console.error('Erro ao obter receita mensal:', error);
  729 â”‚     return {
  730 â”‚       monthly: 0,
  731 â”‚       total: 0,
  732 â”‚       growth: 0,
  733 â”‚       revenueData: []
  734 â”‚     };
  735 â”‚   }
  736 â”‚ };
  737 â”‚ 
  738 â”‚ // Calcular taxa de ocupaÃ§Ã£o
  739 â”‚ export const getOccupancyRate = async () => {
  740 â”‚   try {
  741 â”‚     // Obter todos os quartos
  742 â”‚     const rooms = await getDocuments<Room>('rooms');
  743 â”‚     const totalRooms = rooms.length;
  744 â”‚     
  745 â”‚     if (totalRooms === 0) {
  746 â”‚       return { rate: 0, growth: 0 };
  747 â”‚     }
  748 â”‚     
  749 â”‚     // Obter todas as reservas
  750 â”‚     const bookings = await getDocuments<Booking>('bookings');
  751 â”‚     
  752 â”‚     // Filtrar reservas confirmadas e concluÃ­das para o mÃªs atual
  753 â”‚     const currentDate = new Date();
  754 â”‚     const currentMonth = currentDate.getMonth();
  755 â”‚     const currentYear = currentDate.getFullYear();
  756 â”‚     
  757 â”‚     const currentMonthBookings = bookings.filter(booking => {
  758 â”‚       const checkInDate = booking.checkIn.toDate();
  759 â”‚       return (
  760 â”‚         (booking.status === 'confirmed' || booking.status === 'completed') &&
  761 â”‚         checkInDate.getMonth() === currentMonth &&
  762 â”‚         checkInDate.getFullYear() === currentYear
  763 â”‚       );
  764 â”‚     });
  765 â”‚     
  766 â”‚     // Calcular dias ocupados por quarto
  767 â”‚     const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
  768 â”‚     const totalPossibleRoomDays = totalRooms * daysInMonth;
  769 â”‚     
  770 â”‚     // Contar dias ocupados (simplificado - em produÃ§Ã£o seria mais complexo)
  771 â”‚     let occupiedDays = 0;
  772 â”‚     
  773 â”‚     currentMonthBookings.forEach(booking => {
  774 â”‚       const checkIn = booking.checkIn.toDate();
  775 â”‚       const checkOut = booking.checkOut.toDate();
  776 â”‚       
  777 â”‚       // Ajustar datas para considerar apenas o mÃªs atual
  778 â”‚       const startDate = new Date(Math.max(
  779 â”‚         checkIn.getTime(),
  780 â”‚         new Date(currentYear, currentMonth, 1).getTime()
  781 â”‚       ));
  782 â”‚       const endDate = new Date(Math.min(
  783 â”‚         checkOut.getTime(),
  784 â”‚         new Date(currentYear, currentMonth + 1, 0).getTime()
  785 â”‚       ));
  786 â”‚       
  787 â”‚       // Calcular dias entre datas (incluindo check-in, excluindo check-out)
  788 â”‚       const days = Math.max(0, Math.floor((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)));
  789 â”‚       occupiedDays += days;
  790 â”‚     });
  791 â”‚     
  792 â”‚     const occupancyRate = (occupiedDays / totalPossibleRoomDays) * 100;
  793 â”‚     
  794 â”‚     // SimulaÃ§Ã£o de crescimento (em produÃ§Ã£o, compararia com mÃªs anterior)
  795 â”‚     const growth = occupancyRate > 50 ? 5 : -3;
  796 â”‚     
  797 â”‚     return {
  798 â”‚       rate: Math.round(occupancyRate),
  799 â”‚       growth: Math.round(growth)
  800 â”‚     };
  801 â”‚   } catch (error) {
  802 â”‚     console.error('Erro ao calcular taxa de ocupaÃ§Ã£o:', error);
  803 â”‚     return { rate: 0, growth: 0 };
  804 â”‚   }
  805 â”‚ };
  806 â”‚ 
  807 â”‚ // Obter reservas agrupadas por plataforma
  808 â”‚ export const getBookingsByPlatform = async () => {
  809 â”‚   try {
  810 â”‚     const bookings = await getDocuments<Booking>('bookings');
  811 â”‚     
  812 â”‚     // Categorizar reservas por origem
  813 â”‚     const platforms = [
  814 â”‚       { 
  815 â”‚         platform: "Booking.com", 
  816 â”‚         color: "#003580", 
  817 â”‚         icon: "Globe",
  818 â”‚         bookings: []
  819 â”‚       },
  820 â”‚       { 
  821 â”‚         platform: "Airbnb", 
  822 â”‚         color: "#FF5A5F", 
  823 â”‚         icon: "Heart",
  824 â”‚         bookings: []
  825 â”‚       },
  826 â”‚       { 
  827 â”‚         platform: "Direto", 
  828 â”‚         color: "#4CAF50", 
  829 â”‚         icon: "Home",
  830 â”‚         bookings: []
  831 â”‚       }
  832 â”‚     ];
  833 â”‚     
  834 â”‚     // Para fins de demonstraÃ§Ã£o, colocar todas as reservas como "Direto" por enquanto
  835 â”‚     // Em produÃ§Ã£o, usaria um campo "platformOrigin" ou similar na tabela de reservas
  836 â”‚     const platformIndex = 2; // Ãndice da plataforma "Direto"
  837 â”‚     
  838 â”‚     bookings.forEach(booking => {
  839 â”‚       // Transformar para o formato esperado pelo componente
  840 â”‚       const transformedBooking = {
  841 â”‚         id: booking.id || '',
  842 â”‚         guestName: booking.guestName,
  843 â”‚         roomName: booking.roomName,
  844 â”‚         checkIn: booking.checkIn.toDate().toLocaleDateString('pt-PT'),
  845 â”‚         checkOut: booking.checkOut.toDate().toLocaleDateString('pt-PT'),
  846 â”‚         status: booking.status,
  847 â”‚         value: new Intl.NumberFormat('pt-PT', {
  848 â”‚           style: 'currency',
  849 â”‚           currency: 'EUR'
  850 â”‚         }).format(booking.totalPrice)
  851 â”‚       };
  852 â”‚       
  853 â”‚       // Adicionar Ã  plataforma "Direto"
  854 â”‚       (platforms[platformIndex] as any).bookings.push(transformedBooking);
  855 â”‚     });
  856 â”‚     
  857 â”‚     return platforms;
  858 â”‚   } catch (error) {
  859 â”‚     console.error('Erro ao obter reservas por plataforma:', error);
  860 â”‚     return [];
  861 â”‚   }
  862 â”‚ };
  863 â”‚ 
  864 â”‚ // FunÃ§Ã£o para obter o preÃ§o de um quarto para uma data especÃ­fica
  865 â”‚ export const getRoomPriceForDate = async (roomId: string, date: Date): Promise<number> => {
  866 â”‚   try {
  867 â”‚     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  868 â”‚     
  869 â”‚     if (!roomDoc.exists()) {
  870 â”‚       throw new Error("Quarto nÃ£o encontrado");
  871 â”‚     }
  872 â”‚     
  873 â”‚     const roomData = roomDoc.data() as Room;
  874 â”‚     const basePrice = roomData.price;
  875 â”‚     
  876 â”‚     if (!roomData.seasonalPrices || roomData.seasonalPrices.length === 0) {
  877 â”‚       return basePrice;
  878 â”‚     }
  879 â”‚     
  880 â”‚     // Verificar se a data estÃ¡ dentro de algum perÃ­odo sazonal
  881 â”‚     for (const seasonalPrice of roomData.seasonalPrices) {
  882 â”‚       const startDate = new Date(seasonalPrice.startDate);
  883 â”‚       const endDate = new Date(seasonalPrice.endDate);
  884 â”‚       
  885 â”‚       if (date >= startDate && date <= endDate) {
  886 â”‚         return seasonalPrice.price;
  887 â”‚       }
  888 â”‚     }
  889 â”‚     
  890 â”‚     // Se nÃ£o cair em nenhum perÃ­odo sazonal, retorna o preÃ§o base
  891 â”‚     return basePrice;
  892 â”‚   } catch (error) {
  893 â”‚     console.error("Erro ao obter preÃ§o do quarto:", error);
  894 â”‚     throw error;
  895 â”‚   }
  896 â”‚ }
  897 â”‚ 
  898 â”‚ // FunÃ§Ã£o para calcular o preÃ§o total de uma estadia
  899 â”‚ export const calculateStayPrice = async (
  900 â”‚   roomId: string, 
  901 â”‚   checkIn: Date, 
  902 â”‚   checkOut: Date
  903 â”‚ ): Promise<{
  904 â”‚   totalPrice: number;
  905 â”‚   nightlyPrices: { date: string; price: number }[];
  906 â”‚   serviceFee: number;
  907 â”‚   totalWithFee: number;
  908 â”‚ }> => {
  909 â”‚   try {
  910 â”‚     console.log(`ğŸ” Iniciando cÃ¡lculo de preÃ§o para estadia: ${checkIn.toISOString().split('T')[0]} atÃ© ${checkOut.toISOString().split('T')[0]}`);
  911 â”‚     
  912 â”‚     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  913 â”‚     
  914 â”‚     if (!roomDoc.exists()) {
  915 â”‚       throw new Error("Quarto nÃ£o encontrado");
  916 â”‚     }
  917 â”‚     
  918 â”‚     const roomData = roomDoc.data() as Room;
  919 â”‚     console.log(`ğŸ“ Dados do quarto ${roomId}:`, {
  920 â”‚       nome: roomData.name,
  921 â”‚       precoBase: roomData.price,
  922 â”‚       taxaServico: roomData.serviceFeePct || 0,
  923 â”‚       temPrecosSazonais: !!roomData.seasonalPrices?.length
  924 â”‚     });
  925 â”‚     
  926 â”‚     const nightlyPrices: { date: string; price: number }[] = [];
  927 â”‚     let totalPrice = 0;
  928 â”‚     
  929 â”‚     // Calcular o nÃºmero de noites - corrigido para usar o mÃ©todo correto de cÃ¡lculo
  930 â”‚     // O nÃºmero de noites Ã© a diferenÃ§a em dias (estadia = checkout - checkin)
  931 â”‚     const noites = differenceInDays(checkOut, checkIn);
  932 â”‚     console.log(`ğŸ—“ï¸ NÃºmero de noites calculado: ${noites}`);
  933 â”‚     
  934 â”‚     if (noites <= 0) {
  935 â”‚       console.error(`âš ï¸ Erro: nÃºmero de noites invÃ¡lido (${noites})`);
  936 â”‚       throw new Error("Data de check-out deve ser posterior Ã  data de check-in");
  937 â”‚     }
  938 â”‚     
  939 â”‚     // Para cada noite, verificar o preÃ§o aplicÃ¡vel (preÃ§o base ou sazonal)
  940 â”‚     // ComeÃ§amos exatamente do dia de check-in
  941 â”‚     const currentDate = new Date(checkIn);
  942 â”‚     currentDate.setHours(0, 0, 0, 0); // Normalizar para meia-noite
  943 â”‚     
  944 â”‚     // Processamos cada dia de estadia (noite)
  945 â”‚     console.log(`ğŸ“Š Calculando preÃ§os por noite:`);
  946 â”‚     for (let i = 0; i < noites; i++) {
  947 â”‚       // Obtemos o preÃ§o para esta data
  948 â”‚       const dateCopy = new Date(currentDate);
  949 â”‚       const priceForDate = await getRoomPriceForDate(roomId, dateCopy);
  950 â”‚       const dateString = dateCopy.toISOString().split('T')[0]; // YYYY-MM-DD
  951 â”‚       
  952 â”‚       console.log(`   - ${dateString}: â‚¬${priceForDate}`);
  953 â”‚       
  954 â”‚       nightlyPrices.push({
  955 â”‚         date: dateString,
  956 â”‚         price: priceForDate
  957 â”‚       });
  958 â”‚       
  959 â”‚       totalPrice += priceForDate;
  960 â”‚       
  961 â”‚       // AvanÃ§amos para o prÃ³ximo dia
  962 â”‚       currentDate.setDate(currentDate.getDate() + 1);
  963 â”‚     }
  964 â”‚     
  965 â”‚     // VerificaÃ§Ã£o de seguranÃ§a para o cÃ¡lculo do totalPrice
  966 â”‚     const manualTotal = nightlyPrices.reduce((sum, night) => sum + night.price, 0);
  967 â”‚     if (Math.abs(totalPrice - manualTotal) > 1) {
  968 â”‚       console.error(`âš ï¸ DiscrepÃ¢ncia detectada no cÃ¡lculo do preÃ§o total!`);
  969 â”‚       console.error(`   - Total calculado iterativamente: â‚¬${totalPrice}`);
  970 â”‚       console.error(`   - Total calculado via reduce: â‚¬${manualTotal}`);
  971 â”‚       console.error(`   - Usando o valor recalculado para seguranÃ§a!`);
  972 â”‚       totalPrice = manualTotal;
  973 â”‚     }
  974 â”‚     
  975 â”‚     // Calcular taxa de serviÃ§o
  976 â”‚     const serviceFee = (totalPrice * (roomData.serviceFeePct || 0)) / 100;
  977 â”‚     const totalWithFee = totalPrice + serviceFee;
  978 â”‚     
  979 â”‚     console.log(`ğŸ’° Resumo do cÃ¡lculo:`);
  980 â”‚     console.log(`   - Total das diÃ¡rias: â‚¬${totalPrice}`);
  981 â”‚     console.log(`   - Taxa de serviÃ§o (${roomData.serviceFeePct || 0}%): â‚¬${serviceFee}`);
  982 â”‚     console.log(`   - Total com taxas: â‚¬${totalWithFee}`);
  983 â”‚     
  984 â”‚     return {
  985 â”‚       totalPrice,
  986 â”‚       nightlyPrices,
  987 â”‚       serviceFee,
  988 â”‚       totalWithFee
  989 â”‚     };
  990 â”‚   } catch (error) {
  991 â”‚     console.error("âŒ Erro ao calcular preÃ§o da estadia:", error);
  992 â”‚     throw error;
  993 â”‚   }
  994 â”‚ } 
  995 â”‚ import { 
  996 â”‚   collection, 
  997 â”‚   getDocs, 
  998 â”‚   getDoc, 
  999 â”‚   doc, 
 1000 â”‚   setDoc, 
 1001 â”‚   addDoc, 
 1002 â”‚   updateDoc, 
 1003 â”‚   deleteDoc,
 1004 â”‚   query,
 1005 â”‚   where,
 1006 â”‚   orderBy,
 1007 â”‚   limit,
      Â·   â”€â”€â”¬â”€â”€
      Â·     â•°â”€â”€ `limit` redefined here
 1008 â”‚   serverTimestamp
 1009 â”‚ } from 'firebase/firestore';
 1010 â”‚ import { db } from './config';
      â•°â”€â”€â”€â”€

  Ã— the name `serverTimestamp` is defined multiple times
      â•­â”€[/home/runner/workspace/lib/firebase/firestore.ts:14:1]
   14 â”‚   DocumentData,
   15 â”‚   QueryConstraint,
   16 â”‚   Timestamp,
   17 â”‚   serverTimestamp
      Â·   â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€
      Â·          â•°â”€â”€ previous definition of `serverTimestamp` here
   18 â”‚ } from 'firebase/firestore'
   19 â”‚ import { db } from './config'
   20 â”‚ import { Room, SeasonalPrice } from '@/lib/types'
   21 â”‚ import { differenceInDays } from 'date-fns'
   22 â”‚ 
   23 â”‚ // Tipos de dados
   24 â”‚ export interface Booking {
   25 â”‚   id?: string
   26 â”‚   userId?: string
   27 â”‚   guestName: string
   28 â”‚   guestEmail: string
   29 â”‚   guestPhone: string
   30 â”‚   roomId: string
   31 â”‚   roomName: string
   32 â”‚   checkIn: Timestamp
   33 â”‚   checkOut: Timestamp
   34 â”‚   adults: number
   35 â”‚   children: number
   36 â”‚   totalPrice: number
   37 â”‚   status: 'pending' | 'confirmed' | 'cancelled' | 'completed'
   38 â”‚   paymentStatus: 'pending' | 'paid' | 'refunded'
   39 â”‚   specialRequests?: string
   40 â”‚   createdAt?: Timestamp
   41 â”‚   updatedAt?: Timestamp
   42 â”‚ }
   43 â”‚ 
   44 â”‚ export interface Contact {
   45 â”‚   id?: string
   46 â”‚   name: string
   47 â”‚   email: string
   48 â”‚   phone?: string
   49 â”‚   subject: string
   50 â”‚   message: string
   51 â”‚   status: 'new' | 'read' | 'replied'
   52 â”‚   createdAt: Timestamp
   53 â”‚   updatedAt?: Timestamp
   54 â”‚   repliedAt?: Timestamp
   55 â”‚   replyContent?: string
   56 â”‚   reservationDetails?: {
   57 â”‚     checkIn?: Timestamp
   58 â”‚     checkOut?: Timestamp
   59 â”‚     roomId?: string
   60 â”‚     roomName?: string
   61 â”‚     totalGuests?: number
   62 â”‚     totalPrice?: number
   63 â”‚   }
   64 â”‚ }
   65 â”‚ 
   66 â”‚ // FunÃ§Ãµes genÃ©ricas para CRUD
   67 â”‚ export const createDocument = async <T extends DocumentData>(
   68 â”‚   collectionName: string,
   69 â”‚   data: T
   70 â”‚ ): Promise<string> => {
   71 â”‚   const docRef = await addDoc(collection(db, collectionName), {
   72 â”‚     ...data,
   73 â”‚     createdAt: serverTimestamp(),
   74 â”‚     updatedAt: serverTimestamp()
   75 â”‚   })
   76 â”‚   return docRef.id
   77 â”‚ }
   78 â”‚ 
   79 â”‚ export const createDocumentWithId = async <T extends DocumentData>(
   80 â”‚   collectionName: string,
   81 â”‚   id: string,
   82 â”‚   data: T
   83 â”‚ ): Promise<void> => {
   84 â”‚   await setDoc(doc(db, collectionName, id), {
   85 â”‚     ...data,
   86 â”‚     createdAt: serverTimestamp(),
   87 â”‚     updatedAt: serverTimestamp()
   88 â”‚   })
   89 â”‚ }
   90 â”‚ 
   91 â”‚ export const getDocument = async <T>(
   92 â”‚   collectionName: string,
   93 â”‚   id: string
   94 â”‚ ): Promise<T | null> => {
   95 â”‚   const docRef = doc(db, collectionName, id)
   96 â”‚   const docSnap = await getDoc(docRef)
   97 â”‚   
   98 â”‚   if (docSnap.exists()) {
   99 â”‚     const data = docSnap.data();
  100 â”‚     console.log("Dados brutos recuperados do Firestore para quarto:", id, data);
  101 â”‚     
  102 â”‚     if (data?.serviceFeePct !== undefined) {
  103 â”‚       console.log("serviceFeePct antes da conversÃ£o:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
  104 â”‚       // Garantir que serviceFeePct seja um nÃºmero
  105 â”‚       data.serviceFeePct = Number(data.serviceFeePct);
  106 â”‚       console.log("serviceFeePct apÃ³s conversÃ£o:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
  107 â”‚     }
  108 â”‚     
  109 â”‚     return { id: docSnap.id, ...data } as T
  110 â”‚   } else {
  111 â”‚     return null
  112 â”‚   }
  113 â”‚ }
  114 â”‚ 
  115 â”‚ export const getDocuments = async <T>(
  116 â”‚   collectionName: string,
  117 â”‚   constraints: QueryConstraint[] = [],
  118 â”‚   forceRefresh = false
  119 â”‚ ): Promise<T[]> => {
  120 â”‚   try {
  121 â”‚     const collectionRef = collection(db, collectionName)
  122 â”‚     const q = query(collectionRef, ...constraints)
  123 â”‚     
  124 â”‚     // Se forceRefresh for verdadeiro, adicionar opÃ§Ãµes que forÃ§am uma nova consulta ao Firestore
  125 â”‚     const querySnapshot = await getDocs(q)
  126 â”‚     
  127 â”‚     console.log(`Buscando documentos na coleÃ§Ã£o ${collectionName} - ForÃ§a atualizaÃ§Ã£o: ${forceRefresh}`);
  128 â”‚     
  129 â”‚     return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }) as T)
  130 â”‚   } catch (error) {
  131 â”‚     console.error(`Erro ao buscar documentos da coleÃ§Ã£o ${collectionName}:`, error);
  132 â”‚     return [];
  133 â”‚   }
  134 â”‚ }
  135 â”‚ 
  136 â”‚ export const updateDocument = async <T extends DocumentData>(
  137 â”‚   collectionName: string,
  138 â”‚   id: string,
  139 â”‚   data: Partial<T>
  140 â”‚ ): Promise<void> => {
  141 â”‚   const docRef = doc(db, collectionName, id)
  142 â”‚   await updateDoc(docRef, {
  143 â”‚     ...data,
  144 â”‚     updatedAt: serverTimestamp()
  145 â”‚   })
  146 â”‚ }
  147 â”‚ 
  148 â”‚ export const deleteDocument = async (
  149 â”‚   collectionName: string,
  150 â”‚   id: string
  151 â”‚ ): Promise<boolean> => {
  152 â”‚   const docRef = doc(db, collectionName, id)
  153 â”‚   await deleteDoc(docRef)
  154 â”‚   return true
  155 â”‚ }
  156 â”‚ 
  157 â”‚ // FunÃ§Ãµes para gerenciar quartos
  158 â”‚ export const getRooms = async (forceRefresh = false): Promise<Room[]> => {
  159 â”‚   try {
  160 â”‚     const constraints: QueryConstraint[] = []
  161 â”‚     
  162 â”‚     constraints.push(orderBy('name', 'asc'))
  163 â”‚     
  164 â”‚     const rooms = await getDocuments<Room>('rooms', constraints, forceRefresh)
  165 â”‚     
  166 â”‚     // Garantir que todos os campos necessÃ¡rios estejam presentes
  167 â”‚     return rooms.map(room => {
  168 â”‚       console.log(`Firebase - Quarto ${room.id} dados brutos:`, room);
  169 â”‚       
  170 â”‚       // Garantir que serviceFeePct seja um nÃºmero
  171 â”‚       const serviceFeePct = room.serviceFeePct !== undefined 
  172 â”‚         ? Number(room.serviceFeePct) 
  173 â”‚         : 10;
  174 â”‚         
  175 â”‚       console.log(`Firebase - Quarto ${room.id} serviceFeePct:`, {
  176 â”‚         original: room.serviceFeePct,
  177 â”‚         tipo: typeof room.serviceFeePct,
  178 â”‚         convertido: serviceFeePct
  179 â”‚       });
  180 â”‚       
  181 â”‚       return {
  182 â”‚         id: room.id,
  183 â”‚         name: room.name || '',
  184 â”‚         type: room.type || 'standard',
  185 â”‚         description: room.description || '',
  186 â”‚         price: room.price || 0,
  187 â”‚         capacity: room.capacity || 2,
  188 â”‚         size: room.size || 0,
  189 â”‚         available: room.available !== undefined ? room.available : true,
  190 â”‚         serviceFeePct: serviceFeePct,
  191 â”‚         images: room.images || [],
  192 â”‚         amenities: room.amenities || [],
  193 â”‚         additionalServices: room.additionalServices || [],
  194 â”‚         highlights: room.highlights || [],
  195 â”‚         createdAt: room.createdAt,
  196 â”‚         updatedAt: room.updatedAt
  197 â”‚       };
  198 â”‚     });
  199 â”‚   } catch (error) {
  200 â”‚     console.error('Erro ao buscar quartos:', error)
  201 â”‚     return []
  202 â”‚   }
  203 â”‚ }
  204 â”‚ 
  205 â”‚ export const getAvailableRooms = async (
  206 â”‚   checkIn: Date,
  207 â”‚   checkOut: Date
  208 â”‚ ): Promise<Room[]> => {
  209 â”‚   try {
  210 â”‚     // Buscar todos os quartos que estÃ£o marcados como disponÃ­veis em geral
  211 â”‚     const constraints: QueryConstraint[] = [
  212 â”‚       where('available', '==', true)
  213 â”‚     ]
  214 â”‚     
  215 â”‚     const rooms = await getDocuments<Room>('rooms', constraints);
  216 â”‚     
  217 â”‚     // Filtrar os quartos que estÃ£o disponÃ­veis nas datas especÃ­ficas
  218 â”‚     return filterAvailableRoomsByDate(rooms, checkIn, checkOut);
  219 â”‚   } catch (error) {
  220 â”‚     console.error('Erro ao buscar quartos disponÃ­veis:', error)
  221 â”‚     return []
  222 â”‚   }
  223 â”‚ }
  224 â”‚ 
  225 â”‚ // FunÃ§Ã£o auxiliar para verificar disponibilidade entre datas
  226 â”‚ export const filterAvailableRoomsByDate = (
  227 â”‚   rooms: Room[],
  228 â”‚   checkIn: Date,
  229 â”‚   checkOut: Date
  230 â”‚ ): Room[] => {
  231 â”‚   // Converter checkIn e checkOut para ISO strings
  232 â”‚   const dateStrings = getDatesInRange(checkIn, checkOut);
  233 â”‚   
  234 â”‚   return rooms.filter(room => {
  235 â”‚     // Se nÃ£o tiver controle de disponibilidade especÃ­fico, considera disponÃ­vel
  236 â”‚     if (!room.availabilityDates) return true;
  237 â”‚     
  238 â”‚     // Verificar se alguma data no intervalo estÃ¡ indisponÃ­vel
  239 â”‚     return !dateStrings.some(dateStr => 
  240 â”‚       room.availabilityDates?.[dateStr] === false
  241 â”‚     );
  242 â”‚   });
  243 â”‚ };
  244 â”‚ 
  245 â”‚ // FunÃ§Ã£o para obter disponibilidade de um quarto especÃ­fico
  246 â”‚ export const getRoomAvailability = async (
  247 â”‚   roomId: string, 
  248 â”‚   startDate: Date, 
  249 â”‚   endDate: Date
  250 â”‚ ): Promise<{[date: string]: boolean}> => {
  251 â”‚   try {
  252 â”‚     const room = await getRoomById(roomId);
  253 â”‚     if (!room) throw new Error(`Quarto com ID ${roomId} nÃ£o encontrado`);
  254 â”‚     
  255 â”‚     // Gerar datas no intervalo
  256 â”‚     const dateStrings = getDatesInRange(startDate, endDate);
  257 â”‚     
  258 â”‚     // Se nÃ£o tiver configuraÃ§Ã£o de disponibilidade especÃ­fica, assume tudo disponÃ­vel
  259 â”‚     if (!room.availabilityDates) {
  260 â”‚       return dateStrings.reduce((acc, date) => {
  261 â”‚         acc[date] = true;
  262 â”‚         return acc;
  263 â”‚       }, {} as {[date: string]: boolean});
  264 â”‚     }
  265 â”‚     
  266 â”‚     // Preencher com os dados de disponibilidade existentes
  267 â”‚     return dateStrings.reduce((acc, date) => {
  268 â”‚       acc[date] = room.availabilityDates?.[date] !== false; // disponÃ­vel por padrÃ£o se nÃ£o estiver explicitamente indisponÃ­vel
  269 â”‚       return acc;
  270 â”‚     }, {} as {[date: string]: boolean});
  271 â”‚   } catch (error) {
  272 â”‚     console.error(`Erro ao verificar disponibilidade do quarto ${roomId}:`, error);
  273 â”‚     throw error;
  274 â”‚   }
  275 â”‚ };
  276 â”‚ 
  277 â”‚ // FunÃ§Ã£o para atualizar disponibilidade de um quarto
  278 â”‚ export const updateRoomAvailability = async (
  279 â”‚   roomId: string,
  280 â”‚   availabilityDates: {[date: string]: boolean}
  281 â”‚ ): Promise<boolean> => {
  282 â”‚   try {
  283 â”‚     await updateDocument('rooms', roomId, {
  284 â”‚       availabilityDates,
  285 â”‚       updatedAt: serverTimestamp()
  286 â”‚     });
  287 â”‚     return true;
  288 â”‚   } catch (error) {
  289 â”‚     console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  290 â”‚     return false;
  291 â”‚   }
  292 â”‚ };
  293 â”‚ 
  294 â”‚ // FunÃ§Ã£o auxiliar para gerar array de strings de data entre um intervalo
  295 â”‚ export const getDatesInRange = (startDate: Date, endDate: Date): string[] => {
  296 â”‚   const dates: string[] = [];
  297 â”‚   const currentDate = new Date(startDate);
  298 â”‚   
  299 â”‚   // Normalizar para meia-noite no fuso horÃ¡rio local
  300 â”‚   currentDate.setHours(0, 0, 0, 0);
  301 â”‚   const endDateNormalized = new Date(endDate);
  302 â”‚   endDateNormalized.setHours(0, 0, 0, 0);
  303 â”‚   
  304 â”‚   // Adicionar cada data no intervalo EXCETO o dia de checkout
  305 â”‚   // Usando < em vez de <= para nÃ£o incluir o dia de checkout
  306 â”‚   while (currentDate < endDateNormalized) {
  307 â”‚     dates.push(currentDate.toISOString().split('T')[0]); // Formato YYYY-MM-DD
  308 â”‚     currentDate.setDate(currentDate.getDate() + 1);
  309 â”‚   }
  310 â”‚   
  311 â”‚   return dates;
  312 â”‚ };
  313 â”‚ 
  314 â”‚ export const getRoomById = async (id: string): Promise<Room | null> => {
  315 â”‚   try {
  316 â”‚     const room = await getDocument<Room>('rooms', id);
  317 â”‚     
  318 â”‚     if (!room) return null;
  319 â”‚     
  320 â”‚     console.log(`Firebase - getRoomById ${id} dados brutos:`, room);
  321 â”‚     
  322 â”‚     // Log especÃ­fico para serviceFeePct
  323 â”‚     console.log(`serviceFeePct no Firestore:`, room.serviceFeePct);
  324 â”‚     
  325 â”‚     // Garantir que todos os campos necessÃ¡rios estejam presentes
  326 â”‚     return {
  327 â”‚       ...room,
  328 â”‚       name: room.name || '',
  329 â”‚       type: room.type || 'standard',
  330 â”‚       description: room.description || '',
  331 â”‚       price: room.price || 0,
  332 â”‚       capacity: room.capacity || 2,
  333 â”‚       size: room.size || 0,
  334 â”‚       available: room.available !== undefined ? room.available : true,
  335 â”‚       serviceFeePct: room.serviceFeePct !== undefined ? room.serviceFeePct : 10,
  336 â”‚       images: room.images || [],
  337 â”‚       amenities: room.amenities || [],
  338 â”‚       additionalServices: room.additionalServices || [],
  339 â”‚       highlights: room.highlights || []
  340 â”‚     };
  341 â”‚   } catch (error) {
  342 â”‚     console.error(`Erro ao buscar quarto com ID ${id}:`, error);
  343 â”‚     return null;
  344 â”‚   }
  345 â”‚ }
  346 â”‚ 
  347 â”‚ export const createRoom = async (roomData: Omit<Room, 'id' | 'createdAt' | 'updatedAt'>): Promise<Room> => {
  348 â”‚   try {
  349 â”‚     console.log("createRoom - Dados recebidos:", roomData);
  350 â”‚     
  351 â”‚     const roomWithTimestamps = {
  352 â”‚       ...roomData,
  353 â”‚       available: roomData.available !== undefined ? roomData.available : true,
  354 â”‚       featured: roomData.featured || false,
  355 â”‚       amenities: roomData.amenities || [],
  356 â”‚       additionalServices: roomData.additionalServices || [],
  357 â”‚       highlights: roomData.highlights || [],
  358 â”‚       createdAt: serverTimestamp(),
  359 â”‚       updatedAt: serverTimestamp()
  360 â”‚     }
  361 â”‚     
  362 â”‚     console.log("createRoom - Dados a serem salvos:", roomWithTimestamps);
  363 â”‚     
  364 â”‚     const id = await createDocument('rooms', roomWithTimestamps)
  365 â”‚     
  366 â”‚     return {
  367 â”‚       id,
  368 â”‚       ...roomData,
  369 â”‚       amenities: roomData.amenities || [],
  370 â”‚       additionalServices: roomData.additionalServices || [],
  371 â”‚       highlights: roomData.highlights || [],
  372 â”‚       createdAt: Timestamp.now(),
  373 â”‚       updatedAt: Timestamp.now()
  374 â”‚     }
  375 â”‚   } catch (error) {
  376 â”‚     console.error('Erro ao criar quarto:', error)
  377 â”‚     throw error
  378 â”‚   }
  379 â”‚ }
  380 â”‚ 
  381 â”‚ export const updateRoom = async (id: string, roomData: Partial<Omit<Room, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Room> => {
  382 â”‚   try {
  383 â”‚     console.log(`updateRoom - ID: ${id}, Dados recebidos:`, roomData);
  384 â”‚     
  385 â”‚     // Garantir que estamos lidando explicitamente com o serviceFeePct se ele for 0
  386 â”‚     if (roomData.serviceFeePct === 0) {
  387 â”‚       console.log("updateRoom - Detectado serviceFeePct com valor 0, salvando explicitamente.", roomData.serviceFeePct);
  388 â”‚     }
  389 â”‚     
  390 â”‚     // Adicionar timestamp de atualizaÃ§Ã£o
  391 â”‚     const roomWithTimestamp = {
  392 â”‚       ...roomData,
  393 â”‚       amenities: roomData.amenities || [],
  394 â”‚       additionalServices: roomData.additionalServices || [],
  395 â”‚       highlights: roomData.highlights || [],
  396 â”‚       updatedAt: serverTimestamp()
  397 â”‚     }
  398 â”‚     
  399 â”‚     console.log(`updateRoom - Dados a serem salvos:`, roomWithTimestamp);
  400 â”‚     
  401 â”‚     await updateDocument('rooms', id, roomWithTimestamp)
  402 â”‚     
  403 â”‚     const updatedRoom = await getRoomById(id)
  404 â”‚     if (!updatedRoom) {
  405 â”‚       throw new Error(`Quarto com ID ${id} nÃ£o encontrado apÃ³s atualizaÃ§Ã£o`)
  406 â”‚     }
  407 â”‚     
  408 â”‚     return updatedRoom
  409 â”‚   } catch (error) {
  410 â”‚     console.error('Erro ao atualizar quarto:', error)
  411 â”‚     throw error
  412 â”‚   }
  413 â”‚ }
  414 â”‚ 
  415 â”‚ export const deleteRoom = async (id: string): Promise<boolean> => {
  416 â”‚   return await deleteDocument('rooms', id)
  417 â”‚ }
  418 â”‚ 
  419 â”‚ // FunÃ§Ãµes especÃ­ficas para reservas
  420 â”‚ export const createBooking = async (bookingData: any) => {
  421 â”‚   try {
  422 â”‚     const bookingsCollection = collection(db, 'bookings');
  423 â”‚     const docRef = await addDoc(bookingsCollection, bookingData);
  424 â”‚     
  425 â”‚     // CORREÃ‡ÃƒO: NÃ£o bloquear a data no momento da criaÃ§Ã£o da reserva
  426 â”‚     // O bloqueio serÃ¡ feito apenas quando o pagamento for confirmado
  427 â”‚     // atravÃ©s da funÃ§Ã£o updateBookingStatus
  428 â”‚     
  429 â”‚     return docRef;
  430 â”‚   } catch (error) {
  431 â”‚     console.error('Erro ao criar reserva:', error);
  432 â”‚     throw error;
  433 â”‚   }
  434 â”‚ };
  435 â”‚ 
  436 â”‚ // Nova funÃ§Ã£o para atualizar status da reserva e bloquear as datas da estadia
  437 â”‚ export const updateBookingStatus = async (
  438 â”‚   bookingId: string, 
  439 â”‚   newStatus: 'pending' | 'confirmed' | 'cancelled' | 'completed',
  440 â”‚   newPaymentStatus: 'pending' | 'paid' | 'refunded'
  441 â”‚ ): Promise<boolean> => {
  442 â”‚   try {
  443 â”‚     // ReferÃªncia ao documento da reserva
  444 â”‚     const bookingRef = doc(db, 'bookings', bookingId);
  445 â”‚     const bookingSnap = await getDoc(bookingRef);
  446 â”‚     
  447 â”‚     if (!bookingSnap.exists()) {
  448 â”‚       console.error(`Booking ${bookingId} nÃ£o existe ao atualizar status`);
  449 â”‚       return false;
  450 â”‚     }
  451 â”‚     
  452 â”‚     const bookingData = bookingSnap.data();
  453 â”‚     
  454 â”‚     // Atualizar o status da reserva
  455 â”‚     await updateDoc(bookingRef, {
  456 â”‚       status: newStatus,
  457 â”‚       paymentStatus: newPaymentStatus,
  458 â”‚       updatedAt: serverTimestamp(),
  459 â”‚       ...(newStatus === 'confirmed' && { confirmedAt: serverTimestamp() })
  460 â”‚     });
  461 â”‚     
  462 â”‚     // Se a reserva estÃ¡ sendo confirmada, precisamos bloquear as datas
  463 â”‚     if (newStatus === 'confirmed') {
  464 â”‚       console.log(`Atualizando disponibilidade para reserva confirmada: ${bookingId}`);
  465 â”‚       
  466 â”‚       // Recuperar datas de check-in e check-out
  467 â”‚       const checkIn = bookingData.checkIn.toDate();
  468 â”‚       const checkOut = bookingData.checkOut.toDate();
  469 â”‚       const roomId = bookingData.roomId;
  470 â”‚       
  471 â”‚       // Obter todas as datas entre check-in e check-out
  472 â”‚       const dates: Date[] = [];
  473 â”‚       const currentDate = new Date(checkIn);
  474 â”‚       
  475 â”‚       while (currentDate < checkOut) {
  476 â”‚         dates.push(new Date(currentDate));
  477 â”‚         currentDate.setDate(currentDate.getDate() + 1);
  478 â”‚       }
  479 â”‚       
  480 â”‚       console.log(`Bloqueando ${dates.length} dias para quarto ${roomId}`);
  481 â”‚       
  482 â”‚       // Atualizar disponibilidade para cada data
  483 â”‚       const availabilityUpdates: {[date: string]: boolean} = {};
  484 â”‚       
  485 â”‚       dates.forEach(date => {
  486 â”‚         const dateString = date.toISOString().split('T')[0]; // formato YYYY-MM-DD
  487 â”‚         availabilityUpdates[dateString] = false; // false significa indisponÃ­vel
  488 â”‚       });
  489 â”‚       
  490 â”‚       // Atualizar disponibilidade do quarto
  491 â”‚       if (Object.keys(availabilityUpdates).length > 0) {
  492 â”‚         try {
  493 â”‚           // Obter o documento do quarto
  494 â”‚           const roomRef = doc(db, 'rooms', roomId);
  495 â”‚           const roomSnap = await getDoc(roomRef);
  496 â”‚           
  497 â”‚           if (roomSnap.exists()) {
  498 â”‚             const roomData = roomSnap.data();
  499 â”‚             const currentAvailability = roomData.availabilityDates || {};
  500 â”‚             
  501 â”‚             // Mesclar a disponibilidade atual com as novas atualizaÃ§Ãµes
  502 â”‚             const updatedAvailability = {
  503 â”‚               ...currentAvailability,
  504 â”‚               ...availabilityUpdates
  505 â”‚             };
  506 â”‚             
  507 â”‚             // Atualizar o documento do quarto
  508 â”‚             await updateDoc(roomRef, {
  509 â”‚               availabilityDates: updatedAvailability,
  510 â”‚               updatedAt: serverTimestamp()
  511 â”‚             });
  512 â”‚             
  513 â”‚             console.log(`Disponibilidade atualizada com sucesso para quarto ${roomId}`);
  514 â”‚             
  515 â”‚             // Criar log da reserva
  516 â”‚             await addDoc(collection(db, 'bookingLogs'), {
  517 â”‚               bookingId,
  518 â”‚               roomId,
  519 â”‚               action: 'status_updated',
  520 â”‚               previousStatus: bookingData.status,
  521 â”‚               newStatus,
  522 â”‚               previousPaymentStatus: bookingData.paymentStatus,
  523 â”‚               newPaymentStatus,
  524 â”‚               datesBlocked: Object.keys(availabilityUpdates),
  525 â”‚               timestamp: serverTimestamp(),
  526 â”‚               userId: bookingData.userId || 'system'
  527 â”‚             });
  528 â”‚           } else {
  529 â”‚             console.error(`Quarto ${roomId} nÃ£o encontrado ao atualizar disponibilidade`);
  530 â”‚           }
  531 â”‚         } catch (error) {
  532 â”‚           console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  533 â”‚         }
  534 â”‚       }
  535 â”‚     }
  536 â”‚     
  537 â”‚     return true;
  538 â”‚   } catch (error) {
  539 â”‚     console.error(`Erro ao atualizar status da reserva ${bookingId}:`, error);
  540 â”‚     return false;
  541 â”‚   }
  542 â”‚ }
  543 â”‚ 
  544 â”‚ export const getUserBookings = async (userId: string): Promise<Booking[]> => {
  545 â”‚   return getDocuments<Booking>('bookings', [
  546 â”‚     where('userId', '==', userId),
  547 â”‚     orderBy('createdAt', 'desc')
  548 â”‚   ])
  549 â”‚ }
  550 â”‚ 
  551 â”‚ export const getRecentBookings = async (count = 5): Promise<Booking[]> => {
  552 â”‚   return getDocuments<Booking>('bookings', [
  553 â”‚     orderBy('createdAt', 'desc'),
  554 â”‚     limit(count)
  555 â”‚   ])
  556 â”‚ }
  557 â”‚ 
  558 â”‚ export const getRoomBookings = async (roomId: string): Promise<Booking[]> => {
  559 â”‚   try {
  560 â”‚     const constraints: QueryConstraint[] = [
  561 â”‚       where('roomId', '==', roomId),
  562 â”‚       orderBy('checkIn', 'asc')
  563 â”‚     ];
  564 â”‚     
  565 â”‚     return await getDocuments<Booking>('bookings', constraints);
  566 â”‚   } catch (error) {
  567 â”‚     console.error(`Erro ao buscar reservas do quarto ${roomId}:`, error);
  568 â”‚     return [];
  569 â”‚   }
  570 â”‚ };
  571 â”‚ 
  572 â”‚ // FunÃ§Ãµes especÃ­ficas para contatos
  573 â”‚ export const createContactMessage = async (contactData: Contact) => {
  574 â”‚   try {
  575 â”‚     const contactsCollection = collection(db, 'contacts')
  576 â”‚     
  577 â”‚     // Garantir que o status seja 'new' para novos contatos
  578 â”‚     const contactWithDefaults = {
  579 â”‚       ...contactData,
  580 â”‚       status: contactData.status || 'new',
  581 â”‚       createdAt: contactData.createdAt || Timestamp.now()
  582 â”‚     }
  583 â”‚     
  584 â”‚     // Se tiver detalhes de reserva, adicionar metadados
  585 â”‚     if (contactWithDefaults.reservationDetails) {
  586 â”‚       // Ajustar subject para indicar que Ã© relacionado a reserva
  587 â”‚       if (!contactWithDefaults.subject.includes('Reserva')) {
  588 â”‚         contactWithDefaults.subject = `Reserva: ${contactWithDefaults.subject}`;
  589 â”‚       }
  590 â”‚     }
  591 â”‚     
  592 â”‚     const docRef = await addDoc(contactsCollection, contactWithDefaults)
  593 â”‚     return docRef
  594 â”‚   } catch (error) {
  595 â”‚     console.error('Erro ao criar mensagem de contato:', error)
  596 â”‚     throw error
  597 â”‚   }
  598 â”‚ }
  599 â”‚ 
  600 â”‚ export const getNewContactMessages = async (): Promise<Contact[]> => {
  601 â”‚   return getDocuments<Contact>('contacts', [
  602 â”‚     where('status', '==', 'new'),
  603 â”‚     orderBy('createdAt', 'desc')
  604 â”‚   ])
  605 â”‚ }
  606 â”‚ 
  607 â”‚ // FunÃ§Ãµes para Dashboard com dados reais
  608 â”‚ 
  609 â”‚ export const getDashboardStats = async () => {
  610 â”‚   try {
  611 â”‚     const [totalBookings, totalRevenue, occupancyRate, bookingsByPlatform] = await Promise.all([
  612 â”‚       getTotalBookings(),
  613 â”‚       getMonthlyRevenue(),
  614 â”‚       getOccupancyRate(),
  615 â”‚       getBookingsByPlatform()
  616 â”‚     ]);
  617 â”‚ 
  618 â”‚     return {
  619 â”‚       totalBookings,
  620 â”‚       totalRevenue,
  621 â”‚       occupancyRate,
  622 â”‚       bookingsByPlatform
  623 â”‚     };
  624 â”‚   } catch (error) {
  625 â”‚     console.error('Erro ao obter estatÃ­sticas do dashboard:', error);
  626 â”‚     throw error;
  627 â”‚   }
  628 â”‚ };
  629 â”‚ 
  630 â”‚ // Obter total de reservas
  631 â”‚ export const getTotalBookings = async () => {
  632 â”‚   try {
  633 â”‚     // Obter todas as reservas
  634 â”‚     const bookings = await getDocuments<Booking>('bookings');
  635 â”‚     
  636 â”‚     // Contar reservas por status
  637 â”‚     const confirmed = bookings.filter(b => b.status === 'confirmed').length;
  638 â”‚     const pending = bookings.filter(b => b.status === 'pending').length;
  639 â”‚     const cancelled = bookings.filter(b => b.status === 'cancelled').length;
  640 â”‚     const completed = bookings.filter(b => b.status === 'completed').length;
  641 â”‚     
  642 â”‚     // Calcular crescimento em relaÃ§Ã£o ao mÃªs anterior (simulado por enquanto)
  643 â”‚     // Em uma implementaÃ§Ã£o real, vocÃª compararia com dados do mÃªs anterior
  644 â”‚     const growth = ((confirmed + completed) / (bookings.length || 1) * 100) - 50;
  645 â”‚     
  646 â”‚     return {
  647 â”‚       total: bookings.length,
  648 â”‚       confirmed,
  649 â”‚       pending,
  650 â”‚       cancelled,
  651 â”‚       completed,
  652 â”‚       growth: Math.round(growth) // Arredonda para nÃºmero inteiro
  653 â”‚     };
  654 â”‚   } catch (error) {
  655 â”‚     console.error('Erro ao obter total de reservas:', error);
  656 â”‚     return {
  657 â”‚       total: 0,
  658 â”‚       confirmed: 0,
  659 â”‚       pending: 0, 
  660 â”‚       cancelled: 0,
  661 â”‚       completed: 0,
  662 â”‚       growth: 0
  663 â”‚     };
  664 â”‚   }
  665 â”‚ };
  666 â”‚ 
  667 â”‚ // Obter receita mensal
  668 â”‚ export const getMonthlyRevenue = async () => {
  669 â”‚   try {
  670 â”‚     const bookings = await getDocuments<Booking>('bookings');
  671 â”‚     
  672 â”‚     // Filtrar reservas confirmadas e concluÃ­das
  673 â”‚     const validBookings = bookings.filter(b => 
  674 â”‚       b.status === 'confirmed' || b.status === 'completed'
  675 â”‚     );
  676 â”‚     
  677 â”‚     // Calcular receita total
  678 â”‚     const totalRevenue = validBookings.reduce((acc, booking) => acc + booking.totalPrice, 0);
  679 â”‚     
  680 â”‚     // Agrupar receita por mÃªs
  681 â”‚     const revenueByMonth = validBookings.reduce((acc, booking) => {
  682 â”‚       const date = booking.checkIn.toDate();
  683 â”‚       const month = date.getMonth(); // 0-11
  684 â”‚       const year = date.getFullYear();
  685 â”‚       const key = `${year}-${month}`;
  686 â”‚       
  687 â”‚       if (!acc[key]) {
  688 â”‚         acc[key] = 0;
  689 â”‚       }
  690 â”‚       acc[key] += booking.totalPrice;
  691 â”‚       return acc;
  692 â”‚     }, {} as Record<string, number>);
  693 â”‚     
  694 â”‚     // Converter para formato de array para grÃ¡fico
  695 â”‚     const monthNames = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
  696 â”‚     
  697 â”‚     const currentDate = new Date();
  698 â”‚     const currentMonth = currentDate.getMonth();
  699 â”‚     const currentYear = currentDate.getFullYear();
  700 â”‚     
  701 â”‚     const revenueData = [];
  702 â”‚     
  703 â”‚     // Gerar dados dos Ãºltimos 12 meses
  704 â”‚     for (let i = 0; i < 12; i++) {
  705 â”‚       const month = (currentMonth - i + 12) % 12;
  706 â”‚       const year = currentMonth - i < 0 ? currentYear - 1 : currentYear;
  707 â”‚       const key = `${year}-${month}`;
  708 â”‚       
  709 â”‚       revenueData.unshift({
  710 â”‚         month: monthNames[month],
  711 â”‚         value: revenueByMonth[key] || 0
  712 â”‚       });
  713 â”‚     }
  714 â”‚     
  715 â”‚     // Calcular crescimento em relaÃ§Ã£o ao mÃªs anterior
  716 â”‚     const lastMonthRevenue = revenueData[revenueData.length - 2]?.value || 0;
  717 â”‚     const currentMonthRevenue = revenueData[revenueData.length - 1]?.value || 0;
  718 â”‚     
  719 â”‚     const growth = lastMonthRevenue ? ((currentMonthRevenue - lastMonthRevenue) / lastMonthRevenue) * 100 : 0;
  720 â”‚     
  721 â”‚     return {
  722 â”‚       monthly: currentMonthRevenue,
  723 â”‚       total: totalRevenue,
  724 â”‚       growth: Math.round(growth),
  725 â”‚       revenueData
  726 â”‚     };
  727 â”‚   } catch (error) {
  728 â”‚     console.error('Erro ao obter receita mensal:', error);
  729 â”‚     return {
  730 â”‚       monthly: 0,
  731 â”‚       total: 0,
  732 â”‚       growth: 0,
  733 â”‚       revenueData: []
  734 â”‚     };
  735 â”‚   }
  736 â”‚ };
  737 â”‚ 
  738 â”‚ // Calcular taxa de ocupaÃ§Ã£o
  739 â”‚ export const getOccupancyRate = async () => {
  740 â”‚   try {
  741 â”‚     // Obter todos os quartos
  742 â”‚     const rooms = await getDocuments<Room>('rooms');
  743 â”‚     const totalRooms = rooms.length;
  744 â”‚     
  745 â”‚     if (totalRooms === 0) {
  746 â”‚       return { rate: 0, growth: 0 };
  747 â”‚     }
  748 â”‚     
  749 â”‚     // Obter todas as reservas
  750 â”‚     const bookings = await getDocuments<Booking>('bookings');
  751 â”‚     
  752 â”‚     // Filtrar reservas confirmadas e concluÃ­das para o mÃªs atual
  753 â”‚     const currentDate = new Date();
  754 â”‚     const currentMonth = currentDate.getMonth();
  755 â”‚     const currentYear = currentDate.getFullYear();
  756 â”‚     
  757 â”‚     const currentMonthBookings = bookings.filter(booking => {
  758 â”‚       const checkInDate = booking.checkIn.toDate();
  759 â”‚       return (
  760 â”‚         (booking.status === 'confirmed' || booking.status === 'completed') &&
  761 â”‚         checkInDate.getMonth() === currentMonth &&
  762 â”‚         checkInDate.getFullYear() === currentYear
  763 â”‚       );
  764 â”‚     });
  765 â”‚     
  766 â”‚     // Calcular dias ocupados por quarto
  767 â”‚     const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
  768 â”‚     const totalPossibleRoomDays = totalRooms * daysInMonth;
  769 â”‚     
  770 â”‚     // Contar dias ocupados (simplificado - em produÃ§Ã£o seria mais complexo)
  771 â”‚     let occupiedDays = 0;
  772 â”‚     
  773 â”‚     currentMonthBookings.forEach(booking => {
  774 â”‚       const checkIn = booking.checkIn.toDate();
  775 â”‚       const checkOut = booking.checkOut.toDate();
  776 â”‚       
  777 â”‚       // Ajustar datas para considerar apenas o mÃªs atual
  778 â”‚       const startDate = new Date(Math.max(
  779 â”‚         checkIn.getTime(),
  780 â”‚         new Date(currentYear, currentMonth, 1).getTime()
  781 â”‚       ));
  782 â”‚       const endDate = new Date(Math.min(
  783 â”‚         checkOut.getTime(),
  784 â”‚         new Date(currentYear, currentMonth + 1, 0).getTime()
  785 â”‚       ));
  786 â”‚       
  787 â”‚       // Calcular dias entre datas (incluindo check-in, excluindo check-out)
  788 â”‚       const days = Math.max(0, Math.floor((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)));
  789 â”‚       occupiedDays += days;
  790 â”‚     });
  791 â”‚     
  792 â”‚     const occupancyRate = (occupiedDays / totalPossibleRoomDays) * 100;
  793 â”‚     
  794 â”‚     // SimulaÃ§Ã£o de crescimento (em produÃ§Ã£o, compararia com mÃªs anterior)
  795 â”‚     const growth = occupancyRate > 50 ? 5 : -3;
  796 â”‚     
  797 â”‚     return {
  798 â”‚       rate: Math.round(occupancyRate),
  799 â”‚       growth: Math.round(growth)
  800 â”‚     };
  801 â”‚   } catch (error) {
  802 â”‚     console.error('Erro ao calcular taxa de ocupaÃ§Ã£o:', error);
  803 â”‚     return { rate: 0, growth: 0 };
  804 â”‚   }
  805 â”‚ };
  806 â”‚ 
  807 â”‚ // Obter reservas agrupadas por plataforma
  808 â”‚ export const getBookingsByPlatform = async () => {
  809 â”‚   try {
  810 â”‚     const bookings = await getDocuments<Booking>('bookings');
  811 â”‚     
  812 â”‚     // Categorizar reservas por origem
  813 â”‚     const platforms = [
  814 â”‚       { 
  815 â”‚         platform: "Booking.com", 
  816 â”‚         color: "#003580", 
  817 â”‚         icon: "Globe",
  818 â”‚         bookings: []
  819 â”‚       },
  820 â”‚       { 
  821 â”‚         platform: "Airbnb", 
  822 â”‚         color: "#FF5A5F", 
  823 â”‚         icon: "Heart",
  824 â”‚         bookings: []
  825 â”‚       },
  826 â”‚       { 
  827 â”‚         platform: "Direto", 
  828 â”‚         color: "#4CAF50", 
  829 â”‚         icon: "Home",
  830 â”‚         bookings: []
  831 â”‚       }
  832 â”‚     ];
  833 â”‚     
  834 â”‚     // Para fins de demonstraÃ§Ã£o, colocar todas as reservas como "Direto" por enquanto
  835 â”‚     // Em produÃ§Ã£o, usaria um campo "platformOrigin" ou similar na tabela de reservas
  836 â”‚     const platformIndex = 2; // Ãndice da plataforma "Direto"
  837 â”‚     
  838 â”‚     bookings.forEach(booking => {
  839 â”‚       // Transformar para o formato esperado pelo componente
  840 â”‚       const transformedBooking = {
  841 â”‚         id: booking.id || '',
  842 â”‚         guestName: booking.guestName,
  843 â”‚         roomName: booking.roomName,
  844 â”‚         checkIn: booking.checkIn.toDate().toLocaleDateString('pt-PT'),
  845 â”‚         checkOut: booking.checkOut.toDate().toLocaleDateString('pt-PT'),
  846 â”‚         status: booking.status,
  847 â”‚         value: new Intl.NumberFormat('pt-PT', {
  848 â”‚           style: 'currency',
  849 â”‚           currency: 'EUR'
  850 â”‚         }).format(booking.totalPrice)
  851 â”‚       };
  852 â”‚       
  853 â”‚       // Adicionar Ã  plataforma "Direto"
  854 â”‚       (platforms[platformIndex] as any).bookings.push(transformedBooking);
  855 â”‚     });
  856 â”‚     
  857 â”‚     return platforms;
  858 â”‚   } catch (error) {
  859 â”‚     console.error('Erro ao obter reservas por plataforma:', error);
  860 â”‚     return [];
  861 â”‚   }
  862 â”‚ };
  863 â”‚ 
  864 â”‚ // FunÃ§Ã£o para obter o preÃ§o de um quarto para uma data especÃ­fica
  865 â”‚ export const getRoomPriceForDate = async (roomId: string, date: Date): Promise<number> => {
  866 â”‚   try {
  867 â”‚     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  868 â”‚     
  869 â”‚     if (!roomDoc.exists()) {
  870 â”‚       throw new Error("Quarto nÃ£o encontrado");
  871 â”‚     }
  872 â”‚     
  873 â”‚     const roomData = roomDoc.data() as Room;
  874 â”‚     const basePrice = roomData.price;
  875 â”‚     
  876 â”‚     if (!roomData.seasonalPrices || roomData.seasonalPrices.length === 0) {
  877 â”‚       return basePrice;
  878 â”‚     }
  879 â”‚     
  880 â”‚     // Verificar se a data estÃ¡ dentro de algum perÃ­odo sazonal
  881 â”‚     for (const seasonalPrice of roomData.seasonalPrices) {
  882 â”‚       const startDate = new Date(seasonalPrice.startDate);
  883 â”‚       const endDate = new Date(seasonalPrice.endDate);
  884 â”‚       
  885 â”‚       if (date >= startDate && date <= endDate) {
  886 â”‚         return seasonalPrice.price;
  887 â”‚       }
  888 â”‚     }
  889 â”‚     
  890 â”‚     // Se nÃ£o cair em nenhum perÃ­odo sazonal, retorna o preÃ§o base
  891 â”‚     return basePrice;
  892 â”‚   } catch (error) {
  893 â”‚     console.error("Erro ao obter preÃ§o do quarto:", error);
  894 â”‚     throw error;
  895 â”‚   }
  896 â”‚ }
  897 â”‚ 
  898 â”‚ // FunÃ§Ã£o para calcular o preÃ§o total de uma estadia
  899 â”‚ export const calculateStayPrice = async (
  900 â”‚   roomId: string, 
  901 â”‚   checkIn: Date, 
  902 â”‚   checkOut: Date
  903 â”‚ ): Promise<{
  904 â”‚   totalPrice: number;
  905 â”‚   nightlyPrices: { date: string; price: number }[];
  906 â”‚   serviceFee: number;
  907 â”‚   totalWithFee: number;
  908 â”‚ }> => {
  909 â”‚   try {
  910 â”‚     console.log(`ğŸ” Iniciando cÃ¡lculo de preÃ§o para estadia: ${checkIn.toISOString().split('T')[0]} atÃ© ${checkOut.toISOString().split('T')[0]}`);
  911 â”‚     
  912 â”‚     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  913 â”‚     
  914 â”‚     if (!roomDoc.exists()) {
  915 â”‚       throw new Error("Quarto nÃ£o encontrado");
  916 â”‚     }
  917 â”‚     
  918 â”‚     const roomData = roomDoc.data() as Room;
  919 â”‚     console.log(`ğŸ“ Dados do quarto ${roomId}:`, {
  920 â”‚       nome: roomData.name,
  921 â”‚       precoBase: roomData.price,
  922 â”‚       taxaServico: roomData.serviceFeePct || 0,
  923 â”‚       temPrecosSazonais: !!roomData.seasonalPrices?.length
  924 â”‚     });
  925 â”‚     
  926 â”‚     const nightlyPrices: { date: string; price: number }[] = [];
  927 â”‚     let totalPrice = 0;
  928 â”‚     
  929 â”‚     // Calcular o nÃºmero de noites - corrigido para usar o mÃ©todo correto de cÃ¡lculo
  930 â”‚     // O nÃºmero de noites Ã© a diferenÃ§a em dias (estadia = checkout - checkin)
  931 â”‚     const noites = differenceInDays(checkOut, checkIn);
  932 â”‚     console.log(`ğŸ—“ï¸ NÃºmero de noites calculado: ${noites}`);
  933 â”‚     
  934 â”‚     if (noites <= 0) {
  935 â”‚       console.error(`âš ï¸ Erro: nÃºmero de noites invÃ¡lido (${noites})`);
  936 â”‚       throw new Error("Data de check-out deve ser posterior Ã  data de check-in");
  937 â”‚     }
  938 â”‚     
  939 â”‚     // Para cada noite, verificar o preÃ§o aplicÃ¡vel (preÃ§o base ou sazonal)
  940 â”‚     // ComeÃ§amos exatamente do dia de check-in
  941 â”‚     const currentDate = new Date(checkIn);
  942 â”‚     currentDate.setHours(0, 0, 0, 0); // Normalizar para meia-noite
  943 â”‚     
  944 â”‚     // Processamos cada dia de estadia (noite)
  945 â”‚     console.log(`ğŸ“Š Calculando preÃ§os por noite:`);
  946 â”‚     for (let i = 0; i < noites; i++) {
  947 â”‚       // Obtemos o preÃ§o para esta data
  948 â”‚       const dateCopy = new Date(currentDate);
  949 â”‚       const priceForDate = await getRoomPriceForDate(roomId, dateCopy);
  950 â”‚       const dateString = dateCopy.toISOString().split('T')[0]; // YYYY-MM-DD
  951 â”‚       
  952 â”‚       console.log(`   - ${dateString}: â‚¬${priceForDate}`);
  953 â”‚       
  954 â”‚       nightlyPrices.push({
  955 â”‚         date: dateString,
  956 â”‚         price: priceForDate
  957 â”‚       });
  958 â”‚       
  959 â”‚       totalPrice += priceForDate;
  960 â”‚       
  961 â”‚       // AvanÃ§amos para o prÃ³ximo dia
  962 â”‚       currentDate.setDate(currentDate.getDate() + 1);
  963 â”‚     }
  964 â”‚     
  965 â”‚     // VerificaÃ§Ã£o de seguranÃ§a para o cÃ¡lculo do totalPrice
  966 â”‚     const manualTotal = nightlyPrices.reduce((sum, night) => sum + night.price, 0);
  967 â”‚     if (Math.abs(totalPrice - manualTotal) > 1) {
  968 â”‚       console.error(`âš ï¸ DiscrepÃ¢ncia detectada no cÃ¡lculo do preÃ§o total!`);
  969 â”‚       console.error(`   - Total calculado iterativamente: â‚¬${totalPrice}`);
  970 â”‚       console.error(`   - Total calculado via reduce: â‚¬${manualTotal}`);
  971 â”‚       console.error(`   - Usando o valor recalculado para seguranÃ§a!`);
  972 â”‚       totalPrice = manualTotal;
  973 â”‚     }
  974 â”‚     
  975 â”‚     // Calcular taxa de serviÃ§o
  976 â”‚     const serviceFee = (totalPrice * (roomData.serviceFeePct || 0)) / 100;
  977 â”‚     const totalWithFee = totalPrice + serviceFee;
  978 â”‚     
  979 â”‚     console.log(`ğŸ’° Resumo do cÃ¡lculo:`);
  980 â”‚     console.log(`   - Total das diÃ¡rias: â‚¬${totalPrice}`);
  981 â”‚     console.log(`   - Taxa de serviÃ§o (${roomData.serviceFeePct || 0}%): â‚¬${serviceFee}`);
  982 â”‚     console.log(`   - Total com taxas: â‚¬${totalWithFee}`);
  983 â”‚     
  984 â”‚     return {
  985 â”‚       totalPrice,
  986 â”‚       nightlyPrices,
  987 â”‚       serviceFee,
  988 â”‚       totalWithFee
  989 â”‚     };
  990 â”‚   } catch (error) {
  991 â”‚     console.error("âŒ Erro ao calcular preÃ§o da estadia:", error);
  992 â”‚     throw error;
  993 â”‚   }
  994 â”‚ } 
  995 â”‚ import { 
  996 â”‚   collection, 
  997 â”‚   getDocs, 
  998 â”‚   getDoc, 
  999 â”‚   doc, 
 1000 â”‚   setDoc, 
 1001 â”‚   addDoc, 
 1002 â”‚   updateDoc, 
 1003 â”‚   deleteDoc,
 1004 â”‚   query,
 1005 â”‚   where,
 1006 â”‚   orderBy,
 1007 â”‚   limit,
 1008 â”‚   serverTimestamp
      Â·   â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€
      Â·          â•°â”€â”€ `serverTimestamp` redefined here
 1009 â”‚ } from 'firebase/firestore';
 1010 â”‚ import { db } from './config';
      â•°â”€â”€â”€â”€

  Ã— the name `db` is defined multiple times
      â•­â”€[/home/runner/workspace/lib/firebase/firestore.ts:16:1]
   16 â”‚   Timestamp,
   17 â”‚   serverTimestamp
   18 â”‚ } from 'firebase/firestore'
   19 â”‚ import { db } from './config'
      Â·          â”€â”¬
      Â·           â•°â”€â”€ previous definition of `db` here
   20 â”‚ import { Room, SeasonalPrice } from '@/lib/types'
   21 â”‚ import { differenceInDays } from 'date-fns'
   22 â”‚ 
   23 â”‚ // Tipos de dados
   24 â”‚ export interface Booking {
   25 â”‚   id?: string
   26 â”‚   userId?: string
   27 â”‚   guestName: string
   28 â”‚   guestEmail: string
   29 â”‚   guestPhone: string
   30 â”‚   roomId: string
   31 â”‚   roomName: string
   32 â”‚   checkIn: Timestamp
   33 â”‚   checkOut: Timestamp
   34 â”‚   adults: number
   35 â”‚   children: number
   36 â”‚   totalPrice: number
   37 â”‚   status: 'pending' | 'confirmed' | 'cancelled' | 'completed'
   38 â”‚   paymentStatus: 'pending' | 'paid' | 'refunded'
   39 â”‚   specialRequests?: string
   40 â”‚   createdAt?: Timestamp
   41 â”‚   updatedAt?: Timestamp
   42 â”‚ }
   43 â”‚ 
   44 â”‚ export interface Contact {
   45 â”‚   id?: string
   46 â”‚   name: string
   47 â”‚   email: string
   48 â”‚   phone?: string
   49 â”‚   subject: string
   50 â”‚   message: string
   51 â”‚   status: 'new' | 'read' | 'replied'
   52 â”‚   createdAt: Timestamp
   53 â”‚   updatedAt?: Timestamp
   54 â”‚   repliedAt?: Timestamp
   55 â”‚   replyContent?: string
   56 â”‚   reservationDetails?: {
   57 â”‚     checkIn?: Timestamp
   58 â”‚     checkOut?: Timestamp
   59 â”‚     roomId?: string
   60 â”‚     roomName?: string
   61 â”‚     totalGuests?: number
   62 â”‚     totalPrice?: number
   63 â”‚   }
   64 â”‚ }
   65 â”‚ 
   66 â”‚ // FunÃ§Ãµes genÃ©ricas para CRUD
   67 â”‚ export const createDocument = async <T extends DocumentData>(
   68 â”‚   collectionName: string,
   69 â”‚   data: T
   70 â”‚ ): Promise<string> => {
   71 â”‚   const docRef = await addDoc(collection(db, collectionName), {
   72 â”‚     ...data,
   73 â”‚     createdAt: serverTimestamp(),
   74 â”‚     updatedAt: serverTimestamp()
   75 â”‚   })
   76 â”‚   return docRef.id
   77 â”‚ }
   78 â”‚ 
   79 â”‚ export const createDocumentWithId = async <T extends DocumentData>(
   80 â”‚   collectionName: string,
   81 â”‚   id: string,
   82 â”‚   data: T
   83 â”‚ ): Promise<void> => {
   84 â”‚   await setDoc(doc(db, collectionName, id), {
   85 â”‚     ...data,
   86 â”‚     createdAt: serverTimestamp(),
   87 â”‚     updatedAt: serverTimestamp()
   88 â”‚   })
   89 â”‚ }
   90 â”‚ 
   91 â”‚ export const getDocument = async <T>(
   92 â”‚   collectionName: string,
   93 â”‚   id: string
   94 â”‚ ): Promise<T | null> => {
   95 â”‚   const docRef = doc(db, collectionName, id)
   96 â”‚   const docSnap = await getDoc(docRef)
   97 â”‚   
   98 â”‚   if (docSnap.exists()) {
   99 â”‚     const data = docSnap.data();
  100 â”‚     console.log("Dados brutos recuperados do Firestore para quarto:", id, data);
  101 â”‚     
  102 â”‚     if (data?.serviceFeePct !== undefined) {
  103 â”‚       console.log("serviceFeePct antes da conversÃ£o:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
  104 â”‚       // Garantir que serviceFeePct seja um nÃºmero
  105 â”‚       data.serviceFeePct = Number(data.serviceFeePct);
  106 â”‚       console.log("serviceFeePct apÃ³s conversÃ£o:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
  107 â”‚     }
  108 â”‚     
  109 â”‚     return { id: docSnap.id, ...data } as T
  110 â”‚   } else {
  111 â”‚     return null
  112 â”‚   }
  113 â”‚ }
  114 â”‚ 
  115 â”‚ export const getDocuments = async <T>(
  116 â”‚   collectionName: string,
  117 â”‚   constraints: QueryConstraint[] = [],
  118 â”‚   forceRefresh = false
  119 â”‚ ): Promise<T[]> => {
  120 â”‚   try {
  121 â”‚     const collectionRef = collection(db, collectionName)
  122 â”‚     const q = query(collectionRef, ...constraints)
  123 â”‚     
  124 â”‚     // Se forceRefresh for verdadeiro, adicionar opÃ§Ãµes que forÃ§am uma nova consulta ao Firestore
  125 â”‚     const querySnapshot = await getDocs(q)
  126 â”‚     
  127 â”‚     console.log(`Buscando documentos na coleÃ§Ã£o ${collectionName} - ForÃ§a atualizaÃ§Ã£o: ${forceRefresh}`);
  128 â”‚     
  129 â”‚     return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }) as T)
  130 â”‚   } catch (error) {
  131 â”‚     console.error(`Erro ao buscar documentos da coleÃ§Ã£o ${collectionName}:`, error);
  132 â”‚     return [];
  133 â”‚   }
  134 â”‚ }
  135 â”‚ 
  136 â”‚ export const updateDocument = async <T extends DocumentData>(
  137 â”‚   collectionName: string,
  138 â”‚   id: string,
  139 â”‚   data: Partial<T>
  140 â”‚ ): Promise<void> => {
  141 â”‚   const docRef = doc(db, collectionName, id)
  142 â”‚   await updateDoc(docRef, {
  143 â”‚     ...data,
  144 â”‚     updatedAt: serverTimestamp()
  145 â”‚   })
  146 â”‚ }
  147 â”‚ 
  148 â”‚ export const deleteDocument = async (
  149 â”‚   collectionName: string,
  150 â”‚   id: string
  151 â”‚ ): Promise<boolean> => {
  152 â”‚   const docRef = doc(db, collectionName, id)
  153 â”‚   await deleteDoc(docRef)
  154 â”‚   return true
  155 â”‚ }
  156 â”‚ 
  157 â”‚ // FunÃ§Ãµes para gerenciar quartos
  158 â”‚ export const getRooms = async (forceRefresh = false): Promise<Room[]> => {
  159 â”‚   try {
  160 â”‚     const constraints: QueryConstraint[] = []
  161 â”‚     
  162 â”‚     constraints.push(orderBy('name', 'asc'))
  163 â”‚     
  164 â”‚     const rooms = await getDocuments<Room>('rooms', constraints, forceRefresh)
  165 â”‚     
  166 â”‚     // Garantir que todos os campos necessÃ¡rios estejam presentes
  167 â”‚     return rooms.map(room => {
  168 â”‚       console.log(`Firebase - Quarto ${room.id} dados brutos:`, room);
  169 â”‚       
  170 â”‚       // Garantir que serviceFeePct seja um nÃºmero
  171 â”‚       const serviceFeePct = room.serviceFeePct !== undefined 
  172 â”‚         ? Number(room.serviceFeePct) 
  173 â”‚         : 10;
  174 â”‚         
  175 â”‚       console.log(`Firebase - Quarto ${room.id} serviceFeePct:`, {
  176 â”‚         original: room.serviceFeePct,
  177 â”‚         tipo: typeof room.serviceFeePct,
  178 â”‚         convertido: serviceFeePct
  179 â”‚       });
  180 â”‚       
  181 â”‚       return {
  182 â”‚         id: room.id,
  183 â”‚         name: room.name || '',
  184 â”‚         type: room.type || 'standard',
  185 â”‚         description: room.description || '',
  186 â”‚         price: room.price || 0,
  187 â”‚         capacity: room.capacity || 2,
  188 â”‚         size: room.size || 0,
  189 â”‚         available: room.available !== undefined ? room.available : true,
  190 â”‚         serviceFeePct: serviceFeePct,
  191 â”‚         images: room.images || [],
  192 â”‚         amenities: room.amenities || [],
  193 â”‚         additionalServices: room.additionalServices || [],
  194 â”‚         highlights: room.highlights || [],
  195 â”‚         createdAt: room.createdAt,
  196 â”‚         updatedAt: room.updatedAt
  197 â”‚       };
  198 â”‚     });
  199 â”‚   } catch (error) {
  200 â”‚     console.error('Erro ao buscar quartos:', error)
  201 â”‚     return []
  202 â”‚   }
  203 â”‚ }
  204 â”‚ 
  205 â”‚ export const getAvailableRooms = async (
  206 â”‚   checkIn: Date,
  207 â”‚   checkOut: Date
  208 â”‚ ): Promise<Room[]> => {
  209 â”‚   try {
  210 â”‚     // Buscar todos os quartos que estÃ£o marcados como disponÃ­veis em geral
  211 â”‚     const constraints: QueryConstraint[] = [
  212 â”‚       where('available', '==', true)
  213 â”‚     ]
  214 â”‚     
  215 â”‚     const rooms = await getDocuments<Room>('rooms', constraints);
  216 â”‚     
  217 â”‚     // Filtrar os quartos que estÃ£o disponÃ­veis nas datas especÃ­ficas
  218 â”‚     return filterAvailableRoomsByDate(rooms, checkIn, checkOut);
  219 â”‚   } catch (error) {
  220 â”‚     console.error('Erro ao buscar quartos disponÃ­veis:', error)
  221 â”‚     return []
  222 â”‚   }
  223 â”‚ }
  224 â”‚ 
  225 â”‚ // FunÃ§Ã£o auxiliar para verificar disponibilidade entre datas
  226 â”‚ export const filterAvailableRoomsByDate = (
  227 â”‚   rooms: Room[],
  228 â”‚   checkIn: Date,
  229 â”‚   checkOut: Date
  230 â”‚ ): Room[] => {
  231 â”‚   // Converter checkIn e checkOut para ISO strings
  232 â”‚   const dateStrings = getDatesInRange(checkIn, checkOut);
  233 â”‚   
  234 â”‚   return rooms.filter(room => {
  235 â”‚     // Se nÃ£o tiver controle de disponibilidade especÃ­fico, considera disponÃ­vel
  236 â”‚     if (!room.availabilityDates) return true;
  237 â”‚     
  238 â”‚     // Verificar se alguma data no intervalo estÃ¡ indisponÃ­vel
  239 â”‚     return !dateStrings.some(dateStr => 
  240 â”‚       room.availabilityDates?.[dateStr] === false
  241 â”‚     );
  242 â”‚   });
  243 â”‚ };
  244 â”‚ 
  245 â”‚ // FunÃ§Ã£o para obter disponibilidade de um quarto especÃ­fico
  246 â”‚ export const getRoomAvailability = async (
  247 â”‚   roomId: string, 
  248 â”‚   startDate: Date, 
  249 â”‚   endDate: Date
  250 â”‚ ): Promise<{[date: string]: boolean}> => {
  251 â”‚   try {
  252 â”‚     const room = await getRoomById(roomId);
  253 â”‚     if (!room) throw new Error(`Quarto com ID ${roomId} nÃ£o encontrado`);
  254 â”‚     
  255 â”‚     // Gerar datas no intervalo
  256 â”‚     const dateStrings = getDatesInRange(startDate, endDate);
  257 â”‚     
  258 â”‚     // Se nÃ£o tiver configuraÃ§Ã£o de disponibilidade especÃ­fica, assume tudo disponÃ­vel
  259 â”‚     if (!room.availabilityDates) {
  260 â”‚       return dateStrings.reduce((acc, date) => {
  261 â”‚         acc[date] = true;
  262 â”‚         return acc;
  263 â”‚       }, {} as {[date: string]: boolean});
  264 â”‚     }
  265 â”‚     
  266 â”‚     // Preencher com os dados de disponibilidade existentes
  267 â”‚     return dateStrings.reduce((acc, date) => {
  268 â”‚       acc[date] = room.availabilityDates?.[date] !== false; // disponÃ­vel por padrÃ£o se nÃ£o estiver explicitamente indisponÃ­vel
  269 â”‚       return acc;
  270 â”‚     }, {} as {[date: string]: boolean});
  271 â”‚   } catch (error) {
  272 â”‚     console.error(`Erro ao verificar disponibilidade do quarto ${roomId}:`, error);
  273 â”‚     throw error;
  274 â”‚   }
  275 â”‚ };
  276 â”‚ 
  277 â”‚ // FunÃ§Ã£o para atualizar disponibilidade de um quarto
  278 â”‚ export const updateRoomAvailability = async (
  279 â”‚   roomId: string,
  280 â”‚   availabilityDates: {[date: string]: boolean}
  281 â”‚ ): Promise<boolean> => {
  282 â”‚   try {
  283 â”‚     await updateDocument('rooms', roomId, {
  284 â”‚       availabilityDates,
  285 â”‚       updatedAt: serverTimestamp()
  286 â”‚     });
  287 â”‚     return true;
  288 â”‚   } catch (error) {
  289 â”‚     console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  290 â”‚     return false;
  291 â”‚   }
  292 â”‚ };
  293 â”‚ 
  294 â”‚ // FunÃ§Ã£o auxiliar para gerar array de strings de data entre um intervalo
  295 â”‚ export const getDatesInRange = (startDate: Date, endDate: Date): string[] => {
  296 â”‚   const dates: string[] = [];
  297 â”‚   const currentDate = new Date(startDate);
  298 â”‚   
  299 â”‚   // Normalizar para meia-noite no fuso horÃ¡rio local
  300 â”‚   currentDate.setHours(0, 0, 0, 0);
  301 â”‚   const endDateNormalized = new Date(endDate);
  302 â”‚   endDateNormalized.setHours(0, 0, 0, 0);
  303 â”‚   
  304 â”‚   // Adicionar cada data no intervalo EXCETO o dia de checkout
  305 â”‚   // Usando < em vez de <= para nÃ£o incluir o dia de checkout
  306 â”‚   while (currentDate < endDateNormalized) {
  307 â”‚     dates.push(currentDate.toISOString().split('T')[0]); // Formato YYYY-MM-DD
  308 â”‚     currentDate.setDate(currentDate.getDate() + 1);
  309 â”‚   }
  310 â”‚   
  311 â”‚   return dates;
  312 â”‚ };
  313 â”‚ 
  314 â”‚ export const getRoomById = async (id: string): Promise<Room | null> => {
  315 â”‚   try {
  316 â”‚     const room = await getDocument<Room>('rooms', id);
  317 â”‚     
  318 â”‚     if (!room) return null;
  319 â”‚     
  320 â”‚     console.log(`Firebase - getRoomById ${id} dados brutos:`, room);
  321 â”‚     
  322 â”‚     // Log especÃ­fico para serviceFeePct
  323 â”‚     console.log(`serviceFeePct no Firestore:`, room.serviceFeePct);
  324 â”‚     
  325 â”‚     // Garantir que todos os campos necessÃ¡rios estejam presentes
  326 â”‚     return {
  327 â”‚       ...room,
  328 â”‚       name: room.name || '',
  329 â”‚       type: room.type || 'standard',
  330 â”‚       description: room.description || '',
  331 â”‚       price: room.price || 0,
  332 â”‚       capacity: room.capacity || 2,
  333 â”‚       size: room.size || 0,
  334 â”‚       available: room.available !== undefined ? room.available : true,
  335 â”‚       serviceFeePct: room.serviceFeePct !== undefined ? room.serviceFeePct : 10,
  336 â”‚       images: room.images || [],
  337 â”‚       amenities: room.amenities || [],
  338 â”‚       additionalServices: room.additionalServices || [],
  339 â”‚       highlights: room.highlights || []
  340 â”‚     };
  341 â”‚   } catch (error) {
  342 â”‚     console.error(`Erro ao buscar quarto com ID ${id}:`, error);
  343 â”‚     return null;
  344 â”‚   }
  345 â”‚ }
  346 â”‚ 
  347 â”‚ export const createRoom = async (roomData: Omit<Room, 'id' | 'createdAt' | 'updatedAt'>): Promise<Room> => {
  348 â”‚   try {
  349 â”‚     console.log("createRoom - Dados recebidos:", roomData);
  350 â”‚     
  351 â”‚     const roomWithTimestamps = {
  352 â”‚       ...roomData,
  353 â”‚       available: roomData.available !== undefined ? roomData.available : true,
  354 â”‚       featured: roomData.featured || false,
  355 â”‚       amenities: roomData.amenities || [],
  356 â”‚       additionalServices: roomData.additionalServices || [],
  357 â”‚       highlights: roomData.highlights || [],
  358 â”‚       createdAt: serverTimestamp(),
  359 â”‚       updatedAt: serverTimestamp()
  360 â”‚     }
  361 â”‚     
  362 â”‚     console.log("createRoom - Dados a serem salvos:", roomWithTimestamps);
  363 â”‚     
  364 â”‚     const id = await createDocument('rooms', roomWithTimestamps)
  365 â”‚     
  366 â”‚     return {
  367 â”‚       id,
  368 â”‚       ...roomData,
  369 â”‚       amenities: roomData.amenities || [],
  370 â”‚       additionalServices: roomData.additionalServices || [],
  371 â”‚       highlights: roomData.highlights || [],
  372 â”‚       createdAt: Timestamp.now(),
  373 â”‚       updatedAt: Timestamp.now()
  374 â”‚     }
  375 â”‚   } catch (error) {
  376 â”‚     console.error('Erro ao criar quarto:', error)
  377 â”‚     throw error
  378 â”‚   }
  379 â”‚ }
  380 â”‚ 
  381 â”‚ export const updateRoom = async (id: string, roomData: Partial<Omit<Room, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Room> => {
  382 â”‚   try {
  383 â”‚     console.log(`updateRoom - ID: ${id}, Dados recebidos:`, roomData);
  384 â”‚     
  385 â”‚     // Garantir que estamos lidando explicitamente com o serviceFeePct se ele for 0
  386 â”‚     if (roomData.serviceFeePct === 0) {
  387 â”‚       console.log("updateRoom - Detectado serviceFeePct com valor 0, salvando explicitamente.", roomData.serviceFeePct);
  388 â”‚     }
  389 â”‚     
  390 â”‚     // Adicionar timestamp de atualizaÃ§Ã£o
  391 â”‚     const roomWithTimestamp = {
  392 â”‚       ...roomData,
  393 â”‚       amenities: roomData.amenities || [],
  394 â”‚       additionalServices: roomData.additionalServices || [],
  395 â”‚       highlights: roomData.highlights || [],
  396 â”‚       updatedAt: serverTimestamp()
  397 â”‚     }
  398 â”‚     
  399 â”‚     console.log(`updateRoom - Dados a serem salvos:`, roomWithTimestamp);
  400 â”‚     
  401 â”‚     await updateDocument('rooms', id, roomWithTimestamp)
  402 â”‚     
  403 â”‚     const updatedRoom = await getRoomById(id)
  404 â”‚     if (!updatedRoom) {
  405 â”‚       throw new Error(`Quarto com ID ${id} nÃ£o encontrado apÃ³s atualizaÃ§Ã£o`)
  406 â”‚     }
  407 â”‚     
  408 â”‚     return updatedRoom
  409 â”‚   } catch (error) {
  410 â”‚     console.error('Erro ao atualizar quarto:', error)
  411 â”‚     throw error
  412 â”‚   }
  413 â”‚ }
  414 â”‚ 
  415 â”‚ export const deleteRoom = async (id: string): Promise<boolean> => {
  416 â”‚   return await deleteDocument('rooms', id)
  417 â”‚ }
  418 â”‚ 
  419 â”‚ // FunÃ§Ãµes especÃ­ficas para reservas
  420 â”‚ export const createBooking = async (bookingData: any) => {
  421 â”‚   try {
  422 â”‚     const bookingsCollection = collection(db, 'bookings');
  423 â”‚     const docRef = await addDoc(bookingsCollection, bookingData);
  424 â”‚     
  425 â”‚     // CORREÃ‡ÃƒO: NÃ£o bloquear a data no momento da criaÃ§Ã£o da reserva
  426 â”‚     // O bloqueio serÃ¡ feito apenas quando o pagamento for confirmado
  427 â”‚     // atravÃ©s da funÃ§Ã£o updateBookingStatus
  428 â”‚     
  429 â”‚     return docRef;
  430 â”‚   } catch (error) {
  431 â”‚     console.error('Erro ao criar reserva:', error);
  432 â”‚     throw error;
  433 â”‚   }
  434 â”‚ };
  435 â”‚ 
  436 â”‚ // Nova funÃ§Ã£o para atualizar status da reserva e bloquear as datas da estadia
  437 â”‚ export const updateBookingStatus = async (
  438 â”‚   bookingId: string, 
  439 â”‚   newStatus: 'pending' | 'confirmed' | 'cancelled' | 'completed',
  440 â”‚   newPaymentStatus: 'pending' | 'paid' | 'refunded'
  441 â”‚ ): Promise<boolean> => {
  442 â”‚   try {
  443 â”‚     // ReferÃªncia ao documento da reserva
  444 â”‚     const bookingRef = doc(db, 'bookings', bookingId);
  445 â”‚     const bookingSnap = await getDoc(bookingRef);
  446 â”‚     
  447 â”‚     if (!bookingSnap.exists()) {
  448 â”‚       console.error(`Booking ${bookingId} nÃ£o existe ao atualizar status`);
  449 â”‚       return false;
  450 â”‚     }
  451 â”‚     
  452 â”‚     const bookingData = bookingSnap.data();
  453 â”‚     
  454 â”‚     // Atualizar o status da reserva
  455 â”‚     await updateDoc(bookingRef, {
  456 â”‚       status: newStatus,
  457 â”‚       paymentStatus: newPaymentStatus,
  458 â”‚       updatedAt: serverTimestamp(),
  459 â”‚       ...(newStatus === 'confirmed' && { confirmedAt: serverTimestamp() })
  460 â”‚     });
  461 â”‚     
  462 â”‚     // Se a reserva estÃ¡ sendo confirmada, precisamos bloquear as datas
  463 â”‚     if (newStatus === 'confirmed') {
  464 â”‚       console.log(`Atualizando disponibilidade para reserva confirmada: ${bookingId}`);
  465 â”‚       
  466 â”‚       // Recuperar datas de check-in e check-out
  467 â”‚       const checkIn = bookingData.checkIn.toDate();
  468 â”‚       const checkOut = bookingData.checkOut.toDate();
  469 â”‚       const roomId = bookingData.roomId;
  470 â”‚       
  471 â”‚       // Obter todas as datas entre check-in e check-out
  472 â”‚       const dates: Date[] = [];
  473 â”‚       const currentDate = new Date(checkIn);
  474 â”‚       
  475 â”‚       while (currentDate < checkOut) {
  476 â”‚         dates.push(new Date(currentDate));
  477 â”‚         currentDate.setDate(currentDate.getDate() + 1);
  478 â”‚       }
  479 â”‚       
  480 â”‚       console.log(`Bloqueando ${dates.length} dias para quarto ${roomId}`);
  481 â”‚       
  482 â”‚       // Atualizar disponibilidade para cada data
  483 â”‚       const availabilityUpdates: {[date: string]: boolean} = {};
  484 â”‚       
  485 â”‚       dates.forEach(date => {
  486 â”‚         const dateString = date.toISOString().split('T')[0]; // formato YYYY-MM-DD
  487 â”‚         availabilityUpdates[dateString] = false; // false significa indisponÃ­vel
  488 â”‚       });
  489 â”‚       
  490 â”‚       // Atualizar disponibilidade do quarto
  491 â”‚       if (Object.keys(availabilityUpdates).length > 0) {
  492 â”‚         try {
  493 â”‚           // Obter o documento do quarto
  494 â”‚           const roomRef = doc(db, 'rooms', roomId);
  495 â”‚           const roomSnap = await getDoc(roomRef);
  496 â”‚           
  497 â”‚           if (roomSnap.exists()) {
  498 â”‚             const roomData = roomSnap.data();
  499 â”‚             const currentAvailability = roomData.availabilityDates || {};
  500 â”‚             
  501 â”‚             // Mesclar a disponibilidade atual com as novas atualizaÃ§Ãµes
  502 â”‚             const updatedAvailability = {
  503 â”‚               ...currentAvailability,
  504 â”‚               ...availabilityUpdates
  505 â”‚             };
  506 â”‚             
  507 â”‚             // Atualizar o documento do quarto
  508 â”‚             await updateDoc(roomRef, {
  509 â”‚               availabilityDates: updatedAvailability,
  510 â”‚               updatedAt: serverTimestamp()
  511 â”‚             });
  512 â”‚             
  513 â”‚             console.log(`Disponibilidade atualizada com sucesso para quarto ${roomId}`);
  514 â”‚             
  515 â”‚             // Criar log da reserva
  516 â”‚             await addDoc(collection(db, 'bookingLogs'), {
  517 â”‚               bookingId,
  518 â”‚               roomId,
  519 â”‚               action: 'status_updated',
  520 â”‚               previousStatus: bookingData.status,
  521 â”‚               newStatus,
  522 â”‚               previousPaymentStatus: bookingData.paymentStatus,
  523 â”‚               newPaymentStatus,
  524 â”‚               datesBlocked: Object.keys(availabilityUpdates),
  525 â”‚               timestamp: serverTimestamp(),
  526 â”‚               userId: bookingData.userId || 'system'
  527 â”‚             });
  528 â”‚           } else {
  529 â”‚             console.error(`Quarto ${roomId} nÃ£o encontrado ao atualizar disponibilidade`);
  530 â”‚           }
  531 â”‚         } catch (error) {
  532 â”‚           console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  533 â”‚         }
  534 â”‚       }
  535 â”‚     }
  536 â”‚     
  537 â”‚     return true;
  538 â”‚   } catch (error) {
  539 â”‚     console.error(`Erro ao atualizar status da reserva ${bookingId}:`, error);
  540 â”‚     return false;
  541 â”‚   }
  542 â”‚ }
  543 â”‚ 
  544 â”‚ export const getUserBookings = async (userId: string): Promise<Booking[]> => {
  545 â”‚   return getDocuments<Booking>('bookings', [
  546 â”‚     where('userId', '==', userId),
  547 â”‚     orderBy('createdAt', 'desc')
  548 â”‚   ])
  549 â”‚ }
  550 â”‚ 
  551 â”‚ export const getRecentBookings = async (count = 5): Promise<Booking[]> => {
  552 â”‚   return getDocuments<Booking>('bookings', [
  553 â”‚     orderBy('createdAt', 'desc'),
  554 â”‚     limit(count)
  555 â”‚   ])
  556 â”‚ }
  557 â”‚ 
  558 â”‚ export const getRoomBookings = async (roomId: string): Promise<Booking[]> => {
  559 â”‚   try {
  560 â”‚     const constraints: QueryConstraint[] = [
  561 â”‚       where('roomId', '==', roomId),
  562 â”‚       orderBy('checkIn', 'asc')
  563 â”‚     ];
  564 â”‚     
  565 â”‚     return await getDocuments<Booking>('bookings', constraints);
  566 â”‚   } catch (error) {
  567 â”‚     console.error(`Erro ao buscar reservas do quarto ${roomId}:`, error);
  568 â”‚     return [];
  569 â”‚   }
  570 â”‚ };
  571 â”‚ 
  572 â”‚ // FunÃ§Ãµes especÃ­ficas para contatos
  573 â”‚ export const createContactMessage = async (contactData: Contact) => {
  574 â”‚   try {
  575 â”‚     const contactsCollection = collection(db, 'contacts')
  576 â”‚     
  577 â”‚     // Garantir que o status seja 'new' para novos contatos
  578 â”‚     const contactWithDefaults = {
  579 â”‚       ...contactData,
  580 â”‚       status: contactData.status || 'new',
  581 â”‚       createdAt: contactData.createdAt || Timestamp.now()
  582 â”‚     }
  583 â”‚     
  584 â”‚     // Se tiver detalhes de reserva, adicionar metadados
  585 â”‚     if (contactWithDefaults.reservationDetails) {
  586 â”‚       // Ajustar subject para indicar que Ã© relacionado a reserva
  587 â”‚       if (!contactWithDefaults.subject.includes('Reserva')) {
  588 â”‚         contactWithDefaults.subject = `Reserva: ${contactWithDefaults.subject}`;
  589 â”‚       }
  590 â”‚     }
  591 â”‚     
  592 â”‚     const docRef = await addDoc(contactsCollection, contactWithDefaults)
  593 â”‚     return docRef
  594 â”‚   } catch (error) {
  595 â”‚     console.error('Erro ao criar mensagem de contato:', error)
  596 â”‚     throw error
  597 â”‚   }
  598 â”‚ }
  599 â”‚ 
  600 â”‚ export const getNewContactMessages = async (): Promise<Contact[]> => {
  601 â”‚   return getDocuments<Contact>('contacts', [
  602 â”‚     where('status', '==', 'new'),
  603 â”‚     orderBy('createdAt', 'desc')
  604 â”‚   ])
  605 â”‚ }
  606 â”‚ 
  607 â”‚ // FunÃ§Ãµes para Dashboard com dados reais
  608 â”‚ 
  609 â”‚ export const getDashboardStats = async () => {
  610 â”‚   try {
  611 â”‚     const [totalBookings, totalRevenue, occupancyRate, bookingsByPlatform] = await Promise.all([
  612 â”‚       getTotalBookings(),
  613 â”‚       getMonthlyRevenue(),
  614 â”‚       getOccupancyRate(),
  615 â”‚       getBookingsByPlatform()
  616 â”‚     ]);
  617 â”‚ 
  618 â”‚     return {
  619 â”‚       totalBookings,
  620 â”‚       totalRevenue,
  621 â”‚       occupancyRate,
  622 â”‚       bookingsByPlatform
  623 â”‚     };
  624 â”‚   } catch (error) {
  625 â”‚     console.error('Erro ao obter estatÃ­sticas do dashboard:', error);
  626 â”‚     throw error;
  627 â”‚   }
  628 â”‚ };
  629 â”‚ 
  630 â”‚ // Obter total de reservas
  631 â”‚ export const getTotalBookings = async () => {
  632 â”‚   try {
  633 â”‚     // Obter todas as reservas
  634 â”‚     const bookings = await getDocuments<Booking>('bookings');
  635 â”‚     
  636 â”‚     // Contar reservas por status
  637 â”‚     const confirmed = bookings.filter(b => b.status === 'confirmed').length;
  638 â”‚     const pending = bookings.filter(b => b.status === 'pending').length;
  639 â”‚     const cancelled = bookings.filter(b => b.status === 'cancelled').length;
  640 â”‚     const completed = bookings.filter(b => b.status === 'completed').length;
  641 â”‚     
  642 â”‚     // Calcular crescimento em relaÃ§Ã£o ao mÃªs anterior (simulado por enquanto)
  643 â”‚     // Em uma implementaÃ§Ã£o real, vocÃª compararia com dados do mÃªs anterior
  644 â”‚     const growth = ((confirmed + completed) / (bookings.length || 1) * 100) - 50;
  645 â”‚     
  646 â”‚     return {
  647 â”‚       total: bookings.length,
  648 â”‚       confirmed,
  649 â”‚       pending,
  650 â”‚       cancelled,
  651 â”‚       completed,
  652 â”‚       growth: Math.round(growth) // Arredonda para nÃºmero inteiro
  653 â”‚     };
  654 â”‚   } catch (error) {
  655 â”‚     console.error('Erro ao obter total de reservas:', error);
  656 â”‚     return {
  657 â”‚       total: 0,
  658 â”‚       confirmed: 0,
  659 â”‚       pending: 0, 
  660 â”‚       cancelled: 0,
  661 â”‚       completed: 0,
  662 â”‚       growth: 0
  663 â”‚     };
  664 â”‚   }
  665 â”‚ };
  666 â”‚ 
  667 â”‚ // Obter receita mensal
  668 â”‚ export const getMonthlyRevenue = async () => {
  669 â”‚   try {
  670 â”‚     const bookings = await getDocuments<Booking>('bookings');
  671 â”‚     
  672 â”‚     // Filtrar reservas confirmadas e concluÃ­das
  673 â”‚     const validBookings = bookings.filter(b => 
  674 â”‚       b.status === 'confirmed' || b.status === 'completed'
  675 â”‚     );
  676 â”‚     
  677 â”‚     // Calcular receita total
  678 â”‚     const totalRevenue = validBookings.reduce((acc, booking) => acc + booking.totalPrice, 0);
  679 â”‚     
  680 â”‚     // Agrupar receita por mÃªs
  681 â”‚     const revenueByMonth = validBookings.reduce((acc, booking) => {
  682 â”‚       const date = booking.checkIn.toDate();
  683 â”‚       const month = date.getMonth(); // 0-11
  684 â”‚       const year = date.getFullYear();
  685 â”‚       const key = `${year}-${month}`;
  686 â”‚       
  687 â”‚       if (!acc[key]) {
  688 â”‚         acc[key] = 0;
  689 â”‚       }
  690 â”‚       acc[key] += booking.totalPrice;
  691 â”‚       return acc;
  692 â”‚     }, {} as Record<string, number>);
  693 â”‚     
  694 â”‚     // Converter para formato de array para grÃ¡fico
  695 â”‚     const monthNames = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
  696 â”‚     
  697 â”‚     const currentDate = new Date();
  698 â”‚     const currentMonth = currentDate.getMonth();
  699 â”‚     const currentYear = currentDate.getFullYear();
  700 â”‚     
  701 â”‚     const revenueData = [];
  702 â”‚     
  703 â”‚     // Gerar dados dos Ãºltimos 12 meses
  704 â”‚     for (let i = 0; i < 12; i++) {
  705 â”‚       const month = (currentMonth - i + 12) % 12;
  706 â”‚       const year = currentMonth - i < 0 ? currentYear - 1 : currentYear;
  707 â”‚       const key = `${year}-${month}`;
  708 â”‚       
  709 â”‚       revenueData.unshift({
  710 â”‚         month: monthNames[month],
  711 â”‚         value: revenueByMonth[key] || 0
  712 â”‚       });
  713 â”‚     }
  714 â”‚     
  715 â”‚     // Calcular crescimento em relaÃ§Ã£o ao mÃªs anterior
  716 â”‚     const lastMonthRevenue = revenueData[revenueData.length - 2]?.value || 0;
  717 â”‚     const currentMonthRevenue = revenueData[revenueData.length - 1]?.value || 0;
  718 â”‚     
  719 â”‚     const growth = lastMonthRevenue ? ((currentMonthRevenue - lastMonthRevenue) / lastMonthRevenue) * 100 : 0;
  720 â”‚     
  721 â”‚     return {
  722 â”‚       monthly: currentMonthRevenue,
  723 â”‚       total: totalRevenue,
  724 â”‚       growth: Math.round(growth),
  725 â”‚       revenueData
  726 â”‚     };
  727 â”‚   } catch (error) {
  728 â”‚     console.error('Erro ao obter receita mensal:', error);
  729 â”‚     return {
  730 â”‚       monthly: 0,
  731 â”‚       total: 0,
  732 â”‚       growth: 0,
  733 â”‚       revenueData: []
  734 â”‚     };
  735 â”‚   }
  736 â”‚ };
  737 â”‚ 
  738 â”‚ // Calcular taxa de ocupaÃ§Ã£o
  739 â”‚ export const getOccupancyRate = async () => {
  740 â”‚   try {
  741 â”‚     // Obter todos os quartos
  742 â”‚     const rooms = await getDocuments<Room>('rooms');
  743 â”‚     const totalRooms = rooms.length;
  744 â”‚     
  745 â”‚     if (totalRooms === 0) {
  746 â”‚       return { rate: 0, growth: 0 };
  747 â”‚     }
  748 â”‚     
  749 â”‚     // Obter todas as reservas
  750 â”‚     const bookings = await getDocuments<Booking>('bookings');
  751 â”‚     
  752 â”‚     // Filtrar reservas confirmadas e concluÃ­das para o mÃªs atual
  753 â”‚     const currentDate = new Date();
  754 â”‚     const currentMonth = currentDate.getMonth();
  755 â”‚     const currentYear = currentDate.getFullYear();
  756 â”‚     
  757 â”‚     const currentMonthBookings = bookings.filter(booking => {
  758 â”‚       const checkInDate = booking.checkIn.toDate();
  759 â”‚       return (
  760 â”‚         (booking.status === 'confirmed' || booking.status === 'completed') &&
  761 â”‚         checkInDate.getMonth() === currentMonth &&
  762 â”‚         checkInDate.getFullYear() === currentYear
  763 â”‚       );
  764 â”‚     });
  765 â”‚     
  766 â”‚     // Calcular dias ocupados por quarto
  767 â”‚     const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
  768 â”‚     const totalPossibleRoomDays = totalRooms * daysInMonth;
  769 â”‚     
  770 â”‚     // Contar dias ocupados (simplificado - em produÃ§Ã£o seria mais complexo)
  771 â”‚     let occupiedDays = 0;
  772 â”‚     
  773 â”‚     currentMonthBookings.forEach(booking => {
  774 â”‚       const checkIn = booking.checkIn.toDate();
  775 â”‚       const checkOut = booking.checkOut.toDate();
  776 â”‚       
  777 â”‚       // Ajustar datas para considerar apenas o mÃªs atual
  778 â”‚       const startDate = new Date(Math.max(
  779 â”‚         checkIn.getTime(),
  780 â”‚         new Date(currentYear, currentMonth, 1).getTime()
  781 â”‚       ));
  782 â”‚       const endDate = new Date(Math.min(
  783 â”‚         checkOut.getTime(),
  784 â”‚         new Date(currentYear, currentMonth + 1, 0).getTime()
  785 â”‚       ));
  786 â”‚       
  787 â”‚       // Calcular dias entre datas (incluindo check-in, excluindo check-out)
  788 â”‚       const days = Math.max(0, Math.floor((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)));
  789 â”‚       occupiedDays += days;
  790 â”‚     });
  791 â”‚     
  792 â”‚     const occupancyRate = (occupiedDays / totalPossibleRoomDays) * 100;
  793 â”‚     
  794 â”‚     // SimulaÃ§Ã£o de crescimento (em produÃ§Ã£o, compararia com mÃªs anterior)
  795 â”‚     const growth = occupancyRate > 50 ? 5 : -3;
  796 â”‚     
  797 â”‚     return {
  798 â”‚       rate: Math.round(occupancyRate),
  799 â”‚       growth: Math.round(growth)
  800 â”‚     };
  801 â”‚   } catch (error) {
  802 â”‚     console.error('Erro ao calcular taxa de ocupaÃ§Ã£o:', error);
  803 â”‚     return { rate: 0, growth: 0 };
  804 â”‚   }
  805 â”‚ };
  806 â”‚ 
  807 â”‚ // Obter reservas agrupadas por plataforma
  808 â”‚ export const getBookingsByPlatform = async () => {
  809 â”‚   try {
  810 â”‚     const bookings = await getDocuments<Booking>('bookings');
  811 â”‚     
  812 â”‚     // Categorizar reservas por origem
  813 â”‚     const platforms = [
  814 â”‚       { 
  815 â”‚         platform: "Booking.com", 
  816 â”‚         color: "#003580", 
  817 â”‚         icon: "Globe",
  818 â”‚         bookings: []
  819 â”‚       },
  820 â”‚       { 
  821 â”‚         platform: "Airbnb", 
  822 â”‚         color: "#FF5A5F", 
  823 â”‚         icon: "Heart",
  824 â”‚         bookings: []
  825 â”‚       },
  826 â”‚       { 
  827 â”‚         platform: "Direto", 
  828 â”‚         color: "#4CAF50", 
  829 â”‚         icon: "Home",
  830 â”‚         bookings: []
  831 â”‚       }
  832 â”‚     ];
  833 â”‚     
  834 â”‚     // Para fins de demonstraÃ§Ã£o, colocar todas as reservas como "Direto" por enquanto
  835 â”‚     // Em produÃ§Ã£o, usaria um campo "platformOrigin" ou similar na tabela de reservas
  836 â”‚     const platformIndex = 2; // Ãndice da plataforma "Direto"
  837 â”‚     
  838 â”‚     bookings.forEach(booking => {
  839 â”‚       // Transformar para o formato esperado pelo componente
  840 â”‚       const transformedBooking = {
  841 â”‚         id: booking.id || '',
  842 â”‚         guestName: booking.guestName,
  843 â”‚         roomName: booking.roomName,
  844 â”‚         checkIn: booking.checkIn.toDate().toLocaleDateString('pt-PT'),
  845 â”‚         checkOut: booking.checkOut.toDate().toLocaleDateString('pt-PT'),
  846 â”‚         status: booking.status,
  847 â”‚         value: new Intl.NumberFormat('pt-PT', {
  848 â”‚           style: 'currency',
  849 â”‚           currency: 'EUR'
  850 â”‚         }).format(booking.totalPrice)
  851 â”‚       };
  852 â”‚       
  853 â”‚       // Adicionar Ã  plataforma "Direto"
  854 â”‚       (platforms[platformIndex] as any).bookings.push(transformedBooking);
  855 â”‚     });
  856 â”‚     
  857 â”‚     return platforms;
  858 â”‚   } catch (error) {
  859 â”‚     console.error('Erro ao obter reservas por plataforma:', error);
  860 â”‚     return [];
  861 â”‚   }
  862 â”‚ };
  863 â”‚ 
  864 â”‚ // FunÃ§Ã£o para obter o preÃ§o de um quarto para uma data especÃ­fica
  865 â”‚ export const getRoomPriceForDate = async (roomId: string, date: Date): Promise<number> => {
  866 â”‚   try {
  867 â”‚     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  868 â”‚     
  869 â”‚     if (!roomDoc.exists()) {
  870 â”‚       throw new Error("Quarto nÃ£o encontrado");
  871 â”‚     }
  872 â”‚     
  873 â”‚     const roomData = roomDoc.data() as Room;
  874 â”‚     const basePrice = roomData.price;
  875 â”‚     
  876 â”‚     if (!roomData.seasonalPrices || roomData.seasonalPrices.length === 0) {
  877 â”‚       return basePrice;
  878 â”‚     }
  879 â”‚     
  880 â”‚     // Verificar se a data estÃ¡ dentro de algum perÃ­odo sazonal
  881 â”‚     for (const seasonalPrice of roomData.seasonalPrices) {
  882 â”‚       const startDate = new Date(seasonalPrice.startDate);
  883 â”‚       const endDate = new Date(seasonalPrice.endDate);
  884 â”‚       
  885 â”‚       if (date >= startDate && date <= endDate) {
  886 â”‚         return seasonalPrice.price;
  887 â”‚       }
  888 â”‚     }
  889 â”‚     
  890 â”‚     // Se nÃ£o cair em nenhum perÃ­odo sazonal, retorna o preÃ§o base
  891 â”‚     return basePrice;
  892 â”‚   } catch (error) {
  893 â”‚     console.error("Erro ao obter preÃ§o do quarto:", error);
  894 â”‚     throw error;
  895 â”‚   }
  896 â”‚ }
  897 â”‚ 
  898 â”‚ // FunÃ§Ã£o para calcular o preÃ§o total de uma estadia
  899 â”‚ export const calculateStayPrice = async (
  900 â”‚   roomId: string, 
  901 â”‚   checkIn: Date, 
  902 â”‚   checkOut: Date
  903 â”‚ ): Promise<{
  904 â”‚   totalPrice: number;
  905 â”‚   nightlyPrices: { date: string; price: number }[];
  906 â”‚   serviceFee: number;
  907 â”‚   totalWithFee: number;
  908 â”‚ }> => {
  909 â”‚   try {
  910 â”‚     console.log(`ğŸ” Iniciando cÃ¡lculo de preÃ§o para estadia: ${checkIn.toISOString().split('T')[0]} atÃ© ${checkOut.toISOString().split('T')[0]}`);
  911 â”‚     
  912 â”‚     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  913 â”‚     
  914 â”‚     if (!roomDoc.exists()) {
  915 â”‚       throw new Error("Quarto nÃ£o encontrado");
  916 â”‚     }
  917 â”‚     
  918 â”‚     const roomData = roomDoc.data() as Room;
  919 â”‚     console.log(`ğŸ“ Dados do quarto ${roomId}:`, {
  920 â”‚       nome: roomData.name,
  921 â”‚       precoBase: roomData.price,
  922 â”‚       taxaServico: roomData.serviceFeePct || 0,
  923 â”‚       temPrecosSazonais: !!roomData.seasonalPrices?.length
  924 â”‚     });
  925 â”‚     
  926 â”‚     const nightlyPrices: { date: string; price: number }[] = [];
  927 â”‚     let totalPrice = 0;
  928 â”‚     
  929 â”‚     // Calcular o nÃºmero de noites - corrigido para usar o mÃ©todo correto de cÃ¡lculo
  930 â”‚     // O nÃºmero de noites Ã© a diferenÃ§a em dias (estadia = checkout - checkin)
  931 â”‚     const noites = differenceInDays(checkOut, checkIn);
  932 â”‚     console.log(`ğŸ—“ï¸ NÃºmero de noites calculado: ${noites}`);
  933 â”‚     
  934 â”‚     if (noites <= 0) {
  935 â”‚       console.error(`âš ï¸ Erro: nÃºmero de noites invÃ¡lido (${noites})`);
  936 â”‚       throw new Error("Data de check-out deve ser posterior Ã  data de check-in");
  937 â”‚     }
  938 â”‚     
  939 â”‚     // Para cada noite, verificar o preÃ§o aplicÃ¡vel (preÃ§o base ou sazonal)
  940 â”‚     // ComeÃ§amos exatamente do dia de check-in
  941 â”‚     const currentDate = new Date(checkIn);
  942 â”‚     currentDate.setHours(0, 0, 0, 0); // Normalizar para meia-noite
  943 â”‚     
  944 â”‚     // Processamos cada dia de estadia (noite)
  945 â”‚     console.log(`ğŸ“Š Calculando preÃ§os por noite:`);
  946 â”‚     for (let i = 0; i < noites; i++) {
  947 â”‚       // Obtemos o preÃ§o para esta data
  948 â”‚       const dateCopy = new Date(currentDate);
  949 â”‚       const priceForDate = await getRoomPriceForDate(roomId, dateCopy);
  950 â”‚       const dateString = dateCopy.toISOString().split('T')[0]; // YYYY-MM-DD
  951 â”‚       
  952 â”‚       console.log(`   - ${dateString}: â‚¬${priceForDate}`);
  953 â”‚       
  954 â”‚       nightlyPrices.push({
  955 â”‚         date: dateString,
  956 â”‚         price: priceForDate
  957 â”‚       });
  958 â”‚       
  959 â”‚       totalPrice += priceForDate;
  960 â”‚       
  961 â”‚       // AvanÃ§amos para o prÃ³ximo dia
  962 â”‚       currentDate.setDate(currentDate.getDate() + 1);
  963 â”‚     }
  964 â”‚     
  965 â”‚     // VerificaÃ§Ã£o de seguranÃ§a para o cÃ¡lculo do totalPrice
  966 â”‚     const manualTotal = nightlyPrices.reduce((sum, night) => sum + night.price, 0);
  967 â”‚     if (Math.abs(totalPrice - manualTotal) > 1) {
  968 â”‚       console.error(`âš ï¸ DiscrepÃ¢ncia detectada no cÃ¡lculo do preÃ§o total!`);
  969 â”‚       console.error(`   - Total calculado iterativamente: â‚¬${totalPrice}`);
  970 â”‚       console.error(`   - Total calculado via reduce: â‚¬${manualTotal}`);
  971 â”‚       console.error(`   - Usando o valor recalculado para seguranÃ§a!`);
  972 â”‚       totalPrice = manualTotal;
  973 â”‚     }
  974 â”‚     
  975 â”‚     // Calcular taxa de serviÃ§o
  976 â”‚     const serviceFee = (totalPrice * (roomData.serviceFeePct || 0)) / 100;
  977 â”‚     const totalWithFee = totalPrice + serviceFee;
  978 â”‚     
  979 â”‚     console.log(`ğŸ’° Resumo do cÃ¡lculo:`);
  980 â”‚     console.log(`   - Total das diÃ¡rias: â‚¬${totalPrice}`);
  981 â”‚     console.log(`   - Taxa de serviÃ§o (${roomData.serviceFeePct || 0}%): â‚¬${serviceFee}`);
  982 â”‚     console.log(`   - Total com taxas: â‚¬${totalWithFee}`);
  983 â”‚     
  984 â”‚     return {
  985 â”‚       totalPrice,
  986 â”‚       nightlyPrices,
  987 â”‚       serviceFee,
  988 â”‚       totalWithFee
  989 â”‚     };
  990 â”‚   } catch (error) {
  991 â”‚     console.error("âŒ Erro ao calcular preÃ§o da estadia:", error);
  992 â”‚     throw error;
  993 â”‚   }
  994 â”‚ } 
  995 â”‚ import { 
  996 â”‚   collection, 
  997 â”‚   getDocs, 
  998 â”‚   getDoc, 
  999 â”‚   doc, 
 1000 â”‚   setDoc, 
 1001 â”‚   addDoc, 
 1002 â”‚   updateDoc, 
 1003 â”‚   deleteDoc,
 1004 â”‚   query,
 1005 â”‚   where,
 1006 â”‚   orderBy,
 1007 â”‚   limit,
 1008 â”‚   serverTimestamp
 1009 â”‚ } from 'firebase/firestore';
 1010 â”‚ import { db } from './config';
      Â·          â”€â”¬
      Â·           â•°â”€â”€ `db` redefined here
 1011 â”‚ 
 1012 â”‚ // Get all documents from a collection
 1013 â”‚ export async function getDocuments<T>(collectionName: string, forceRefresh = false): Promise<T[]> {
      â•°â”€â”€â”€â”€

  Ã— the name `getDocuments` is defined multiple times
      â•­â”€[/home/runner/workspace/lib/firebase/firestore.ts:112:1]
  112 â”‚   }
  113 â”‚ }
  114 â”‚ 
  115 â”‚ export const getDocuments = async <T>(
      Â·              â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€
      Â·                    â•°â”€â”€ previous definition of `getDocuments` here
  116 â”‚   collectionName: string,
  117 â”‚   constraints: QueryConstraint[] = [],
  118 â”‚   forceRefresh = false
  119 â”‚ ): Promise<T[]> => {
  120 â”‚   try {
  121 â”‚     const collectionRef = collection(db, collectionName)
  122 â”‚     const q = query(collectionRef, ...constraints)
  123 â”‚     
  124 â”‚     // Se forceRefresh for verdadeiro, adicionar opÃ§Ãµes que forÃ§am uma nova consulta ao Firestore
  125 â”‚     const querySnapshot = await getDocs(q)
  126 â”‚     
  127 â”‚     console.log(`Buscando documentos na coleÃ§Ã£o ${collectionName} - ForÃ§a atualizaÃ§Ã£o: ${forceRefresh}`);
  128 â”‚     
  129 â”‚     return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }) as T)
  130 â”‚   } catch (error) {
  131 â”‚     console.error(`Erro ao buscar documentos da coleÃ§Ã£o ${collectionName}:`, error);
  132 â”‚     return [];
  133 â”‚   }
  134 â”‚ }
  135 â”‚ 
  136 â”‚ export const updateDocument = async <T extends DocumentData>(
  137 â”‚   collectionName: string,
  138 â”‚   id: string,
  139 â”‚   data: Partial<T>
  140 â”‚ ): Promise<void> => {
  141 â”‚   const docRef = doc(db, collectionName, id)
  142 â”‚   await updateDoc(docRef, {
  143 â”‚     ...data,
  144 â”‚     updatedAt: serverTimestamp()
  145 â”‚   })
  146 â”‚ }
  147 â”‚ 
  148 â”‚ export const deleteDocument = async (
  149 â”‚   collectionName: string,
  150 â”‚   id: string
  151 â”‚ ): Promise<boolean> => {
  152 â”‚   const docRef = doc(db, collectionName, id)
  153 â”‚   await deleteDoc(docRef)
  154 â”‚   return true
  155 â”‚ }
  156 â”‚ 
  157 â”‚ // FunÃ§Ãµes para gerenciar quartos
  158 â”‚ export const getRooms = async (forceRefresh = false): Promise<Room[]> => {
  159 â”‚   try {
  160 â”‚     const constraints: QueryConstraint[] = []
  161 â”‚     
  162 â”‚     constraints.push(orderBy('name', 'asc'))
  163 â”‚     
  164 â”‚     const rooms = await getDocuments<Room>('rooms', constraints, forceRefresh)
  165 â”‚     
  166 â”‚     // Garantir que todos os campos necessÃ¡rios estejam presentes
  167 â”‚     return rooms.map(room => {
  168 â”‚       console.log(`Firebase - Quarto ${room.id} dados brutos:`, room);
  169 â”‚       
  170 â”‚       // Garantir que serviceFeePct seja um nÃºmero
  171 â”‚       const serviceFeePct = room.serviceFeePct !== undefined 
  172 â”‚         ? Number(room.serviceFeePct) 
  173 â”‚         : 10;
  174 â”‚         
  175 â”‚       console.log(`Firebase - Quarto ${room.id} serviceFeePct:`, {
  176 â”‚         original: room.serviceFeePct,
  177 â”‚         tipo: typeof room.serviceFeePct,
  178 â”‚         convertido: serviceFeePct
  179 â”‚       });
  180 â”‚       
  181 â”‚       return {
  182 â”‚         id: room.id,
  183 â”‚         name: room.name || '',
  184 â”‚         type: room.type || 'standard',
  185 â”‚         description: room.description || '',
  186 â”‚         price: room.price || 0,
  187 â”‚         capacity: room.capacity || 2,
  188 â”‚         size: room.size || 0,
  189 â”‚         available: room.available !== undefined ? room.available : true,
  190 â”‚         serviceFeePct: serviceFeePct,
  191 â”‚         images: room.images || [],
  192 â”‚         amenities: room.amenities || [],
  193 â”‚         additionalServices: room.additionalServices || [],
  194 â”‚         highlights: room.highlights || [],
  195 â”‚         createdAt: room.createdAt,
  196 â”‚         updatedAt: room.updatedAt
  197 â”‚       };
  198 â”‚     });
  199 â”‚   } catch (error) {
  200 â”‚     console.error('Erro ao buscar quartos:', error)
  201 â”‚     return []
  202 â”‚   }
  203 â”‚ }
  204 â”‚ 
  205 â”‚ export const getAvailableRooms = async (
  206 â”‚   checkIn: Date,
  207 â”‚   checkOut: Date
  208 â”‚ ): Promise<Room[]> => {
  209 â”‚   try {
  210 â”‚     // Buscar todos os quartos que estÃ£o marcados como disponÃ­veis em geral
  211 â”‚     const constraints: QueryConstraint[] = [
  212 â”‚       where('available', '==', true)
  213 â”‚     ]
  214 â”‚     
  215 â”‚     const rooms = await getDocuments<Room>('rooms', constraints);
  216 â”‚     
  217 â”‚     // Filtrar os quartos que estÃ£o disponÃ­veis nas datas especÃ­ficas
  218 â”‚     return filterAvailableRoomsByDate(rooms, checkIn, checkOut);
  219 â”‚   } catch (error) {
  220 â”‚     console.error('Erro ao buscar quartos disponÃ­veis:', error)
  221 â”‚     return []
  222 â”‚   }
  223 â”‚ }
  224 â”‚ 
  225 â”‚ // FunÃ§Ã£o auxiliar para verificar disponibilidade entre datas
  226 â”‚ export const filterAvailableRoomsByDate = (
  227 â”‚   rooms: Room[],
  228 â”‚   checkIn: Date,
  229 â”‚   checkOut: Date
  230 â”‚ ): Room[] => {
  231 â”‚   // Converter checkIn e checkOut para ISO strings
  232 â”‚   const dateStrings = getDatesInRange(checkIn, checkOut);
  233 â”‚   
  234 â”‚   return rooms.filter(room => {
  235 â”‚     // Se nÃ£o tiver controle de disponibilidade especÃ­fico, considera disponÃ­vel
  236 â”‚     if (!room.availabilityDates) return true;
  237 â”‚     
  238 â”‚     // Verificar se alguma data no intervalo estÃ¡ indisponÃ­vel
  239 â”‚     return !dateStrings.some(dateStr => 
  240 â”‚       room.availabilityDates?.[dateStr] === false
  241 â”‚     );
  242 â”‚   });
  243 â”‚ };
  244 â”‚ 
  245 â”‚ // FunÃ§Ã£o para obter disponibilidade de um quarto especÃ­fico
  246 â”‚ export const getRoomAvailability = async (
  247 â”‚   roomId: string, 
  248 â”‚   startDate: Date, 
  249 â”‚   endDate: Date
  250 â”‚ ): Promise<{[date: string]: boolean}> => {
  251 â”‚   try {
  252 â”‚     const room = await getRoomById(roomId);
  253 â”‚     if (!room) throw new Error(`Quarto com ID ${roomId} nÃ£o encontrado`);
  254 â”‚     
  255 â”‚     // Gerar datas no intervalo
  256 â”‚     const dateStrings = getDatesInRange(startDate, endDate);
  257 â”‚     
  258 â”‚     // Se nÃ£o tiver configuraÃ§Ã£o de disponibilidade especÃ­fica, assume tudo disponÃ­vel
  259 â”‚     if (!room.availabilityDates) {
  260 â”‚       return dateStrings.reduce((acc, date) => {
  261 â”‚         acc[date] = true;
  262 â”‚         return acc;
  263 â”‚       }, {} as {[date: string]: boolean});
  264 â”‚     }
  265 â”‚     
  266 â”‚     // Preencher com os dados de disponibilidade existentes
  267 â”‚     return dateStrings.reduce((acc, date) => {
  268 â”‚       acc[date] = room.availabilityDates?.[date] !== false; // disponÃ­vel por padrÃ£o se nÃ£o estiver explicitamente indisponÃ­vel
  269 â”‚       return acc;
  270 â”‚     }, {} as {[date: string]: boolean});
  271 â”‚   } catch (error) {
  272 â”‚     console.error(`Erro ao verificar disponibilidade do quarto ${roomId}:`, error);
  273 â”‚     throw error;
  274 â”‚   }
  275 â”‚ };
  276 â”‚ 
  277 â”‚ // FunÃ§Ã£o para atualizar disponibilidade de um quarto
  278 â”‚ export const updateRoomAvailability = async (
  279 â”‚   roomId: string,
  280 â”‚   availabilityDates: {[date: string]: boolean}
  281 â”‚ ): Promise<boolean> => {
  282 â”‚   try {
  283 â”‚     await updateDocument('rooms', roomId, {
  284 â”‚       availabilityDates,
  285 â”‚       updatedAt: serverTimestamp()
  286 â”‚     });
  287 â”‚     return true;
  288 â”‚   } catch (error) {
  289 â”‚     console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  290 â”‚     return false;
  291 â”‚   }
  292 â”‚ };
  293 â”‚ 
  294 â”‚ // FunÃ§Ã£o auxiliar para gerar array de strings de data entre um intervalo
  295 â”‚ export const getDatesInRange = (startDate: Date, endDate: Date): string[] => {
  296 â”‚   const dates: string[] = [];
  297 â”‚   const currentDate = new Date(startDate);
  298 â”‚   
  299 â”‚   // Normalizar para meia-noite no fuso horÃ¡rio local
  300 â”‚   currentDate.setHours(0, 0, 0, 0);
  301 â”‚   const endDateNormalized = new Date(endDate);
  302 â”‚   endDateNormalized.setHours(0, 0, 0, 0);
  303 â”‚   
  304 â”‚   // Adicionar cada data no intervalo EXCETO o dia de checkout
  305 â”‚   // Usando < em vez de <= para nÃ£o incluir o dia de checkout
  306 â”‚   while (currentDate < endDateNormalized) {
  307 â”‚     dates.push(currentDate.toISOString().split('T')[0]); // Formato YYYY-MM-DD
  308 â”‚     currentDate.setDate(currentDate.getDate() + 1);
  309 â”‚   }
  310 â”‚   
  311 â”‚   return dates;
  312 â”‚ };
  313 â”‚ 
  314 â”‚ export const getRoomById = async (id: string): Promise<Room | null> => {
  315 â”‚   try {
  316 â”‚     const room = await getDocument<Room>('rooms', id);
  317 â”‚     
  318 â”‚     if (!room) return null;
  319 â”‚     
  320 â”‚     console.log(`Firebase - getRoomById ${id} dados brutos:`, room);
  321 â”‚     
  322 â”‚     // Log especÃ­fico para serviceFeePct
  323 â”‚     console.log(`serviceFeePct no Firestore:`, room.serviceFeePct);
  324 â”‚     
  325 â”‚     // Garantir que todos os campos necessÃ¡rios estejam presentes
  326 â”‚     return {
  327 â”‚       ...room,
  328 â”‚       name: room.name || '',
  329 â”‚       type: room.type || 'standard',
  330 â”‚       description: room.description || '',
  331 â”‚       price: room.price || 0,
  332 â”‚       capacity: room.capacity || 2,
  333 â”‚       size: room.size || 0,
  334 â”‚       available: room.available !== undefined ? room.available : true,
  335 â”‚       serviceFeePct: room.serviceFeePct !== undefined ? room.serviceFeePct : 10,
  336 â”‚       images: room.images || [],
  337 â”‚       amenities: room.amenities || [],
  338 â”‚       additionalServices: room.additionalServices || [],
  339 â”‚       highlights: room.highlights || []
  340 â”‚     };
  341 â”‚   } catch (error) {
  342 â”‚     console.error(`Erro ao buscar quarto com ID ${id}:`, error);
  343 â”‚     return null;
  344 â”‚   }
  345 â”‚ }
  346 â”‚ 
  347 â”‚ export const createRoom = async (roomData: Omit<Room, 'id' | 'createdAt' | 'updatedAt'>): Promise<Room> => {
  348 â”‚   try {
  349 â”‚     console.log("createRoom - Dados recebidos:", roomData);
  350 â”‚     
  351 â”‚     const roomWithTimestamps = {
  352 â”‚       ...roomData,
  353 â”‚       available: roomData.available !== undefined ? roomData.available : true,
  354 â”‚       featured: roomData.featured || false,
  355 â”‚       amenities: roomData.amenities || [],
  356 â”‚       additionalServices: roomData.additionalServices || [],
  357 â”‚       highlights: roomData.highlights || [],
  358 â”‚       createdAt: serverTimestamp(),
  359 â”‚       updatedAt: serverTimestamp()
  360 â”‚     }
  361 â”‚     
  362 â”‚     console.log("createRoom - Dados a serem salvos:", roomWithTimestamps);
  363 â”‚     
  364 â”‚     const id = await createDocument('rooms', roomWithTimestamps)
  365 â”‚     
  366 â”‚     return {
  367 â”‚       id,
  368 â”‚       ...roomData,
  369 â”‚       amenities: roomData.amenities || [],
  370 â”‚       additionalServices: roomData.additionalServices || [],
  371 â”‚       highlights: roomData.highlights || [],
  372 â”‚       createdAt: Timestamp.now(),
  373 â”‚       updatedAt: Timestamp.now()
  374 â”‚     }
  375 â”‚   } catch (error) {
  376 â”‚     console.error('Erro ao criar quarto:', error)
  377 â”‚     throw error
  378 â”‚   }
  379 â”‚ }
  380 â”‚ 
  381 â”‚ export const updateRoom = async (id: string, roomData: Partial<Omit<Room, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Room> => {
  382 â”‚   try {
  383 â”‚     console.log(`updateRoom - ID: ${id}, Dados recebidos:`, roomData);
  384 â”‚     
  385 â”‚     // Garantir que estamos lidando explicitamente com o serviceFeePct se ele for 0
  386 â”‚     if (roomData.serviceFeePct === 0) {
  387 â”‚       console.log("updateRoom - Detectado serviceFeePct com valor 0, salvando explicitamente.", roomData.serviceFeePct);
  388 â”‚     }
  389 â”‚     
  390 â”‚     // Adicionar timestamp de atualizaÃ§Ã£o
  391 â”‚     const roomWithTimestamp = {
  392 â”‚       ...roomData,
  393 â”‚       amenities: roomData.amenities || [],
  394 â”‚       additionalServices: roomData.additionalServices || [],
  395 â”‚       highlights: roomData.highlights || [],
  396 â”‚       updatedAt: serverTimestamp()
  397 â”‚     }
  398 â”‚     
  399 â”‚     console.log(`updateRoom - Dados a serem salvos:`, roomWithTimestamp);
  400 â”‚     
  401 â”‚     await updateDocument('rooms', id, roomWithTimestamp)
  402 â”‚     
  403 â”‚     const updatedRoom = await getRoomById(id)
  404 â”‚     if (!updatedRoom) {
  405 â”‚       throw new Error(`Quarto com ID ${id} nÃ£o encontrado apÃ³s atualizaÃ§Ã£o`)
  406 â”‚     }
  407 â”‚     
  408 â”‚     return updatedRoom
  409 â”‚   } catch (error) {
  410 â”‚     console.error('Erro ao atualizar quarto:', error)
  411 â”‚     throw error
  412 â”‚   }
  413 â”‚ }
  414 â”‚ 
  415 â”‚ export const deleteRoom = async (id: string): Promise<boolean> => {
  416 â”‚   return await deleteDocument('rooms', id)
  417 â”‚ }
  418 â”‚ 
  419 â”‚ // FunÃ§Ãµes especÃ­ficas para reservas
  420 â”‚ export const createBooking = async (bookingData: any) => {
  421 â”‚   try {
  422 â”‚     const bookingsCollection = collection(db, 'bookings');
  423 â”‚     const docRef = await addDoc(bookingsCollection, bookingData);
  424 â”‚     
  425 â”‚     // CORREÃ‡ÃƒO: NÃ£o bloquear a data no momento da criaÃ§Ã£o da reserva
  426 â”‚     // O bloqueio serÃ¡ feito apenas quando o pagamento for confirmado
  427 â”‚     // atravÃ©s da funÃ§Ã£o updateBookingStatus
  428 â”‚     
  429 â”‚     return docRef;
  430 â”‚   } catch (error) {
  431 â”‚     console.error('Erro ao criar reserva:', error);
  432 â”‚     throw error;
  433 â”‚   }
  434 â”‚ };
  435 â”‚ 
  436 â”‚ // Nova funÃ§Ã£o para atualizar status da reserva e bloquear as datas da estadia
  437 â”‚ export const updateBookingStatus = async (
  438 â”‚   bookingId: string, 
  439 â”‚   newStatus: 'pending' | 'confirmed' | 'cancelled' | 'completed',
  440 â”‚   newPaymentStatus: 'pending' | 'paid' | 'refunded'
  441 â”‚ ): Promise<boolean> => {
  442 â”‚   try {
  443 â”‚     // ReferÃªncia ao documento da reserva
  444 â”‚     const bookingRef = doc(db, 'bookings', bookingId);
  445 â”‚     const bookingSnap = await getDoc(bookingRef);
  446 â”‚     
  447 â”‚     if (!bookingSnap.exists()) {
  448 â”‚       console.error(`Booking ${bookingId} nÃ£o existe ao atualizar status`);
  449 â”‚       return false;
  450 â”‚     }
  451 â”‚     
  452 â”‚     const bookingData = bookingSnap.data();
  453 â”‚     
  454 â”‚     // Atualizar o status da reserva
  455 â”‚     await updateDoc(bookingRef, {
  456 â”‚       status: newStatus,
  457 â”‚       paymentStatus: newPaymentStatus,
  458 â”‚       updatedAt: serverTimestamp(),
  459 â”‚       ...(newStatus === 'confirmed' && { confirmedAt: serverTimestamp() })
  460 â”‚     });
  461 â”‚     
  462 â”‚     // Se a reserva estÃ¡ sendo confirmada, precisamos bloquear as datas
  463 â”‚     if (newStatus === 'confirmed') {
  464 â”‚       console.log(`Atualizando disponibilidade para reserva confirmada: ${bookingId}`);
  465 â”‚       
  466 â”‚       // Recuperar datas de check-in e check-out
  467 â”‚       const checkIn = bookingData.checkIn.toDate();
  468 â”‚       const checkOut = bookingData.checkOut.toDate();
  469 â”‚       const roomId = bookingData.roomId;
  470 â”‚       
  471 â”‚       // Obter todas as datas entre check-in e check-out
  472 â”‚       const dates: Date[] = [];
  473 â”‚       const currentDate = new Date(checkIn);
  474 â”‚       
  475 â”‚       while (currentDate < checkOut) {
  476 â”‚         dates.push(new Date(currentDate));
  477 â”‚         currentDate.setDate(currentDate.getDate() + 1);
  478 â”‚       }
  479 â”‚       
  480 â”‚       console.log(`Bloqueando ${dates.length} dias para quarto ${roomId}`);
  481 â”‚       
  482 â”‚       // Atualizar disponibilidade para cada data
  483 â”‚       const availabilityUpdates: {[date: string]: boolean} = {};
  484 â”‚       
  485 â”‚       dates.forEach(date => {
  486 â”‚         const dateString = date.toISOString().split('T')[0]; // formato YYYY-MM-DD
  487 â”‚         availabilityUpdates[dateString] = false; // false significa indisponÃ­vel
  488 â”‚       });
  489 â”‚       
  490 â”‚       // Atualizar disponibilidade do quarto
  491 â”‚       if (Object.keys(availabilityUpdates).length > 0) {
  492 â”‚         try {
  493 â”‚           // Obter o documento do quarto
  494 â”‚           const roomRef = doc(db, 'rooms', roomId);
  495 â”‚           const roomSnap = await getDoc(roomRef);
  496 â”‚           
  497 â”‚           if (roomSnap.exists()) {
  498 â”‚             const roomData = roomSnap.data();
  499 â”‚             const currentAvailability = roomData.availabilityDates || {};
  500 â”‚             
  501 â”‚             // Mesclar a disponibilidade atual com as novas atualizaÃ§Ãµes
  502 â”‚             const updatedAvailability = {
  503 â”‚               ...currentAvailability,
  504 â”‚               ...availabilityUpdates
  505 â”‚             };
  506 â”‚             
  507 â”‚             // Atualizar o documento do quarto
  508 â”‚             await updateDoc(roomRef, {
  509 â”‚               availabilityDates: updatedAvailability,
  510 â”‚               updatedAt: serverTimestamp()
  511 â”‚             });
  512 â”‚             
  513 â”‚             console.log(`Disponibilidade atualizada com sucesso para quarto ${roomId}`);
  514 â”‚             
  515 â”‚             // Criar log da reserva
  516 â”‚             await addDoc(collection(db, 'bookingLogs'), {
  517 â”‚               bookingId,
  518 â”‚               roomId,
  519 â”‚               action: 'status_updated',
  520 â”‚               previousStatus: bookingData.status,
  521 â”‚               newStatus,
  522 â”‚               previousPaymentStatus: bookingData.paymentStatus,
  523 â”‚               newPaymentStatus,
  524 â”‚               datesBlocked: Object.keys(availabilityUpdates),
  525 â”‚               timestamp: serverTimestamp(),
  526 â”‚               userId: bookingData.userId || 'system'
  527 â”‚             });
  528 â”‚           } else {
  529 â”‚             console.error(`Quarto ${roomId} nÃ£o encontrado ao atualizar disponibilidade`);
  530 â”‚           }
  531 â”‚         } catch (error) {
  532 â”‚           console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  533 â”‚         }
  534 â”‚       }
  535 â”‚     }
  536 â”‚     
  537 â”‚     return true;
  538 â”‚   } catch (error) {
  539 â”‚     console.error(`Erro ao atualizar status da reserva ${bookingId}:`, error);
  540 â”‚     return false;
  541 â”‚   }
  542 â”‚ }
  543 â”‚ 
  544 â”‚ export const getUserBookings = async (userId: string): Promise<Booking[]> => {
  545 â”‚   return getDocuments<Booking>('bookings', [
  546 â”‚     where('userId', '==', userId),
  547 â”‚     orderBy('createdAt', 'desc')
  548 â”‚   ])
  549 â”‚ }
  550 â”‚ 
  551 â”‚ export const getRecentBookings = async (count = 5): Promise<Booking[]> => {
  552 â”‚   return getDocuments<Booking>('bookings', [
  553 â”‚     orderBy('createdAt', 'desc'),
  554 â”‚     limit(count)
  555 â”‚   ])
  556 â”‚ }
  557 â”‚ 
  558 â”‚ export const getRoomBookings = async (roomId: string): Promise<Booking[]> => {
  559 â”‚   try {
  560 â”‚     const constraints: QueryConstraint[] = [
  561 â”‚       where('roomId', '==', roomId),
  562 â”‚       orderBy('checkIn', 'asc')
  563 â”‚     ];
  564 â”‚     
  565 â”‚     return await getDocuments<Booking>('bookings', constraints);
  566 â”‚   } catch (error) {
  567 â”‚     console.error(`Erro ao buscar reservas do quarto ${roomId}:`, error);
  568 â”‚     return [];
  569 â”‚   }
  570 â”‚ };
  571 â”‚ 
  572 â”‚ // FunÃ§Ãµes especÃ­ficas para contatos
  573 â”‚ export const createContactMessage = async (contactData: Contact) => {
  574 â”‚   try {
  575 â”‚     const contactsCollection = collection(db, 'contacts')
  576 â”‚     
  577 â”‚     // Garantir que o status seja 'new' para novos contatos
  578 â”‚     const contactWithDefaults = {
  579 â”‚       ...contactData,
  580 â”‚       status: contactData.status || 'new',
  581 â”‚       createdAt: contactData.createdAt || Timestamp.now()
  582 â”‚     }
  583 â”‚     
  584 â”‚     // Se tiver detalhes de reserva, adicionar metadados
  585 â”‚     if (contactWithDefaults.reservationDetails) {
  586 â”‚       // Ajustar subject para indicar que Ã© relacionado a reserva
  587 â”‚       if (!contactWithDefaults.subject.includes('Reserva')) {
  588 â”‚         contactWithDefaults.subject = `Reserva: ${contactWithDefaults.subject}`;
  589 â”‚       }
  590 â”‚     }
  591 â”‚     
  592 â”‚     const docRef = await addDoc(contactsCollection, contactWithDefaults)
  593 â”‚     return docRef
  594 â”‚   } catch (error) {
  595 â”‚     console.error('Erro ao criar mensagem de contato:', error)
  596 â”‚     throw error
  597 â”‚   }
  598 â”‚ }
  599 â”‚ 
  600 â”‚ export const getNewContactMessages = async (): Promise<Contact[]> => {
  601 â”‚   return getDocuments<Contact>('contacts', [
  602 â”‚     where('status', '==', 'new'),
  603 â”‚     orderBy('createdAt', 'desc')
  604 â”‚   ])
  605 â”‚ }
  606 â”‚ 
  607 â”‚ // FunÃ§Ãµes para Dashboard com dados reais
  608 â”‚ 
  609 â”‚ export const getDashboardStats = async () => {
  610 â”‚   try {
  611 â”‚     const [totalBookings, totalRevenue, occupancyRate, bookingsByPlatform] = await Promise.all([
  612 â”‚       getTotalBookings(),
  613 â”‚       getMonthlyRevenue(),
  614 â”‚       getOccupancyRate(),
  615 â”‚       getBookingsByPlatform()
  616 â”‚     ]);
  617 â”‚ 
  618 â”‚     return {
  619 â”‚       totalBookings,
  620 â”‚       totalRevenue,
  621 â”‚       occupancyRate,
  622 â”‚       bookingsByPlatform
  623 â”‚     };
  624 â”‚   } catch (error) {
  625 â”‚     console.error('Erro ao obter estatÃ­sticas do dashboard:', error);
  626 â”‚     throw error;
  627 â”‚   }
  628 â”‚ };
  629 â”‚ 
  630 â”‚ // Obter total de reservas
  631 â”‚ export const getTotalBookings = async () => {
  632 â”‚   try {
  633 â”‚     // Obter todas as reservas
  634 â”‚     const bookings = await getDocuments<Booking>('bookings');
  635 â”‚     
  636 â”‚     // Contar reservas por status
  637 â”‚     const confirmed = bookings.filter(b => b.status === 'confirmed').length;
  638 â”‚     const pending = bookings.filter(b => b.status === 'pending').length;
  639 â”‚     const cancelled = bookings.filter(b => b.status === 'cancelled').length;
  640 â”‚     const completed = bookings.filter(b => b.status === 'completed').length;
  641 â”‚     
  642 â”‚     // Calcular crescimento em relaÃ§Ã£o ao mÃªs anterior (simulado por enquanto)
  643 â”‚     // Em uma implementaÃ§Ã£o real, vocÃª compararia com dados do mÃªs anterior
  644 â”‚     const growth = ((confirmed + completed) / (bookings.length || 1) * 100) - 50;
  645 â”‚     
  646 â”‚     return {
  647 â”‚       total: bookings.length,
  648 â”‚       confirmed,
  649 â”‚       pending,
  650 â”‚       cancelled,
  651 â”‚       completed,
  652 â”‚       growth: Math.round(growth) // Arredonda para nÃºmero inteiro
  653 â”‚     };
  654 â”‚   } catch (error) {
  655 â”‚     console.error('Erro ao obter total de reservas:', error);
  656 â”‚     return {
  657 â”‚       total: 0,
  658 â”‚       confirmed: 0,
  659 â”‚       pending: 0, 
  660 â”‚       cancelled: 0,
  661 â”‚       completed: 0,
  662 â”‚       growth: 0
  663 â”‚     };
  664 â”‚   }
  665 â”‚ };
  666 â”‚ 
  667 â”‚ // Obter receita mensal
  668 â”‚ export const getMonthlyRevenue = async () => {
  669 â”‚   try {
  670 â”‚     const bookings = await getDocuments<Booking>('bookings');
  671 â”‚     
  672 â”‚     // Filtrar reservas confirmadas e concluÃ­das
  673 â”‚     const validBookings = bookings.filter(b => 
  674 â”‚       b.status === 'confirmed' || b.status === 'completed'
  675 â”‚     );
  676 â”‚     
  677 â”‚     // Calcular receita total
  678 â”‚     const totalRevenue = validBookings.reduce((acc, booking) => acc + booking.totalPrice, 0);
  679 â”‚     
  680 â”‚     // Agrupar receita por mÃªs
  681 â”‚     const revenueByMonth = validBookings.reduce((acc, booking) => {
  682 â”‚       const date = booking.checkIn.toDate();
  683 â”‚       const month = date.getMonth(); // 0-11
  684 â”‚       const year = date.getFullYear();
  685 â”‚       const key = `${year}-${month}`;
  686 â”‚       
  687 â”‚       if (!acc[key]) {
  688 â”‚         acc[key] = 0;
  689 â”‚       }
  690 â”‚       acc[key] += booking.totalPrice;
  691 â”‚       return acc;
  692 â”‚     }, {} as Record<string, number>);
  693 â”‚     
  694 â”‚     // Converter para formato de array para grÃ¡fico
  695 â”‚     const monthNames = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
  696 â”‚     
  697 â”‚     const currentDate = new Date();
  698 â”‚     const currentMonth = currentDate.getMonth();
  699 â”‚     const currentYear = currentDate.getFullYear();
  700 â”‚     
  701 â”‚     const revenueData = [];
  702 â”‚     
  703 â”‚     // Gerar dados dos Ãºltimos 12 meses
  704 â”‚     for (let i = 0; i < 12; i++) {
  705 â”‚       const month = (currentMonth - i + 12) % 12;
  706 â”‚       const year = currentMonth - i < 0 ? currentYear - 1 : currentYear;
  707 â”‚       const key = `${year}-${month}`;
  708 â”‚       
  709 â”‚       revenueData.unshift({
  710 â”‚         month: monthNames[month],
  711 â”‚         value: revenueByMonth[key] || 0
  712 â”‚       });
  713 â”‚     }
  714 â”‚     
  715 â”‚     // Calcular crescimento em relaÃ§Ã£o ao mÃªs anterior
  716 â”‚     const lastMonthRevenue = revenueData[revenueData.length - 2]?.value || 0;
  717 â”‚     const currentMonthRevenue = revenueData[revenueData.length - 1]?.value || 0;
  718 â”‚     
  719 â”‚     const growth = lastMonthRevenue ? ((currentMonthRevenue - lastMonthRevenue) / lastMonthRevenue) * 100 : 0;
  720 â”‚     
  721 â”‚     return {
  722 â”‚       monthly: currentMonthRevenue,
  723 â”‚       total: totalRevenue,
  724 â”‚       growth: Math.round(growth),
  725 â”‚       revenueData
  726 â”‚     };
  727 â”‚   } catch (error) {
  728 â”‚     console.error('Erro ao obter receita mensal:', error);
  729 â”‚     return {
  730 â”‚       monthly: 0,
  731 â”‚       total: 0,
  732 â”‚       growth: 0,
  733 â”‚       revenueData: []
  734 â”‚     };
  735 â”‚   }
  736 â”‚ };
  737 â”‚ 
  738 â”‚ // Calcular taxa de ocupaÃ§Ã£o
  739 â”‚ export const getOccupancyRate = async () => {
  740 â”‚   try {
  741 â”‚     // Obter todos os quartos
  742 â”‚     const rooms = await getDocuments<Room>('rooms');
  743 â”‚     const totalRooms = rooms.length;
  744 â”‚     
  745 â”‚     if (totalRooms === 0) {
  746 â”‚       return { rate: 0, growth: 0 };
  747 â”‚     }
  748 â”‚     
  749 â”‚     // Obter todas as reservas
  750 â”‚     const bookings = await getDocuments<Booking>('bookings');
  751 â”‚     
  752 â”‚     // Filtrar reservas confirmadas e concluÃ­das para o mÃªs atual
  753 â”‚     const currentDate = new Date();
  754 â”‚     const currentMonth = currentDate.getMonth();
  755 â”‚     const currentYear = currentDate.getFullYear();
  756 â”‚     
  757 â”‚     const currentMonthBookings = bookings.filter(booking => {
  758 â”‚       const checkInDate = booking.checkIn.toDate();
  759 â”‚       return (
  760 â”‚         (booking.status === 'confirmed' || booking.status === 'completed') &&
  761 â”‚         checkInDate.getMonth() === currentMonth &&
  762 â”‚         checkInDate.getFullYear() === currentYear
  763 â”‚       );
  764 â”‚     });
  765 â”‚     
  766 â”‚     // Calcular dias ocupados por quarto
  767 â”‚     const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
  768 â”‚     const totalPossibleRoomDays = totalRooms * daysInMonth;
  769 â”‚     
  770 â”‚     // Contar dias ocupados (simplificado - em produÃ§Ã£o seria mais complexo)
  771 â”‚     let occupiedDays = 0;
  772 â”‚     
  773 â”‚     currentMonthBookings.forEach(booking => {
  774 â”‚       const checkIn = booking.checkIn.toDate();
  775 â”‚       const checkOut = booking.checkOut.toDate();
  776 â”‚       
  777 â”‚       // Ajustar datas para considerar apenas o mÃªs atual
  778 â”‚       const startDate = new Date(Math.max(
  779 â”‚         checkIn.getTime(),
  780 â”‚         new Date(currentYear, currentMonth, 1).getTime()
  781 â”‚       ));
  782 â”‚       const endDate = new Date(Math.min(
  783 â”‚         checkOut.getTime(),
  784 â”‚         new Date(currentYear, currentMonth + 1, 0).getTime()
  785 â”‚       ));
  786 â”‚       
  787 â”‚       // Calcular dias entre datas (incluindo check-in, excluindo check-out)
  788 â”‚       const days = Math.max(0, Math.floor((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)));
  789 â”‚       occupiedDays += days;
  790 â”‚     });
  791 â”‚     
  792 â”‚     const occupancyRate = (occupiedDays / totalPossibleRoomDays) * 100;
  793 â”‚     
  794 â”‚     // SimulaÃ§Ã£o de crescimento (em produÃ§Ã£o, compararia com mÃªs anterior)
  795 â”‚     const growth = occupancyRate > 50 ? 5 : -3;
  796 â”‚     
  797 â”‚     return {
  798 â”‚       rate: Math.round(occupancyRate),
  799 â”‚       growth: Math.round(growth)
  800 â”‚     };
  801 â”‚   } catch (error) {
  802 â”‚     console.error('Erro ao calcular taxa de ocupaÃ§Ã£o:', error);
  803 â”‚     return { rate: 0, growth: 0 };
  804 â”‚   }
  805 â”‚ };
  806 â”‚ 
  807 â”‚ // Obter reservas agrupadas por plataforma
  808 â”‚ export const getBookingsByPlatform = async () => {
  809 â”‚   try {
  810 â”‚     const bookings = await getDocuments<Booking>('bookings');
  811 â”‚     
  812 â”‚     // Categorizar reservas por origem
  813 â”‚     const platforms = [
  814 â”‚       { 
  815 â”‚         platform: "Booking.com", 
  816 â”‚         color: "#003580", 
  817 â”‚         icon: "Globe",
  818 â”‚         bookings: []
  819 â”‚       },
  820 â”‚       { 
  821 â”‚         platform: "Airbnb", 
  822 â”‚         color: "#FF5A5F", 
  823 â”‚         icon: "Heart",
  824 â”‚         bookings: []
  825 â”‚       },
  826 â”‚       { 
  827 â”‚         platform: "Direto", 
  828 â”‚         color: "#4CAF50", 
  829 â”‚         icon: "Home",
  830 â”‚         bookings: []
  831 â”‚       }
  832 â”‚     ];
  833 â”‚     
  834 â”‚     // Para fins de demonstraÃ§Ã£o, colocar todas as reservas como "Direto" por enquanto
  835 â”‚     // Em produÃ§Ã£o, usaria um campo "platformOrigin" ou similar na tabela de reservas
  836 â”‚     const platformIndex = 2; // Ãndice da plataforma "Direto"
  837 â”‚     
  838 â”‚     bookings.forEach(booking => {
  839 â”‚       // Transformar para o formato esperado pelo componente
  840 â”‚       const transformedBooking = {
  841 â”‚         id: booking.id || '',
  842 â”‚         guestName: booking.guestName,
  843 â”‚         roomName: booking.roomName,
  844 â”‚         checkIn: booking.checkIn.toDate().toLocaleDateString('pt-PT'),
  845 â”‚         checkOut: booking.checkOut.toDate().toLocaleDateString('pt-PT'),
  846 â”‚         status: booking.status,
  847 â”‚         value: new Intl.NumberFormat('pt-PT', {
  848 â”‚           style: 'currency',
  849 â”‚           currency: 'EUR'
  850 â”‚         }).format(booking.totalPrice)
  851 â”‚       };
  852 â”‚       
  853 â”‚       // Adicionar Ã  plataforma "Direto"
  854 â”‚       (platforms[platformIndex] as any).bookings.push(transformedBooking);
  855 â”‚     });
  856 â”‚     
  857 â”‚     return platforms;
  858 â”‚   } catch (error) {
  859 â”‚     console.error('Erro ao obter reservas por plataforma:', error);
  860 â”‚     return [];
  861 â”‚   }
  862 â”‚ };
  863 â”‚ 
  864 â”‚ // FunÃ§Ã£o para obter o preÃ§o de um quarto para uma data especÃ­fica
  865 â”‚ export const getRoomPriceForDate = async (roomId: string, date: Date): Promise<number> => {
  866 â”‚   try {
  867 â”‚     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  868 â”‚     
  869 â”‚     if (!roomDoc.exists()) {
  870 â”‚       throw new Error("Quarto nÃ£o encontrado");
  871 â”‚     }
  872 â”‚     
  873 â”‚     const roomData = roomDoc.data() as Room;
  874 â”‚     const basePrice = roomData.price;
  875 â”‚     
  876 â”‚     if (!roomData.seasonalPrices || roomData.seasonalPrices.length === 0) {
  877 â”‚       return basePrice;
  878 â”‚     }
  879 â”‚     
  880 â”‚     // Verificar se a data estÃ¡ dentro de algum perÃ­odo sazonal
  881 â”‚     for (const seasonalPrice of roomData.seasonalPrices) {
  882 â”‚       const startDate = new Date(seasonalPrice.startDate);
  883 â”‚       const endDate = new Date(seasonalPrice.endDate);
  884 â”‚       
  885 â”‚       if (date >= startDate && date <= endDate) {
  886 â”‚         return seasonalPrice.price;
  887 â”‚       }
  888 â”‚     }
  889 â”‚     
  890 â”‚     // Se nÃ£o cair em nenhum perÃ­odo sazonal, retorna o preÃ§o base
  891 â”‚     return basePrice;
  892 â”‚   } catch (error) {
  893 â”‚     console.error("Erro ao obter preÃ§o do quarto:", error);
  894 â”‚     throw error;
  895 â”‚   }
  896 â”‚ }
  897 â”‚ 
  898 â”‚ // FunÃ§Ã£o para calcular o preÃ§o total de uma estadia
  899 â”‚ export const calculateStayPrice = async (
  900 â”‚   roomId: string, 
  901 â”‚   checkIn: Date, 
  902 â”‚   checkOut: Date
  903 â”‚ ): Promise<{
  904 â”‚   totalPrice: number;
  905 â”‚   nightlyPrices: { date: string; price: number }[];
  906 â”‚   serviceFee: number;
  907 â”‚   totalWithFee: number;
  908 â”‚ }> => {
  909 â”‚   try {
  910 â”‚     console.log(`ğŸ” Iniciando cÃ¡lculo de preÃ§o para estadia: ${checkIn.toISOString().split('T')[0]} atÃ© ${checkOut.toISOString().split('T')[0]}`);
  911 â”‚     
  912 â”‚     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  913 â”‚     
  914 â”‚     if (!roomDoc.exists()) {
  915 â”‚       throw new Error("Quarto nÃ£o encontrado");
  916 â”‚     }
  917 â”‚     
  918 â”‚     const roomData = roomDoc.data() as Room;
  919 â”‚     console.log(`ğŸ“ Dados do quarto ${roomId}:`, {
  920 â”‚       nome: roomData.name,
  921 â”‚       precoBase: roomData.price,
  922 â”‚       taxaServico: roomData.serviceFeePct || 0,
  923 â”‚       temPrecosSazonais: !!roomData.seasonalPrices?.length
  924 â”‚     });
  925 â”‚     
  926 â”‚     const nightlyPrices: { date: string; price: number }[] = [];
  927 â”‚     let totalPrice = 0;
  928 â”‚     
  929 â”‚     // Calcular o nÃºmero de noites - corrigido para usar o mÃ©todo correto de cÃ¡lculo
  930 â”‚     // O nÃºmero de noites Ã© a diferenÃ§a em dias (estadia = checkout - checkin)
  931 â”‚     const noites = differenceInDays(checkOut, checkIn);
  932 â”‚     console.log(`ğŸ—“ï¸ NÃºmero de noites calculado: ${noites}`);
  933 â”‚     
  934 â”‚     if (noites <= 0) {
  935 â”‚       console.error(`âš ï¸ Erro: nÃºmero de noites invÃ¡lido (${noites})`);
  936 â”‚       throw new Error("Data de check-out deve ser posterior Ã  data de check-in");
  937 â”‚     }
  938 â”‚     
  939 â”‚     // Para cada noite, verificar o preÃ§o aplicÃ¡vel (preÃ§o base ou sazonal)
  940 â”‚     // ComeÃ§amos exatamente do dia de check-in
  941 â”‚     const currentDate = new Date(checkIn);
  942 â”‚     currentDate.setHours(0, 0, 0, 0); // Normalizar para meia-noite
  943 â”‚     
  944 â”‚     // Processamos cada dia de estadia (noite)
  945 â”‚     console.log(`ğŸ“Š Calculando preÃ§os por noite:`);
  946 â”‚     for (let i = 0; i < noites; i++) {
  947 â”‚       // Obtemos o preÃ§o para esta data
  948 â”‚       const dateCopy = new Date(currentDate);
  949 â”‚       const priceForDate = await getRoomPriceForDate(roomId, dateCopy);
  950 â”‚       const dateString = dateCopy.toISOString().split('T')[0]; // YYYY-MM-DD
  951 â”‚       
  952 â”‚       console.log(`   - ${dateString}: â‚¬${priceForDate}`);
  953 â”‚       
  954 â”‚       nightlyPrices.push({
  955 â”‚         date: dateString,
  956 â”‚         price: priceForDate
  957 â”‚       });
  958 â”‚       
  959 â”‚       totalPrice += priceForDate;
  960 â”‚       
  961 â”‚       // AvanÃ§amos para o prÃ³ximo dia
  962 â”‚       currentDate.setDate(currentDate.getDate() + 1);
  963 â”‚     }
  964 â”‚     
  965 â”‚     // VerificaÃ§Ã£o de seguranÃ§a para o cÃ¡lculo do totalPrice
  966 â”‚     const manualTotal = nightlyPrices.reduce((sum, night) => sum + night.price, 0);
  967 â”‚     if (Math.abs(totalPrice - manualTotal) > 1) {
  968 â”‚       console.error(`âš ï¸ DiscrepÃ¢ncia detectada no cÃ¡lculo do preÃ§o total!`);
  969 â”‚       console.error(`   - Total calculado iterativamente: â‚¬${totalPrice}`);
  970 â”‚       console.error(`   - Total calculado via reduce: â‚¬${manualTotal}`);
  971 â”‚       console.error(`   - Usando o valor recalculado para seguranÃ§a!`);
  972 â”‚       totalPrice = manualTotal;
  973 â”‚     }
  974 â”‚     
  975 â”‚     // Calcular taxa de serviÃ§o
  976 â”‚     const serviceFee = (totalPrice * (roomData.serviceFeePct || 0)) / 100;
  977 â”‚     const totalWithFee = totalPrice + serviceFee;
  978 â”‚     
  979 â”‚     console.log(`ğŸ’° Resumo do cÃ¡lculo:`);
  980 â”‚     console.log(`   - Total das diÃ¡rias: â‚¬${totalPrice}`);
  981 â”‚     console.log(`   - Taxa de serviÃ§o (${roomData.serviceFeePct || 0}%): â‚¬${serviceFee}`);
  982 â”‚     console.log(`   - Total com taxas: â‚¬${totalWithFee}`);
  983 â”‚     
  984 â”‚     return {
  985 â”‚       totalPrice,
  986 â”‚       nightlyPrices,
  987 â”‚       serviceFee,
  988 â”‚       totalWithFee
  989 â”‚     };
  990 â”‚   } catch (error) {
  991 â”‚     console.error("âŒ Erro ao calcular preÃ§o da estadia:", error);
  992 â”‚     throw error;
  993 â”‚   }
  994 â”‚ } 
  995 â”‚ import { 
  996 â”‚   collection, 
  997 â”‚   getDocs, 
  998 â”‚   getDoc, 
  999 â”‚   doc, 
 1000 â”‚   setDoc, 
 1001 â”‚   addDoc, 
 1002 â”‚   updateDoc, 
 1003 â”‚   deleteDoc,
 1004 â”‚   query,
 1005 â”‚   where,
 1006 â”‚   orderBy,
 1007 â”‚   limit,
 1008 â”‚   serverTimestamp
 1009 â”‚ } from 'firebase/firestore';
 1010 â”‚ import { db } from './config';
 1011 â”‚ 
 1012 â”‚ // Get all documents from a collection
 1013 â”‚ export async function getDocuments<T>(collectionName: string, forceRefresh = false): Promise<T[]> {
      Â·                       â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€
      Â·                             â•°â”€â”€ `getDocuments` redefined here
 1014 â”‚   console.log(`Buscando documentos na coleÃ§Ã£o ${collectionName} - ForÃ§a atualizaÃ§Ã£o: ${forceRefresh}`);
 1015 â”‚   try {
 1016 â”‚     const querySnapshot = await getDocs(collection(db, collectionName));
      â•°â”€â”€â”€â”€

  Ã— the name `updateDocument` is defined multiple times
      â•­â”€[/home/runner/workspace/lib/firebase/firestore.ts:133:1]
  133 â”‚   }
  134 â”‚ }
  135 â”‚ 
  136 â”‚ export const updateDocument = async <T extends DocumentData>(
      Â·              â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€
      Â·                     â•°â”€â”€ previous definition of `updateDocument` here
  137 â”‚   collectionName: string,
  138 â”‚   id: string,
  139 â”‚   data: Partial<T>
  140 â”‚ ): Promise<void> => {
  141 â”‚   const docRef = doc(db, collectionName, id)
  142 â”‚   await updateDoc(docRef, {
  143 â”‚     ...data,
  144 â”‚     updatedAt: serverTimestamp()
  145 â”‚   })
  146 â”‚ }
  147 â”‚ 
  148 â”‚ export const deleteDocument = async (
  149 â”‚   collectionName: string,
  150 â”‚   id: string
  151 â”‚ ): Promise<boolean> => {
  152 â”‚   const docRef = doc(db, collectionName, id)
  153 â”‚   await deleteDoc(docRef)
  154 â”‚   return true
  155 â”‚ }
  156 â”‚ 
  157 â”‚ // FunÃ§Ãµes para gerenciar quartos
  158 â”‚ export const getRooms = async (forceRefresh = false): Promise<Room[]> => {
  159 â”‚   try {
  160 â”‚     const constraints: QueryConstraint[] = []
  161 â”‚     
  162 â”‚     constraints.push(orderBy('name', 'asc'))
  163 â”‚     
  164 â”‚     const rooms = await getDocuments<Room>('rooms', constraints, forceRefresh)
  165 â”‚     
  166 â”‚     // Garantir que todos os campos necessÃ¡rios estejam presentes
  167 â”‚     return rooms.map(room => {
  168 â”‚       console.log(`Firebase - Quarto ${room.id} dados brutos:`, room);
  169 â”‚       
  170 â”‚       // Garantir que serviceFeePct seja um nÃºmero
  171 â”‚       const serviceFeePct = room.serviceFeePct !== undefined 
  172 â”‚         ? Number(room.serviceFeePct) 
  173 â”‚         : 10;
  174 â”‚         
  175 â”‚       console.log(`Firebase - Quarto ${room.id} serviceFeePct:`, {
  176 â”‚         original: room.serviceFeePct,
  177 â”‚         tipo: typeof room.serviceFeePct,
  178 â”‚         convertido: serviceFeePct
  179 â”‚       });
  180 â”‚       
  181 â”‚       return {
  182 â”‚         id: room.id,
  183 â”‚         name: room.name || '',
  184 â”‚         type: room.type || 'standard',
  185 â”‚         description: room.description || '',
  186 â”‚         price: room.price || 0,
  187 â”‚         capacity: room.capacity || 2,
  188 â”‚         size: room.size || 0,
  189 â”‚         available: room.available !== undefined ? room.available : true,
  190 â”‚         serviceFeePct: serviceFeePct,
  191 â”‚         images: room.images || [],
  192 â”‚         amenities: room.amenities || [],
  193 â”‚         additionalServices: room.additionalServices || [],
  194 â”‚         highlights: room.highlights || [],
  195 â”‚         createdAt: room.createdAt,
  196 â”‚         updatedAt: room.updatedAt
  197 â”‚       };
  198 â”‚     });
  199 â”‚   } catch (error) {
  200 â”‚     console.error('Erro ao buscar quartos:', error)
  201 â”‚     return []
  202 â”‚   }
  203 â”‚ }
  204 â”‚ 
  205 â”‚ export const getAvailableRooms = async (
  206 â”‚   checkIn: Date,
  207 â”‚   checkOut: Date
  208 â”‚ ): Promise<Room[]> => {
  209 â”‚   try {
  210 â”‚     // Buscar todos os quartos que estÃ£o marcados como disponÃ­veis em geral
  211 â”‚     const constraints: QueryConstraint[] = [
  212 â”‚       where('available', '==', true)
  213 â”‚     ]
  214 â”‚     
  215 â”‚     const rooms = await getDocuments<Room>('rooms', constraints);
  216 â”‚     
  217 â”‚     // Filtrar os quartos que estÃ£o disponÃ­veis nas datas especÃ­ficas
  218 â”‚     return filterAvailableRoomsByDate(rooms, checkIn, checkOut);
  219 â”‚   } catch (error) {
  220 â”‚     console.error('Erro ao buscar quartos disponÃ­veis:', error)
  221 â”‚     return []
  222 â”‚   }
  223 â”‚ }
  224 â”‚ 
  225 â”‚ // FunÃ§Ã£o auxiliar para verificar disponibilidade entre datas
  226 â”‚ export const filterAvailableRoomsByDate = (
  227 â”‚   rooms: Room[],
  228 â”‚   checkIn: Date,
  229 â”‚   checkOut: Date
  230 â”‚ ): Room[] => {
  231 â”‚   // Converter checkIn e checkOut para ISO strings
  232 â”‚   const dateStrings = getDatesInRange(checkIn, checkOut);
  233 â”‚   
  234 â”‚   return rooms.filter(room => {
  235 â”‚     // Se nÃ£o tiver controle de disponibilidade especÃ­fico, considera disponÃ­vel
  236 â”‚     if (!room.availabilityDates) return true;
  237 â”‚     
  238 â”‚     // Verificar se alguma data no intervalo estÃ¡ indisponÃ­vel
  239 â”‚     return !dateStrings.some(dateStr => 
  240 â”‚       room.availabilityDates?.[dateStr] === false
  241 â”‚     );
  242 â”‚   });
  243 â”‚ };
  244 â”‚ 
  245 â”‚ // FunÃ§Ã£o para obter disponibilidade de um quarto especÃ­fico
  246 â”‚ export const getRoomAvailability = async (
  247 â”‚   roomId: string, 
  248 â”‚   startDate: Date, 
  249 â”‚   endDate: Date
  250 â”‚ ): Promise<{[date: string]: boolean}> => {
  251 â”‚   try {
  252 â”‚     const room = await getRoomById(roomId);
  253 â”‚     if (!room) throw new Error(`Quarto com ID ${roomId} nÃ£o encontrado`);
  254 â”‚     
  255 â”‚     // Gerar datas no intervalo
  256 â”‚     const dateStrings = getDatesInRange(startDate, endDate);
  257 â”‚     
  258 â”‚     // Se nÃ£o tiver configuraÃ§Ã£o de disponibilidade especÃ­fica, assume tudo disponÃ­vel
  259 â”‚     if (!room.availabilityDates) {
  260 â”‚       return dateStrings.reduce((acc, date) => {
  261 â”‚         acc[date] = true;
  262 â”‚         return acc;
  263 â”‚       }, {} as {[date: string]: boolean});
  264 â”‚     }
  265 â”‚     
  266 â”‚     // Preencher com os dados de disponibilidade existentes
  267 â”‚     return dateStrings.reduce((acc, date) => {
  268 â”‚       acc[date] = room.availabilityDates?.[date] !== false; // disponÃ­vel por padrÃ£o se nÃ£o estiver explicitamente indisponÃ­vel
  269 â”‚       return acc;
  270 â”‚     }, {} as {[date: string]: boolean});
  271 â”‚   } catch (error) {
  272 â”‚     console.error(`Erro ao verificar disponibilidade do quarto ${roomId}:`, error);
  273 â”‚     throw error;
  274 â”‚   }
  275 â”‚ };
  276 â”‚ 
  277 â”‚ // FunÃ§Ã£o para atualizar disponibilidade de um quarto
  278 â”‚ export const updateRoomAvailability = async (
  279 â”‚   roomId: string,
  280 â”‚   availabilityDates: {[date: string]: boolean}
  281 â”‚ ): Promise<boolean> => {
  282 â”‚   try {
  283 â”‚     await updateDocument('rooms', roomId, {
  284 â”‚       availabilityDates,
  285 â”‚       updatedAt: serverTimestamp()
  286 â”‚     });
  287 â”‚     return true;
  288 â”‚   } catch (error) {
  289 â”‚     console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  290 â”‚     return false;
  291 â”‚   }
  292 â”‚ };
  293 â”‚ 
  294 â”‚ // FunÃ§Ã£o auxiliar para gerar array de strings de data entre um intervalo
  295 â”‚ export const getDatesInRange = (startDate: Date, endDate: Date): string[] => {
  296 â”‚   const dates: string[] = [];
  297 â”‚   const currentDate = new Date(startDate);
  298 â”‚   
  299 â”‚   // Normalizar para meia-noite no fuso horÃ¡rio local
  300 â”‚   currentDate.setHours(0, 0, 0, 0);
  301 â”‚   const endDateNormalized = new Date(endDate);
  302 â”‚   endDateNormalized.setHours(0, 0, 0, 0);
  303 â”‚   
  304 â”‚   // Adicionar cada data no intervalo EXCETO o dia de checkout
  305 â”‚   // Usando < em vez de <= para nÃ£o incluir o dia de checkout
  306 â”‚   while (currentDate < endDateNormalized) {
  307 â”‚     dates.push(currentDate.toISOString().split('T')[0]); // Formato YYYY-MM-DD
  308 â”‚     currentDate.setDate(currentDate.getDate() + 1);
  309 â”‚   }
  310 â”‚   
  311 â”‚   return dates;
  312 â”‚ };
  313 â”‚ 
  314 â”‚ export const getRoomById = async (id: string): Promise<Room | null> => {
  315 â”‚   try {
  316 â”‚     const room = await getDocument<Room>('rooms', id);
  317 â”‚     
  318 â”‚     if (!room) return null;
  319 â”‚     
  320 â”‚     console.log(`Firebase - getRoomById ${id} dados brutos:`, room);
  321 â”‚     
  322 â”‚     // Log especÃ­fico para serviceFeePct
  323 â”‚     console.log(`serviceFeePct no Firestore:`, room.serviceFeePct);
  324 â”‚     
  325 â”‚     // Garantir que todos os campos necessÃ¡rios estejam presentes
  326 â”‚     return {
  327 â”‚       ...room,
  328 â”‚       name: room.name || '',
  329 â”‚       type: room.type || 'standard',
  330 â”‚       description: room.description || '',
  331 â”‚       price: room.price || 0,
  332 â”‚       capacity: room.capacity || 2,
  333 â”‚       size: room.size || 0,
  334 â”‚       available: room.available !== undefined ? room.available : true,
  335 â”‚       serviceFeePct: room.serviceFeePct !== undefined ? room.serviceFeePct : 10,
  336 â”‚       images: room.images || [],
  337 â”‚       amenities: room.amenities || [],
  338 â”‚       additionalServices: room.additionalServices || [],
  339 â”‚       highlights: room.highlights || []
  340 â”‚     };
  341 â”‚   } catch (error) {
  342 â”‚     console.error(`Erro ao buscar quarto com ID ${id}:`, error);
  343 â”‚     return null;
  344 â”‚   }
  345 â”‚ }
  346 â”‚ 
  347 â”‚ export const createRoom = async (roomData: Omit<Room, 'id' | 'createdAt' | 'updatedAt'>): Promise<Room> => {
  348 â”‚   try {
  349 â”‚     console.log("createRoom - Dados recebidos:", roomData);
  350 â”‚     
  351 â”‚     const roomWithTimestamps = {
  352 â”‚       ...roomData,
  353 â”‚       available: roomData.available !== undefined ? roomData.available : true,
  354 â”‚       featured: roomData.featured || false,
  355 â”‚       amenities: roomData.amenities || [],
  356 â”‚       additionalServices: roomData.additionalServices || [],
  357 â”‚       highlights: roomData.highlights || [],
  358 â”‚       createdAt: serverTimestamp(),
  359 â”‚       updatedAt: serverTimestamp()
  360 â”‚     }
  361 â”‚     
  362 â”‚     console.log("createRoom - Dados a serem salvos:", roomWithTimestamps);
  363 â”‚     
  364 â”‚     const id = await createDocument('rooms', roomWithTimestamps)
  365 â”‚     
  366 â”‚     return {
  367 â”‚       id,
  368 â”‚       ...roomData,
  369 â”‚       amenities: roomData.amenities || [],
  370 â”‚       additionalServices: roomData.additionalServices || [],
  371 â”‚       highlights: roomData.highlights || [],
  372 â”‚       createdAt: Timestamp.now(),
  373 â”‚       updatedAt: Timestamp.now()
  374 â”‚     }
  375 â”‚   } catch (error) {
  376 â”‚     console.error('Erro ao criar quarto:', error)
  377 â”‚     throw error
  378 â”‚   }
  379 â”‚ }
  380 â”‚ 
  381 â”‚ export const updateRoom = async (id: string, roomData: Partial<Omit<Room, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Room> => {
  382 â”‚   try {
  383 â”‚     console.log(`updateRoom - ID: ${id}, Dados recebidos:`, roomData);
  384 â”‚     
  385 â”‚     // Garantir que estamos lidando explicitamente com o serviceFeePct se ele for 0
  386 â”‚     if (roomData.serviceFeePct === 0) {
  387 â”‚       console.log("updateRoom - Detectado serviceFeePct com valor 0, salvando explicitamente.", roomData.serviceFeePct);
  388 â”‚     }
  389 â”‚     
  390 â”‚     // Adicionar timestamp de atualizaÃ§Ã£o
  391 â”‚     const roomWithTimestamp = {
  392 â”‚       ...roomData,
  393 â”‚       amenities: roomData.amenities || [],
  394 â”‚       additionalServices: roomData.additionalServices || [],
  395 â”‚       highlights: roomData.highlights || [],
  396 â”‚       updatedAt: serverTimestamp()
  397 â”‚     }
  398 â”‚     
  399 â”‚     console.log(`updateRoom - Dados a serem salvos:`, roomWithTimestamp);
  400 â”‚     
  401 â”‚     await updateDocument('rooms', id, roomWithTimestamp)
  402 â”‚     
  403 â”‚     const updatedRoom = await getRoomById(id)
  404 â”‚     if (!updatedRoom) {
  405 â”‚       throw new Error(`Quarto com ID ${id} nÃ£o encontrado apÃ³s atualizaÃ§Ã£o`)
  406 â”‚     }
  407 â”‚     
  408 â”‚     return updatedRoom
  409 â”‚   } catch (error) {
  410 â”‚     console.error('Erro ao atualizar quarto:', error)
  411 â”‚     throw error
  412 â”‚   }
  413 â”‚ }
  414 â”‚ 
  415 â”‚ export const deleteRoom = async (id: string): Promise<boolean> => {
  416 â”‚   return await deleteDocument('rooms', id)
  417 â”‚ }
  418 â”‚ 
  419 â”‚ // FunÃ§Ãµes especÃ­ficas para reservas
  420 â”‚ export const createBooking = async (bookingData: any) => {
  421 â”‚   try {
  422 â”‚     const bookingsCollection = collection(db, 'bookings');
  423 â”‚     const docRef = await addDoc(bookingsCollection, bookingData);
  424 â”‚     
  425 â”‚     // CORREÃ‡ÃƒO: NÃ£o bloquear a data no momento da criaÃ§Ã£o da reserva
  426 â”‚     // O bloqueio serÃ¡ feito apenas quando o pagamento for confirmado
  427 â”‚     // atravÃ©s da funÃ§Ã£o updateBookingStatus
  428 â”‚     
  429 â”‚     return docRef;
  430 â”‚   } catch (error) {
  431 â”‚     console.error('Erro ao criar reserva:', error);
  432 â”‚     throw error;
  433 â”‚   }
  434 â”‚ };
  435 â”‚ 
  436 â”‚ // Nova funÃ§Ã£o para atualizar status da reserva e bloquear as datas da estadia
  437 â”‚ export const updateBookingStatus = async (
  438 â”‚   bookingId: string, 
  439 â”‚   newStatus: 'pending' | 'confirmed' | 'cancelled' | 'completed',
  440 â”‚   newPaymentStatus: 'pending' | 'paid' | 'refunded'
  441 â”‚ ): Promise<boolean> => {
  442 â”‚   try {
  443 â”‚     // ReferÃªncia ao documento da reserva
  444 â”‚     const bookingRef = doc(db, 'bookings', bookingId);
  445 â”‚     const bookingSnap = await getDoc(bookingRef);
  446 â”‚     
  447 â”‚     if (!bookingSnap.exists()) {
  448 â”‚       console.error(`Booking ${bookingId} nÃ£o existe ao atualizar status`);
  449 â”‚       return false;
  450 â”‚     }
  451 â”‚     
  452 â”‚     const bookingData = bookingSnap.data();
  453 â”‚     
  454 â”‚     // Atualizar o status da reserva
  455 â”‚     await updateDoc(bookingRef, {
  456 â”‚       status: newStatus,
  457 â”‚       paymentStatus: newPaymentStatus,
  458 â”‚       updatedAt: serverTimestamp(),
  459 â”‚       ...(newStatus === 'confirmed' && { confirmedAt: serverTimestamp() })
  460 â”‚     });
  461 â”‚     
  462 â”‚     // Se a reserva estÃ¡ sendo confirmada, precisamos bloquear as datas
  463 â”‚     if (newStatus === 'confirmed') {
  464 â”‚       console.log(`Atualizando disponibilidade para reserva confirmada: ${bookingId}`);
  465 â”‚       
  466 â”‚       // Recuperar datas de check-in e check-out
  467 â”‚       const checkIn = bookingData.checkIn.toDate();
  468 â”‚       const checkOut = bookingData.checkOut.toDate();
  469 â”‚       const roomId = bookingData.roomId;
  470 â”‚       
  471 â”‚       // Obter todas as datas entre check-in e check-out
  472 â”‚       const dates: Date[] = [];
  473 â”‚       const currentDate = new Date(checkIn);
  474 â”‚       
  475 â”‚       while (currentDate < checkOut) {
  476 â”‚         dates.push(new Date(currentDate));
  477 â”‚         currentDate.setDate(currentDate.getDate() + 1);
  478 â”‚       }
  479 â”‚       
  480 â”‚       console.log(`Bloqueando ${dates.length} dias para quarto ${roomId}`);
  481 â”‚       
  482 â”‚       // Atualizar disponibilidade para cada data
  483 â”‚       const availabilityUpdates: {[date: string]: boolean} = {};
  484 â”‚       
  485 â”‚       dates.forEach(date => {
  486 â”‚         const dateString = date.toISOString().split('T')[0]; // formato YYYY-MM-DD
  487 â”‚         availabilityUpdates[dateString] = false; // false significa indisponÃ­vel
  488 â”‚       });
  489 â”‚       
  490 â”‚       // Atualizar disponibilidade do quarto
  491 â”‚       if (Object.keys(availabilityUpdates).length > 0) {
  492 â”‚         try {
  493 â”‚           // Obter o documento do quarto
  494 â”‚           const roomRef = doc(db, 'rooms', roomId);
  495 â”‚           const roomSnap = await getDoc(roomRef);
  496 â”‚           
  497 â”‚           if (roomSnap.exists()) {
  498 â”‚             const roomData = roomSnap.data();
  499 â”‚             const currentAvailability = roomData.availabilityDates || {};
  500 â”‚             
  501 â”‚             // Mesclar a disponibilidade atual com as novas atualizaÃ§Ãµes
  502 â”‚             const updatedAvailability = {
  503 â”‚               ...currentAvailability,
  504 â”‚               ...availabilityUpdates
  505 â”‚             };
  506 â”‚             
  507 â”‚             // Atualizar o documento do quarto
  508 â”‚             await updateDoc(roomRef, {
  509 â”‚               availabilityDates: updatedAvailability,
  510 â”‚               updatedAt: serverTimestamp()
  511 â”‚             });
  512 â”‚             
  513 â”‚             console.log(`Disponibilidade atualizada com sucesso para quarto ${roomId}`);
  514 â”‚             
  515 â”‚             // Criar log da reserva
  516 â”‚             await addDoc(collection(db, 'bookingLogs'), {
  517 â”‚               bookingId,
  518 â”‚               roomId,
  519 â”‚               action: 'status_updated',
  520 â”‚               previousStatus: bookingData.status,
  521 â”‚               newStatus,
  522 â”‚               previousPaymentStatus: bookingData.paymentStatus,
  523 â”‚               newPaymentStatus,
  524 â”‚               datesBlocked: Object.keys(availabilityUpdates),
  525 â”‚               timestamp: serverTimestamp(),
  526 â”‚               userId: bookingData.userId || 'system'
  527 â”‚             });
  528 â”‚           } else {
  529 â”‚             console.error(`Quarto ${roomId} nÃ£o encontrado ao atualizar disponibilidade`);
  530 â”‚           }
  531 â”‚         } catch (error) {
  532 â”‚           console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  533 â”‚         }
  534 â”‚       }
  535 â”‚     }
  536 â”‚     
  537 â”‚     return true;
  538 â”‚   } catch (error) {
  539 â”‚     console.error(`Erro ao atualizar status da reserva ${bookingId}:`, error);
  540 â”‚     return false;
  541 â”‚   }
  542 â”‚ }
  543 â”‚ 
  544 â”‚ export const getUserBookings = async (userId: string): Promise<Booking[]> => {
  545 â”‚   return getDocuments<Booking>('bookings', [
  546 â”‚     where('userId', '==', userId),
  547 â”‚     orderBy('createdAt', 'desc')
  548 â”‚   ])
  549 â”‚ }
  550 â”‚ 
  551 â”‚ export const getRecentBookings = async (count = 5): Promise<Booking[]> => {
  552 â”‚   return getDocuments<Booking>('bookings', [
  553 â”‚     orderBy('createdAt', 'desc'),
  554 â”‚     limit(count)
  555 â”‚   ])
  556 â”‚ }
  557 â”‚ 
  558 â”‚ export const getRoomBookings = async (roomId: string): Promise<Booking[]> => {
  559 â”‚   try {
  560 â”‚     const constraints: QueryConstraint[] = [
  561 â”‚       where('roomId', '==', roomId),
  562 â”‚       orderBy('checkIn', 'asc')
  563 â”‚     ];
  564 â”‚     
  565 â”‚     return await getDocuments<Booking>('bookings', constraints);
  566 â”‚   } catch (error) {
  567 â”‚     console.error(`Erro ao buscar reservas do quarto ${roomId}:`, error);
  568 â”‚     return [];
  569 â”‚   }
  570 â”‚ };
  571 â”‚ 
  572 â”‚ // FunÃ§Ãµes especÃ­ficas para contatos
  573 â”‚ export const createContactMessage = async (contactData: Contact) => {
  574 â”‚   try {
  575 â”‚     const contactsCollection = collection(db, 'contacts')
  576 â”‚     
  577 â”‚     // Garantir que o status seja 'new' para novos contatos
  578 â”‚     const contactWithDefaults = {
  579 â”‚       ...contactData,
  580 â”‚       status: contactData.status || 'new',
  581 â”‚       createdAt: contactData.createdAt || Timestamp.now()
  582 â”‚     }
  583 â”‚     
  584 â”‚     // Se tiver detalhes de reserva, adicionar metadados
  585 â”‚     if (contactWithDefaults.reservationDetails) {
  586 â”‚       // Ajustar subject para indicar que Ã© relacionado a reserva
  587 â”‚       if (!contactWithDefaults.subject.includes('Reserva')) {
  588 â”‚         contactWithDefaults.subject = `Reserva: ${contactWithDefaults.subject}`;
  589 â”‚       }
  590 â”‚     }
  591 â”‚     
  592 â”‚     const docRef = await addDoc(contactsCollection, contactWithDefaults)
  593 â”‚     return docRef
  594 â”‚   } catch (error) {
  595 â”‚     console.error('Erro ao criar mensagem de contato:', error)
  596 â”‚     throw error
  597 â”‚   }
  598 â”‚ }
  599 â”‚ 
  600 â”‚ export const getNewContactMessages = async (): Promise<Contact[]> => {
  601 â”‚   return getDocuments<Contact>('contacts', [
  602 â”‚     where('status', '==', 'new'),
  603 â”‚     orderBy('createdAt', 'desc')
  604 â”‚   ])
  605 â”‚ }
  606 â”‚ 
  607 â”‚ // FunÃ§Ãµes para Dashboard com dados reais
  608 â”‚ 
  609 â”‚ export const getDashboardStats = async () => {
  610 â”‚   try {
  611 â”‚     const [totalBookings, totalRevenue, occupancyRate, bookingsByPlatform] = await Promise.all([
  612 â”‚       getTotalBookings(),
  613 â”‚       getMonthlyRevenue(),
  614 â”‚       getOccupancyRate(),
  615 â”‚       getBookingsByPlatform()
  616 â”‚     ]);
  617 â”‚ 
  618 â”‚     return {
  619 â”‚       totalBookings,
  620 â”‚       totalRevenue,
  621 â”‚       occupancyRate,
  622 â”‚       bookingsByPlatform
  623 â”‚     };
  624 â”‚   } catch (error) {
  625 â”‚     console.error('Erro ao obter estatÃ­sticas do dashboard:', error);
  626 â”‚     throw error;
  627 â”‚   }
  628 â”‚ };
  629 â”‚ 
  630 â”‚ // Obter total de reservas
  631 â”‚ export const getTotalBookings = async () => {
  632 â”‚   try {
  633 â”‚     // Obter todas as reservas
  634 â”‚     const bookings = await getDocuments<Booking>('bookings');
  635 â”‚     
  636 â”‚     // Contar reservas por status
  637 â”‚     const confirmed = bookings.filter(b => b.status === 'confirmed').length;
  638 â”‚     const pending = bookings.filter(b => b.status === 'pending').length;
  639 â”‚     const cancelled = bookings.filter(b => b.status === 'cancelled').length;
  640 â”‚     const completed = bookings.filter(b => b.status === 'completed').length;
  641 â”‚     
  642 â”‚     // Calcular crescimento em relaÃ§Ã£o ao mÃªs anterior (simulado por enquanto)
  643 â”‚     // Em uma implementaÃ§Ã£o real, vocÃª compararia com dados do mÃªs anterior
  644 â”‚     const growth = ((confirmed + completed) / (bookings.length || 1) * 100) - 50;
  645 â”‚     
  646 â”‚     return {
  647 â”‚       total: bookings.length,
  648 â”‚       confirmed,
  649 â”‚       pending,
  650 â”‚       cancelled,
  651 â”‚       completed,
  652 â”‚       growth: Math.round(growth) // Arredonda para nÃºmero inteiro
  653 â”‚     };
  654 â”‚   } catch (error) {
  655 â”‚     console.error('Erro ao obter total de reservas:', error);
  656 â”‚     return {
  657 â”‚       total: 0,
  658 â”‚       confirmed: 0,
  659 â”‚       pending: 0, 
  660 â”‚       cancelled: 0,
  661 â”‚       completed: 0,
  662 â”‚       growth: 0
  663 â”‚     };
  664 â”‚   }
  665 â”‚ };
  666 â”‚ 
  667 â”‚ // Obter receita mensal
  668 â”‚ export const getMonthlyRevenue = async () => {
  669 â”‚   try {
  670 â”‚     const bookings = await getDocuments<Booking>('bookings');
  671 â”‚     
  672 â”‚     // Filtrar reservas confirmadas e concluÃ­das
  673 â”‚     const validBookings = bookings.filter(b => 
  674 â”‚       b.status === 'confirmed' || b.status === 'completed'
  675 â”‚     );
  676 â”‚     
  677 â”‚     // Calcular receita total
  678 â”‚     const totalRevenue = validBookings.reduce((acc, booking) => acc + booking.totalPrice, 0);
  679 â”‚     
  680 â”‚     // Agrupar receita por mÃªs
  681 â”‚     const revenueByMonth = validBookings.reduce((acc, booking) => {
  682 â”‚       const date = booking.checkIn.toDate();
  683 â”‚       const month = date.getMonth(); // 0-11
  684 â”‚       const year = date.getFullYear();
  685 â”‚       const key = `${year}-${month}`;
  686 â”‚       
  687 â”‚       if (!acc[key]) {
  688 â”‚         acc[key] = 0;
  689 â”‚       }
  690 â”‚       acc[key] += booking.totalPrice;
  691 â”‚       return acc;
  692 â”‚     }, {} as Record<string, number>);
  693 â”‚     
  694 â”‚     // Converter para formato de array para grÃ¡fico
  695 â”‚     const monthNames = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
  696 â”‚     
  697 â”‚     const currentDate = new Date();
  698 â”‚     const currentMonth = currentDate.getMonth();
  699 â”‚     const currentYear = currentDate.getFullYear();
  700 â”‚     
  701 â”‚     const revenueData = [];
  702 â”‚     
  703 â”‚     // Gerar dados dos Ãºltimos 12 meses
  704 â”‚     for (let i = 0; i < 12; i++) {
  705 â”‚       const month = (currentMonth - i + 12) % 12;
  706 â”‚       const year = currentMonth - i < 0 ? currentYear - 1 : currentYear;
  707 â”‚       const key = `${year}-${month}`;
  708 â”‚       
  709 â”‚       revenueData.unshift({
  710 â”‚         month: monthNames[month],
  711 â”‚         value: revenueByMonth[key] || 0
  712 â”‚       });
  713 â”‚     }
  714 â”‚     
  715 â”‚     // Calcular crescimento em relaÃ§Ã£o ao mÃªs anterior
  716 â”‚     const lastMonthRevenue = revenueData[revenueData.length - 2]?.value || 0;
  717 â”‚     const currentMonthRevenue = revenueData[revenueData.length - 1]?.value || 0;
  718 â”‚     
  719 â”‚     const growth = lastMonthRevenue ? ((currentMonthRevenue - lastMonthRevenue) / lastMonthRevenue) * 100 : 0;
  720 â”‚     
  721 â”‚     return {
  722 â”‚       monthly: currentMonthRevenue,
  723 â”‚       total: totalRevenue,
  724 â”‚       growth: Math.round(growth),
  725 â”‚       revenueData
  726 â”‚     };
  727 â”‚   } catch (error) {
  728 â”‚     console.error('Erro ao obter receita mensal:', error);
  729 â”‚     return {
  730 â”‚       monthly: 0,
  731 â”‚       total: 0,
  732 â”‚       growth: 0,
  733 â”‚       revenueData: []
  734 â”‚     };
  735 â”‚   }
  736 â”‚ };
  737 â”‚ 
  738 â”‚ // Calcular taxa de ocupaÃ§Ã£o
  739 â”‚ export const getOccupancyRate = async () => {
  740 â”‚   try {
  741 â”‚     // Obter todos os quartos
  742 â”‚     const rooms = await getDocuments<Room>('rooms');
  743 â”‚     const totalRooms = rooms.length;
  744 â”‚     
  745 â”‚     if (totalRooms === 0) {
  746 â”‚       return { rate: 0, growth: 0 };
  747 â”‚     }
  748 â”‚     
  749 â”‚     // Obter todas as reservas
  750 â”‚     const bookings = await getDocuments<Booking>('bookings');
  751 â”‚     
  752 â”‚     // Filtrar reservas confirmadas e concluÃ­das para o mÃªs atual
  753 â”‚     const currentDate = new Date();
  754 â”‚     const currentMonth = currentDate.getMonth();
  755 â”‚     const currentYear = currentDate.getFullYear();
  756 â”‚     
  757 â”‚     const currentMonthBookings = bookings.filter(booking => {
  758 â”‚       const checkInDate = booking.checkIn.toDate();
  759 â”‚       return (
  760 â”‚         (booking.status === 'confirmed' || booking.status === 'completed') &&
  761 â”‚         checkInDate.getMonth() === currentMonth &&
  762 â”‚         checkInDate.getFullYear() === currentYear
  763 â”‚       );
  764 â”‚     });
  765 â”‚     
  766 â”‚     // Calcular dias ocupados por quarto
  767 â”‚     const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
  768 â”‚     const totalPossibleRoomDays = totalRooms * daysInMonth;
  769 â”‚     
  770 â”‚     // Contar dias ocupados (simplificado - em produÃ§Ã£o seria mais complexo)
  771 â”‚     let occupiedDays = 0;
  772 â”‚     
  773 â”‚     currentMonthBookings.forEach(booking => {
  774 â”‚       const checkIn = booking.checkIn.toDate();
  775 â”‚       const checkOut = booking.checkOut.toDate();
  776 â”‚       
  777 â”‚       // Ajustar datas para considerar apenas o mÃªs atual
  778 â”‚       const startDate = new Date(Math.max(
  779 â”‚         checkIn.getTime(),
  780 â”‚         new Date(currentYear, currentMonth, 1).getTime()
  781 â”‚       ));
  782 â”‚       const endDate = new Date(Math.min(
  783 â”‚         checkOut.getTime(),
  784 â”‚         new Date(currentYear, currentMonth + 1, 0).getTime()
  785 â”‚       ));
  786 â”‚       
  787 â”‚       // Calcular dias entre datas (incluindo check-in, excluindo check-out)
  788 â”‚       const days = Math.max(0, Math.floor((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)));
  789 â”‚       occupiedDays += days;
  790 â”‚     });
  791 â”‚     
  792 â”‚     const occupancyRate = (occupiedDays / totalPossibleRoomDays) * 100;
  793 â”‚     
  794 â”‚     // SimulaÃ§Ã£o de crescimento (em produÃ§Ã£o, compararia com mÃªs anterior)
  795 â”‚     const growth = occupancyRate > 50 ? 5 : -3;
  796 â”‚     
  797 â”‚     return {
  798 â”‚       rate: Math.round(occupancyRate),
  799 â”‚       growth: Math.round(growth)
  800 â”‚     };
  801 â”‚   } catch (error) {
  802 â”‚     console.error('Erro ao calcular taxa de ocupaÃ§Ã£o:', error);
  803 â”‚     return { rate: 0, growth: 0 };
  804 â”‚   }
  805 â”‚ };
  806 â”‚ 
  807 â”‚ // Obter reservas agrupadas por plataforma
  808 â”‚ export const getBookingsByPlatform = async () => {
  809 â”‚   try {
  810 â”‚     const bookings = await getDocuments<Booking>('bookings');
  811 â”‚     
  812 â”‚     // Categorizar reservas por origem
  813 â”‚     const platforms = [
  814 â”‚       { 
  815 â”‚         platform: "Booking.com", 
  816 â”‚         color: "#003580", 
  817 â”‚         icon: "Globe",
  818 â”‚         bookings: []
  819 â”‚       },
  820 â”‚       { 
  821 â”‚         platform: "Airbnb", 
  822 â”‚         color: "#FF5A5F", 
  823 â”‚         icon: "Heart",
  824 â”‚         bookings: []
  825 â”‚       },
  826 â”‚       { 
  827 â”‚         platform: "Direto", 
  828 â”‚         color: "#4CAF50", 
  829 â”‚         icon: "Home",
  830 â”‚         bookings: []
  831 â”‚       }
  832 â”‚     ];
  833 â”‚     
  834 â”‚     // Para fins de demonstraÃ§Ã£o, colocar todas as reservas como "Direto" por enquanto
  835 â”‚     // Em produÃ§Ã£o, usaria um campo "platformOrigin" ou similar na tabela de reservas
  836 â”‚     const platformIndex = 2; // Ãndice da plataforma "Direto"
  837 â”‚     
  838 â”‚     bookings.forEach(booking => {
  839 â”‚       // Transformar para o formato esperado pelo componente
  840 â”‚       const transformedBooking = {
  841 â”‚         id: booking.id || '',
  842 â”‚         guestName: booking.guestName,
  843 â”‚         roomName: booking.roomName,
  844 â”‚         checkIn: booking.checkIn.toDate().toLocaleDateString('pt-PT'),
  845 â”‚         checkOut: booking.checkOut.toDate().toLocaleDateString('pt-PT'),
  846 â”‚         status: booking.status,
  847 â”‚         value: new Intl.NumberFormat('pt-PT', {
  848 â”‚           style: 'currency',
  849 â”‚           currency: 'EUR'
  850 â”‚         }).format(booking.totalPrice)
  851 â”‚       };
  852 â”‚       
  853 â”‚       // Adicionar Ã  plataforma "Direto"
  854 â”‚       (platforms[platformIndex] as any).bookings.push(transformedBooking);
  855 â”‚     });
  856 â”‚     
  857 â”‚     return platforms;
  858 â”‚   } catch (error) {
  859 â”‚     console.error('Erro ao obter reservas por plataforma:', error);
  860 â”‚     return [];
  861 â”‚   }
  862 â”‚ };
  863 â”‚ 
  864 â”‚ // FunÃ§Ã£o para obter o preÃ§o de um quarto para uma data especÃ­fica
  865 â”‚ export const getRoomPriceForDate = async (roomId: string, date: Date): Promise<number> => {
  866 â”‚   try {
  867 â”‚     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  868 â”‚     
  869 â”‚     if (!roomDoc.exists()) {
  870 â”‚       throw new Error("Quarto nÃ£o encontrado");
  871 â”‚     }
  872 â”‚     
  873 â”‚     const roomData = roomDoc.data() as Room;
  874 â”‚     const basePrice = roomData.price;
  875 â”‚     
  876 â”‚     if (!roomData.seasonalPrices || roomData.seasonalPrices.length === 0) {
  877 â”‚       return basePrice;
  878 â”‚     }
  879 â”‚     
  880 â”‚     // Verificar se a data estÃ¡ dentro de algum perÃ­odo sazonal
  881 â”‚     for (const seasonalPrice of roomData.seasonalPrices) {
  882 â”‚       const startDate = new Date(seasonalPrice.startDate);
  883 â”‚       const endDate = new Date(seasonalPrice.endDate);
  884 â”‚       
  885 â”‚       if (date >= startDate && date <= endDate) {
  886 â”‚         return seasonalPrice.price;
  887 â”‚       }
  888 â”‚     }
  889 â”‚     
  890 â”‚     // Se nÃ£o cair em nenhum perÃ­odo sazonal, retorna o preÃ§o base
  891 â”‚     return basePrice;
  892 â”‚   } catch (error) {
  893 â”‚     console.error("Erro ao obter preÃ§o do quarto:", error);
  894 â”‚     throw error;
  895 â”‚   }
  896 â”‚ }
  897 â”‚ 
  898 â”‚ // FunÃ§Ã£o para calcular o preÃ§o total de uma estadia
  899 â”‚ export const calculateStayPrice = async (
  900 â”‚   roomId: string, 
  901 â”‚   checkIn: Date, 
  902 â”‚   checkOut: Date
  903 â”‚ ): Promise<{
  904 â”‚   totalPrice: number;
  905 â”‚   nightlyPrices: { date: string; price: number }[];
  906 â”‚   serviceFee: number;
  907 â”‚   totalWithFee: number;
  908 â”‚ }> => {
  909 â”‚   try {
  910 â”‚     console.log(`ğŸ” Iniciando cÃ¡lculo de preÃ§o para estadia: ${checkIn.toISOString().split('T')[0]} atÃ© ${checkOut.toISOString().split('T')[0]}`);
  911 â”‚     
  912 â”‚     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  913 â”‚     
  914 â”‚     if (!roomDoc.exists()) {
  915 â”‚       throw new Error("Quarto nÃ£o encontrado");
  916 â”‚     }
  917 â”‚     
  918 â”‚     const roomData = roomDoc.data() as Room;
  919 â”‚     console.log(`ğŸ“ Dados do quarto ${roomId}:`, {
  920 â”‚       nome: roomData.name,
  921 â”‚       precoBase: roomData.price,
  922 â”‚       taxaServico: roomData.serviceFeePct || 0,
  923 â”‚       temPrecosSazonais: !!roomData.seasonalPrices?.length
  924 â”‚     });
  925 â”‚     
  926 â”‚     const nightlyPrices: { date: string; price: number }[] = [];
  927 â”‚     let totalPrice = 0;
  928 â”‚     
  929 â”‚     // Calcular o nÃºmero de noites - corrigido para usar o mÃ©todo correto de cÃ¡lculo
  930 â”‚     // O nÃºmero de noites Ã© a diferenÃ§a em dias (estadia = checkout - checkin)
  931 â”‚     const noites = differenceInDays(checkOut, checkIn);
  932 â”‚     console.log(`ğŸ—“ï¸ NÃºmero de noites calculado: ${noites}`);
  933 â”‚     
  934 â”‚     if (noites <= 0) {
  935 â”‚       console.error(`âš ï¸ Erro: nÃºmero de noites invÃ¡lido (${noites})`);
  936 â”‚       throw new Error("Data de check-out deve ser posterior Ã  data de check-in");
  937 â”‚     }
  938 â”‚     
  939 â”‚     // Para cada noite, verificar o preÃ§o aplicÃ¡vel (preÃ§o base ou sazonal)
  940 â”‚     // ComeÃ§amos exatamente do dia de check-in
  941 â”‚     const currentDate = new Date(checkIn);
  942 â”‚     currentDate.setHours(0, 0, 0, 0); // Normalizar para meia-noite
  943 â”‚     
  944 â”‚     // Processamos cada dia de estadia (noite)
  945 â”‚     console.log(`ğŸ“Š Calculando preÃ§os por noite:`);
  946 â”‚     for (let i = 0; i < noites; i++) {
  947 â”‚       // Obtemos o preÃ§o para esta data
  948 â”‚       const dateCopy = new Date(currentDate);
  949 â”‚       const priceForDate = await getRoomPriceForDate(roomId, dateCopy);
  950 â”‚       const dateString = dateCopy.toISOString().split('T')[0]; // YYYY-MM-DD
  951 â”‚       
  952 â”‚       console.log(`   - ${dateString}: â‚¬${priceForDate}`);
  953 â”‚       
  954 â”‚       nightlyPrices.push({
  955 â”‚         date: dateString,
  956 â”‚         price: priceForDate
  957 â”‚       });
  958 â”‚       
  959 â”‚       totalPrice += priceForDate;
  960 â”‚       
  961 â”‚       // AvanÃ§amos para o prÃ³ximo dia
  962 â”‚       currentDate.setDate(currentDate.getDate() + 1);
  963 â”‚     }
  964 â”‚     
  965 â”‚     // VerificaÃ§Ã£o de seguranÃ§a para o cÃ¡lculo do totalPrice
  966 â”‚     const manualTotal = nightlyPrices.reduce((sum, night) => sum + night.price, 0);
  967 â”‚     if (Math.abs(totalPrice - manualTotal) > 1) {
  968 â”‚       console.error(`âš ï¸ DiscrepÃ¢ncia detectada no cÃ¡lculo do preÃ§o total!`);
  969 â”‚       console.error(`   - Total calculado iterativamente: â‚¬${totalPrice}`);
  970 â”‚       console.error(`   - Total calculado via reduce: â‚¬${manualTotal}`);
  971 â”‚       console.error(`   - Usando o valor recalculado para seguranÃ§a!`);
  972 â”‚       totalPrice = manualTotal;
  973 â”‚     }
  974 â”‚     
  975 â”‚     // Calcular taxa de serviÃ§o
  976 â”‚     const serviceFee = (totalPrice * (roomData.serviceFeePct || 0)) / 100;
  977 â”‚     const totalWithFee = totalPrice + serviceFee;
  978 â”‚     
  979 â”‚     console.log(`ğŸ’° Resumo do cÃ¡lculo:`);
  980 â”‚     console.log(`   - Total das diÃ¡rias: â‚¬${totalPrice}`);
  981 â”‚     console.log(`   - Taxa de serviÃ§o (${roomData.serviceFeePct || 0}%): â‚¬${serviceFee}`);
  982 â”‚     console.log(`   - Total com taxas: â‚¬${totalWithFee}`);
  983 â”‚     
  984 â”‚     return {
  985 â”‚       totalPrice,
  986 â”‚       nightlyPrices,
  987 â”‚       serviceFee,
  988 â”‚       totalWithFee
  989 â”‚     };
  990 â”‚   } catch (error) {
  991 â”‚     console.error("âŒ Erro ao calcular preÃ§o da estadia:", error);
  992 â”‚     throw error;
  993 â”‚   }
  994 â”‚ } 
  995 â”‚ import { 
  996 â”‚   collection, 
  997 â”‚   getDocs, 
  998 â”‚   getDoc, 
  999 â”‚   doc, 
 1000 â”‚   setDoc, 
 1001 â”‚   addDoc, 
 1002 â”‚   updateDoc, 
 1003 â”‚   deleteDoc,
 1004 â”‚   query,
 1005 â”‚   where,
 1006 â”‚   orderBy,
 1007 â”‚   limit,
 1008 â”‚   serverTimestamp
 1009 â”‚ } from 'firebase/firestore';
 1010 â”‚ import { db } from './config';
 1011 â”‚ 
 1012 â”‚ // Get all documents from a collection
 1013 â”‚ export async function getDocuments<T>(collectionName: string, forceRefresh = false): Promise<T[]> {
 1014 â”‚   console.log(`Buscando documentos na coleÃ§Ã£o ${collectionName} - ForÃ§a atualizaÃ§Ã£o: ${forceRefresh}`);
 1015 â”‚   try {
 1016 â”‚     const querySnapshot = await getDocs(collection(db, collectionName));
 1017 â”‚     return querySnapshot.docs.map(doc => ({
 1018 â”‚       id: doc.id,
 1019 â”‚       ...doc.data()
 1020 â”‚     })) as T[];
 1021 â”‚   } catch (error) {
 1022 â”‚     console.error('Erro ao buscar documentos:', error);
 1023 â”‚     return [];
 1024 â”‚   }
 1025 â”‚ }
 1026 â”‚ 
 1027 â”‚ // Get a document by ID
 1028 â”‚ export async function getDocumentById<T>(collectionName: string, docId: string): Promise<T | null> {
 1029 â”‚   try {
 1030 â”‚     const docRef = doc(db, collectionName, docId);
 1031 â”‚     const docSnap = await getDoc(docRef);
 1032 â”‚     
 1033 â”‚     if (docSnap.exists()) {
 1034 â”‚       return {
 1035 â”‚         id: docSnap.id,
 1036 â”‚         ...docSnap.data()
 1037 â”‚       } as T;
 1038 â”‚     } else {
 1039 â”‚       return null;
 1040 â”‚     }
 1041 â”‚   } catch (error) {
 1042 â”‚     console.error('Erro ao buscar documento:', error);
 1043 â”‚     return null;
 1044 â”‚   }
 1045 â”‚ }
 1046 â”‚ 
 1047 â”‚ // Add a new document
 1048 â”‚ export async function addDocument<T>(collectionName: string, data: any): Promise<T | null> {
 1049 â”‚   try {
 1050 â”‚     const docRef = await addDoc(collection(db, collectionName), {
 1051 â”‚       ...data,
 1052 â”‚       createdAt: serverTimestamp()
 1053 â”‚     });
 1054 â”‚     
 1055 â”‚     return {
 1056 â”‚       id: docRef.id,
 1057 â”‚       ...data
 1058 â”‚     } as T;
 1059 â”‚   } catch (error) {
 1060 â”‚     console.error('Erro ao adicionar documento:', error);
 1061 â”‚     return null;
 1062 â”‚   }
 1063 â”‚ }
 1064 â”‚ 
 1065 â”‚ // Update a document
 1066 â”‚ export async function updateDocument(collectionName: string, docId: string, data: any): Promise<boolean> {
      Â·                       â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€
      Â·                              â•°â”€â”€ `updateDocument` redefined here
 1067 â”‚   try {
 1068 â”‚     const docRef = doc(db, collectionName, docId);
 1069 â”‚     await updateDoc(docRef, {
      â•°â”€â”€â”€â”€

  Ã— the name `deleteDocument` is defined multiple times
      â•­â”€[/home/runner/workspace/lib/firebase/firestore.ts:145:1]
  145 â”‚   })
  146 â”‚ }
  147 â”‚ 
  148 â”‚ export const deleteDocument = async (
      Â·              â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€
      Â·                     â•°â”€â”€ previous definition of `deleteDocument` here
  149 â”‚   collectionName: string,
  150 â”‚   id: string
  151 â”‚ ): Promise<boolean> => {
  152 â”‚   const docRef = doc(db, collectionName, id)
  153 â”‚   await deleteDoc(docRef)
  154 â”‚   return true
  155 â”‚ }
  156 â”‚ 
  157 â”‚ // FunÃ§Ãµes para gerenciar quartos
  158 â”‚ export const getRooms = async (forceRefresh = false): Promise<Room[]> => {
  159 â”‚   try {
  160 â”‚     const constraints: QueryConstraint[] = []
  161 â”‚     
  162 â”‚     constraints.push(orderBy('name', 'asc'))
  163 â”‚     
  164 â”‚     const rooms = await getDocuments<Room>('rooms', constraints, forceRefresh)
  165 â”‚     
  166 â”‚     // Garantir que todos os campos necessÃ¡rios estejam presentes
  167 â”‚     return rooms.map(room => {
  168 â”‚       console.log(`Firebase - Quarto ${room.id} dados brutos:`, room);
  169 â”‚       
  170 â”‚       // Garantir que serviceFeePct seja um nÃºmero
  171 â”‚       const serviceFeePct = room.serviceFeePct !== undefined 
  172 â”‚         ? Number(room.serviceFeePct) 
  173 â”‚         : 10;
  174 â”‚         
  175 â”‚       console.log(`Firebase - Quarto ${room.id} serviceFeePct:`, {
  176 â”‚         original: room.serviceFeePct,
  177 â”‚         tipo: typeof room.serviceFeePct,
  178 â”‚         convertido: serviceFeePct
  179 â”‚       });
  180 â”‚       
  181 â”‚       return {
  182 â”‚         id: room.id,
  183 â”‚         name: room.name || '',
  184 â”‚         type: room.type || 'standard',
  185 â”‚         description: room.description || '',
  186 â”‚         price: room.price || 0,
  187 â”‚         capacity: room.capacity || 2,
  188 â”‚         size: room.size || 0,
  189 â”‚         available: room.available !== undefined ? room.available : true,
  190 â”‚         serviceFeePct: serviceFeePct,
  191 â”‚         images: room.images || [],
  192 â”‚         amenities: room.amenities || [],
  193 â”‚         additionalServices: room.additionalServices || [],
  194 â”‚         highlights: room.highlights || [],
  195 â”‚         createdAt: room.createdAt,
  196 â”‚         updatedAt: room.updatedAt
  197 â”‚       };
  198 â”‚     });
  199 â”‚   } catch (error) {
  200 â”‚     console.error('Erro ao buscar quartos:', error)
  201 â”‚     return []
  202 â”‚   }
  203 â”‚ }
  204 â”‚ 
  205 â”‚ export const getAvailableRooms = async (
  206 â”‚   checkIn: Date,
  207 â”‚   checkOut: Date
  208 â”‚ ): Promise<Room[]> => {
  209 â”‚   try {
  210 â”‚     // Buscar todos os quartos que estÃ£o marcados como disponÃ­veis em geral
  211 â”‚     const constraints: QueryConstraint[] = [
  212 â”‚       where('available', '==', true)
  213 â”‚     ]
  214 â”‚     
  215 â”‚     const rooms = await getDocuments<Room>('rooms', constraints);
  216 â”‚     
  217 â”‚     // Filtrar os quartos que estÃ£o disponÃ­veis nas datas especÃ­ficas
  218 â”‚     return filterAvailableRoomsByDate(rooms, checkIn, checkOut);
  219 â”‚   } catch (error) {
  220 â”‚     console.error('Erro ao buscar quartos disponÃ­veis:', error)
  221 â”‚     return []
  222 â”‚   }
  223 â”‚ }
  224 â”‚ 
  225 â”‚ // FunÃ§Ã£o auxiliar para verificar disponibilidade entre datas
  226 â”‚ export const filterAvailableRoomsByDate = (
  227 â”‚   rooms: Room[],
  228 â”‚   checkIn: Date,
  229 â”‚   checkOut: Date
  230 â”‚ ): Room[] => {
  231 â”‚   // Converter checkIn e checkOut para ISO strings
  232 â”‚   const dateStrings = getDatesInRange(checkIn, checkOut);
  233 â”‚   
  234 â”‚   return rooms.filter(room => {
  235 â”‚     // Se nÃ£o tiver controle de disponibilidade especÃ­fico, considera disponÃ­vel
  236 â”‚     if (!room.availabilityDates) return true;
  237 â”‚     
  238 â”‚     // Verificar se alguma data no intervalo estÃ¡ indisponÃ­vel
  239 â”‚     return !dateStrings.some(dateStr => 
  240 â”‚       room.availabilityDates?.[dateStr] === false
  241 â”‚     );
  242 â”‚   });
  243 â”‚ };
  244 â”‚ 
  245 â”‚ // FunÃ§Ã£o para obter disponibilidade de um quarto especÃ­fico
  246 â”‚ export const getRoomAvailability = async (
  247 â”‚   roomId: string, 
  248 â”‚   startDate: Date, 
  249 â”‚   endDate: Date
  250 â”‚ ): Promise<{[date: string]: boolean}> => {
  251 â”‚   try {
  252 â”‚     const room = await getRoomById(roomId);
  253 â”‚     if (!room) throw new Error(`Quarto com ID ${roomId} nÃ£o encontrado`);
  254 â”‚     
  255 â”‚     // Gerar datas no intervalo
  256 â”‚     const dateStrings = getDatesInRange(startDate, endDate);
  257 â”‚     
  258 â”‚     // Se nÃ£o tiver configuraÃ§Ã£o de disponibilidade especÃ­fica, assume tudo disponÃ­vel
  259 â”‚     if (!room.availabilityDates) {
  260 â”‚       return dateStrings.reduce((acc, date) => {
  261 â”‚         acc[date] = true;
  262 â”‚         return acc;
  263 â”‚       }, {} as {[date: string]: boolean});
  264 â”‚     }
  265 â”‚     
  266 â”‚     // Preencher com os dados de disponibilidade existentes
  267 â”‚     return dateStrings.reduce((acc, date) => {
  268 â”‚       acc[date] = room.availabilityDates?.[date] !== false; // disponÃ­vel por padrÃ£o se nÃ£o estiver explicitamente indisponÃ­vel
  269 â”‚       return acc;
  270 â”‚     }, {} as {[date: string]: boolean});
  271 â”‚   } catch (error) {
  272 â”‚     console.error(`Erro ao verificar disponibilidade do quarto ${roomId}:`, error);
  273 â”‚     throw error;
  274 â”‚   }
  275 â”‚ };
  276 â”‚ 
  277 â”‚ // FunÃ§Ã£o para atualizar disponibilidade de um quarto
  278 â”‚ export const updateRoomAvailability = async (
  279 â”‚   roomId: string,
  280 â”‚   availabilityDates: {[date: string]: boolean}
  281 â”‚ ): Promise<boolean> => {
  282 â”‚   try {
  283 â”‚     await updateDocument('rooms', roomId, {
  284 â”‚       availabilityDates,
  285 â”‚       updatedAt: serverTimestamp()
  286 â”‚     });
  287 â”‚     return true;
  288 â”‚   } catch (error) {
  289 â”‚     console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  290 â”‚     return false;
  291 â”‚   }
  292 â”‚ };
  293 â”‚ 
  294 â”‚ // FunÃ§Ã£o auxiliar para gerar array de strings de data entre um intervalo
  295 â”‚ export const getDatesInRange = (startDate: Date, endDate: Date): string[] => {
  296 â”‚   const dates: string[] = [];
  297 â”‚   const currentDate = new Date(startDate);
  298 â”‚   
  299 â”‚   // Normalizar para meia-noite no fuso horÃ¡rio local
  300 â”‚   currentDate.setHours(0, 0, 0, 0);
  301 â”‚   const endDateNormalized = new Date(endDate);
  302 â”‚   endDateNormalized.setHours(0, 0, 0, 0);
  303 â”‚   
  304 â”‚   // Adicionar cada data no intervalo EXCETO o dia de checkout
  305 â”‚   // Usando < em vez de <= para nÃ£o incluir o dia de checkout
  306 â”‚   while (currentDate < endDateNormalized) {
  307 â”‚     dates.push(currentDate.toISOString().split('T')[0]); // Formato YYYY-MM-DD
  308 â”‚     currentDate.setDate(currentDate.getDate() + 1);
  309 â”‚   }
  310 â”‚   
  311 â”‚   return dates;
  312 â”‚ };
  313 â”‚ 
  314 â”‚ export const getRoomById = async (id: string): Promise<Room | null> => {
  315 â”‚   try {
  316 â”‚     const room = await getDocument<Room>('rooms', id);
  317 â”‚     
  318 â”‚     if (!room) return null;
  319 â”‚     
  320 â”‚     console.log(`Firebase - getRoomById ${id} dados brutos:`, room);
  321 â”‚     
  322 â”‚     // Log especÃ­fico para serviceFeePct
  323 â”‚     console.log(`serviceFeePct no Firestore:`, room.serviceFeePct);
  324 â”‚     
  325 â”‚     // Garantir que todos os campos necessÃ¡rios estejam presentes
  326 â”‚     return {
  327 â”‚       ...room,
  328 â”‚       name: room.name || '',
  329 â”‚       type: room.type || 'standard',
  330 â”‚       description: room.description || '',
  331 â”‚       price: room.price || 0,
  332 â”‚       capacity: room.capacity || 2,
  333 â”‚       size: room.size || 0,
  334 â”‚       available: room.available !== undefined ? room.available : true,
  335 â”‚       serviceFeePct: room.serviceFeePct !== undefined ? room.serviceFeePct : 10,
  336 â”‚       images: room.images || [],
  337 â”‚       amenities: room.amenities || [],
  338 â”‚       additionalServices: room.additionalServices || [],
  339 â”‚       highlights: room.highlights || []
  340 â”‚     };
  341 â”‚   } catch (error) {
  342 â”‚     console.error(`Erro ao buscar quarto com ID ${id}:`, error);
  343 â”‚     return null;
  344 â”‚   }
  345 â”‚ }
  346 â”‚ 
  347 â”‚ export const createRoom = async (roomData: Omit<Room, 'id' | 'createdAt' | 'updatedAt'>): Promise<Room> => {
  348 â”‚   try {
  349 â”‚     console.log("createRoom - Dados recebidos:", roomData);
  350 â”‚     
  351 â”‚     const roomWithTimestamps = {
  352 â”‚       ...roomData,
  353 â”‚       available: roomData.available !== undefined ? roomData.available : true,
  354 â”‚       featured: roomData.featured || false,
  355 â”‚       amenities: roomData.amenities || [],
  356 â”‚       additionalServices: roomData.additionalServices || [],
  357 â”‚       highlights: roomData.highlights || [],
  358 â”‚       createdAt: serverTimestamp(),
  359 â”‚       updatedAt: serverTimestamp()
  360 â”‚     }
  361 â”‚     
  362 â”‚     console.log("createRoom - Dados a serem salvos:", roomWithTimestamps);
  363 â”‚     
  364 â”‚     const id = await createDocument('rooms', roomWithTimestamps)
  365 â”‚     
  366 â”‚     return {
  367 â”‚       id,
  368 â”‚       ...roomData,
  369 â”‚       amenities: roomData.amenities || [],
  370 â”‚       additionalServices: roomData.additionalServices || [],
  371 â”‚       highlights: roomData.highlights || [],
  372 â”‚       createdAt: Timestamp.now(),
  373 â”‚       updatedAt: Timestamp.now()
  374 â”‚     }
  375 â”‚   } catch (error) {
  376 â”‚     console.error('Erro ao criar quarto:', error)
  377 â”‚     throw error
  378 â”‚   }
  379 â”‚ }
  380 â”‚ 
  381 â”‚ export const updateRoom = async (id: string, roomData: Partial<Omit<Room, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Room> => {
  382 â”‚   try {
  383 â”‚     console.log(`updateRoom - ID: ${id}, Dados recebidos:`, roomData);
  384 â”‚     
  385 â”‚     // Garantir que estamos lidando explicitamente com o serviceFeePct se ele for 0
  386 â”‚     if (roomData.serviceFeePct === 0) {
  387 â”‚       console.log("updateRoom - Detectado serviceFeePct com valor 0, salvando explicitamente.", roomData.serviceFeePct);
  388 â”‚     }
  389 â”‚     
  390 â”‚     // Adicionar timestamp de atualizaÃ§Ã£o
  391 â”‚     const roomWithTimestamp = {
  392 â”‚       ...roomData,
  393 â”‚       amenities: roomData.amenities || [],
  394 â”‚       additionalServices: roomData.additionalServices || [],
  395 â”‚       highlights: roomData.highlights || [],
  396 â”‚       updatedAt: serverTimestamp()
  397 â”‚     }
  398 â”‚     
  399 â”‚     console.log(`updateRoom - Dados a serem salvos:`, roomWithTimestamp);
  400 â”‚     
  401 â”‚     await updateDocument('rooms', id, roomWithTimestamp)
  402 â”‚     
  403 â”‚     const updatedRoom = await getRoomById(id)
  404 â”‚     if (!updatedRoom) {
  405 â”‚       throw new Error(`Quarto com ID ${id} nÃ£o encontrado apÃ³s atualizaÃ§Ã£o`)
  406 â”‚     }
  407 â”‚     
  408 â”‚     return updatedRoom
  409 â”‚   } catch (error) {
  410 â”‚     console.error('Erro ao atualizar quarto:', error)
  411 â”‚     throw error
  412 â”‚   }
  413 â”‚ }
  414 â”‚ 
  415 â”‚ export const deleteRoom = async (id: string): Promise<boolean> => {
  416 â”‚   return await deleteDocument('rooms', id)
  417 â”‚ }
  418 â”‚ 
  419 â”‚ // FunÃ§Ãµes especÃ­ficas para reservas
  420 â”‚ export const createBooking = async (bookingData: any) => {
  421 â”‚   try {
  422 â”‚     const bookingsCollection = collection(db, 'bookings');
  423 â”‚     const docRef = await addDoc(bookingsCollection, bookingData);
  424 â”‚     
  425 â”‚     // CORREÃ‡ÃƒO: NÃ£o bloquear a data no momento da criaÃ§Ã£o da reserva
  426 â”‚     // O bloqueio serÃ¡ feito apenas quando o pagamento for confirmado
  427 â”‚     // atravÃ©s da funÃ§Ã£o updateBookingStatus
  428 â”‚     
  429 â”‚     return docRef;
  430 â”‚   } catch (error) {
  431 â”‚     console.error('Erro ao criar reserva:', error);
  432 â”‚     throw error;
  433 â”‚   }
  434 â”‚ };
  435 â”‚ 
  436 â”‚ // Nova funÃ§Ã£o para atualizar status da reserva e bloquear as datas da estadia
  437 â”‚ export const updateBookingStatus = async (
  438 â”‚   bookingId: string, 
  439 â”‚   newStatus: 'pending' | 'confirmed' | 'cancelled' | 'completed',
  440 â”‚   newPaymentStatus: 'pending' | 'paid' | 'refunded'
  441 â”‚ ): Promise<boolean> => {
  442 â”‚   try {
  443 â”‚     // ReferÃªncia ao documento da reserva
  444 â”‚     const bookingRef = doc(db, 'bookings', bookingId);
  445 â”‚     const bookingSnap = await getDoc(bookingRef);
  446 â”‚     
  447 â”‚     if (!bookingSnap.exists()) {
  448 â”‚       console.error(`Booking ${bookingId} nÃ£o existe ao atualizar status`);
  449 â”‚       return false;
  450 â”‚     }
  451 â”‚     
  452 â”‚     const bookingData = bookingSnap.data();
  453 â”‚     
  454 â”‚     // Atualizar o status da reserva
  455 â”‚     await updateDoc(bookingRef, {
  456 â”‚       status: newStatus,
  457 â”‚       paymentStatus: newPaymentStatus,
  458 â”‚       updatedAt: serverTimestamp(),
  459 â”‚       ...(newStatus === 'confirmed' && { confirmedAt: serverTimestamp() })
  460 â”‚     });
  461 â”‚     
  462 â”‚     // Se a reserva estÃ¡ sendo confirmada, precisamos bloquear as datas
  463 â”‚     if (newStatus === 'confirmed') {
  464 â”‚       console.log(`Atualizando disponibilidade para reserva confirmada: ${bookingId}`);
  465 â”‚       
  466 â”‚       // Recuperar datas de check-in e check-out
  467 â”‚       const checkIn = bookingData.checkIn.toDate();
  468 â”‚       const checkOut = bookingData.checkOut.toDate();
  469 â”‚       const roomId = bookingData.roomId;
  470 â”‚       
  471 â”‚       // Obter todas as datas entre check-in e check-out
  472 â”‚       const dates: Date[] = [];
  473 â”‚       const currentDate = new Date(checkIn);
  474 â”‚       
  475 â”‚       while (currentDate < checkOut) {
  476 â”‚         dates.push(new Date(currentDate));
  477 â”‚         currentDate.setDate(currentDate.getDate() + 1);
  478 â”‚       }
  479 â”‚       
  480 â”‚       console.log(`Bloqueando ${dates.length} dias para quarto ${roomId}`);
  481 â”‚       
  482 â”‚       // Atualizar disponibilidade para cada data
  483 â”‚       const availabilityUpdates: {[date: string]: boolean} = {};
  484 â”‚       
  485 â”‚       dates.forEach(date => {
  486 â”‚         const dateString = date.toISOString().split('T')[0]; // formato YYYY-MM-DD
  487 â”‚         availabilityUpdates[dateString] = false; // false significa indisponÃ­vel
  488 â”‚       });
  489 â”‚       
  490 â”‚       // Atualizar disponibilidade do quarto
  491 â”‚       if (Object.keys(availabilityUpdates).length > 0) {
  492 â”‚         try {
  493 â”‚           // Obter o documento do quarto
  494 â”‚           const roomRef = doc(db, 'rooms', roomId);
  495 â”‚           const roomSnap = await getDoc(roomRef);
  496 â”‚           
  497 â”‚           if (roomSnap.exists()) {
  498 â”‚             const roomData = roomSnap.data();
  499 â”‚             const currentAvailability = roomData.availabilityDates || {};
  500 â”‚             
  501 â”‚             // Mesclar a disponibilidade atual com as novas atualizaÃ§Ãµes
  502 â”‚             const updatedAvailability = {
  503 â”‚               ...currentAvailability,
  504 â”‚               ...availabilityUpdates
  505 â”‚             };
  506 â”‚             
  507 â”‚             // Atualizar o documento do quarto
  508 â”‚             await updateDoc(roomRef, {
  509 â”‚               availabilityDates: updatedAvailability,
  510 â”‚               updatedAt: serverTimestamp()
  511 â”‚             });
  512 â”‚             
  513 â”‚             console.log(`Disponibilidade atualizada com sucesso para quarto ${roomId}`);
  514 â”‚             
  515 â”‚             // Criar log da reserva
  516 â”‚             await addDoc(collection(db, 'bookingLogs'), {
  517 â”‚               bookingId,
  518 â”‚               roomId,
  519 â”‚               action: 'status_updated',
  520 â”‚               previousStatus: bookingData.status,
  521 â”‚               newStatus,
  522 â”‚               previousPaymentStatus: bookingData.paymentStatus,
  523 â”‚               newPaymentStatus,
  524 â”‚               datesBlocked: Object.keys(availabilityUpdates),
  525 â”‚               timestamp: serverTimestamp(),
  526 â”‚               userId: bookingData.userId || 'system'
  527 â”‚             });
  528 â”‚           } else {
  529 â”‚             console.error(`Quarto ${roomId} nÃ£o encontrado ao atualizar disponibilidade`);
  530 â”‚           }
  531 â”‚         } catch (error) {
  532 â”‚           console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  533 â”‚         }
  534 â”‚       }
  535 â”‚     }
  536 â”‚     
  537 â”‚     return true;
  538 â”‚   } catch (error) {
  539 â”‚     console.error(`Erro ao atualizar status da reserva ${bookingId}:`, error);
  540 â”‚     return false;
  541 â”‚   }
  542 â”‚ }
  543 â”‚ 
  544 â”‚ export const getUserBookings = async (userId: string): Promise<Booking[]> => {
  545 â”‚   return getDocuments<Booking>('bookings', [
  546 â”‚     where('userId', '==', userId),
  547 â”‚     orderBy('createdAt', 'desc')
  548 â”‚   ])
  549 â”‚ }
  550 â”‚ 
  551 â”‚ export const getRecentBookings = async (count = 5): Promise<Booking[]> => {
  552 â”‚   return getDocuments<Booking>('bookings', [
  553 â”‚     orderBy('createdAt', 'desc'),
  554 â”‚     limit(count)
  555 â”‚   ])
  556 â”‚ }
  557 â”‚ 
  558 â”‚ export const getRoomBookings = async (roomId: string): Promise<Booking[]> => {
  559 â”‚   try {
  560 â”‚     const constraints: QueryConstraint[] = [
  561 â”‚       where('roomId', '==', roomId),
  562 â”‚       orderBy('checkIn', 'asc')
  563 â”‚     ];
  564 â”‚     
  565 â”‚     return await getDocuments<Booking>('bookings', constraints);
  566 â”‚   } catch (error) {
  567 â”‚     console.error(`Erro ao buscar reservas do quarto ${roomId}:`, error);
  568 â”‚     return [];
  569 â”‚   }
  570 â”‚ };
  571 â”‚ 
  572 â”‚ // FunÃ§Ãµes especÃ­ficas para contatos
  573 â”‚ export const createContactMessage = async (contactData: Contact) => {
  574 â”‚   try {
  575 â”‚     const contactsCollection = collection(db, 'contacts')
  576 â”‚     
  577 â”‚     // Garantir que o status seja 'new' para novos contatos
  578 â”‚     const contactWithDefaults = {
  579 â”‚       ...contactData,
  580 â”‚       status: contactData.status || 'new',
  581 â”‚       createdAt: contactData.createdAt || Timestamp.now()
  582 â”‚     }
  583 â”‚     
  584 â”‚     // Se tiver detalhes de reserva, adicionar metadados
  585 â”‚     if (contactWithDefaults.reservationDetails) {
  586 â”‚       // Ajustar subject para indicar que Ã© relacionado a reserva
  587 â”‚       if (!contactWithDefaults.subject.includes('Reserva')) {
  588 â”‚         contactWithDefaults.subject = `Reserva: ${contactWithDefaults.subject}`;
  589 â”‚       }
  590 â”‚     }
  591 â”‚     
  592 â”‚     const docRef = await addDoc(contactsCollection, contactWithDefaults)
  593 â”‚     return docRef
  594 â”‚   } catch (error) {
  595 â”‚     console.error('Erro ao criar mensagem de contato:', error)
  596 â”‚     throw error
  597 â”‚   }
  598 â”‚ }
  599 â”‚ 
  600 â”‚ export const getNewContactMessages = async (): Promise<Contact[]> => {
  601 â”‚   return getDocuments<Contact>('contacts', [
  602 â”‚     where('status', '==', 'new'),
  603 â”‚     orderBy('createdAt', 'desc')
  604 â”‚   ])
  605 â”‚ }
  606 â”‚ 
  607 â”‚ // FunÃ§Ãµes para Dashboard com dados reais
  608 â”‚ 
  609 â”‚ export const getDashboardStats = async () => {
  610 â”‚   try {
  611 â”‚     const [totalBookings, totalRevenue, occupancyRate, bookingsByPlatform] = await Promise.all([
  612 â”‚       getTotalBookings(),
  613 â”‚       getMonthlyRevenue(),
  614 â”‚       getOccupancyRate(),
  615 â”‚       getBookingsByPlatform()
  616 â”‚     ]);
  617 â”‚ 
  618 â”‚     return {
  619 â”‚       totalBookings,
  620 â”‚       totalRevenue,
  621 â”‚       occupancyRate,
  622 â”‚       bookingsByPlatform
  623 â”‚     };
  624 â”‚   } catch (error) {
  625 â”‚     console.error('Erro ao obter estatÃ­sticas do dashboard:', error);
  626 â”‚     throw error;
  627 â”‚   }
  628 â”‚ };
  629 â”‚ 
  630 â”‚ // Obter total de reservas
  631 â”‚ export const getTotalBookings = async () => {
  632 â”‚   try {
  633 â”‚     // Obter todas as reservas
  634 â”‚     const bookings = await getDocuments<Booking>('bookings');
  635 â”‚     
  636 â”‚     // Contar reservas por status
  637 â”‚     const confirmed = bookings.filter(b => b.status === 'confirmed').length;
  638 â”‚     const pending = bookings.filter(b => b.status === 'pending').length;
  639 â”‚     const cancelled = bookings.filter(b => b.status === 'cancelled').length;
  640 â”‚     const completed = bookings.filter(b => b.status === 'completed').length;
  641 â”‚     
  642 â”‚     // Calcular crescimento em relaÃ§Ã£o ao mÃªs anterior (simulado por enquanto)
  643 â”‚     // Em uma implementaÃ§Ã£o real, vocÃª compararia com dados do mÃªs anterior
  644 â”‚     const growth = ((confirmed + completed) / (bookings.length || 1) * 100) - 50;
  645 â”‚     
  646 â”‚     return {
  647 â”‚       total: bookings.length,
  648 â”‚       confirmed,
  649 â”‚       pending,
  650 â”‚       cancelled,
  651 â”‚       completed,
  652 â”‚       growth: Math.round(growth) // Arredonda para nÃºmero inteiro
  653 â”‚     };
  654 â”‚   } catch (error) {
  655 â”‚     console.error('Erro ao obter total de reservas:', error);
  656 â”‚     return {
  657 â”‚       total: 0,
  658 â”‚       confirmed: 0,
  659 â”‚       pending: 0, 
  660 â”‚       cancelled: 0,
  661 â”‚       completed: 0,
  662 â”‚       growth: 0
  663 â”‚     };
  664 â”‚   }
  665 â”‚ };
  666 â”‚ 
  667 â”‚ // Obter receita mensal
  668 â”‚ export const getMonthlyRevenue = async () => {
  669 â”‚   try {
  670 â”‚     const bookings = await getDocuments<Booking>('bookings');
  671 â”‚     
  672 â”‚     // Filtrar reservas confirmadas e concluÃ­das
  673 â”‚     const validBookings = bookings.filter(b => 
  674 â”‚       b.status === 'confirmed' || b.status === 'completed'
  675 â”‚     );
  676 â”‚     
  677 â”‚     // Calcular receita total
  678 â”‚     const totalRevenue = validBookings.reduce((acc, booking) => acc + booking.totalPrice, 0);
  679 â”‚     
  680 â”‚     // Agrupar receita por mÃªs
  681 â”‚     const revenueByMonth = validBookings.reduce((acc, booking) => {
  682 â”‚       const date = booking.checkIn.toDate();
  683 â”‚       const month = date.getMonth(); // 0-11
  684 â”‚       const year = date.getFullYear();
  685 â”‚       const key = `${year}-${month}`;
  686 â”‚       
  687 â”‚       if (!acc[key]) {
  688 â”‚         acc[key] = 0;
  689 â”‚       }
  690 â”‚       acc[key] += booking.totalPrice;
  691 â”‚       return acc;
  692 â”‚     }, {} as Record<string, number>);
  693 â”‚     
  694 â”‚     // Converter para formato de array para grÃ¡fico
  695 â”‚     const monthNames = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
  696 â”‚     
  697 â”‚     const currentDate = new Date();
  698 â”‚     const currentMonth = currentDate.getMonth();
  699 â”‚     const currentYear = currentDate.getFullYear();
  700 â”‚     
  701 â”‚     const revenueData = [];
  702 â”‚     
  703 â”‚     // Gerar dados dos Ãºltimos 12 meses
  704 â”‚     for (let i = 0; i < 12; i++) {
  705 â”‚       const month = (currentMonth - i + 12) % 12;
  706 â”‚       const year = currentMonth - i < 0 ? currentYear - 1 : currentYear;
  707 â”‚       const key = `${year}-${month}`;
  708 â”‚       
  709 â”‚       revenueData.unshift({
  710 â”‚         month: monthNames[month],
  711 â”‚         value: revenueByMonth[key] || 0
  712 â”‚       });
  713 â”‚     }
  714 â”‚     
  715 â”‚     // Calcular crescimento em relaÃ§Ã£o ao mÃªs anterior
  716 â”‚     const lastMonthRevenue = revenueData[revenueData.length - 2]?.value || 0;
  717 â”‚     const currentMonthRevenue = revenueData[revenueData.length - 1]?.value || 0;
  718 â”‚     
  719 â”‚     const growth = lastMonthRevenue ? ((currentMonthRevenue - lastMonthRevenue) / lastMonthRevenue) * 100 : 0;
  720 â”‚     
  721 â”‚     return {
  722 â”‚       monthly: currentMonthRevenue,
  723 â”‚       total: totalRevenue,
  724 â”‚       growth: Math.round(growth),
  725 â”‚       revenueData
  726 â”‚     };
  727 â”‚   } catch (error) {
  728 â”‚     console.error('Erro ao obter receita mensal:', error);
  729 â”‚     return {
  730 â”‚       monthly: 0,
  731 â”‚       total: 0,
  732 â”‚       growth: 0,
  733 â”‚       revenueData: []
  734 â”‚     };
  735 â”‚   }
  736 â”‚ };
  737 â”‚ 
  738 â”‚ // Calcular taxa de ocupaÃ§Ã£o
  739 â”‚ export const getOccupancyRate = async () => {
  740 â”‚   try {
  741 â”‚     // Obter todos os quartos
  742 â”‚     const rooms = await getDocuments<Room>('rooms');
  743 â”‚     const totalRooms = rooms.length;
  744 â”‚     
  745 â”‚     if (totalRooms === 0) {
  746 â”‚       return { rate: 0, growth: 0 };
  747 â”‚     }
  748 â”‚     
  749 â”‚     // Obter todas as reservas
  750 â”‚     const bookings = await getDocuments<Booking>('bookings');
  751 â”‚     
  752 â”‚     // Filtrar reservas confirmadas e concluÃ­das para o mÃªs atual
  753 â”‚     const currentDate = new Date();
  754 â”‚     const currentMonth = currentDate.getMonth();
  755 â”‚     const currentYear = currentDate.getFullYear();
  756 â”‚     
  757 â”‚     const currentMonthBookings = bookings.filter(booking => {
  758 â”‚       const checkInDate = booking.checkIn.toDate();
  759 â”‚       return (
  760 â”‚         (booking.status === 'confirmed' || booking.status === 'completed') &&
  761 â”‚         checkInDate.getMonth() === currentMonth &&
  762 â”‚         checkInDate.getFullYear() === currentYear
  763 â”‚       );
  764 â”‚     });
  765 â”‚     
  766 â”‚     // Calcular dias ocupados por quarto
  767 â”‚     const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
  768 â”‚     const totalPossibleRoomDays = totalRooms * daysInMonth;
  769 â”‚     
  770 â”‚     // Contar dias ocupados (simplificado - em produÃ§Ã£o seria mais complexo)
  771 â”‚     let occupiedDays = 0;
  772 â”‚     
  773 â”‚     currentMonthBookings.forEach(booking => {
  774 â”‚       const checkIn = booking.checkIn.toDate();
  775 â”‚       const checkOut = booking.checkOut.toDate();
  776 â”‚       
  777 â”‚       // Ajustar datas para considerar apenas o mÃªs atual
  778 â”‚       const startDate = new Date(Math.max(
  779 â”‚         checkIn.getTime(),
  780 â”‚         new Date(currentYear, currentMonth, 1).getTime()
  781 â”‚       ));
  782 â”‚       const endDate = new Date(Math.min(
  783 â”‚         checkOut.getTime(),
  784 â”‚         new Date(currentYear, currentMonth + 1, 0).getTime()
  785 â”‚       ));
  786 â”‚       
  787 â”‚       // Calcular dias entre datas (incluindo check-in, excluindo check-out)
  788 â”‚       const days = Math.max(0, Math.floor((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)));
  789 â”‚       occupiedDays += days;
  790 â”‚     });
  791 â”‚     
  792 â”‚     const occupancyRate = (occupiedDays / totalPossibleRoomDays) * 100;
  793 â”‚     
  794 â”‚     // SimulaÃ§Ã£o de crescimento (em produÃ§Ã£o, compararia com mÃªs anterior)
  795 â”‚     const growth = occupancyRate > 50 ? 5 : -3;
  796 â”‚     
  797 â”‚     return {
  798 â”‚       rate: Math.round(occupancyRate),
  799 â”‚       growth: Math.round(growth)
  800 â”‚     };
  801 â”‚   } catch (error) {
  802 â”‚     console.error('Erro ao calcular taxa de ocupaÃ§Ã£o:', error);
  803 â”‚     return { rate: 0, growth: 0 };
  804 â”‚   }
  805 â”‚ };
  806 â”‚ 
  807 â”‚ // Obter reservas agrupadas por plataforma
  808 â”‚ export const getBookingsByPlatform = async () => {
  809 â”‚   try {
  810 â”‚     const bookings = await getDocuments<Booking>('bookings');
  811 â”‚     
  812 â”‚     // Categorizar reservas por origem
  813 â”‚     const platforms = [
  814 â”‚       { 
  815 â”‚         platform: "Booking.com", 
  816 â”‚         color: "#003580", 
  817 â”‚         icon: "Globe",
  818 â”‚         bookings: []
  819 â”‚       },
  820 â”‚       { 
  821 â”‚         platform: "Airbnb", 
  822 â”‚         color: "#FF5A5F", 
  823 â”‚         icon: "Heart",
  824 â”‚         bookings: []
  825 â”‚       },
  826 â”‚       { 
  827 â”‚         platform: "Direto", 
  828 â”‚         color: "#4CAF50", 
  829 â”‚         icon: "Home",
  830 â”‚         bookings: []
  831 â”‚       }
  832 â”‚     ];
  833 â”‚     
  834 â”‚     // Para fins de demonstraÃ§Ã£o, colocar todas as reservas como "Direto" por enquanto
  835 â”‚     // Em produÃ§Ã£o, usaria um campo "platformOrigin" ou similar na tabela de reservas
  836 â”‚     const platformIndex = 2; // Ãndice da plataforma "Direto"
  837 â”‚     
  838 â”‚     bookings.forEach(booking => {
  839 â”‚       // Transformar para o formato esperado pelo componente
  840 â”‚       const transformedBooking = {
  841 â”‚         id: booking.id || '',
  842 â”‚         guestName: booking.guestName,
  843 â”‚         roomName: booking.roomName,
  844 â”‚         checkIn: booking.checkIn.toDate().toLocaleDateString('pt-PT'),
  845 â”‚         checkOut: booking.checkOut.toDate().toLocaleDateString('pt-PT'),
  846 â”‚         status: booking.status,
  847 â”‚         value: new Intl.NumberFormat('pt-PT', {
  848 â”‚           style: 'currency',
  849 â”‚           currency: 'EUR'
  850 â”‚         }).format(booking.totalPrice)
  851 â”‚       };
  852 â”‚       
  853 â”‚       // Adicionar Ã  plataforma "Direto"
  854 â”‚       (platforms[platformIndex] as any).bookings.push(transformedBooking);
  855 â”‚     });
  856 â”‚     
  857 â”‚     return platforms;
  858 â”‚   } catch (error) {
  859 â”‚     console.error('Erro ao obter reservas por plataforma:', error);
  860 â”‚     return [];
  861 â”‚   }
  862 â”‚ };
  863 â”‚ 
  864 â”‚ // FunÃ§Ã£o para obter o preÃ§o de um quarto para uma data especÃ­fica
  865 â”‚ export const getRoomPriceForDate = async (roomId: string, date: Date): Promise<number> => {
  866 â”‚   try {
  867 â”‚     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  868 â”‚     
  869 â”‚     if (!roomDoc.exists()) {
  870 â”‚       throw new Error("Quarto nÃ£o encontrado");
  871 â”‚     }
  872 â”‚     
  873 â”‚     const roomData = roomDoc.data() as Room;
  874 â”‚     const basePrice = roomData.price;
  875 â”‚     
  876 â”‚     if (!roomData.seasonalPrices || roomData.seasonalPrices.length === 0) {
  877 â”‚       return basePrice;
  878 â”‚     }
  879 â”‚     
  880 â”‚     // Verificar se a data estÃ¡ dentro de algum perÃ­odo sazonal
  881 â”‚     for (const seasonalPrice of roomData.seasonalPrices) {
  882 â”‚       const startDate = new Date(seasonalPrice.startDate);
  883 â”‚       const endDate = new Date(seasonalPrice.endDate);
  884 â”‚       
  885 â”‚       if (date >= startDate && date <= endDate) {
  886 â”‚         return seasonalPrice.price;
  887 â”‚       }
  888 â”‚     }
  889 â”‚     
  890 â”‚     // Se nÃ£o cair em nenhum perÃ­odo sazonal, retorna o preÃ§o base
  891 â”‚     return basePrice;
  892 â”‚   } catch (error) {
  893 â”‚     console.error("Erro ao obter preÃ§o do quarto:", error);
  894 â”‚     throw error;
  895 â”‚   }
  896 â”‚ }
  897 â”‚ 
  898 â”‚ // FunÃ§Ã£o para calcular o preÃ§o total de uma estadia
  899 â”‚ export const calculateStayPrice = async (
  900 â”‚   roomId: string, 
  901 â”‚   checkIn: Date, 
  902 â”‚   checkOut: Date
  903 â”‚ ): Promise<{
  904 â”‚   totalPrice: number;
  905 â”‚   nightlyPrices: { date: string; price: number }[];
  906 â”‚   serviceFee: number;
  907 â”‚   totalWithFee: number;
  908 â”‚ }> => {
  909 â”‚   try {
  910 â”‚     console.log(`ğŸ” Iniciando cÃ¡lculo de preÃ§o para estadia: ${checkIn.toISOString().split('T')[0]} atÃ© ${checkOut.toISOString().split('T')[0]}`);
  911 â”‚     
  912 â”‚     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  913 â”‚     
  914 â”‚     if (!roomDoc.exists()) {
  915 â”‚       throw new Error("Quarto nÃ£o encontrado");
  916 â”‚     }
  917 â”‚     
  918 â”‚     const roomData = roomDoc.data() as Room;
  919 â”‚     console.log(`ğŸ“ Dados do quarto ${roomId}:`, {
  920 â”‚       nome: roomData.name,
  921 â”‚       precoBase: roomData.price,
  922 â”‚       taxaServico: roomData.serviceFeePct || 0,
  923 â”‚       temPrecosSazonais: !!roomData.seasonalPrices?.length
  924 â”‚     });
  925 â”‚     
  926 â”‚     const nightlyPrices: { date: string; price: number }[] = [];
  927 â”‚     let totalPrice = 0;
  928 â”‚     
  929 â”‚     // Calcular o nÃºmero de noites - corrigido para usar o mÃ©todo correto de cÃ¡lculo
  930 â”‚     // O nÃºmero de noites Ã© a diferenÃ§a em dias (estadia = checkout - checkin)
  931 â”‚     const noites = differenceInDays(checkOut, checkIn);
  932 â”‚     console.log(`ğŸ—“ï¸ NÃºmero de noites calculado: ${noites}`);
  933 â”‚     
  934 â”‚     if (noites <= 0) {
  935 â”‚       console.error(`âš ï¸ Erro: nÃºmero de noites invÃ¡lido (${noites})`);
  936 â”‚       throw new Error("Data de check-out deve ser posterior Ã  data de check-in");
  937 â”‚     }
  938 â”‚     
  939 â”‚     // Para cada noite, verificar o preÃ§o aplicÃ¡vel (preÃ§o base ou sazonal)
  940 â”‚     // ComeÃ§amos exatamente do dia de check-in
  941 â”‚     const currentDate = new Date(checkIn);
  942 â”‚     currentDate.setHours(0, 0, 0, 0); // Normalizar para meia-noite
  943 â”‚     
  944 â”‚     // Processamos cada dia de estadia (noite)
  945 â”‚     console.log(`ğŸ“Š Calculando preÃ§os por noite:`);
  946 â”‚     for (let i = 0; i < noites; i++) {
  947 â”‚       // Obtemos o preÃ§o para esta data
  948 â”‚       const dateCopy = new Date(currentDate);
  949 â”‚       const priceForDate = await getRoomPriceForDate(roomId, dateCopy);
  950 â”‚       const dateString = dateCopy.toISOString().split('T')[0]; // YYYY-MM-DD
  951 â”‚       
  952 â”‚       console.log(`   - ${dateString}: â‚¬${priceForDate}`);
  953 â”‚       
  954 â”‚       nightlyPrices.push({
  955 â”‚         date: dateString,
  956 â”‚         price: priceForDate
  957 â”‚       });
  958 â”‚       
  959 â”‚       totalPrice += priceForDate;
  960 â”‚       
  961 â”‚       // AvanÃ§amos para o prÃ³ximo dia
  962 â”‚       currentDate.setDate(currentDate.getDate() + 1);
  963 â”‚     }
  964 â”‚     
  965 â”‚     // VerificaÃ§Ã£o de seguranÃ§a para o cÃ¡lculo do totalPrice
  966 â”‚     const manualTotal = nightlyPrices.reduce((sum, night) => sum + night.price, 0);
  967 â”‚     if (Math.abs(totalPrice - manualTotal) > 1) {
  968 â”‚       console.error(`âš ï¸ DiscrepÃ¢ncia detectada no cÃ¡lculo do preÃ§o total!`);
  969 â”‚       console.error(`   - Total calculado iterativamente: â‚¬${totalPrice}`);
  970 â”‚       console.error(`   - Total calculado via reduce: â‚¬${manualTotal}`);
  971 â”‚       console.error(`   - Usando o valor recalculado para seguranÃ§a!`);
  972 â”‚       totalPrice = manualTotal;
  973 â”‚     }
  974 â”‚     
  975 â”‚     // Calcular taxa de serviÃ§o
  976 â”‚     const serviceFee = (totalPrice * (roomData.serviceFeePct || 0)) / 100;
  977 â”‚     const totalWithFee = totalPrice + serviceFee;
  978 â”‚     
  979 â”‚     console.log(`ğŸ’° Resumo do cÃ¡lculo:`);
  980 â”‚     console.log(`   - Total das diÃ¡rias: â‚¬${totalPrice}`);
  981 â”‚     console.log(`   - Taxa de serviÃ§o (${roomData.serviceFeePct || 0}%): â‚¬${serviceFee}`);
  982 â”‚     console.log(`   - Total com taxas: â‚¬${totalWithFee}`);
  983 â”‚     
  984 â”‚     return {
  985 â”‚       totalPrice,
  986 â”‚       nightlyPrices,
  987 â”‚       serviceFee,
  988 â”‚       totalWithFee
  989 â”‚     };
  990 â”‚   } catch (error) {
  991 â”‚     console.error("âŒ Erro ao calcular preÃ§o da estadia:", error);
  992 â”‚     throw error;
  993 â”‚   }
  994 â”‚ } 
  995 â”‚ import { 
  996 â”‚   collection, 
  997 â”‚   getDocs, 
  998 â”‚   getDoc, 
  999 â”‚   doc, 
 1000 â”‚   setDoc, 
 1001 â”‚   addDoc, 
 1002 â”‚   updateDoc, 
 1003 â”‚   deleteDoc,
 1004 â”‚   query,
 1005 â”‚   where,
 1006 â”‚   orderBy,
 1007 â”‚   limit,
 1008 â”‚   serverTimestamp
 1009 â”‚ } from 'firebase/firestore';
 1010 â”‚ import { db } from './config';
 1011 â”‚ 
 1012 â”‚ // Get all documents from a collection
 1013 â”‚ export async function getDocuments<T>(collectionName: string, forceRefresh = false): Promise<T[]> {
 1014 â”‚   console.log(`Buscando documentos na coleÃ§Ã£o ${collectionName} - ForÃ§a atualizaÃ§Ã£o: ${forceRefresh}`);
 1015 â”‚   try {
 1016 â”‚     const querySnapshot = await getDocs(collection(db, collectionName));
 1017 â”‚     return querySnapshot.docs.map(doc => ({
 1018 â”‚       id: doc.id,
 1019 â”‚       ...doc.data()
 1020 â”‚     })) as T[];
 1021 â”‚   } catch (error) {
 1022 â”‚     console.error('Erro ao buscar documentos:', error);
 1023 â”‚     return [];
 1024 â”‚   }
 1025 â”‚ }
 1026 â”‚ 
 1027 â”‚ // Get a document by ID
 1028 â”‚ export async function getDocumentById<T>(collectionName: string, docId: string): Promise<T | null> {
 1029 â”‚   try {
 1030 â”‚     const docRef = doc(db, collectionName, docId);
 1031 â”‚     const docSnap = await getDoc(docRef);
 1032 â”‚     
 1033 â”‚     if (docSnap.exists()) {
 1034 â”‚       return {
 1035 â”‚         id: docSnap.id,
 1036 â”‚         ...docSnap.data()
 1037 â”‚       } as T;
 1038 â”‚     } else {
 1039 â”‚       return null;
 1040 â”‚     }
 1041 â”‚   } catch (error) {
 1042 â”‚     console.error('Erro ao buscar documento:', error);
 1043 â”‚     return null;
 1044 â”‚   }
 1045 â”‚ }
 1046 â”‚ 
 1047 â”‚ // Add a new document
 1048 â”‚ export async function addDocument<T>(collectionName: string, data: any): Promise<T | null> {
 1049 â”‚   try {
 1050 â”‚     const docRef = await addDoc(collection(db, collectionName), {
 1051 â”‚       ...data,
 1052 â”‚       createdAt: serverTimestamp()
 1053 â”‚     });
 1054 â”‚     
 1055 â”‚     return {
 1056 â”‚       id: docRef.id,
 1057 â”‚       ...data
 1058 â”‚     } as T;
 1059 â”‚   } catch (error) {
 1060 â”‚     console.error('Erro ao adicionar documento:', error);
 1061 â”‚     return null;
 1062 â”‚   }
 1063 â”‚ }
 1064 â”‚ 
 1065 â”‚ // Update a document
 1066 â”‚ export async function updateDocument(collectionName: string, docId: string, data: any): Promise<boolean> {
 1067 â”‚   try {
 1068 â”‚     const docRef = doc(db, collectionName, docId);
 1069 â”‚     await updateDoc(docRef, {
 1070 â”‚       ...data,
 1071 â”‚       updatedAt: serverTimestamp()
 1072 â”‚     });
 1073 â”‚     return true;
 1074 â”‚   } catch (error) {
 1075 â”‚     console.error('Erro ao atualizar documento:', error);
 1076 â”‚     return false;
 1077 â”‚   }
 1078 â”‚ }
 1079 â”‚ 
 1080 â”‚ // Delete a document
 1081 â”‚ export async function deleteDocument(collectionName: string, docId: string): Promise<boolean> {
      Â·                       â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€
      Â·                              â•°â”€â”€ `deleteDocument` redefined here
 1082 â”‚   try {
 1083 â”‚     const docRef = doc(db, collectionName, docId);
 1084 â”‚     await deleteDoc(docRef);
      â•°â”€â”€â”€â”€

    at processResult (/home/runner/workspace/node_modules/next/dist/compiled/webpack/bundle5.js:28:398653)
    at <unknown> (/home/runner/workspace/node_modules/next/dist/compiled/webpack/bundle5.js:28:400370)
    at <unknown> (/home/runner/workspace/node_modules/next/dist/compiled/loader-runner/LoaderRunner.js:1:8645)
    at <unknown> (/home/runner/workspace/node_modules/next/dist/compiled/loader-runner/LoaderRunner.js:1:5019)
    at r.callback (/home/runner/workspace/node_modules/next/dist/compiled/loader-runner/LoaderRunner.js:1:4039)
client.js:1 ./lib/firebase/firestore.ts
Error: 
  Ã— the name `collection` is defined multiple times
     â•­â”€[/home/runner/workspace/lib/firebase/firestore.ts:1:1]
   1 â”‚ import {
   2 â”‚   collection,
     Â·   â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€
     Â·        â•°â”€â”€ previous definition of `collection` here
   3 â”‚   doc,
   4 â”‚   setDoc,
   5 â”‚   addDoc,
   6 â”‚   getDoc,
   7 â”‚   getDocs,
   8 â”‚   updateDoc,
   9 â”‚   deleteDoc,
  10 â”‚   query,
  11 â”‚   where,
  12 â”‚   orderBy,
  13 â”‚   limit,
  14 â”‚   DocumentData,
  15 â”‚   QueryConstraint,
  16 â”‚   Timestamp,
  17 â”‚   serverTimestamp
  18 â”‚ } from 'firebase/firestore'
  19 â”‚ import { db } from './config'
  20 â”‚ import { Room, SeasonalPrice } from '@/lib/types'
  21 â”‚ import { differenceInDays } from 'date-fns'
  22 â”‚ 
  23 â”‚ // Tipos de dados
  24 â”‚ export interface Booking {
  25 â”‚   id?: string
  26 â”‚   userId?: string
  27 â”‚   guestName: string
  28 â”‚   guestEmail: string
  29 â”‚   guestPhone: string
  30 â”‚   roomId: string
  31 â”‚   roomName: string
  32 â”‚   checkIn: Timestamp
  33 â”‚   checkOut: Timestamp
  34 â”‚   adults: number
  35 â”‚   children: number
  36 â”‚   totalPrice: number
  37 â”‚   status: 'pending' | 'confirmed' | 'cancelled' | 'completed'
  38 â”‚   paymentStatus: 'pending' | 'paid' | 'refunded'
  39 â”‚   specialRequests?: string
  40 â”‚   createdAt?: Timestamp
  41 â”‚   updatedAt?: Timestamp
  42 â”‚ }
  43 â”‚ 
  44 â”‚ export interface Contact {
  45 â”‚   id?: string
  46 â”‚   name: string
  47 â”‚   email: string
  48 â”‚   phone?: string
  49 â”‚   subject: string
  50 â”‚   message: string
  51 â”‚   status: 'new' | 'read' | 'replied'
  52 â”‚   createdAt: Timestamp
  53 â”‚   updatedAt?: Timestamp
  54 â”‚   repliedAt?: Timestamp
  55 â”‚   replyContent?: string
  56 â”‚   reservationDetails?: {
  57 â”‚     checkIn?: Timestamp
  58 â”‚     checkOut?: Timestamp
  59 â”‚     roomId?: string
  60 â”‚     roomName?: string
  61 â”‚     totalGuests?: number
  62 â”‚     totalPrice?: number
  63 â”‚   }
  64 â”‚ }
  65 â”‚ 
  66 â”‚ // FunÃ§Ãµes genÃ©ricas para CRUD
  67 â”‚ export const createDocument = async <T extends DocumentData>(
  68 â”‚   collectionName: string,
  69 â”‚   data: T
  70 â”‚ ): Promise<string> => {
  71 â”‚   const docRef = await addDoc(collection(db, collectionName), {
  72 â”‚     ...data,
  73 â”‚     createdAt: serverTimestamp(),
  74 â”‚     updatedAt: serverTimestamp()
  75 â”‚   })
  76 â”‚   return docRef.id
  77 â”‚ }
  78 â”‚ 
  79 â”‚ export const createDocumentWithId = async <T extends DocumentData>(
  80 â”‚   collectionName: string,
  81 â”‚   id: string,
  82 â”‚   data: T
  83 â”‚ ): Promise<void> => {
  84 â”‚   await setDoc(doc(db, collectionName, id), {
  85 â”‚     ...data,
  86 â”‚     createdAt: serverTimestamp(),
  87 â”‚     updatedAt: serverTimestamp()
  88 â”‚   })
  89 â”‚ }
  90 â”‚ 
  91 â”‚ export const getDocument = async <T>(
  92 â”‚   collectionName: string,
  93 â”‚   id: string
  94 â”‚ ): Promise<T | null> => {
  95 â”‚   const docRef = doc(db, collectionName, id)
  96 â”‚   const docSnap = await getDoc(docRef)
  97 â”‚   
  98 â”‚   if (docSnap.exists()) {
  99 â”‚     const data = docSnap.data();
 100 â”‚     console.log("Dados brutos recuperados do Firestore para quarto:", id, data);
 101 â”‚     
 102 â”‚     if (data?.serviceFeePct !== undefined) {
 103 â”‚       console.log("serviceFeePct antes da conversÃ£o:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
 104 â”‚       // Garantir que serviceFeePct seja um nÃºmero
 105 â”‚       data.serviceFeePct = Number(data.serviceFeePct);
 106 â”‚       console.log("serviceFeePct apÃ³s conversÃ£o:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
 107 â”‚     }
 108 â”‚     
 109 â”‚     return { id: docSnap.id, ...data } as T
 110 â”‚   } else {
 111 â”‚     return null
 112 â”‚   }
 113 â”‚ }
 114 â”‚ 
 115 â”‚ export const getDocuments = async <T>(
 116 â”‚   collectionName: string,
 117 â”‚   constraints: QueryConstraint[] = [],
 118 â”‚   forceRefresh = false
 119 â”‚ ): Promise<T[]> => {
 120 â”‚   try {
 121 â”‚     const collectionRef = collection(db, collectionName)
 122 â”‚     const q = query(collectionRef, ...constraints)
 123 â”‚     
 124 â”‚     // Se forceRefresh for verdadeiro, adicionar opÃ§Ãµes que forÃ§am uma nova consulta ao Firestore
 125 â”‚     const querySnapshot = await getDocs(q)
 126 â”‚     
 127 â”‚     console.log(`Buscando documentos na coleÃ§Ã£o ${collectionName} - ForÃ§a atualizaÃ§Ã£o: ${forceRefresh}`);
 128 â”‚     
 129 â”‚     return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }) as T)
 130 â”‚   } catch (error) {
 131 â”‚     console.error(`Erro ao buscar documentos da coleÃ§Ã£o ${collectionName}:`, error);
 132 â”‚     return [];
 133 â”‚   }
 134 â”‚ }
 135 â”‚ 
 136 â”‚ export const updateDocument = async <T extends DocumentData>(
 137 â”‚   collectionName: string,
 138 â”‚   id: string,
 139 â”‚   data: Partial<T>
 140 â”‚ ): Promise<void> => {
 141 â”‚   const docRef = doc(db, collectionName, id)
 142 â”‚   await updateDoc(docRef, {
 143 â”‚     ...data,
 144 â”‚     updatedAt: serverTimestamp()
 145 â”‚   })
 146 â”‚ }
 147 â”‚ 
 148 â”‚ export const deleteDocument = async (
 149 â”‚   collectionName: string,
 150 â”‚   id: string
 1
console.error @ client.js:1
/favicon.ico:1 
            
            
           Failed to load resource: the server responded with a status of 404 (Not Found)
