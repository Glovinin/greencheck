index.js:654 Uncaught ModuleBuildError: Module build failed (from ./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js):
Error: 
  × the name `collection` is defined multiple times
     ╭─[/home/runner/workspace/lib/firebase/firestore.ts:1:1]
   1 │ import {
   2 │   collection,
     ·   ─────┬────
     ·        ╰── previous definition of `collection` here
   3 │   doc,
   4 │   setDoc,
   5 │   addDoc,
   6 │   getDoc,
   7 │   getDocs,
   8 │   updateDoc,
   9 │   deleteDoc,
  10 │   query,
  11 │   where,
  12 │   orderBy,
  13 │   limit,
  14 │   DocumentData,
  15 │   QueryConstraint,
  16 │   Timestamp,
  17 │   serverTimestamp
  18 │ } from 'firebase/firestore'
  19 │ import { db } from './config'
  20 │ import { Room, SeasonalPrice } from '@/lib/types'
  21 │ import { differenceInDays } from 'date-fns'
  22 │ 
  23 │ // Tipos de dados
  24 │ export interface Booking {
  25 │   id?: string
  26 │   userId?: string
  27 │   guestName: string
  28 │   guestEmail: string
  29 │   guestPhone: string
  30 │   roomId: string
  31 │   roomName: string
  32 │   checkIn: Timestamp
  33 │   checkOut: Timestamp
  34 │   adults: number
  35 │   children: number
  36 │   totalPrice: number
  37 │   status: 'pending' | 'confirmed' | 'cancelled' | 'completed'
  38 │   paymentStatus: 'pending' | 'paid' | 'refunded'
  39 │   specialRequests?: string
  40 │   createdAt?: Timestamp
  41 │   updatedAt?: Timestamp
  42 │ }
  43 │ 
  44 │ export interface Contact {
  45 │   id?: string
  46 │   name: string
  47 │   email: string
  48 │   phone?: string
  49 │   subject: string
  50 │   message: string
  51 │   status: 'new' | 'read' | 'replied'
  52 │   createdAt: Timestamp
  53 │   updatedAt?: Timestamp
  54 │   repliedAt?: Timestamp
  55 │   replyContent?: string
  56 │   reservationDetails?: {
  57 │     checkIn?: Timestamp
  58 │     checkOut?: Timestamp
  59 │     roomId?: string
  60 │     roomName?: string
  61 │     totalGuests?: number
  62 │     totalPrice?: number
  63 │   }
  64 │ }
  65 │ 
  66 │ // Funções genéricas para CRUD
  67 │ export const createDocument = async <T extends DocumentData>(
  68 │   collectionName: string,
  69 │   data: T
  70 │ ): Promise<string> => {
  71 │   const docRef = await addDoc(collection(db, collectionName), {
  72 │     ...data,
  73 │     createdAt: serverTimestamp(),
  74 │     updatedAt: serverTimestamp()
  75 │   })
  76 │   return docRef.id
  77 │ }
  78 │ 
  79 │ export const createDocumentWithId = async <T extends DocumentData>(
  80 │   collectionName: string,
  81 │   id: string,
  82 │   data: T
  83 │ ): Promise<void> => {
  84 │   await setDoc(doc(db, collectionName, id), {
  85 │     ...data,
  86 │     createdAt: serverTimestamp(),
  87 │     updatedAt: serverTimestamp()
  88 │   })
  89 │ }
  90 │ 
  91 │ export const getDocument = async <T>(
  92 │   collectionName: string,
  93 │   id: string
  94 │ ): Promise<T | null> => {
  95 │   const docRef = doc(db, collectionName, id)
  96 │   const docSnap = await getDoc(docRef)
  97 │   
  98 │   if (docSnap.exists()) {
  99 │     const data = docSnap.data();
 100 │     console.log("Dados brutos recuperados do Firestore para quarto:", id, data);
 101 │     
 102 │     if (data?.serviceFeePct !== undefined) {
 103 │       console.log("serviceFeePct antes da conversão:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
 104 │       // Garantir que serviceFeePct seja um número
 105 │       data.serviceFeePct = Number(data.serviceFeePct);
 106 │       console.log("serviceFeePct após conversão:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
 107 │     }
 108 │     
 109 │     return { id: docSnap.id, ...data } as T
 110 │   } else {
 111 │     return null
 112 │   }
 113 │ }
 114 │ 
 115 │ export const getDocuments = async <T>(
 116 │   collectionName: string,
 117 │   constraints: QueryConstraint[] = [],
 118 │   forceRefresh = false
 119 │ ): Promise<T[]> => {
 120 │   try {
 121 │     const collectionRef = collection(db, collectionName)
 122 │     const q = query(collectionRef, ...constraints)
 123 │     
 124 │     // Se forceRefresh for verdadeiro, adicionar opções que forçam uma nova consulta ao Firestore
 125 │     const querySnapshot = await getDocs(q)
 126 │     
 127 │     console.log(`Buscando documentos na coleção ${collectionName} - Força atualização: ${forceRefresh}`);
 128 │     
 129 │     return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }) as T)
 130 │   } catch (error) {
 131 │     console.error(`Erro ao buscar documentos da coleção ${collectionName}:`, error);
 132 │     return [];
 133 │   }
 134 │ }
 135 │ 
 136 │ export const updateDocument = async <T extends DocumentData>(
 137 │   collectionName: string,
 138 │   id: string,
 139 │   data: Partial<T>
 140 │ ): Promise<void> => {
 141 │   const docRef = doc(db, collectionName, id)
 142 │   await updateDoc(docRef, {
 143 │     ...data,
 144 │     updatedAt: serverTimestamp()
 145 │   })
 146 │ }
 147 │ 
 148 │ export const deleteDocument = async (
 149 │   collectionName: string,
 150 │   id: string
 151 │ ): Promise<boolean> => {
 152 │   const docRef = doc(db, collectionName, id)
 153 │   await deleteDoc(docRef)
 154 │   return true
 155 │ }
 156 │ 
 157 │ // Funções para gerenciar quartos
 158 │ export const getRooms = async (forceRefresh = false): Promise<Room[]> => {
 159 │   try {
 160 │     const constraints: QueryConstraint[] = []
 161 │     
 162 │     constraints.push(orderBy('name', 'asc'))
 163 │     
 164 │     const rooms = await getDocuments<Room>('rooms', constraints, forceRefresh)
 165 │     
 166 │     // Garantir que todos os campos necessários estejam presentes
 167 │     return rooms.map(room => {
 168 │       console.log(`Firebase - Quarto ${room.id} dados brutos:`, room);
 169 │       
 170 │       // Garantir que serviceFeePct seja um número
 171 │       const serviceFeePct = room.serviceFeePct !== undefined 
 172 │         ? Number(room.serviceFeePct) 
 173 │         : 10;
 174 │         
 175 │       console.log(`Firebase - Quarto ${room.id} serviceFeePct:`, {
 176 │         original: room.serviceFeePct,
 177 │         tipo: typeof room.serviceFeePct,
 178 │         convertido: serviceFeePct
 179 │       });
 180 │       
 181 │       return {
 182 │         id: room.id,
 183 │         name: room.name || '',
 184 │         type: room.type || 'standard',
 185 │         description: room.description || '',
 186 │         price: room.price || 0,
 187 │         capacity: room.capacity || 2,
 188 │         size: room.size || 0,
 189 │         available: room.available !== undefined ? room.available : true,
 190 │         serviceFeePct: serviceFeePct,
 191 │         images: room.images || [],
 192 │         amenities: room.amenities || [],
 193 │         additionalServices: room.additionalServices || [],
 194 │         highlights: room.highlights || [],
 195 │         createdAt: room.createdAt,
 196 │         updatedAt: room.updatedAt
 197 │       };
 198 │     });
 199 │   } catch (error) {
 200 │     console.error('Erro ao buscar quartos:', error)
 201 │     return []
 202 │   }
 203 │ }
 204 │ 
 205 │ export const getAvailableRooms = async (
 206 │   checkIn: Date,
 207 │   checkOut: Date
 208 │ ): Promise<Room[]> => {
 209 │   try {
 210 │     // Buscar todos os quartos que estão marcados como disponíveis em geral
 211 │     const constraints: QueryConstraint[] = [
 212 │       where('available', '==', true)
 213 │     ]
 214 │     
 215 │     const rooms = await getDocuments<Room>('rooms', constraints);
 216 │     
 217 │     // Filtrar os quartos que estão disponíveis nas datas específicas
 218 │     return filterAvailableRoomsByDate(rooms, checkIn, checkOut);
 219 │   } catch (error) {
 220 │     console.error('Erro ao buscar quartos disponíveis:', error)
 221 │     return []
 222 │   }
 223 │ }
 224 │ 
 225 │ // Função auxiliar para verificar disponibilidade entre datas
 226 │ export const filterAvailableRoomsByDate = (
 227 │   rooms: Room[],
 228 │   checkIn: Date,
 229 │   checkOut: Date
 230 │ ): Room[] => {
 231 │   // Converter checkIn e checkOut para ISO strings
 232 │   const dateStrings = getDatesInRange(checkIn, checkOut);
 233 │   
 234 │   return rooms.filter(room => {
 235 │     // Se não tiver controle de disponibilidade específico, considera disponível
 236 │     if (!room.availabilityDates) return true;
 237 │     
 238 │     // Verificar se alguma data no intervalo está indisponível
 239 │     return !dateStrings.some(dateStr => 
 240 │       room.availabilityDates?.[dateStr] === false
 241 │     );
 242 │   });
 243 │ };
 244 │ 
 245 │ // Função para obter disponibilidade de um quarto específico
 246 │ export const getRoomAvailability = async (
 247 │   roomId: string, 
 248 │   startDate: Date, 
 249 │   endDate: Date
 250 │ ): Promise<{[date: string]: boolean}> => {
 251 │   try {
 252 │     const room = await getRoomById(roomId);
 253 │     if (!room) throw new Error(`Quarto com ID ${roomId} não encontrado`);
 254 │     
 255 │     // Gerar datas no intervalo
 256 │     const dateStrings = getDatesInRange(startDate, endDate);
 257 │     
 258 │     // Se não tiver configuração de disponibilidade específica, assume tudo disponível
 259 │     if (!room.availabilityDates) {
 260 │       return dateStrings.reduce((acc, date) => {
 261 │         acc[date] = true;
 262 │         return acc;
 263 │       }, {} as {[date: string]: boolean});
 264 │     }
 265 │     
 266 │     // Preencher com os dados de disponibilidade existentes
 267 │     return dateStrings.reduce((acc, date) => {
 268 │       acc[date] = room.availabilityDates?.[date] !== false; // disponível por padrão se não estiver explicitamente indisponível
 269 │       return acc;
 270 │     }, {} as {[date: string]: boolean});
 271 │   } catch (error) {
 272 │     console.error(`Erro ao verificar disponibilidade do quarto ${roomId}:`, error);
 273 │     throw error;
 274 │   }
 275 │ };
 276 │ 
 277 │ // Função para atualizar disponibilidade de um quarto
 278 │ export const updateRoomAvailability = async (
 279 │   roomId: string,
 280 │   availabilityDates: {[date: string]: boolean}
 281 │ ): Promise<boolean> => {
 282 │   try {
 283 │     await updateDocument('rooms', roomId, {
 284 │       availabilityDates,
 285 │       updatedAt: serverTimestamp()
 286 │     });
 287 │     return true;
 288 │   } catch (error) {
 289 │     console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
 290 │     return false;
 291 │   }
 292 │ };
 293 │ 
 294 │ // Função auxiliar para gerar array de strings de data entre um intervalo
 295 │ export const getDatesInRange = (startDate: Date, endDate: Date): string[] => {
 296 │   const dates: string[] = [];
 297 │   const currentDate = new Date(startDate);
 298 │   
 299 │   // Normalizar para meia-noite no fuso horário local
 300 │   currentDate.setHours(0, 0, 0, 0);
 301 │   const endDateNormalized = new Date(endDate);
 302 │   endDateNormalized.setHours(0, 0, 0, 0);
 303 │   
 304 │   // Adicionar cada data no intervalo EXCETO o dia de checkout
 305 │   // Usando < em vez de <= para não incluir o dia de checkout
 306 │   while (currentDate < endDateNormalized) {
 307 │     dates.push(currentDate.toISOString().split('T')[0]); // Formato YYYY-MM-DD
 308 │     currentDate.setDate(currentDate.getDate() + 1);
 309 │   }
 310 │   
 311 │   return dates;
 312 │ };
 313 │ 
 314 │ export const getRoomById = async (id: string): Promise<Room | null> => {
 315 │   try {
 316 │     const room = await getDocument<Room>('rooms', id);
 317 │     
 318 │     if (!room) return null;
 319 │     
 320 │     console.log(`Firebase - getRoomById ${id} dados brutos:`, room);
 321 │     
 322 │     // Log específico para serviceFeePct
 323 │     console.log(`serviceFeePct no Firestore:`, room.serviceFeePct);
 324 │     
 325 │     // Garantir que todos os campos necessários estejam presentes
 326 │     return {
 327 │       ...room,
 328 │       name: room.name || '',
 329 │       type: room.type || 'standard',
 330 │       description: room.description || '',
 331 │       price: room.price || 0,
 332 │       capacity: room.capacity || 2,
 333 │       size: room.size || 0,
 334 │       available: room.available !== undefined ? room.available : true,
 335 │       serviceFeePct: room.serviceFeePct !== undefined ? room.serviceFeePct : 10,
 336 │       images: room.images || [],
 337 │       amenities: room.amenities || [],
 338 │       additionalServices: room.additionalServices || [],
 339 │       highlights: room.highlights || []
 340 │     };
 341 │   } catch (error) {
 342 │     console.error(`Erro ao buscar quarto com ID ${id}:`, error);
 343 │     return null;
 344 │   }
 345 │ }
 346 │ 
 347 │ export const createRoom = async (roomData: Omit<Room, 'id' | 'createdAt' | 'updatedAt'>): Promise<Room> => {
 348 │   try {
 349 │     console.log("createRoom - Dados recebidos:", roomData);
 350 │     
 351 │     const roomWithTimestamps = {
 352 │       ...roomData,
 353 │       available: roomData.available !== undefined ? roomData.available : true,
 354 │       featured: roomData.featured || false,
 355 │       amenities: roomData.amenities || [],
 356 │       additionalServices: roomData.additionalServices || [],
 357 │       highlights: roomData.highlights || [],
 358 │       createdAt: serverTimestamp(),
 359 │       updatedAt: serverTimestamp()
 360 │     }
 361 │     
 362 │     console.log("createRoom - Dados a serem salvos:", roomWithTimestamps);
 363 │     
 364 │     const id = await createDocument('rooms', roomWithTimestamps)
 365 │     
 366 │     return {
 367 │       id,
 368 │       ...roomData,
 369 │       amenities: roomData.amenities || [],
 370 │       additionalServices: roomData.additionalServices || [],
 371 │       highlights: roomData.highlights || [],
 372 │       createdAt: Timestamp.now(),
 373 │       updatedAt: Timestamp.now()
 374 │     }
 375 │   } catch (error) {
 376 │     console.error('Erro ao criar quarto:', error)
 377 │     throw error
 378 │   }
 379 │ }
 380 │ 
 381 │ export const updateRoom = async (id: string, roomData: Partial<Omit<Room, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Room> => {
 382 │   try {
 383 │     console.log(`updateRoom - ID: ${id}, Dados recebidos:`, roomData);
 384 │     
 385 │     // Garantir que estamos lidando explicitamente com o serviceFeePct se ele for 0
 386 │     if (roomData.serviceFeePct === 0) {
 387 │       console.log("updateRoom - Detectado serviceFeePct com valor 0, salvando explicitamente.", roomData.serviceFeePct);
 388 │     }
 389 │     
 390 │     // Adicionar timestamp de atualização
 391 │     const roomWithTimestamp = {
 392 │       ...roomData,
 393 │       amenities: roomData.amenities || [],
 394 │       additionalServices: roomData.additionalServices || [],
 395 │       highlights: roomData.highlights || [],
 396 │       updatedAt: serverTimestamp()
 397 │     }
 398 │     
 399 │     console.log(`updateRoom - Dados a serem salvos:`, roomWithTimestamp);
 400 │     
 401 │     await updateDocument('rooms', id, roomWithTimestamp)
 402 │     
 403 │     const updatedRoom = await getRoomById(id)
 404 │     if (!updatedRoom) {
 405 │       throw new Error(`Quarto com ID ${id} não encontrado após atualização`)
 406 │     }
 407 │     
 408 │     return updatedRoom
 409 │   } catch (error) {
 410 │     console.error('Erro ao atualizar quarto:', error)
 411 │     throw error
 412 │   }
 413 │ }
 414 │ 
 415 │ export const deleteRoom = async (id: string): Promise<boolean> => {
 416 │   return await deleteDocument('rooms', id)
 417 │ }
 418 │ 
 419 │ // Funções específicas para reservas
 420 │ export const createBooking = async (bookingData: any) => {
 421 │   try {
 422 │     const bookingsCollection = collection(db, 'bookings');
 423 │     const docRef = await addDoc(bookingsCollection, bookingData);
 424 │     
 425 │     // CORREÇÃO: Não bloquear a data no momento da criação da reserva
 426 │     // O bloqueio será feito apenas quando o pagamento for confirmado
 427 │     // através da função updateBookingStatus
 428 │     
 429 │     return docRef;
 430 │   } catch (error) {
 431 │     console.error('Erro ao criar reserva:', error);
 432 │     throw error;
 433 │   }
 434 │ };
 435 │ 
 436 │ // Nova função para atualizar status da reserva e bloquear as datas da estadia
 437 │ export const updateBookingStatus = async (
 438 │   bookingId: string, 
 439 │   newStatus: 'pending' | 'confirmed' | 'cancelled' | 'completed',
 440 │   newPaymentStatus: 'pending' | 'paid' | 'refunded'
 441 │ ): Promise<boolean> => {
 442 │   try {
 443 │     // Referência ao documento da reserva
 444 │     const bookingRef = doc(db, 'bookings', bookingId);
 445 │     const bookingSnap = await getDoc(bookingRef);
 446 │     
 447 │     if (!bookingSnap.exists()) {
 448 │       console.error(`Booking ${bookingId} não existe ao atualizar status`);
 449 │       return false;
 450 │     }
 451 │     
 452 │     const bookingData = bookingSnap.data();
 453 │     
 454 │     // Atualizar o status da reserva
 455 │     await updateDoc(bookingRef, {
 456 │       status: newStatus,
 457 │       paymentStatus: newPaymentStatus,
 458 │       updatedAt: serverTimestamp(),
 459 │       ...(newStatus === 'confirmed' && { confirmedAt: serverTimestamp() })
 460 │     });
 461 │     
 462 │     // Se a reserva está sendo confirmada, precisamos bloquear as datas
 463 │     if (newStatus === 'confirmed') {
 464 │       console.log(`Atualizando disponibilidade para reserva confirmada: ${bookingId}`);
 465 │       
 466 │       // Recuperar datas de check-in e check-out
 467 │       const checkIn = bookingData.checkIn.toDate();
 468 │       const checkOut = bookingData.checkOut.toDate();
 469 │       const roomId = bookingData.roomId;
 470 │       
 471 │       // Obter todas as datas entre check-in e check-out
 472 │       const dates: Date[] = [];
 473 │       const currentDate = new Date(checkIn);
 474 │       
 475 │       while (currentDate < checkOut) {
 476 │         dates.push(new Date(currentDate));
 477 │         currentDate.setDate(currentDate.getDate() + 1);
 478 │       }
 479 │       
 480 │       console.log(`Bloqueando ${dates.length} dias para quarto ${roomId}`);
 481 │       
 482 │       // Atualizar disponibilidade para cada data
 483 │       const availabilityUpdates: {[date: string]: boolean} = {};
 484 │       
 485 │       dates.forEach(date => {
 486 │         const dateString = date.toISOString().split('T')[0]; // formato YYYY-MM-DD
 487 │         availabilityUpdates[dateString] = false; // false significa indisponível
 488 │       });
 489 │       
 490 │       // Atualizar disponibilidade do quarto
 491 │       if (Object.keys(availabilityUpdates).length > 0) {
 492 │         try {
 493 │           // Obter o documento do quarto
 494 │           const roomRef = doc(db, 'rooms', roomId);
 495 │           const roomSnap = await getDoc(roomRef);
 496 │           
 497 │           if (roomSnap.exists()) {
 498 │             const roomData = roomSnap.data();
 499 │             const currentAvailability = roomData.availabilityDates || {};
 500 │             
 501 │             // Mesclar a disponibilidade atual com as novas atualizações
 502 │             const updatedAvailability = {
 503 │               ...currentAvailability,
 504 │               ...availabilityUpdates
 505 │             };
 506 │             
 507 │             // Atualizar o documento do quarto
 508 │             await updateDoc(roomRef, {
 509 │               availabilityDates: updatedAvailability,
 510 │               updatedAt: serverTimestamp()
 511 │             });
 512 │             
 513 │             console.log(`Disponibilidade atualizada com sucesso para quarto ${roomId}`);
 514 │             
 515 │             // Criar log da reserva
 516 │             await addDoc(collection(db, 'bookingLogs'), {
 517 │               bookingId,
 518 │               roomId,
 519 │               action: 'status_updated',
 520 │               previousStatus: bookingData.status,
 521 │               newStatus,
 522 │               previousPaymentStatus: bookingData.paymentStatus,
 523 │               newPaymentStatus,
 524 │               datesBlocked: Object.keys(availabilityUpdates),
 525 │               timestamp: serverTimestamp(),
 526 │               userId: bookingData.userId || 'system'
 527 │             });
 528 │           } else {
 529 │             console.error(`Quarto ${roomId} não encontrado ao atualizar disponibilidade`);
 530 │           }
 531 │         } catch (error) {
 532 │           console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
 533 │         }
 534 │       }
 535 │     }
 536 │     
 537 │     return true;
 538 │   } catch (error) {
 539 │     console.error(`Erro ao atualizar status da reserva ${bookingId}:`, error);
 540 │     return false;
 541 │   }
 542 │ }
 543 │ 
 544 │ export const getUserBookings = async (userId: string): Promise<Booking[]> => {
 545 │   return getDocuments<Booking>('bookings', [
 546 │     where('userId', '==', userId),
 547 │     orderBy('createdAt', 'desc')
 548 │   ])
 549 │ }
 550 │ 
 551 │ export const getRecentBookings = async (count = 5): Promise<Booking[]> => {
 552 │   return getDocuments<Booking>('bookings', [
 553 │     orderBy('createdAt', 'desc'),
 554 │     limit(count)
 555 │   ])
 556 │ }
 557 │ 
 558 │ export const getRoomBookings = async (roomId: string): Promise<Booking[]> => {
 559 │   try {
 560 │     const constraints: QueryConstraint[] = [
 561 │       where('roomId', '==', roomId),
 562 │       orderBy('checkIn', 'asc')
 563 │     ];
 564 │     
 565 │     return await getDocuments<Booking>('bookings', constraints);
 566 │   } catch (error) {
 567 │     console.error(`Erro ao buscar reservas do quarto ${roomId}:`, error);
 568 │     return [];
 569 │   }
 570 │ };
 571 │ 
 572 │ // Funções específicas para contatos
 573 │ export const createContactMessage = async (contactData: Contact) => {
 574 │   try {
 575 │     const contactsCollection = collection(db, 'contacts')
 576 │     
 577 │     // Garantir que o status seja 'new' para novos contatos
 578 │     const contactWithDefaults = {
 579 │       ...contactData,
 580 │       status: contactData.status || 'new',
 581 │       createdAt: contactData.createdAt || Timestamp.now()
 582 │     }
 583 │     
 584 │     // Se tiver detalhes de reserva, adicionar metadados
 585 │     if (contactWithDefaults.reservationDetails) {
 586 │       // Ajustar subject para indicar que é relacionado a reserva
 587 │       if (!contactWithDefaults.subject.includes('Reserva')) {
 588 │         contactWithDefaults.subject = `Reserva: ${contactWithDefaults.subject}`;
 589 │       }
 590 │     }
 591 │     
 592 │     const docRef = await addDoc(contactsCollection, contactWithDefaults)
 593 │     return docRef
 594 │   } catch (error) {
 595 │     console.error('Erro ao criar mensagem de contato:', error)
 596 │     throw error
 597 │   }
 598 │ }
 599 │ 
 600 │ export const getNewContactMessages = async (): Promise<Contact[]> => {
 601 │   return getDocuments<Contact>('contacts', [
 602 │     where('status', '==', 'new'),
 603 │     orderBy('createdAt', 'desc')
 604 │   ])
 605 │ }
 606 │ 
 607 │ // Funções para Dashboard com dados reais
 608 │ 
 609 │ export const getDashboardStats = async () => {
 610 │   try {
 611 │     const [totalBookings, totalRevenue, occupancyRate, bookingsByPlatform] = await Promise.all([
 612 │       getTotalBookings(),
 613 │       getMonthlyRevenue(),
 614 │       getOccupancyRate(),
 615 │       getBookingsByPlatform()
 616 │     ]);
 617 │ 
 618 │     return {
 619 │       totalBookings,
 620 │       totalRevenue,
 621 │       occupancyRate,
 622 │       bookingsByPlatform
 623 │     };
 624 │   } catch (error) {
 625 │     console.error('Erro ao obter estatísticas do dashboard:', error);
 626 │     throw error;
 627 │   }
 628 │ };
 629 │ 
 630 │ // Obter total de reservas
 631 │ export const getTotalBookings = async () => {
 632 │   try {
 633 │     // Obter todas as reservas
 634 │     const bookings = await getDocuments<Booking>('bookings');
 635 │     
 636 │     // Contar reservas por status
 637 │     const confirmed = bookings.filter(b => b.status === 'confirmed').length;
 638 │     const pending = bookings.filter(b => b.status === 'pending').length;
 639 │     const cancelled = bookings.filter(b => b.status === 'cancelled').length;
 640 │     const completed = bookings.filter(b => b.status === 'completed').length;
 641 │     
 642 │     // Calcular crescimento em relação ao mês anterior (simulado por enquanto)
 643 │     // Em uma implementação real, você compararia com dados do mês anterior
 644 │     const growth = ((confirmed + completed) / (bookings.length || 1) * 100) - 50;
 645 │     
 646 │     return {
 647 │       total: bookings.length,
 648 │       confirmed,
 649 │       pending,
 650 │       cancelled,
 651 │       completed,
 652 │       growth: Math.round(growth) // Arredonda para número inteiro
 653 │     };
 654 │   } catch (error) {
 655 │     console.error('Erro ao obter total de reservas:', error);
 656 │     return {
 657 │       total: 0,
 658 │       confirmed: 0,
 659 │       pending: 0, 
 660 │       cancelled: 0,
 661 │       completed: 0,
 662 │       growth: 0
 663 │     };
 664 │   }
 665 │ };
 666 │ 
 667 │ // Obter receita mensal
 668 │ export const getMonthlyRevenue = async () => {
 669 │   try {
 670 │     const bookings = await getDocuments<Booking>('bookings');
 671 │     
 672 │     // Filtrar reservas confirmadas e concluídas
 673 │     const validBookings = bookings.filter(b => 
 674 │       b.status === 'confirmed' || b.status === 'completed'
 675 │     );
 676 │     
 677 │     // Calcular receita total
 678 │     const totalRevenue = validBookings.reduce((acc, booking) => acc + booking.totalPrice, 0);
 679 │     
 680 │     // Agrupar receita por mês
 681 │     const revenueByMonth = validBookings.reduce((acc, booking) => {
 682 │       const date = booking.checkIn.toDate();
 683 │       const month = date.getMonth(); // 0-11
 684 │       const year = date.getFullYear();
 685 │       const key = `${year}-${month}`;
 686 │       
 687 │       if (!acc[key]) {
 688 │         acc[key] = 0;
 689 │       }
 690 │       acc[key] += booking.totalPrice;
 691 │       return acc;
 692 │     }, {} as Record<string, number>);
 693 │     
 694 │     // Converter para formato de array para gráfico
 695 │     const monthNames = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
 696 │     
 697 │     const currentDate = new Date();
 698 │     const currentMonth = currentDate.getMonth();
 699 │     const currentYear = currentDate.getFullYear();
 700 │     
 701 │     const revenueData = [];
 702 │     
 703 │     // Gerar dados dos últimos 12 meses
 704 │     for (let i = 0; i < 12; i++) {
 705 │       const month = (currentMonth - i + 12) % 12;
 706 │       const year = currentMonth - i < 0 ? currentYear - 1 : currentYear;
 707 │       const key = `${year}-${month}`;
 708 │       
 709 │       revenueData.unshift({
 710 │         month: monthNames[month],
 711 │         value: revenueByMonth[key] || 0
 712 │       });
 713 │     }
 714 │     
 715 │     // Calcular crescimento em relação ao mês anterior
 716 │     const lastMonthRevenue = revenueData[revenueData.length - 2]?.value || 0;
 717 │     const currentMonthRevenue = revenueData[revenueData.length - 1]?.value || 0;
 718 │     
 719 │     const growth = lastMonthRevenue ? ((currentMonthRevenue - lastMonthRevenue) / lastMonthRevenue) * 100 : 0;
 720 │     
 721 │     return {
 722 │       monthly: currentMonthRevenue,
 723 │       total: totalRevenue,
 724 │       growth: Math.round(growth),
 725 │       revenueData
 726 │     };
 727 │   } catch (error) {
 728 │     console.error('Erro ao obter receita mensal:', error);
 729 │     return {
 730 │       monthly: 0,
 731 │       total: 0,
 732 │       growth: 0,
 733 │       revenueData: []
 734 │     };
 735 │   }
 736 │ };
 737 │ 
 738 │ // Calcular taxa de ocupação
 739 │ export const getOccupancyRate = async () => {
 740 │   try {
 741 │     // Obter todos os quartos
 742 │     const rooms = await getDocuments<Room>('rooms');
 743 │     const totalRooms = rooms.length;
 744 │     
 745 │     if (totalRooms === 0) {
 746 │       return { rate: 0, growth: 0 };
 747 │     }
 748 │     
 749 │     // Obter todas as reservas
 750 │     const bookings = await getDocuments<Booking>('bookings');
 751 │     
 752 │     // Filtrar reservas confirmadas e concluídas para o mês atual
 753 │     const currentDate = new Date();
 754 │     const currentMonth = currentDate.getMonth();
 755 │     const currentYear = currentDate.getFullYear();
 756 │     
 757 │     const currentMonthBookings = bookings.filter(booking => {
 758 │       const checkInDate = booking.checkIn.toDate();
 759 │       return (
 760 │         (booking.status === 'confirmed' || booking.status === 'completed') &&
 761 │         checkInDate.getMonth() === currentMonth &&
 762 │         checkInDate.getFullYear() === currentYear
 763 │       );
 764 │     });
 765 │     
 766 │     // Calcular dias ocupados por quarto
 767 │     const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
 768 │     const totalPossibleRoomDays = totalRooms * daysInMonth;
 769 │     
 770 │     // Contar dias ocupados (simplificado - em produção seria mais complexo)
 771 │     let occupiedDays = 0;
 772 │     
 773 │     currentMonthBookings.forEach(booking => {
 774 │       const checkIn = booking.checkIn.toDate();
 775 │       const checkOut = booking.checkOut.toDate();
 776 │       
 777 │       // Ajustar datas para considerar apenas o mês atual
 778 │       const startDate = new Date(Math.max(
 779 │         checkIn.getTime(),
 780 │         new Date(currentYear, currentMonth, 1).getTime()
 781 │       ));
 782 │       const endDate = new Date(Math.min(
 783 │         checkOut.getTime(),
 784 │         new Date(currentYear, currentMonth + 1, 0).getTime()
 785 │       ));
 786 │       
 787 │       // Calcular dias entre datas (incluindo check-in, excluindo check-out)
 788 │       const days = Math.max(0, Math.floor((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)));
 789 │       occupiedDays += days;
 790 │     });
 791 │     
 792 │     const occupancyRate = (occupiedDays / totalPossibleRoomDays) * 100;
 793 │     
 794 │     // Simulação de crescimento (em produção, compararia com mês anterior)
 795 │     const growth = occupancyRate > 50 ? 5 : -3;
 796 │     
 797 │     return {
 798 │       rate: Math.round(occupancyRate),
 799 │       growth: Math.round(growth)
 800 │     };
 801 │   } catch (error) {
 802 │     console.error('Erro ao calcular taxa de ocupação:', error);
 803 │     return { rate: 0, growth: 0 };
 804 │   }
 805 │ };
 806 │ 
 807 │ // Obter reservas agrupadas por plataforma
 808 │ export const getBookingsByPlatform = async () => {
 809 │   try {
 810 │     const bookings = await getDocuments<Booking>('bookings');
 811 │     
 812 │     // Categorizar reservas por origem
 813 │     const platforms = [
 814 │       { 
 815 │         platform: "Booking.com", 
 816 │         color: "#003580", 
 817 │         icon: "Globe",
 818 │         bookings: []
 819 │       },
 820 │       { 
 821 │         platform: "Airbnb", 
 822 │         color: "#FF5A5F", 
 823 │         icon: "Heart",
 824 │         bookings: []
 825 │       },
 826 │       { 
 827 │         platform: "Direto", 
 828 │         color: "#4CAF50", 
 829 │         icon: "Home",
 830 │         bookings: []
 831 │       }
 832 │     ];
 833 │     
 834 │     // Para fins de demonstração, colocar todas as reservas como "Direto" por enquanto
 835 │     // Em produção, usaria um campo "platformOrigin" ou similar na tabela de reservas
 836 │     const platformIndex = 2; // Índice da plataforma "Direto"
 837 │     
 838 │     bookings.forEach(booking => {
 839 │       // Transformar para o formato esperado pelo componente
 840 │       const transformedBooking = {
 841 │         id: booking.id || '',
 842 │         guestName: booking.guestName,
 843 │         roomName: booking.roomName,
 844 │         checkIn: booking.checkIn.toDate().toLocaleDateString('pt-PT'),
 845 │         checkOut: booking.checkOut.toDate().toLocaleDateString('pt-PT'),
 846 │         status: booking.status,
 847 │         value: new Intl.NumberFormat('pt-PT', {
 848 │           style: 'currency',
 849 │           currency: 'EUR'
 850 │         }).format(booking.totalPrice)
 851 │       };
 852 │       
 853 │       // Adicionar à plataforma "Direto"
 854 │       (platforms[platformIndex] as any).bookings.push(transformedBooking);
 855 │     });
 856 │     
 857 │     return platforms;
 858 │   } catch (error) {
 859 │     console.error('Erro ao obter reservas por plataforma:', error);
 860 │     return [];
 861 │   }
 862 │ };
 863 │ 
 864 │ // Função para obter o preço de um quarto para uma data específica
 865 │ export const getRoomPriceForDate = async (roomId: string, date: Date): Promise<number> => {
 866 │   try {
 867 │     const roomDoc = await getDoc(doc(db, "rooms", roomId));
 868 │     
 869 │     if (!roomDoc.exists()) {
 870 │       throw new Error("Quarto não encontrado");
 871 │     }
 872 │     
 873 │     const roomData = roomDoc.data() as Room;
 874 │     const basePrice = roomData.price;
 875 │     
 876 │     if (!roomData.seasonalPrices || roomData.seasonalPrices.length === 0) {
 877 │       return basePrice;
 878 │     }
 879 │     
 880 │     // Verificar se a data está dentro de algum período sazonal
 881 │     for (const seasonalPrice of roomData.seasonalPrices) {
 882 │       const startDate = new Date(seasonalPrice.startDate);
 883 │       const endDate = new Date(seasonalPrice.endDate);
 884 │       
 885 │       if (date >= startDate && date <= endDate) {
 886 │         return seasonalPrice.price;
 887 │       }
 888 │     }
 889 │     
 890 │     // Se não cair em nenhum período sazonal, retorna o preço base
 891 │     return basePrice;
 892 │   } catch (error) {
 893 │     console.error("Erro ao obter preço do quarto:", error);
 894 │     throw error;
 895 │   }
 896 │ }
 897 │ 
 898 │ // Função para calcular o preço total de uma estadia
 899 │ export const calculateStayPrice = async (
 900 │   roomId: string, 
 901 │   checkIn: Date, 
 902 │   checkOut: Date
 903 │ ): Promise<{
 904 │   totalPrice: number;
 905 │   nightlyPrices: { date: string; price: number }[];
 906 │   serviceFee: number;
 907 │   totalWithFee: number;
 908 │ }> => {
 909 │   try {
 910 │     console.log(`🔍 Iniciando cálculo de preço para estadia: ${checkIn.toISOString().split('T')[0]} até ${checkOut.toISOString().split('T')[0]}`);
 911 │     
 912 │     const roomDoc = await getDoc(doc(db, "rooms", roomId));
 913 │     
 914 │     if (!roomDoc.exists()) {
 915 │       throw new Error("Quarto não encontrado");
 916 │     }
 917 │     
 918 │     const roomData = roomDoc.data() as Room;
 919 │     console.log(`📝 Dados do quarto ${roomId}:`, {
 920 │       nome: roomData.name,
 921 │       precoBase: roomData.price,
 922 │       taxaServico: roomData.serviceFeePct || 0,
 923 │       temPrecosSazonais: !!roomData.seasonalPrices?.length
 924 │     });
 925 │     
 926 │     const nightlyPrices: { date: string; price: number }[] = [];
 927 │     let totalPrice = 0;
 928 │     
 929 │     // Calcular o número de noites - corrigido para usar o método correto de cálculo
 930 │     // O número de noites é a diferença em dias (estadia = checkout - checkin)
 931 │     const noites = differenceInDays(checkOut, checkIn);
 932 │     console.log(`🗓️ Número de noites calculado: ${noites}`);
 933 │     
 934 │     if (noites <= 0) {
 935 │       console.error(`⚠️ Erro: número de noites inválido (${noites})`);
 936 │       throw new Error("Data de check-out deve ser posterior à data de check-in");
 937 │     }
 938 │     
 939 │     // Para cada noite, verificar o preço aplicável (preço base ou sazonal)
 940 │     // Começamos exatamente do dia de check-in
 941 │     const currentDate = new Date(checkIn);
 942 │     currentDate.setHours(0, 0, 0, 0); // Normalizar para meia-noite
 943 │     
 944 │     // Processamos cada dia de estadia (noite)
 945 │     console.log(`📊 Calculando preços por noite:`);
 946 │     for (let i = 0; i < noites; i++) {
 947 │       // Obtemos o preço para esta data
 948 │       const dateCopy = new Date(currentDate);
 949 │       const priceForDate = await getRoomPriceForDate(roomId, dateCopy);
 950 │       const dateString = dateCopy.toISOString().split('T')[0]; // YYYY-MM-DD
 951 │       
 952 │       console.log(`   - ${dateString}: €${priceForDate}`);
 953 │       
 954 │       nightlyPrices.push({
 955 │         date: dateString,
 956 │         price: priceForDate
 957 │       });
 958 │       
 959 │       totalPrice += priceForDate;
 960 │       
 961 │       // Avançamos para o próximo dia
 962 │       currentDate.setDate(currentDate.getDate() + 1);
 963 │     }
 964 │     
 965 │     // Verificação de segurança para o cálculo do totalPrice
 966 │     const manualTotal = nightlyPrices.reduce((sum, night) => sum + night.price, 0);
 967 │     if (Math.abs(totalPrice - manualTotal) > 1) {
 968 │       console.error(`⚠️ Discrepância detectada no cálculo do preço total!`);
 969 │       console.error(`   - Total calculado iterativamente: €${totalPrice}`);
 970 │       console.error(`   - Total calculado via reduce: €${manualTotal}`);
 971 │       console.error(`   - Usando o valor recalculado para segurança!`);
 972 │       totalPrice = manualTotal;
 973 │     }
 974 │     
 975 │     // Calcular taxa de serviço
 976 │     const serviceFee = (totalPrice * (roomData.serviceFeePct || 0)) / 100;
 977 │     const totalWithFee = totalPrice + serviceFee;
 978 │     
 979 │     console.log(`💰 Resumo do cálculo:`);
 980 │     console.log(`   - Total das diárias: €${totalPrice}`);
 981 │     console.log(`   - Taxa de serviço (${roomData.serviceFeePct || 0}%): €${serviceFee}`);
 982 │     console.log(`   - Total com taxas: €${totalWithFee}`);
 983 │     
 984 │     return {
 985 │       totalPrice,
 986 │       nightlyPrices,
 987 │       serviceFee,
 988 │       totalWithFee
 989 │     };
 990 │   } catch (error) {
 991 │     console.error("❌ Erro ao calcular preço da estadia:", error);
 992 │     throw error;
 993 │   }
 994 │ } 
 995 │ import { 
 996 │   collection, 
     ·   ─────┬────
     ·        ╰── `collection` redefined here
 997 │   getDocs, 
 998 │   getDoc, 
 999 │   doc, 
     ╰────

  × the name `getDocs` is defined multiple times
      ╭─[/home/runner/workspace/lib/firebase/firestore.ts:4:1]
    4 │   setDoc,
    5 │   addDoc,
    6 │   getDoc,
    7 │   getDocs,
      ·   ───┬───
      ·      ╰── previous definition of `getDocs` here
    8 │   updateDoc,
    9 │   deleteDoc,
   10 │   query,
   11 │   where,
   12 │   orderBy,
   13 │   limit,
   14 │   DocumentData,
   15 │   QueryConstraint,
   16 │   Timestamp,
   17 │   serverTimestamp
   18 │ } from 'firebase/firestore'
   19 │ import { db } from './config'
   20 │ import { Room, SeasonalPrice } from '@/lib/types'
   21 │ import { differenceInDays } from 'date-fns'
   22 │ 
   23 │ // Tipos de dados
   24 │ export interface Booking {
   25 │   id?: string
   26 │   userId?: string
   27 │   guestName: string
   28 │   guestEmail: string
   29 │   guestPhone: string
   30 │   roomId: string
   31 │   roomName: string
   32 │   checkIn: Timestamp
   33 │   checkOut: Timestamp
   34 │   adults: number
   35 │   children: number
   36 │   totalPrice: number
   37 │   status: 'pending' | 'confirmed' | 'cancelled' | 'completed'
   38 │   paymentStatus: 'pending' | 'paid' | 'refunded'
   39 │   specialRequests?: string
   40 │   createdAt?: Timestamp
   41 │   updatedAt?: Timestamp
   42 │ }
   43 │ 
   44 │ export interface Contact {
   45 │   id?: string
   46 │   name: string
   47 │   email: string
   48 │   phone?: string
   49 │   subject: string
   50 │   message: string
   51 │   status: 'new' | 'read' | 'replied'
   52 │   createdAt: Timestamp
   53 │   updatedAt?: Timestamp
   54 │   repliedAt?: Timestamp
   55 │   replyContent?: string
   56 │   reservationDetails?: {
   57 │     checkIn?: Timestamp
   58 │     checkOut?: Timestamp
   59 │     roomId?: string
   60 │     roomName?: string
   61 │     totalGuests?: number
   62 │     totalPrice?: number
   63 │   }
   64 │ }
   65 │ 
   66 │ // Funções genéricas para CRUD
   67 │ export const createDocument = async <T extends DocumentData>(
   68 │   collectionName: string,
   69 │   data: T
   70 │ ): Promise<string> => {
   71 │   const docRef = await addDoc(collection(db, collectionName), {
   72 │     ...data,
   73 │     createdAt: serverTimestamp(),
   74 │     updatedAt: serverTimestamp()
   75 │   })
   76 │   return docRef.id
   77 │ }
   78 │ 
   79 │ export const createDocumentWithId = async <T extends DocumentData>(
   80 │   collectionName: string,
   81 │   id: string,
   82 │   data: T
   83 │ ): Promise<void> => {
   84 │   await setDoc(doc(db, collectionName, id), {
   85 │     ...data,
   86 │     createdAt: serverTimestamp(),
   87 │     updatedAt: serverTimestamp()
   88 │   })
   89 │ }
   90 │ 
   91 │ export const getDocument = async <T>(
   92 │   collectionName: string,
   93 │   id: string
   94 │ ): Promise<T | null> => {
   95 │   const docRef = doc(db, collectionName, id)
   96 │   const docSnap = await getDoc(docRef)
   97 │   
   98 │   if (docSnap.exists()) {
   99 │     const data = docSnap.data();
  100 │     console.log("Dados brutos recuperados do Firestore para quarto:", id, data);
  101 │     
  102 │     if (data?.serviceFeePct !== undefined) {
  103 │       console.log("serviceFeePct antes da conversão:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
  104 │       // Garantir que serviceFeePct seja um número
  105 │       data.serviceFeePct = Number(data.serviceFeePct);
  106 │       console.log("serviceFeePct após conversão:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
  107 │     }
  108 │     
  109 │     return { id: docSnap.id, ...data } as T
  110 │   } else {
  111 │     return null
  112 │   }
  113 │ }
  114 │ 
  115 │ export const getDocuments = async <T>(
  116 │   collectionName: string,
  117 │   constraints: QueryConstraint[] = [],
  118 │   forceRefresh = false
  119 │ ): Promise<T[]> => {
  120 │   try {
  121 │     const collectionRef = collection(db, collectionName)
  122 │     const q = query(collectionRef, ...constraints)
  123 │     
  124 │     // Se forceRefresh for verdadeiro, adicionar opções que forçam uma nova consulta ao Firestore
  125 │     const querySnapshot = await getDocs(q)
  126 │     
  127 │     console.log(`Buscando documentos na coleção ${collectionName} - Força atualização: ${forceRefresh}`);
  128 │     
  129 │     return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }) as T)
  130 │   } catch (error) {
  131 │     console.error(`Erro ao buscar documentos da coleção ${collectionName}:`, error);
  132 │     return [];
  133 │   }
  134 │ }
  135 │ 
  136 │ export const updateDocument = async <T extends DocumentData>(
  137 │   collectionName: string,
  138 │   id: string,
  139 │   data: Partial<T>
  140 │ ): Promise<void> => {
  141 │   const docRef = doc(db, collectionName, id)
  142 │   await updateDoc(docRef, {
  143 │     ...data,
  144 │     updatedAt: serverTimestamp()
  145 │   })
  146 │ }
  147 │ 
  148 │ export const deleteDocument = async (
  149 │   collectionName: string,
  150 │   id: string
  151 │ ): Promise<boolean> => {
  152 │   const docRef = doc(db, collectionName, id)
  153 │   await deleteDoc(docRef)
  154 │   return true
  155 │ }
  156 │ 
  157 │ // Funções para gerenciar quartos
  158 │ export const getRooms = async (forceRefresh = false): Promise<Room[]> => {
  159 │   try {
  160 │     const constraints: QueryConstraint[] = []
  161 │     
  162 │     constraints.push(orderBy('name', 'asc'))
  163 │     
  164 │     const rooms = await getDocuments<Room>('rooms', constraints, forceRefresh)
  165 │     
  166 │     // Garantir que todos os campos necessários estejam presentes
  167 │     return rooms.map(room => {
  168 │       console.log(`Firebase - Quarto ${room.id} dados brutos:`, room);
  169 │       
  170 │       // Garantir que serviceFeePct seja um número
  171 │       const serviceFeePct = room.serviceFeePct !== undefined 
  172 │         ? Number(room.serviceFeePct) 
  173 │         : 10;
  174 │         
  175 │       console.log(`Firebase - Quarto ${room.id} serviceFeePct:`, {
  176 │         original: room.serviceFeePct,
  177 │         tipo: typeof room.serviceFeePct,
  178 │         convertido: serviceFeePct
  179 │       });
  180 │       
  181 │       return {
  182 │         id: room.id,
  183 │         name: room.name || '',
  184 │         type: room.type || 'standard',
  185 │         description: room.description || '',
  186 │         price: room.price || 0,
  187 │         capacity: room.capacity || 2,
  188 │         size: room.size || 0,
  189 │         available: room.available !== undefined ? room.available : true,
  190 │         serviceFeePct: serviceFeePct,
  191 │         images: room.images || [],
  192 │         amenities: room.amenities || [],
  193 │         additionalServices: room.additionalServices || [],
  194 │         highlights: room.highlights || [],
  195 │         createdAt: room.createdAt,
  196 │         updatedAt: room.updatedAt
  197 │       };
  198 │     });
  199 │   } catch (error) {
  200 │     console.error('Erro ao buscar quartos:', error)
  201 │     return []
  202 │   }
  203 │ }
  204 │ 
  205 │ export const getAvailableRooms = async (
  206 │   checkIn: Date,
  207 │   checkOut: Date
  208 │ ): Promise<Room[]> => {
  209 │   try {
  210 │     // Buscar todos os quartos que estão marcados como disponíveis em geral
  211 │     const constraints: QueryConstraint[] = [
  212 │       where('available', '==', true)
  213 │     ]
  214 │     
  215 │     const rooms = await getDocuments<Room>('rooms', constraints);
  216 │     
  217 │     // Filtrar os quartos que estão disponíveis nas datas específicas
  218 │     return filterAvailableRoomsByDate(rooms, checkIn, checkOut);
  219 │   } catch (error) {
  220 │     console.error('Erro ao buscar quartos disponíveis:', error)
  221 │     return []
  222 │   }
  223 │ }
  224 │ 
  225 │ // Função auxiliar para verificar disponibilidade entre datas
  226 │ export const filterAvailableRoomsByDate = (
  227 │   rooms: Room[],
  228 │   checkIn: Date,
  229 │   checkOut: Date
  230 │ ): Room[] => {
  231 │   // Converter checkIn e checkOut para ISO strings
  232 │   const dateStrings = getDatesInRange(checkIn, checkOut);
  233 │   
  234 │   return rooms.filter(room => {
  235 │     // Se não tiver controle de disponibilidade específico, considera disponível
  236 │     if (!room.availabilityDates) return true;
  237 │     
  238 │     // Verificar se alguma data no intervalo está indisponível
  239 │     return !dateStrings.some(dateStr => 
  240 │       room.availabilityDates?.[dateStr] === false
  241 │     );
  242 │   });
  243 │ };
  244 │ 
  245 │ // Função para obter disponibilidade de um quarto específico
  246 │ export const getRoomAvailability = async (
  247 │   roomId: string, 
  248 │   startDate: Date, 
  249 │   endDate: Date
  250 │ ): Promise<{[date: string]: boolean}> => {
  251 │   try {
  252 │     const room = await getRoomById(roomId);
  253 │     if (!room) throw new Error(`Quarto com ID ${roomId} não encontrado`);
  254 │     
  255 │     // Gerar datas no intervalo
  256 │     const dateStrings = getDatesInRange(startDate, endDate);
  257 │     
  258 │     // Se não tiver configuração de disponibilidade específica, assume tudo disponível
  259 │     if (!room.availabilityDates) {
  260 │       return dateStrings.reduce((acc, date) => {
  261 │         acc[date] = true;
  262 │         return acc;
  263 │       }, {} as {[date: string]: boolean});
  264 │     }
  265 │     
  266 │     // Preencher com os dados de disponibilidade existentes
  267 │     return dateStrings.reduce((acc, date) => {
  268 │       acc[date] = room.availabilityDates?.[date] !== false; // disponível por padrão se não estiver explicitamente indisponível
  269 │       return acc;
  270 │     }, {} as {[date: string]: boolean});
  271 │   } catch (error) {
  272 │     console.error(`Erro ao verificar disponibilidade do quarto ${roomId}:`, error);
  273 │     throw error;
  274 │   }
  275 │ };
  276 │ 
  277 │ // Função para atualizar disponibilidade de um quarto
  278 │ export const updateRoomAvailability = async (
  279 │   roomId: string,
  280 │   availabilityDates: {[date: string]: boolean}
  281 │ ): Promise<boolean> => {
  282 │   try {
  283 │     await updateDocument('rooms', roomId, {
  284 │       availabilityDates,
  285 │       updatedAt: serverTimestamp()
  286 │     });
  287 │     return true;
  288 │   } catch (error) {
  289 │     console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  290 │     return false;
  291 │   }
  292 │ };
  293 │ 
  294 │ // Função auxiliar para gerar array de strings de data entre um intervalo
  295 │ export const getDatesInRange = (startDate: Date, endDate: Date): string[] => {
  296 │   const dates: string[] = [];
  297 │   const currentDate = new Date(startDate);
  298 │   
  299 │   // Normalizar para meia-noite no fuso horário local
  300 │   currentDate.setHours(0, 0, 0, 0);
  301 │   const endDateNormalized = new Date(endDate);
  302 │   endDateNormalized.setHours(0, 0, 0, 0);
  303 │   
  304 │   // Adicionar cada data no intervalo EXCETO o dia de checkout
  305 │   // Usando < em vez de <= para não incluir o dia de checkout
  306 │   while (currentDate < endDateNormalized) {
  307 │     dates.push(currentDate.toISOString().split('T')[0]); // Formato YYYY-MM-DD
  308 │     currentDate.setDate(currentDate.getDate() + 1);
  309 │   }
  310 │   
  311 │   return dates;
  312 │ };
  313 │ 
  314 │ export const getRoomById = async (id: string): Promise<Room | null> => {
  315 │   try {
  316 │     const room = await getDocument<Room>('rooms', id);
  317 │     
  318 │     if (!room) return null;
  319 │     
  320 │     console.log(`Firebase - getRoomById ${id} dados brutos:`, room);
  321 │     
  322 │     // Log específico para serviceFeePct
  323 │     console.log(`serviceFeePct no Firestore:`, room.serviceFeePct);
  324 │     
  325 │     // Garantir que todos os campos necessários estejam presentes
  326 │     return {
  327 │       ...room,
  328 │       name: room.name || '',
  329 │       type: room.type || 'standard',
  330 │       description: room.description || '',
  331 │       price: room.price || 0,
  332 │       capacity: room.capacity || 2,
  333 │       size: room.size || 0,
  334 │       available: room.available !== undefined ? room.available : true,
  335 │       serviceFeePct: room.serviceFeePct !== undefined ? room.serviceFeePct : 10,
  336 │       images: room.images || [],
  337 │       amenities: room.amenities || [],
  338 │       additionalServices: room.additionalServices || [],
  339 │       highlights: room.highlights || []
  340 │     };
  341 │   } catch (error) {
  342 │     console.error(`Erro ao buscar quarto com ID ${id}:`, error);
  343 │     return null;
  344 │   }
  345 │ }
  346 │ 
  347 │ export const createRoom = async (roomData: Omit<Room, 'id' | 'createdAt' | 'updatedAt'>): Promise<Room> => {
  348 │   try {
  349 │     console.log("createRoom - Dados recebidos:", roomData);
  350 │     
  351 │     const roomWithTimestamps = {
  352 │       ...roomData,
  353 │       available: roomData.available !== undefined ? roomData.available : true,
  354 │       featured: roomData.featured || false,
  355 │       amenities: roomData.amenities || [],
  356 │       additionalServices: roomData.additionalServices || [],
  357 │       highlights: roomData.highlights || [],
  358 │       createdAt: serverTimestamp(),
  359 │       updatedAt: serverTimestamp()
  360 │     }
  361 │     
  362 │     console.log("createRoom - Dados a serem salvos:", roomWithTimestamps);
  363 │     
  364 │     const id = await createDocument('rooms', roomWithTimestamps)
  365 │     
  366 │     return {
  367 │       id,
  368 │       ...roomData,
  369 │       amenities: roomData.amenities || [],
  370 │       additionalServices: roomData.additionalServices || [],
  371 │       highlights: roomData.highlights || [],
  372 │       createdAt: Timestamp.now(),
  373 │       updatedAt: Timestamp.now()
  374 │     }
  375 │   } catch (error) {
  376 │     console.error('Erro ao criar quarto:', error)
  377 │     throw error
  378 │   }
  379 │ }
  380 │ 
  381 │ export const updateRoom = async (id: string, roomData: Partial<Omit<Room, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Room> => {
  382 │   try {
  383 │     console.log(`updateRoom - ID: ${id}, Dados recebidos:`, roomData);
  384 │     
  385 │     // Garantir que estamos lidando explicitamente com o serviceFeePct se ele for 0
  386 │     if (roomData.serviceFeePct === 0) {
  387 │       console.log("updateRoom - Detectado serviceFeePct com valor 0, salvando explicitamente.", roomData.serviceFeePct);
  388 │     }
  389 │     
  390 │     // Adicionar timestamp de atualização
  391 │     const roomWithTimestamp = {
  392 │       ...roomData,
  393 │       amenities: roomData.amenities || [],
  394 │       additionalServices: roomData.additionalServices || [],
  395 │       highlights: roomData.highlights || [],
  396 │       updatedAt: serverTimestamp()
  397 │     }
  398 │     
  399 │     console.log(`updateRoom - Dados a serem salvos:`, roomWithTimestamp);
  400 │     
  401 │     await updateDocument('rooms', id, roomWithTimestamp)
  402 │     
  403 │     const updatedRoom = await getRoomById(id)
  404 │     if (!updatedRoom) {
  405 │       throw new Error(`Quarto com ID ${id} não encontrado após atualização`)
  406 │     }
  407 │     
  408 │     return updatedRoom
  409 │   } catch (error) {
  410 │     console.error('Erro ao atualizar quarto:', error)
  411 │     throw error
  412 │   }
  413 │ }
  414 │ 
  415 │ export const deleteRoom = async (id: string): Promise<boolean> => {
  416 │   return await deleteDocument('rooms', id)
  417 │ }
  418 │ 
  419 │ // Funções específicas para reservas
  420 │ export const createBooking = async (bookingData: any) => {
  421 │   try {
  422 │     const bookingsCollection = collection(db, 'bookings');
  423 │     const docRef = await addDoc(bookingsCollection, bookingData);
  424 │     
  425 │     // CORREÇÃO: Não bloquear a data no momento da criação da reserva
  426 │     // O bloqueio será feito apenas quando o pagamento for confirmado
  427 │     // através da função updateBookingStatus
  428 │     
  429 │     return docRef;
  430 │   } catch (error) {
  431 │     console.error('Erro ao criar reserva:', error);
  432 │     throw error;
  433 │   }
  434 │ };
  435 │ 
  436 │ // Nova função para atualizar status da reserva e bloquear as datas da estadia
  437 │ export const updateBookingStatus = async (
  438 │   bookingId: string, 
  439 │   newStatus: 'pending' | 'confirmed' | 'cancelled' | 'completed',
  440 │   newPaymentStatus: 'pending' | 'paid' | 'refunded'
  441 │ ): Promise<boolean> => {
  442 │   try {
  443 │     // Referência ao documento da reserva
  444 │     const bookingRef = doc(db, 'bookings', bookingId);
  445 │     const bookingSnap = await getDoc(bookingRef);
  446 │     
  447 │     if (!bookingSnap.exists()) {
  448 │       console.error(`Booking ${bookingId} não existe ao atualizar status`);
  449 │       return false;
  450 │     }
  451 │     
  452 │     const bookingData = bookingSnap.data();
  453 │     
  454 │     // Atualizar o status da reserva
  455 │     await updateDoc(bookingRef, {
  456 │       status: newStatus,
  457 │       paymentStatus: newPaymentStatus,
  458 │       updatedAt: serverTimestamp(),
  459 │       ...(newStatus === 'confirmed' && { confirmedAt: serverTimestamp() })
  460 │     });
  461 │     
  462 │     // Se a reserva está sendo confirmada, precisamos bloquear as datas
  463 │     if (newStatus === 'confirmed') {
  464 │       console.log(`Atualizando disponibilidade para reserva confirmada: ${bookingId}`);
  465 │       
  466 │       // Recuperar datas de check-in e check-out
  467 │       const checkIn = bookingData.checkIn.toDate();
  468 │       const checkOut = bookingData.checkOut.toDate();
  469 │       const roomId = bookingData.roomId;
  470 │       
  471 │       // Obter todas as datas entre check-in e check-out
  472 │       const dates: Date[] = [];
  473 │       const currentDate = new Date(checkIn);
  474 │       
  475 │       while (currentDate < checkOut) {
  476 │         dates.push(new Date(currentDate));
  477 │         currentDate.setDate(currentDate.getDate() + 1);
  478 │       }
  479 │       
  480 │       console.log(`Bloqueando ${dates.length} dias para quarto ${roomId}`);
  481 │       
  482 │       // Atualizar disponibilidade para cada data
  483 │       const availabilityUpdates: {[date: string]: boolean} = {};
  484 │       
  485 │       dates.forEach(date => {
  486 │         const dateString = date.toISOString().split('T')[0]; // formato YYYY-MM-DD
  487 │         availabilityUpdates[dateString] = false; // false significa indisponível
  488 │       });
  489 │       
  490 │       // Atualizar disponibilidade do quarto
  491 │       if (Object.keys(availabilityUpdates).length > 0) {
  492 │         try {
  493 │           // Obter o documento do quarto
  494 │           const roomRef = doc(db, 'rooms', roomId);
  495 │           const roomSnap = await getDoc(roomRef);
  496 │           
  497 │           if (roomSnap.exists()) {
  498 │             const roomData = roomSnap.data();
  499 │             const currentAvailability = roomData.availabilityDates || {};
  500 │             
  501 │             // Mesclar a disponibilidade atual com as novas atualizações
  502 │             const updatedAvailability = {
  503 │               ...currentAvailability,
  504 │               ...availabilityUpdates
  505 │             };
  506 │             
  507 │             // Atualizar o documento do quarto
  508 │             await updateDoc(roomRef, {
  509 │               availabilityDates: updatedAvailability,
  510 │               updatedAt: serverTimestamp()
  511 │             });
  512 │             
  513 │             console.log(`Disponibilidade atualizada com sucesso para quarto ${roomId}`);
  514 │             
  515 │             // Criar log da reserva
  516 │             await addDoc(collection(db, 'bookingLogs'), {
  517 │               bookingId,
  518 │               roomId,
  519 │               action: 'status_updated',
  520 │               previousStatus: bookingData.status,
  521 │               newStatus,
  522 │               previousPaymentStatus: bookingData.paymentStatus,
  523 │               newPaymentStatus,
  524 │               datesBlocked: Object.keys(availabilityUpdates),
  525 │               timestamp: serverTimestamp(),
  526 │               userId: bookingData.userId || 'system'
  527 │             });
  528 │           } else {
  529 │             console.error(`Quarto ${roomId} não encontrado ao atualizar disponibilidade`);
  530 │           }
  531 │         } catch (error) {
  532 │           console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  533 │         }
  534 │       }
  535 │     }
  536 │     
  537 │     return true;
  538 │   } catch (error) {
  539 │     console.error(`Erro ao atualizar status da reserva ${bookingId}:`, error);
  540 │     return false;
  541 │   }
  542 │ }
  543 │ 
  544 │ export const getUserBookings = async (userId: string): Promise<Booking[]> => {
  545 │   return getDocuments<Booking>('bookings', [
  546 │     where('userId', '==', userId),
  547 │     orderBy('createdAt', 'desc')
  548 │   ])
  549 │ }
  550 │ 
  551 │ export const getRecentBookings = async (count = 5): Promise<Booking[]> => {
  552 │   return getDocuments<Booking>('bookings', [
  553 │     orderBy('createdAt', 'desc'),
  554 │     limit(count)
  555 │   ])
  556 │ }
  557 │ 
  558 │ export const getRoomBookings = async (roomId: string): Promise<Booking[]> => {
  559 │   try {
  560 │     const constraints: QueryConstraint[] = [
  561 │       where('roomId', '==', roomId),
  562 │       orderBy('checkIn', 'asc')
  563 │     ];
  564 │     
  565 │     return await getDocuments<Booking>('bookings', constraints);
  566 │   } catch (error) {
  567 │     console.error(`Erro ao buscar reservas do quarto ${roomId}:`, error);
  568 │     return [];
  569 │   }
  570 │ };
  571 │ 
  572 │ // Funções específicas para contatos
  573 │ export const createContactMessage = async (contactData: Contact) => {
  574 │   try {
  575 │     const contactsCollection = collection(db, 'contacts')
  576 │     
  577 │     // Garantir que o status seja 'new' para novos contatos
  578 │     const contactWithDefaults = {
  579 │       ...contactData,
  580 │       status: contactData.status || 'new',
  581 │       createdAt: contactData.createdAt || Timestamp.now()
  582 │     }
  583 │     
  584 │     // Se tiver detalhes de reserva, adicionar metadados
  585 │     if (contactWithDefaults.reservationDetails) {
  586 │       // Ajustar subject para indicar que é relacionado a reserva
  587 │       if (!contactWithDefaults.subject.includes('Reserva')) {
  588 │         contactWithDefaults.subject = `Reserva: ${contactWithDefaults.subject}`;
  589 │       }
  590 │     }
  591 │     
  592 │     const docRef = await addDoc(contactsCollection, contactWithDefaults)
  593 │     return docRef
  594 │   } catch (error) {
  595 │     console.error('Erro ao criar mensagem de contato:', error)
  596 │     throw error
  597 │   }
  598 │ }
  599 │ 
  600 │ export const getNewContactMessages = async (): Promise<Contact[]> => {
  601 │   return getDocuments<Contact>('contacts', [
  602 │     where('status', '==', 'new'),
  603 │     orderBy('createdAt', 'desc')
  604 │   ])
  605 │ }
  606 │ 
  607 │ // Funções para Dashboard com dados reais
  608 │ 
  609 │ export const getDashboardStats = async () => {
  610 │   try {
  611 │     const [totalBookings, totalRevenue, occupancyRate, bookingsByPlatform] = await Promise.all([
  612 │       getTotalBookings(),
  613 │       getMonthlyRevenue(),
  614 │       getOccupancyRate(),
  615 │       getBookingsByPlatform()
  616 │     ]);
  617 │ 
  618 │     return {
  619 │       totalBookings,
  620 │       totalRevenue,
  621 │       occupancyRate,
  622 │       bookingsByPlatform
  623 │     };
  624 │   } catch (error) {
  625 │     console.error('Erro ao obter estatísticas do dashboard:', error);
  626 │     throw error;
  627 │   }
  628 │ };
  629 │ 
  630 │ // Obter total de reservas
  631 │ export const getTotalBookings = async () => {
  632 │   try {
  633 │     // Obter todas as reservas
  634 │     const bookings = await getDocuments<Booking>('bookings');
  635 │     
  636 │     // Contar reservas por status
  637 │     const confirmed = bookings.filter(b => b.status === 'confirmed').length;
  638 │     const pending = bookings.filter(b => b.status === 'pending').length;
  639 │     const cancelled = bookings.filter(b => b.status === 'cancelled').length;
  640 │     const completed = bookings.filter(b => b.status === 'completed').length;
  641 │     
  642 │     // Calcular crescimento em relação ao mês anterior (simulado por enquanto)
  643 │     // Em uma implementação real, você compararia com dados do mês anterior
  644 │     const growth = ((confirmed + completed) / (bookings.length || 1) * 100) - 50;
  645 │     
  646 │     return {
  647 │       total: bookings.length,
  648 │       confirmed,
  649 │       pending,
  650 │       cancelled,
  651 │       completed,
  652 │       growth: Math.round(growth) // Arredonda para número inteiro
  653 │     };
  654 │   } catch (error) {
  655 │     console.error('Erro ao obter total de reservas:', error);
  656 │     return {
  657 │       total: 0,
  658 │       confirmed: 0,
  659 │       pending: 0, 
  660 │       cancelled: 0,
  661 │       completed: 0,
  662 │       growth: 0
  663 │     };
  664 │   }
  665 │ };
  666 │ 
  667 │ // Obter receita mensal
  668 │ export const getMonthlyRevenue = async () => {
  669 │   try {
  670 │     const bookings = await getDocuments<Booking>('bookings');
  671 │     
  672 │     // Filtrar reservas confirmadas e concluídas
  673 │     const validBookings = bookings.filter(b => 
  674 │       b.status === 'confirmed' || b.status === 'completed'
  675 │     );
  676 │     
  677 │     // Calcular receita total
  678 │     const totalRevenue = validBookings.reduce((acc, booking) => acc + booking.totalPrice, 0);
  679 │     
  680 │     // Agrupar receita por mês
  681 │     const revenueByMonth = validBookings.reduce((acc, booking) => {
  682 │       const date = booking.checkIn.toDate();
  683 │       const month = date.getMonth(); // 0-11
  684 │       const year = date.getFullYear();
  685 │       const key = `${year}-${month}`;
  686 │       
  687 │       if (!acc[key]) {
  688 │         acc[key] = 0;
  689 │       }
  690 │       acc[key] += booking.totalPrice;
  691 │       return acc;
  692 │     }, {} as Record<string, number>);
  693 │     
  694 │     // Converter para formato de array para gráfico
  695 │     const monthNames = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
  696 │     
  697 │     const currentDate = new Date();
  698 │     const currentMonth = currentDate.getMonth();
  699 │     const currentYear = currentDate.getFullYear();
  700 │     
  701 │     const revenueData = [];
  702 │     
  703 │     // Gerar dados dos últimos 12 meses
  704 │     for (let i = 0; i < 12; i++) {
  705 │       const month = (currentMonth - i + 12) % 12;
  706 │       const year = currentMonth - i < 0 ? currentYear - 1 : currentYear;
  707 │       const key = `${year}-${month}`;
  708 │       
  709 │       revenueData.unshift({
  710 │         month: monthNames[month],
  711 │         value: revenueByMonth[key] || 0
  712 │       });
  713 │     }
  714 │     
  715 │     // Calcular crescimento em relação ao mês anterior
  716 │     const lastMonthRevenue = revenueData[revenueData.length - 2]?.value || 0;
  717 │     const currentMonthRevenue = revenueData[revenueData.length - 1]?.value || 0;
  718 │     
  719 │     const growth = lastMonthRevenue ? ((currentMonthRevenue - lastMonthRevenue) / lastMonthRevenue) * 100 : 0;
  720 │     
  721 │     return {
  722 │       monthly: currentMonthRevenue,
  723 │       total: totalRevenue,
  724 │       growth: Math.round(growth),
  725 │       revenueData
  726 │     };
  727 │   } catch (error) {
  728 │     console.error('Erro ao obter receita mensal:', error);
  729 │     return {
  730 │       monthly: 0,
  731 │       total: 0,
  732 │       growth: 0,
  733 │       revenueData: []
  734 │     };
  735 │   }
  736 │ };
  737 │ 
  738 │ // Calcular taxa de ocupação
  739 │ export const getOccupancyRate = async () => {
  740 │   try {
  741 │     // Obter todos os quartos
  742 │     const rooms = await getDocuments<Room>('rooms');
  743 │     const totalRooms = rooms.length;
  744 │     
  745 │     if (totalRooms === 0) {
  746 │       return { rate: 0, growth: 0 };
  747 │     }
  748 │     
  749 │     // Obter todas as reservas
  750 │     const bookings = await getDocuments<Booking>('bookings');
  751 │     
  752 │     // Filtrar reservas confirmadas e concluídas para o mês atual
  753 │     const currentDate = new Date();
  754 │     const currentMonth = currentDate.getMonth();
  755 │     const currentYear = currentDate.getFullYear();
  756 │     
  757 │     const currentMonthBookings = bookings.filter(booking => {
  758 │       const checkInDate = booking.checkIn.toDate();
  759 │       return (
  760 │         (booking.status === 'confirmed' || booking.status === 'completed') &&
  761 │         checkInDate.getMonth() === currentMonth &&
  762 │         checkInDate.getFullYear() === currentYear
  763 │       );
  764 │     });
  765 │     
  766 │     // Calcular dias ocupados por quarto
  767 │     const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
  768 │     const totalPossibleRoomDays = totalRooms * daysInMonth;
  769 │     
  770 │     // Contar dias ocupados (simplificado - em produção seria mais complexo)
  771 │     let occupiedDays = 0;
  772 │     
  773 │     currentMonthBookings.forEach(booking => {
  774 │       const checkIn = booking.checkIn.toDate();
  775 │       const checkOut = booking.checkOut.toDate();
  776 │       
  777 │       // Ajustar datas para considerar apenas o mês atual
  778 │       const startDate = new Date(Math.max(
  779 │         checkIn.getTime(),
  780 │         new Date(currentYear, currentMonth, 1).getTime()
  781 │       ));
  782 │       const endDate = new Date(Math.min(
  783 │         checkOut.getTime(),
  784 │         new Date(currentYear, currentMonth + 1, 0).getTime()
  785 │       ));
  786 │       
  787 │       // Calcular dias entre datas (incluindo check-in, excluindo check-out)
  788 │       const days = Math.max(0, Math.floor((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)));
  789 │       occupiedDays += days;
  790 │     });
  791 │     
  792 │     const occupancyRate = (occupiedDays / totalPossibleRoomDays) * 100;
  793 │     
  794 │     // Simulação de crescimento (em produção, compararia com mês anterior)
  795 │     const growth = occupancyRate > 50 ? 5 : -3;
  796 │     
  797 │     return {
  798 │       rate: Math.round(occupancyRate),
  799 │       growth: Math.round(growth)
  800 │     };
  801 │   } catch (error) {
  802 │     console.error('Erro ao calcular taxa de ocupação:', error);
  803 │     return { rate: 0, growth: 0 };
  804 │   }
  805 │ };
  806 │ 
  807 │ // Obter reservas agrupadas por plataforma
  808 │ export const getBookingsByPlatform = async () => {
  809 │   try {
  810 │     const bookings = await getDocuments<Booking>('bookings');
  811 │     
  812 │     // Categorizar reservas por origem
  813 │     const platforms = [
  814 │       { 
  815 │         platform: "Booking.com", 
  816 │         color: "#003580", 
  817 │         icon: "Globe",
  818 │         bookings: []
  819 │       },
  820 │       { 
  821 │         platform: "Airbnb", 
  822 │         color: "#FF5A5F", 
  823 │         icon: "Heart",
  824 │         bookings: []
  825 │       },
  826 │       { 
  827 │         platform: "Direto", 
  828 │         color: "#4CAF50", 
  829 │         icon: "Home",
  830 │         bookings: []
  831 │       }
  832 │     ];
  833 │     
  834 │     // Para fins de demonstração, colocar todas as reservas como "Direto" por enquanto
  835 │     // Em produção, usaria um campo "platformOrigin" ou similar na tabela de reservas
  836 │     const platformIndex = 2; // Índice da plataforma "Direto"
  837 │     
  838 │     bookings.forEach(booking => {
  839 │       // Transformar para o formato esperado pelo componente
  840 │       const transformedBooking = {
  841 │         id: booking.id || '',
  842 │         guestName: booking.guestName,
  843 │         roomName: booking.roomName,
  844 │         checkIn: booking.checkIn.toDate().toLocaleDateString('pt-PT'),
  845 │         checkOut: booking.checkOut.toDate().toLocaleDateString('pt-PT'),
  846 │         status: booking.status,
  847 │         value: new Intl.NumberFormat('pt-PT', {
  848 │           style: 'currency',
  849 │           currency: 'EUR'
  850 │         }).format(booking.totalPrice)
  851 │       };
  852 │       
  853 │       // Adicionar à plataforma "Direto"
  854 │       (platforms[platformIndex] as any).bookings.push(transformedBooking);
  855 │     });
  856 │     
  857 │     return platforms;
  858 │   } catch (error) {
  859 │     console.error('Erro ao obter reservas por plataforma:', error);
  860 │     return [];
  861 │   }
  862 │ };
  863 │ 
  864 │ // Função para obter o preço de um quarto para uma data específica
  865 │ export const getRoomPriceForDate = async (roomId: string, date: Date): Promise<number> => {
  866 │   try {
  867 │     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  868 │     
  869 │     if (!roomDoc.exists()) {
  870 │       throw new Error("Quarto não encontrado");
  871 │     }
  872 │     
  873 │     const roomData = roomDoc.data() as Room;
  874 │     const basePrice = roomData.price;
  875 │     
  876 │     if (!roomData.seasonalPrices || roomData.seasonalPrices.length === 0) {
  877 │       return basePrice;
  878 │     }
  879 │     
  880 │     // Verificar se a data está dentro de algum período sazonal
  881 │     for (const seasonalPrice of roomData.seasonalPrices) {
  882 │       const startDate = new Date(seasonalPrice.startDate);
  883 │       const endDate = new Date(seasonalPrice.endDate);
  884 │       
  885 │       if (date >= startDate && date <= endDate) {
  886 │         return seasonalPrice.price;
  887 │       }
  888 │     }
  889 │     
  890 │     // Se não cair em nenhum período sazonal, retorna o preço base
  891 │     return basePrice;
  892 │   } catch (error) {
  893 │     console.error("Erro ao obter preço do quarto:", error);
  894 │     throw error;
  895 │   }
  896 │ }
  897 │ 
  898 │ // Função para calcular o preço total de uma estadia
  899 │ export const calculateStayPrice = async (
  900 │   roomId: string, 
  901 │   checkIn: Date, 
  902 │   checkOut: Date
  903 │ ): Promise<{
  904 │   totalPrice: number;
  905 │   nightlyPrices: { date: string; price: number }[];
  906 │   serviceFee: number;
  907 │   totalWithFee: number;
  908 │ }> => {
  909 │   try {
  910 │     console.log(`🔍 Iniciando cálculo de preço para estadia: ${checkIn.toISOString().split('T')[0]} até ${checkOut.toISOString().split('T')[0]}`);
  911 │     
  912 │     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  913 │     
  914 │     if (!roomDoc.exists()) {
  915 │       throw new Error("Quarto não encontrado");
  916 │     }
  917 │     
  918 │     const roomData = roomDoc.data() as Room;
  919 │     console.log(`📝 Dados do quarto ${roomId}:`, {
  920 │       nome: roomData.name,
  921 │       precoBase: roomData.price,
  922 │       taxaServico: roomData.serviceFeePct || 0,
  923 │       temPrecosSazonais: !!roomData.seasonalPrices?.length
  924 │     });
  925 │     
  926 │     const nightlyPrices: { date: string; price: number }[] = [];
  927 │     let totalPrice = 0;
  928 │     
  929 │     // Calcular o número de noites - corrigido para usar o método correto de cálculo
  930 │     // O número de noites é a diferença em dias (estadia = checkout - checkin)
  931 │     const noites = differenceInDays(checkOut, checkIn);
  932 │     console.log(`🗓️ Número de noites calculado: ${noites}`);
  933 │     
  934 │     if (noites <= 0) {
  935 │       console.error(`⚠️ Erro: número de noites inválido (${noites})`);
  936 │       throw new Error("Data de check-out deve ser posterior à data de check-in");
  937 │     }
  938 │     
  939 │     // Para cada noite, verificar o preço aplicável (preço base ou sazonal)
  940 │     // Começamos exatamente do dia de check-in
  941 │     const currentDate = new Date(checkIn);
  942 │     currentDate.setHours(0, 0, 0, 0); // Normalizar para meia-noite
  943 │     
  944 │     // Processamos cada dia de estadia (noite)
  945 │     console.log(`📊 Calculando preços por noite:`);
  946 │     for (let i = 0; i < noites; i++) {
  947 │       // Obtemos o preço para esta data
  948 │       const dateCopy = new Date(currentDate);
  949 │       const priceForDate = await getRoomPriceForDate(roomId, dateCopy);
  950 │       const dateString = dateCopy.toISOString().split('T')[0]; // YYYY-MM-DD
  951 │       
  952 │       console.log(`   - ${dateString}: €${priceForDate}`);
  953 │       
  954 │       nightlyPrices.push({
  955 │         date: dateString,
  956 │         price: priceForDate
  957 │       });
  958 │       
  959 │       totalPrice += priceForDate;
  960 │       
  961 │       // Avançamos para o próximo dia
  962 │       currentDate.setDate(currentDate.getDate() + 1);
  963 │     }
  964 │     
  965 │     // Verificação de segurança para o cálculo do totalPrice
  966 │     const manualTotal = nightlyPrices.reduce((sum, night) => sum + night.price, 0);
  967 │     if (Math.abs(totalPrice - manualTotal) > 1) {
  968 │       console.error(`⚠️ Discrepância detectada no cálculo do preço total!`);
  969 │       console.error(`   - Total calculado iterativamente: €${totalPrice}`);
  970 │       console.error(`   - Total calculado via reduce: €${manualTotal}`);
  971 │       console.error(`   - Usando o valor recalculado para segurança!`);
  972 │       totalPrice = manualTotal;
  973 │     }
  974 │     
  975 │     // Calcular taxa de serviço
  976 │     const serviceFee = (totalPrice * (roomData.serviceFeePct || 0)) / 100;
  977 │     const totalWithFee = totalPrice + serviceFee;
  978 │     
  979 │     console.log(`💰 Resumo do cálculo:`);
  980 │     console.log(`   - Total das diárias: €${totalPrice}`);
  981 │     console.log(`   - Taxa de serviço (${roomData.serviceFeePct || 0}%): €${serviceFee}`);
  982 │     console.log(`   - Total com taxas: €${totalWithFee}`);
  983 │     
  984 │     return {
  985 │       totalPrice,
  986 │       nightlyPrices,
  987 │       serviceFee,
  988 │       totalWithFee
  989 │     };
  990 │   } catch (error) {
  991 │     console.error("❌ Erro ao calcular preço da estadia:", error);
  992 │     throw error;
  993 │   }
  994 │ } 
  995 │ import { 
  996 │   collection, 
  997 │   getDocs, 
      ·   ───┬───
      ·      ╰── `getDocs` redefined here
  998 │   getDoc, 
  999 │   doc, 
 1000 │   setDoc, 
      ╰────

  × the name `getDoc` is defined multiple times
      ╭─[/home/runner/workspace/lib/firebase/firestore.ts:3:1]
    3 │   doc,
    4 │   setDoc,
    5 │   addDoc,
    6 │   getDoc,
      ·   ───┬──
      ·      ╰── previous definition of `getDoc` here
    7 │   getDocs,
    8 │   updateDoc,
    9 │   deleteDoc,
   10 │   query,
   11 │   where,
   12 │   orderBy,
   13 │   limit,
   14 │   DocumentData,
   15 │   QueryConstraint,
   16 │   Timestamp,
   17 │   serverTimestamp
   18 │ } from 'firebase/firestore'
   19 │ import { db } from './config'
   20 │ import { Room, SeasonalPrice } from '@/lib/types'
   21 │ import { differenceInDays } from 'date-fns'
   22 │ 
   23 │ // Tipos de dados
   24 │ export interface Booking {
   25 │   id?: string
   26 │   userId?: string
   27 │   guestName: string
   28 │   guestEmail: string
   29 │   guestPhone: string
   30 │   roomId: string
   31 │   roomName: string
   32 │   checkIn: Timestamp
   33 │   checkOut: Timestamp
   34 │   adults: number
   35 │   children: number
   36 │   totalPrice: number
   37 │   status: 'pending' | 'confirmed' | 'cancelled' | 'completed'
   38 │   paymentStatus: 'pending' | 'paid' | 'refunded'
   39 │   specialRequests?: string
   40 │   createdAt?: Timestamp
   41 │   updatedAt?: Timestamp
   42 │ }
   43 │ 
   44 │ export interface Contact {
   45 │   id?: string
   46 │   name: string
   47 │   email: string
   48 │   phone?: string
   49 │   subject: string
   50 │   message: string
   51 │   status: 'new' | 'read' | 'replied'
   52 │   createdAt: Timestamp
   53 │   updatedAt?: Timestamp
   54 │   repliedAt?: Timestamp
   55 │   replyContent?: string
   56 │   reservationDetails?: {
   57 │     checkIn?: Timestamp
   58 │     checkOut?: Timestamp
   59 │     roomId?: string
   60 │     roomName?: string
   61 │     totalGuests?: number
   62 │     totalPrice?: number
   63 │   }
   64 │ }
   65 │ 
   66 │ // Funções genéricas para CRUD
   67 │ export const createDocument = async <T extends DocumentData>(
   68 │   collectionName: string,
   69 │   data: T
   70 │ ): Promise<string> => {
   71 │   const docRef = await addDoc(collection(db, collectionName), {
   72 │     ...data,
   73 │     createdAt: serverTimestamp(),
   74 │     updatedAt: serverTimestamp()
   75 │   })
   76 │   return docRef.id
   77 │ }
   78 │ 
   79 │ export const createDocumentWithId = async <T extends DocumentData>(
   80 │   collectionName: string,
   81 │   id: string,
   82 │   data: T
   83 │ ): Promise<void> => {
   84 │   await setDoc(doc(db, collectionName, id), {
   85 │     ...data,
   86 │     createdAt: serverTimestamp(),
   87 │     updatedAt: serverTimestamp()
   88 │   })
   89 │ }
   90 │ 
   91 │ export const getDocument = async <T>(
   92 │   collectionName: string,
   93 │   id: string
   94 │ ): Promise<T | null> => {
   95 │   const docRef = doc(db, collectionName, id)
   96 │   const docSnap = await getDoc(docRef)
   97 │   
   98 │   if (docSnap.exists()) {
   99 │     const data = docSnap.data();
  100 │     console.log("Dados brutos recuperados do Firestore para quarto:", id, data);
  101 │     
  102 │     if (data?.serviceFeePct !== undefined) {
  103 │       console.log("serviceFeePct antes da conversão:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
  104 │       // Garantir que serviceFeePct seja um número
  105 │       data.serviceFeePct = Number(data.serviceFeePct);
  106 │       console.log("serviceFeePct após conversão:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
  107 │     }
  108 │     
  109 │     return { id: docSnap.id, ...data } as T
  110 │   } else {
  111 │     return null
  112 │   }
  113 │ }
  114 │ 
  115 │ export const getDocuments = async <T>(
  116 │   collectionName: string,
  117 │   constraints: QueryConstraint[] = [],
  118 │   forceRefresh = false
  119 │ ): Promise<T[]> => {
  120 │   try {
  121 │     const collectionRef = collection(db, collectionName)
  122 │     const q = query(collectionRef, ...constraints)
  123 │     
  124 │     // Se forceRefresh for verdadeiro, adicionar opções que forçam uma nova consulta ao Firestore
  125 │     const querySnapshot = await getDocs(q)
  126 │     
  127 │     console.log(`Buscando documentos na coleção ${collectionName} - Força atualização: ${forceRefresh}`);
  128 │     
  129 │     return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }) as T)
  130 │   } catch (error) {
  131 │     console.error(`Erro ao buscar documentos da coleção ${collectionName}:`, error);
  132 │     return [];
  133 │   }
  134 │ }
  135 │ 
  136 │ export const updateDocument = async <T extends DocumentData>(
  137 │   collectionName: string,
  138 │   id: string,
  139 │   data: Partial<T>
  140 │ ): Promise<void> => {
  141 │   const docRef = doc(db, collectionName, id)
  142 │   await updateDoc(docRef, {
  143 │     ...data,
  144 │     updatedAt: serverTimestamp()
  145 │   })
  146 │ }
  147 │ 
  148 │ export const deleteDocument = async (
  149 │   collectionName: string,
  150 │   id: string
  151 │ ): Promise<boolean> => {
  152 │   const docRef = doc(db, collectionName, id)
  153 │   await deleteDoc(docRef)
  154 │   return true
  155 │ }
  156 │ 
  157 │ // Funções para gerenciar quartos
  158 │ export const getRooms = async (forceRefresh = false): Promise<Room[]> => {
  159 │   try {
  160 │     const constraints: QueryConstraint[] = []
  161 │     
  162 │     constraints.push(orderBy('name', 'asc'))
  163 │     
  164 │     const rooms = await getDocuments<Room>('rooms', constraints, forceRefresh)
  165 │     
  166 │     // Garantir que todos os campos necessários estejam presentes
  167 │     return rooms.map(room => {
  168 │       console.log(`Firebase - Quarto ${room.id} dados brutos:`, room);
  169 │       
  170 │       // Garantir que serviceFeePct seja um número
  171 │       const serviceFeePct = room.serviceFeePct !== undefined 
  172 │         ? Number(room.serviceFeePct) 
  173 │         : 10;
  174 │         
  175 │       console.log(`Firebase - Quarto ${room.id} serviceFeePct:`, {
  176 │         original: room.serviceFeePct,
  177 │         tipo: typeof room.serviceFeePct,
  178 │         convertido: serviceFeePct
  179 │       });
  180 │       
  181 │       return {
  182 │         id: room.id,
  183 │         name: room.name || '',
  184 │         type: room.type || 'standard',
  185 │         description: room.description || '',
  186 │         price: room.price || 0,
  187 │         capacity: room.capacity || 2,
  188 │         size: room.size || 0,
  189 │         available: room.available !== undefined ? room.available : true,
  190 │         serviceFeePct: serviceFeePct,
  191 │         images: room.images || [],
  192 │         amenities: room.amenities || [],
  193 │         additionalServices: room.additionalServices || [],
  194 │         highlights: room.highlights || [],
  195 │         createdAt: room.createdAt,
  196 │         updatedAt: room.updatedAt
  197 │       };
  198 │     });
  199 │   } catch (error) {
  200 │     console.error('Erro ao buscar quartos:', error)
  201 │     return []
  202 │   }
  203 │ }
  204 │ 
  205 │ export const getAvailableRooms = async (
  206 │   checkIn: Date,
  207 │   checkOut: Date
  208 │ ): Promise<Room[]> => {
  209 │   try {
  210 │     // Buscar todos os quartos que estão marcados como disponíveis em geral
  211 │     const constraints: QueryConstraint[] = [
  212 │       where('available', '==', true)
  213 │     ]
  214 │     
  215 │     const rooms = await getDocuments<Room>('rooms', constraints);
  216 │     
  217 │     // Filtrar os quartos que estão disponíveis nas datas específicas
  218 │     return filterAvailableRoomsByDate(rooms, checkIn, checkOut);
  219 │   } catch (error) {
  220 │     console.error('Erro ao buscar quartos disponíveis:', error)
  221 │     return []
  222 │   }
  223 │ }
  224 │ 
  225 │ // Função auxiliar para verificar disponibilidade entre datas
  226 │ export const filterAvailableRoomsByDate = (
  227 │   rooms: Room[],
  228 │   checkIn: Date,
  229 │   checkOut: Date
  230 │ ): Room[] => {
  231 │   // Converter checkIn e checkOut para ISO strings
  232 │   const dateStrings = getDatesInRange(checkIn, checkOut);
  233 │   
  234 │   return rooms.filter(room => {
  235 │     // Se não tiver controle de disponibilidade específico, considera disponível
  236 │     if (!room.availabilityDates) return true;
  237 │     
  238 │     // Verificar se alguma data no intervalo está indisponível
  239 │     return !dateStrings.some(dateStr => 
  240 │       room.availabilityDates?.[dateStr] === false
  241 │     );
  242 │   });
  243 │ };
  244 │ 
  245 │ // Função para obter disponibilidade de um quarto específico
  246 │ export const getRoomAvailability = async (
  247 │   roomId: string, 
  248 │   startDate: Date, 
  249 │   endDate: Date
  250 │ ): Promise<{[date: string]: boolean}> => {
  251 │   try {
  252 │     const room = await getRoomById(roomId);
  253 │     if (!room) throw new Error(`Quarto com ID ${roomId} não encontrado`);
  254 │     
  255 │     // Gerar datas no intervalo
  256 │     const dateStrings = getDatesInRange(startDate, endDate);
  257 │     
  258 │     // Se não tiver configuração de disponibilidade específica, assume tudo disponível
  259 │     if (!room.availabilityDates) {
  260 │       return dateStrings.reduce((acc, date) => {
  261 │         acc[date] = true;
  262 │         return acc;
  263 │       }, {} as {[date: string]: boolean});
  264 │     }
  265 │     
  266 │     // Preencher com os dados de disponibilidade existentes
  267 │     return dateStrings.reduce((acc, date) => {
  268 │       acc[date] = room.availabilityDates?.[date] !== false; // disponível por padrão se não estiver explicitamente indisponível
  269 │       return acc;
  270 │     }, {} as {[date: string]: boolean});
  271 │   } catch (error) {
  272 │     console.error(`Erro ao verificar disponibilidade do quarto ${roomId}:`, error);
  273 │     throw error;
  274 │   }
  275 │ };
  276 │ 
  277 │ // Função para atualizar disponibilidade de um quarto
  278 │ export const updateRoomAvailability = async (
  279 │   roomId: string,
  280 │   availabilityDates: {[date: string]: boolean}
  281 │ ): Promise<boolean> => {
  282 │   try {
  283 │     await updateDocument('rooms', roomId, {
  284 │       availabilityDates,
  285 │       updatedAt: serverTimestamp()
  286 │     });
  287 │     return true;
  288 │   } catch (error) {
  289 │     console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  290 │     return false;
  291 │   }
  292 │ };
  293 │ 
  294 │ // Função auxiliar para gerar array de strings de data entre um intervalo
  295 │ export const getDatesInRange = (startDate: Date, endDate: Date): string[] => {
  296 │   const dates: string[] = [];
  297 │   const currentDate = new Date(startDate);
  298 │   
  299 │   // Normalizar para meia-noite no fuso horário local
  300 │   currentDate.setHours(0, 0, 0, 0);
  301 │   const endDateNormalized = new Date(endDate);
  302 │   endDateNormalized.setHours(0, 0, 0, 0);
  303 │   
  304 │   // Adicionar cada data no intervalo EXCETO o dia de checkout
  305 │   // Usando < em vez de <= para não incluir o dia de checkout
  306 │   while (currentDate < endDateNormalized) {
  307 │     dates.push(currentDate.toISOString().split('T')[0]); // Formato YYYY-MM-DD
  308 │     currentDate.setDate(currentDate.getDate() + 1);
  309 │   }
  310 │   
  311 │   return dates;
  312 │ };
  313 │ 
  314 │ export const getRoomById = async (id: string): Promise<Room | null> => {
  315 │   try {
  316 │     const room = await getDocument<Room>('rooms', id);
  317 │     
  318 │     if (!room) return null;
  319 │     
  320 │     console.log(`Firebase - getRoomById ${id} dados brutos:`, room);
  321 │     
  322 │     // Log específico para serviceFeePct
  323 │     console.log(`serviceFeePct no Firestore:`, room.serviceFeePct);
  324 │     
  325 │     // Garantir que todos os campos necessários estejam presentes
  326 │     return {
  327 │       ...room,
  328 │       name: room.name || '',
  329 │       type: room.type || 'standard',
  330 │       description: room.description || '',
  331 │       price: room.price || 0,
  332 │       capacity: room.capacity || 2,
  333 │       size: room.size || 0,
  334 │       available: room.available !== undefined ? room.available : true,
  335 │       serviceFeePct: room.serviceFeePct !== undefined ? room.serviceFeePct : 10,
  336 │       images: room.images || [],
  337 │       amenities: room.amenities || [],
  338 │       additionalServices: room.additionalServices || [],
  339 │       highlights: room.highlights || []
  340 │     };
  341 │   } catch (error) {
  342 │     console.error(`Erro ao buscar quarto com ID ${id}:`, error);
  343 │     return null;
  344 │   }
  345 │ }
  346 │ 
  347 │ export const createRoom = async (roomData: Omit<Room, 'id' | 'createdAt' | 'updatedAt'>): Promise<Room> => {
  348 │   try {
  349 │     console.log("createRoom - Dados recebidos:", roomData);
  350 │     
  351 │     const roomWithTimestamps = {
  352 │       ...roomData,
  353 │       available: roomData.available !== undefined ? roomData.available : true,
  354 │       featured: roomData.featured || false,
  355 │       amenities: roomData.amenities || [],
  356 │       additionalServices: roomData.additionalServices || [],
  357 │       highlights: roomData.highlights || [],
  358 │       createdAt: serverTimestamp(),
  359 │       updatedAt: serverTimestamp()
  360 │     }
  361 │     
  362 │     console.log("createRoom - Dados a serem salvos:", roomWithTimestamps);
  363 │     
  364 │     const id = await createDocument('rooms', roomWithTimestamps)
  365 │     
  366 │     return {
  367 │       id,
  368 │       ...roomData,
  369 │       amenities: roomData.amenities || [],
  370 │       additionalServices: roomData.additionalServices || [],
  371 │       highlights: roomData.highlights || [],
  372 │       createdAt: Timestamp.now(),
  373 │       updatedAt: Timestamp.now()
  374 │     }
  375 │   } catch (error) {
  376 │     console.error('Erro ao criar quarto:', error)
  377 │     throw error
  378 │   }
  379 │ }
  380 │ 
  381 │ export const updateRoom = async (id: string, roomData: Partial<Omit<Room, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Room> => {
  382 │   try {
  383 │     console.log(`updateRoom - ID: ${id}, Dados recebidos:`, roomData);
  384 │     
  385 │     // Garantir que estamos lidando explicitamente com o serviceFeePct se ele for 0
  386 │     if (roomData.serviceFeePct === 0) {
  387 │       console.log("updateRoom - Detectado serviceFeePct com valor 0, salvando explicitamente.", roomData.serviceFeePct);
  388 │     }
  389 │     
  390 │     // Adicionar timestamp de atualização
  391 │     const roomWithTimestamp = {
  392 │       ...roomData,
  393 │       amenities: roomData.amenities || [],
  394 │       additionalServices: roomData.additionalServices || [],
  395 │       highlights: roomData.highlights || [],
  396 │       updatedAt: serverTimestamp()
  397 │     }
  398 │     
  399 │     console.log(`updateRoom - Dados a serem salvos:`, roomWithTimestamp);
  400 │     
  401 │     await updateDocument('rooms', id, roomWithTimestamp)
  402 │     
  403 │     const updatedRoom = await getRoomById(id)
  404 │     if (!updatedRoom) {
  405 │       throw new Error(`Quarto com ID ${id} não encontrado após atualização`)
  406 │     }
  407 │     
  408 │     return updatedRoom
  409 │   } catch (error) {
  410 │     console.error('Erro ao atualizar quarto:', error)
  411 │     throw error
  412 │   }
  413 │ }
  414 │ 
  415 │ export const deleteRoom = async (id: string): Promise<boolean> => {
  416 │   return await deleteDocument('rooms', id)
  417 │ }
  418 │ 
  419 │ // Funções específicas para reservas
  420 │ export const createBooking = async (bookingData: any) => {
  421 │   try {
  422 │     const bookingsCollection = collection(db, 'bookings');
  423 │     const docRef = await addDoc(bookingsCollection, bookingData);
  424 │     
  425 │     // CORREÇÃO: Não bloquear a data no momento da criação da reserva
  426 │     // O bloqueio será feito apenas quando o pagamento for confirmado
  427 │     // através da função updateBookingStatus
  428 │     
  429 │     return docRef;
  430 │   } catch (error) {
  431 │     console.error('Erro ao criar reserva:', error);
  432 │     throw error;
  433 │   }
  434 │ };
  435 │ 
  436 │ // Nova função para atualizar status da reserva e bloquear as datas da estadia
  437 │ export const updateBookingStatus = async (
  438 │   bookingId: string, 
  439 │   newStatus: 'pending' | 'confirmed' | 'cancelled' | 'completed',
  440 │   newPaymentStatus: 'pending' | 'paid' | 'refunded'
  441 │ ): Promise<boolean> => {
  442 │   try {
  443 │     // Referência ao documento da reserva
  444 │     const bookingRef = doc(db, 'bookings', bookingId);
  445 │     const bookingSnap = await getDoc(bookingRef);
  446 │     
  447 │     if (!bookingSnap.exists()) {
  448 │       console.error(`Booking ${bookingId} não existe ao atualizar status`);
  449 │       return false;
  450 │     }
  451 │     
  452 │     const bookingData = bookingSnap.data();
  453 │     
  454 │     // Atualizar o status da reserva
  455 │     await updateDoc(bookingRef, {
  456 │       status: newStatus,
  457 │       paymentStatus: newPaymentStatus,
  458 │       updatedAt: serverTimestamp(),
  459 │       ...(newStatus === 'confirmed' && { confirmedAt: serverTimestamp() })
  460 │     });
  461 │     
  462 │     // Se a reserva está sendo confirmada, precisamos bloquear as datas
  463 │     if (newStatus === 'confirmed') {
  464 │       console.log(`Atualizando disponibilidade para reserva confirmada: ${bookingId}`);
  465 │       
  466 │       // Recuperar datas de check-in e check-out
  467 │       const checkIn = bookingData.checkIn.toDate();
  468 │       const checkOut = bookingData.checkOut.toDate();
  469 │       const roomId = bookingData.roomId;
  470 │       
  471 │       // Obter todas as datas entre check-in e check-out
  472 │       const dates: Date[] = [];
  473 │       const currentDate = new Date(checkIn);
  474 │       
  475 │       while (currentDate < checkOut) {
  476 │         dates.push(new Date(currentDate));
  477 │         currentDate.setDate(currentDate.getDate() + 1);
  478 │       }
  479 │       
  480 │       console.log(`Bloqueando ${dates.length} dias para quarto ${roomId}`);
  481 │       
  482 │       // Atualizar disponibilidade para cada data
  483 │       const availabilityUpdates: {[date: string]: boolean} = {};
  484 │       
  485 │       dates.forEach(date => {
  486 │         const dateString = date.toISOString().split('T')[0]; // formato YYYY-MM-DD
  487 │         availabilityUpdates[dateString] = false; // false significa indisponível
  488 │       });
  489 │       
  490 │       // Atualizar disponibilidade do quarto
  491 │       if (Object.keys(availabilityUpdates).length > 0) {
  492 │         try {
  493 │           // Obter o documento do quarto
  494 │           const roomRef = doc(db, 'rooms', roomId);
  495 │           const roomSnap = await getDoc(roomRef);
  496 │           
  497 │           if (roomSnap.exists()) {
  498 │             const roomData = roomSnap.data();
  499 │             const currentAvailability = roomData.availabilityDates || {};
  500 │             
  501 │             // Mesclar a disponibilidade atual com as novas atualizações
  502 │             const updatedAvailability = {
  503 │               ...currentAvailability,
  504 │               ...availabilityUpdates
  505 │             };
  506 │             
  507 │             // Atualizar o documento do quarto
  508 │             await updateDoc(roomRef, {
  509 │               availabilityDates: updatedAvailability,
  510 │               updatedAt: serverTimestamp()
  511 │             });
  512 │             
  513 │             console.log(`Disponibilidade atualizada com sucesso para quarto ${roomId}`);
  514 │             
  515 │             // Criar log da reserva
  516 │             await addDoc(collection(db, 'bookingLogs'), {
  517 │               bookingId,
  518 │               roomId,
  519 │               action: 'status_updated',
  520 │               previousStatus: bookingData.status,
  521 │               newStatus,
  522 │               previousPaymentStatus: bookingData.paymentStatus,
  523 │               newPaymentStatus,
  524 │               datesBlocked: Object.keys(availabilityUpdates),
  525 │               timestamp: serverTimestamp(),
  526 │               userId: bookingData.userId || 'system'
  527 │             });
  528 │           } else {
  529 │             console.error(`Quarto ${roomId} não encontrado ao atualizar disponibilidade`);
  530 │           }
  531 │         } catch (error) {
  532 │           console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  533 │         }
  534 │       }
  535 │     }
  536 │     
  537 │     return true;
  538 │   } catch (error) {
  539 │     console.error(`Erro ao atualizar status da reserva ${bookingId}:`, error);
  540 │     return false;
  541 │   }
  542 │ }
  543 │ 
  544 │ export const getUserBookings = async (userId: string): Promise<Booking[]> => {
  545 │   return getDocuments<Booking>('bookings', [
  546 │     where('userId', '==', userId),
  547 │     orderBy('createdAt', 'desc')
  548 │   ])
  549 │ }
  550 │ 
  551 │ export const getRecentBookings = async (count = 5): Promise<Booking[]> => {
  552 │   return getDocuments<Booking>('bookings', [
  553 │     orderBy('createdAt', 'desc'),
  554 │     limit(count)
  555 │   ])
  556 │ }
  557 │ 
  558 │ export const getRoomBookings = async (roomId: string): Promise<Booking[]> => {
  559 │   try {
  560 │     const constraints: QueryConstraint[] = [
  561 │       where('roomId', '==', roomId),
  562 │       orderBy('checkIn', 'asc')
  563 │     ];
  564 │     
  565 │     return await getDocuments<Booking>('bookings', constraints);
  566 │   } catch (error) {
  567 │     console.error(`Erro ao buscar reservas do quarto ${roomId}:`, error);
  568 │     return [];
  569 │   }
  570 │ };
  571 │ 
  572 │ // Funções específicas para contatos
  573 │ export const createContactMessage = async (contactData: Contact) => {
  574 │   try {
  575 │     const contactsCollection = collection(db, 'contacts')
  576 │     
  577 │     // Garantir que o status seja 'new' para novos contatos
  578 │     const contactWithDefaults = {
  579 │       ...contactData,
  580 │       status: contactData.status || 'new',
  581 │       createdAt: contactData.createdAt || Timestamp.now()
  582 │     }
  583 │     
  584 │     // Se tiver detalhes de reserva, adicionar metadados
  585 │     if (contactWithDefaults.reservationDetails) {
  586 │       // Ajustar subject para indicar que é relacionado a reserva
  587 │       if (!contactWithDefaults.subject.includes('Reserva')) {
  588 │         contactWithDefaults.subject = `Reserva: ${contactWithDefaults.subject}`;
  589 │       }
  590 │     }
  591 │     
  592 │     const docRef = await addDoc(contactsCollection, contactWithDefaults)
  593 │     return docRef
  594 │   } catch (error) {
  595 │     console.error('Erro ao criar mensagem de contato:', error)
  596 │     throw error
  597 │   }
  598 │ }
  599 │ 
  600 │ export const getNewContactMessages = async (): Promise<Contact[]> => {
  601 │   return getDocuments<Contact>('contacts', [
  602 │     where('status', '==', 'new'),
  603 │     orderBy('createdAt', 'desc')
  604 │   ])
  605 │ }
  606 │ 
  607 │ // Funções para Dashboard com dados reais
  608 │ 
  609 │ export const getDashboardStats = async () => {
  610 │   try {
  611 │     const [totalBookings, totalRevenue, occupancyRate, bookingsByPlatform] = await Promise.all([
  612 │       getTotalBookings(),
  613 │       getMonthlyRevenue(),
  614 │       getOccupancyRate(),
  615 │       getBookingsByPlatform()
  616 │     ]);
  617 │ 
  618 │     return {
  619 │       totalBookings,
  620 │       totalRevenue,
  621 │       occupancyRate,
  622 │       bookingsByPlatform
  623 │     };
  624 │   } catch (error) {
  625 │     console.error('Erro ao obter estatísticas do dashboard:', error);
  626 │     throw error;
  627 │   }
  628 │ };
  629 │ 
  630 │ // Obter total de reservas
  631 │ export const getTotalBookings = async () => {
  632 │   try {
  633 │     // Obter todas as reservas
  634 │     const bookings = await getDocuments<Booking>('bookings');
  635 │     
  636 │     // Contar reservas por status
  637 │     const confirmed = bookings.filter(b => b.status === 'confirmed').length;
  638 │     const pending = bookings.filter(b => b.status === 'pending').length;
  639 │     const cancelled = bookings.filter(b => b.status === 'cancelled').length;
  640 │     const completed = bookings.filter(b => b.status === 'completed').length;
  641 │     
  642 │     // Calcular crescimento em relação ao mês anterior (simulado por enquanto)
  643 │     // Em uma implementação real, você compararia com dados do mês anterior
  644 │     const growth = ((confirmed + completed) / (bookings.length || 1) * 100) - 50;
  645 │     
  646 │     return {
  647 │       total: bookings.length,
  648 │       confirmed,
  649 │       pending,
  650 │       cancelled,
  651 │       completed,
  652 │       growth: Math.round(growth) // Arredonda para número inteiro
  653 │     };
  654 │   } catch (error) {
  655 │     console.error('Erro ao obter total de reservas:', error);
  656 │     return {
  657 │       total: 0,
  658 │       confirmed: 0,
  659 │       pending: 0, 
  660 │       cancelled: 0,
  661 │       completed: 0,
  662 │       growth: 0
  663 │     };
  664 │   }
  665 │ };
  666 │ 
  667 │ // Obter receita mensal
  668 │ export const getMonthlyRevenue = async () => {
  669 │   try {
  670 │     const bookings = await getDocuments<Booking>('bookings');
  671 │     
  672 │     // Filtrar reservas confirmadas e concluídas
  673 │     const validBookings = bookings.filter(b => 
  674 │       b.status === 'confirmed' || b.status === 'completed'
  675 │     );
  676 │     
  677 │     // Calcular receita total
  678 │     const totalRevenue = validBookings.reduce((acc, booking) => acc + booking.totalPrice, 0);
  679 │     
  680 │     // Agrupar receita por mês
  681 │     const revenueByMonth = validBookings.reduce((acc, booking) => {
  682 │       const date = booking.checkIn.toDate();
  683 │       const month = date.getMonth(); // 0-11
  684 │       const year = date.getFullYear();
  685 │       const key = `${year}-${month}`;
  686 │       
  687 │       if (!acc[key]) {
  688 │         acc[key] = 0;
  689 │       }
  690 │       acc[key] += booking.totalPrice;
  691 │       return acc;
  692 │     }, {} as Record<string, number>);
  693 │     
  694 │     // Converter para formato de array para gráfico
  695 │     const monthNames = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
  696 │     
  697 │     const currentDate = new Date();
  698 │     const currentMonth = currentDate.getMonth();
  699 │     const currentYear = currentDate.getFullYear();
  700 │     
  701 │     const revenueData = [];
  702 │     
  703 │     // Gerar dados dos últimos 12 meses
  704 │     for (let i = 0; i < 12; i++) {
  705 │       const month = (currentMonth - i + 12) % 12;
  706 │       const year = currentMonth - i < 0 ? currentYear - 1 : currentYear;
  707 │       const key = `${year}-${month}`;
  708 │       
  709 │       revenueData.unshift({
  710 │         month: monthNames[month],
  711 │         value: revenueByMonth[key] || 0
  712 │       });
  713 │     }
  714 │     
  715 │     // Calcular crescimento em relação ao mês anterior
  716 │     const lastMonthRevenue = revenueData[revenueData.length - 2]?.value || 0;
  717 │     const currentMonthRevenue = revenueData[revenueData.length - 1]?.value || 0;
  718 │     
  719 │     const growth = lastMonthRevenue ? ((currentMonthRevenue - lastMonthRevenue) / lastMonthRevenue) * 100 : 0;
  720 │     
  721 │     return {
  722 │       monthly: currentMonthRevenue,
  723 │       total: totalRevenue,
  724 │       growth: Math.round(growth),
  725 │       revenueData
  726 │     };
  727 │   } catch (error) {
  728 │     console.error('Erro ao obter receita mensal:', error);
  729 │     return {
  730 │       monthly: 0,
  731 │       total: 0,
  732 │       growth: 0,
  733 │       revenueData: []
  734 │     };
  735 │   }
  736 │ };
  737 │ 
  738 │ // Calcular taxa de ocupação
  739 │ export const getOccupancyRate = async () => {
  740 │   try {
  741 │     // Obter todos os quartos
  742 │     const rooms = await getDocuments<Room>('rooms');
  743 │     const totalRooms = rooms.length;
  744 │     
  745 │     if (totalRooms === 0) {
  746 │       return { rate: 0, growth: 0 };
  747 │     }
  748 │     
  749 │     // Obter todas as reservas
  750 │     const bookings = await getDocuments<Booking>('bookings');
  751 │     
  752 │     // Filtrar reservas confirmadas e concluídas para o mês atual
  753 │     const currentDate = new Date();
  754 │     const currentMonth = currentDate.getMonth();
  755 │     const currentYear = currentDate.getFullYear();
  756 │     
  757 │     const currentMonthBookings = bookings.filter(booking => {
  758 │       const checkInDate = booking.checkIn.toDate();
  759 │       return (
  760 │         (booking.status === 'confirmed' || booking.status === 'completed') &&
  761 │         checkInDate.getMonth() === currentMonth &&
  762 │         checkInDate.getFullYear() === currentYear
  763 │       );
  764 │     });
  765 │     
  766 │     // Calcular dias ocupados por quarto
  767 │     const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
  768 │     const totalPossibleRoomDays = totalRooms * daysInMonth;
  769 │     
  770 │     // Contar dias ocupados (simplificado - em produção seria mais complexo)
  771 │     let occupiedDays = 0;
  772 │     
  773 │     currentMonthBookings.forEach(booking => {
  774 │       const checkIn = booking.checkIn.toDate();
  775 │       const checkOut = booking.checkOut.toDate();
  776 │       
  777 │       // Ajustar datas para considerar apenas o mês atual
  778 │       const startDate = new Date(Math.max(
  779 │         checkIn.getTime(),
  780 │         new Date(currentYear, currentMonth, 1).getTime()
  781 │       ));
  782 │       const endDate = new Date(Math.min(
  783 │         checkOut.getTime(),
  784 │         new Date(currentYear, currentMonth + 1, 0).getTime()
  785 │       ));
  786 │       
  787 │       // Calcular dias entre datas (incluindo check-in, excluindo check-out)
  788 │       const days = Math.max(0, Math.floor((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)));
  789 │       occupiedDays += days;
  790 │     });
  791 │     
  792 │     const occupancyRate = (occupiedDays / totalPossibleRoomDays) * 100;
  793 │     
  794 │     // Simulação de crescimento (em produção, compararia com mês anterior)
  795 │     const growth = occupancyRate > 50 ? 5 : -3;
  796 │     
  797 │     return {
  798 │       rate: Math.round(occupancyRate),
  799 │       growth: Math.round(growth)
  800 │     };
  801 │   } catch (error) {
  802 │     console.error('Erro ao calcular taxa de ocupação:', error);
  803 │     return { rate: 0, growth: 0 };
  804 │   }
  805 │ };
  806 │ 
  807 │ // Obter reservas agrupadas por plataforma
  808 │ export const getBookingsByPlatform = async () => {
  809 │   try {
  810 │     const bookings = await getDocuments<Booking>('bookings');
  811 │     
  812 │     // Categorizar reservas por origem
  813 │     const platforms = [
  814 │       { 
  815 │         platform: "Booking.com", 
  816 │         color: "#003580", 
  817 │         icon: "Globe",
  818 │         bookings: []
  819 │       },
  820 │       { 
  821 │         platform: "Airbnb", 
  822 │         color: "#FF5A5F", 
  823 │         icon: "Heart",
  824 │         bookings: []
  825 │       },
  826 │       { 
  827 │         platform: "Direto", 
  828 │         color: "#4CAF50", 
  829 │         icon: "Home",
  830 │         bookings: []
  831 │       }
  832 │     ];
  833 │     
  834 │     // Para fins de demonstração, colocar todas as reservas como "Direto" por enquanto
  835 │     // Em produção, usaria um campo "platformOrigin" ou similar na tabela de reservas
  836 │     const platformIndex = 2; // Índice da plataforma "Direto"
  837 │     
  838 │     bookings.forEach(booking => {
  839 │       // Transformar para o formato esperado pelo componente
  840 │       const transformedBooking = {
  841 │         id: booking.id || '',
  842 │         guestName: booking.guestName,
  843 │         roomName: booking.roomName,
  844 │         checkIn: booking.checkIn.toDate().toLocaleDateString('pt-PT'),
  845 │         checkOut: booking.checkOut.toDate().toLocaleDateString('pt-PT'),
  846 │         status: booking.status,
  847 │         value: new Intl.NumberFormat('pt-PT', {
  848 │           style: 'currency',
  849 │           currency: 'EUR'
  850 │         }).format(booking.totalPrice)
  851 │       };
  852 │       
  853 │       // Adicionar à plataforma "Direto"
  854 │       (platforms[platformIndex] as any).bookings.push(transformedBooking);
  855 │     });
  856 │     
  857 │     return platforms;
  858 │   } catch (error) {
  859 │     console.error('Erro ao obter reservas por plataforma:', error);
  860 │     return [];
  861 │   }
  862 │ };
  863 │ 
  864 │ // Função para obter o preço de um quarto para uma data específica
  865 │ export const getRoomPriceForDate = async (roomId: string, date: Date): Promise<number> => {
  866 │   try {
  867 │     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  868 │     
  869 │     if (!roomDoc.exists()) {
  870 │       throw new Error("Quarto não encontrado");
  871 │     }
  872 │     
  873 │     const roomData = roomDoc.data() as Room;
  874 │     const basePrice = roomData.price;
  875 │     
  876 │     if (!roomData.seasonalPrices || roomData.seasonalPrices.length === 0) {
  877 │       return basePrice;
  878 │     }
  879 │     
  880 │     // Verificar se a data está dentro de algum período sazonal
  881 │     for (const seasonalPrice of roomData.seasonalPrices) {
  882 │       const startDate = new Date(seasonalPrice.startDate);
  883 │       const endDate = new Date(seasonalPrice.endDate);
  884 │       
  885 │       if (date >= startDate && date <= endDate) {
  886 │         return seasonalPrice.price;
  887 │       }
  888 │     }
  889 │     
  890 │     // Se não cair em nenhum período sazonal, retorna o preço base
  891 │     return basePrice;
  892 │   } catch (error) {
  893 │     console.error("Erro ao obter preço do quarto:", error);
  894 │     throw error;
  895 │   }
  896 │ }
  897 │ 
  898 │ // Função para calcular o preço total de uma estadia
  899 │ export const calculateStayPrice = async (
  900 │   roomId: string, 
  901 │   checkIn: Date, 
  902 │   checkOut: Date
  903 │ ): Promise<{
  904 │   totalPrice: number;
  905 │   nightlyPrices: { date: string; price: number }[];
  906 │   serviceFee: number;
  907 │   totalWithFee: number;
  908 │ }> => {
  909 │   try {
  910 │     console.log(`🔍 Iniciando cálculo de preço para estadia: ${checkIn.toISOString().split('T')[0]} até ${checkOut.toISOString().split('T')[0]}`);
  911 │     
  912 │     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  913 │     
  914 │     if (!roomDoc.exists()) {
  915 │       throw new Error("Quarto não encontrado");
  916 │     }
  917 │     
  918 │     const roomData = roomDoc.data() as Room;
  919 │     console.log(`📝 Dados do quarto ${roomId}:`, {
  920 │       nome: roomData.name,
  921 │       precoBase: roomData.price,
  922 │       taxaServico: roomData.serviceFeePct || 0,
  923 │       temPrecosSazonais: !!roomData.seasonalPrices?.length
  924 │     });
  925 │     
  926 │     const nightlyPrices: { date: string; price: number }[] = [];
  927 │     let totalPrice = 0;
  928 │     
  929 │     // Calcular o número de noites - corrigido para usar o método correto de cálculo
  930 │     // O número de noites é a diferença em dias (estadia = checkout - checkin)
  931 │     const noites = differenceInDays(checkOut, checkIn);
  932 │     console.log(`🗓️ Número de noites calculado: ${noites}`);
  933 │     
  934 │     if (noites <= 0) {
  935 │       console.error(`⚠️ Erro: número de noites inválido (${noites})`);
  936 │       throw new Error("Data de check-out deve ser posterior à data de check-in");
  937 │     }
  938 │     
  939 │     // Para cada noite, verificar o preço aplicável (preço base ou sazonal)
  940 │     // Começamos exatamente do dia de check-in
  941 │     const currentDate = new Date(checkIn);
  942 │     currentDate.setHours(0, 0, 0, 0); // Normalizar para meia-noite
  943 │     
  944 │     // Processamos cada dia de estadia (noite)
  945 │     console.log(`📊 Calculando preços por noite:`);
  946 │     for (let i = 0; i < noites; i++) {
  947 │       // Obtemos o preço para esta data
  948 │       const dateCopy = new Date(currentDate);
  949 │       const priceForDate = await getRoomPriceForDate(roomId, dateCopy);
  950 │       const dateString = dateCopy.toISOString().split('T')[0]; // YYYY-MM-DD
  951 │       
  952 │       console.log(`   - ${dateString}: €${priceForDate}`);
  953 │       
  954 │       nightlyPrices.push({
  955 │         date: dateString,
  956 │         price: priceForDate
  957 │       });
  958 │       
  959 │       totalPrice += priceForDate;
  960 │       
  961 │       // Avançamos para o próximo dia
  962 │       currentDate.setDate(currentDate.getDate() + 1);
  963 │     }
  964 │     
  965 │     // Verificação de segurança para o cálculo do totalPrice
  966 │     const manualTotal = nightlyPrices.reduce((sum, night) => sum + night.price, 0);
  967 │     if (Math.abs(totalPrice - manualTotal) > 1) {
  968 │       console.error(`⚠️ Discrepância detectada no cálculo do preço total!`);
  969 │       console.error(`   - Total calculado iterativamente: €${totalPrice}`);
  970 │       console.error(`   - Total calculado via reduce: €${manualTotal}`);
  971 │       console.error(`   - Usando o valor recalculado para segurança!`);
  972 │       totalPrice = manualTotal;
  973 │     }
  974 │     
  975 │     // Calcular taxa de serviço
  976 │     const serviceFee = (totalPrice * (roomData.serviceFeePct || 0)) / 100;
  977 │     const totalWithFee = totalPrice + serviceFee;
  978 │     
  979 │     console.log(`💰 Resumo do cálculo:`);
  980 │     console.log(`   - Total das diárias: €${totalPrice}`);
  981 │     console.log(`   - Taxa de serviço (${roomData.serviceFeePct || 0}%): €${serviceFee}`);
  982 │     console.log(`   - Total com taxas: €${totalWithFee}`);
  983 │     
  984 │     return {
  985 │       totalPrice,
  986 │       nightlyPrices,
  987 │       serviceFee,
  988 │       totalWithFee
  989 │     };
  990 │   } catch (error) {
  991 │     console.error("❌ Erro ao calcular preço da estadia:", error);
  992 │     throw error;
  993 │   }
  994 │ } 
  995 │ import { 
  996 │   collection, 
  997 │   getDocs, 
  998 │   getDoc, 
      ·   ───┬──
      ·      ╰── `getDoc` redefined here
  999 │   doc, 
 1000 │   setDoc, 
 1001 │   addDoc, 
      ╰────

  × the name `doc` is defined multiple times
      ╭─[/home/runner/workspace/lib/firebase/firestore.ts:1:1]
    1 │ import {
    2 │   collection,
    3 │   doc,
      ·   ─┬─
      ·    ╰── previous definition of `doc` here
    4 │   setDoc,
    5 │   addDoc,
    6 │   getDoc,
    7 │   getDocs,
    8 │   updateDoc,
    9 │   deleteDoc,
   10 │   query,
   11 │   where,
   12 │   orderBy,
   13 │   limit,
   14 │   DocumentData,
   15 │   QueryConstraint,
   16 │   Timestamp,
   17 │   serverTimestamp
   18 │ } from 'firebase/firestore'
   19 │ import { db } from './config'
   20 │ import { Room, SeasonalPrice } from '@/lib/types'
   21 │ import { differenceInDays } from 'date-fns'
   22 │ 
   23 │ // Tipos de dados
   24 │ export interface Booking {
   25 │   id?: string
   26 │   userId?: string
   27 │   guestName: string
   28 │   guestEmail: string
   29 │   guestPhone: string
   30 │   roomId: string
   31 │   roomName: string
   32 │   checkIn: Timestamp
   33 │   checkOut: Timestamp
   34 │   adults: number
   35 │   children: number
   36 │   totalPrice: number
   37 │   status: 'pending' | 'confirmed' | 'cancelled' | 'completed'
   38 │   paymentStatus: 'pending' | 'paid' | 'refunded'
   39 │   specialRequests?: string
   40 │   createdAt?: Timestamp
   41 │   updatedAt?: Timestamp
   42 │ }
   43 │ 
   44 │ export interface Contact {
   45 │   id?: string
   46 │   name: string
   47 │   email: string
   48 │   phone?: string
   49 │   subject: string
   50 │   message: string
   51 │   status: 'new' | 'read' | 'replied'
   52 │   createdAt: Timestamp
   53 │   updatedAt?: Timestamp
   54 │   repliedAt?: Timestamp
   55 │   replyContent?: string
   56 │   reservationDetails?: {
   57 │     checkIn?: Timestamp
   58 │     checkOut?: Timestamp
   59 │     roomId?: string
   60 │     roomName?: string
   61 │     totalGuests?: number
   62 │     totalPrice?: number
   63 │   }
   64 │ }
   65 │ 
   66 │ // Funções genéricas para CRUD
   67 │ export const createDocument = async <T extends DocumentData>(
   68 │   collectionName: string,
   69 │   data: T
   70 │ ): Promise<string> => {
   71 │   const docRef = await addDoc(collection(db, collectionName), {
   72 │     ...data,
   73 │     createdAt: serverTimestamp(),
   74 │     updatedAt: serverTimestamp()
   75 │   })
   76 │   return docRef.id
   77 │ }
   78 │ 
   79 │ export const createDocumentWithId = async <T extends DocumentData>(
   80 │   collectionName: string,
   81 │   id: string,
   82 │   data: T
   83 │ ): Promise<void> => {
   84 │   await setDoc(doc(db, collectionName, id), {
   85 │     ...data,
   86 │     createdAt: serverTimestamp(),
   87 │     updatedAt: serverTimestamp()
   88 │   })
   89 │ }
   90 │ 
   91 │ export const getDocument = async <T>(
   92 │   collectionName: string,
   93 │   id: string
   94 │ ): Promise<T | null> => {
   95 │   const docRef = doc(db, collectionName, id)
   96 │   const docSnap = await getDoc(docRef)
   97 │   
   98 │   if (docSnap.exists()) {
   99 │     const data = docSnap.data();
  100 │     console.log("Dados brutos recuperados do Firestore para quarto:", id, data);
  101 │     
  102 │     if (data?.serviceFeePct !== undefined) {
  103 │       console.log("serviceFeePct antes da conversão:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
  104 │       // Garantir que serviceFeePct seja um número
  105 │       data.serviceFeePct = Number(data.serviceFeePct);
  106 │       console.log("serviceFeePct após conversão:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
  107 │     }
  108 │     
  109 │     return { id: docSnap.id, ...data } as T
  110 │   } else {
  111 │     return null
  112 │   }
  113 │ }
  114 │ 
  115 │ export const getDocuments = async <T>(
  116 │   collectionName: string,
  117 │   constraints: QueryConstraint[] = [],
  118 │   forceRefresh = false
  119 │ ): Promise<T[]> => {
  120 │   try {
  121 │     const collectionRef = collection(db, collectionName)
  122 │     const q = query(collectionRef, ...constraints)
  123 │     
  124 │     // Se forceRefresh for verdadeiro, adicionar opções que forçam uma nova consulta ao Firestore
  125 │     const querySnapshot = await getDocs(q)
  126 │     
  127 │     console.log(`Buscando documentos na coleção ${collectionName} - Força atualização: ${forceRefresh}`);
  128 │     
  129 │     return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }) as T)
  130 │   } catch (error) {
  131 │     console.error(`Erro ao buscar documentos da coleção ${collectionName}:`, error);
  132 │     return [];
  133 │   }
  134 │ }
  135 │ 
  136 │ export const updateDocument = async <T extends DocumentData>(
  137 │   collectionName: string,
  138 │   id: string,
  139 │   data: Partial<T>
  140 │ ): Promise<void> => {
  141 │   const docRef = doc(db, collectionName, id)
  142 │   await updateDoc(docRef, {
  143 │     ...data,
  144 │     updatedAt: serverTimestamp()
  145 │   })
  146 │ }
  147 │ 
  148 │ export const deleteDocument = async (
  149 │   collectionName: string,
  150 │   id: string
  151 │ ): Promise<boolean> => {
  152 │   const docRef = doc(db, collectionName, id)
  153 │   await deleteDoc(docRef)
  154 │   return true
  155 │ }
  156 │ 
  157 │ // Funções para gerenciar quartos
  158 │ export const getRooms = async (forceRefresh = false): Promise<Room[]> => {
  159 │   try {
  160 │     const constraints: QueryConstraint[] = []
  161 │     
  162 │     constraints.push(orderBy('name', 'asc'))
  163 │     
  164 │     const rooms = await getDocuments<Room>('rooms', constraints, forceRefresh)
  165 │     
  166 │     // Garantir que todos os campos necessários estejam presentes
  167 │     return rooms.map(room => {
  168 │       console.log(`Firebase - Quarto ${room.id} dados brutos:`, room);
  169 │       
  170 │       // Garantir que serviceFeePct seja um número
  171 │       const serviceFeePct = room.serviceFeePct !== undefined 
  172 │         ? Number(room.serviceFeePct) 
  173 │         : 10;
  174 │         
  175 │       console.log(`Firebase - Quarto ${room.id} serviceFeePct:`, {
  176 │         original: room.serviceFeePct,
  177 │         tipo: typeof room.serviceFeePct,
  178 │         convertido: serviceFeePct
  179 │       });
  180 │       
  181 │       return {
  182 │         id: room.id,
  183 │         name: room.name || '',
  184 │         type: room.type || 'standard',
  185 │         description: room.description || '',
  186 │         price: room.price || 0,
  187 │         capacity: room.capacity || 2,
  188 │         size: room.size || 0,
  189 │         available: room.available !== undefined ? room.available : true,
  190 │         serviceFeePct: serviceFeePct,
  191 │         images: room.images || [],
  192 │         amenities: room.amenities || [],
  193 │         additionalServices: room.additionalServices || [],
  194 │         highlights: room.highlights || [],
  195 │         createdAt: room.createdAt,
  196 │         updatedAt: room.updatedAt
  197 │       };
  198 │     });
  199 │   } catch (error) {
  200 │     console.error('Erro ao buscar quartos:', error)
  201 │     return []
  202 │   }
  203 │ }
  204 │ 
  205 │ export const getAvailableRooms = async (
  206 │   checkIn: Date,
  207 │   checkOut: Date
  208 │ ): Promise<Room[]> => {
  209 │   try {
  210 │     // Buscar todos os quartos que estão marcados como disponíveis em geral
  211 │     const constraints: QueryConstraint[] = [
  212 │       where('available', '==', true)
  213 │     ]
  214 │     
  215 │     const rooms = await getDocuments<Room>('rooms', constraints);
  216 │     
  217 │     // Filtrar os quartos que estão disponíveis nas datas específicas
  218 │     return filterAvailableRoomsByDate(rooms, checkIn, checkOut);
  219 │   } catch (error) {
  220 │     console.error('Erro ao buscar quartos disponíveis:', error)
  221 │     return []
  222 │   }
  223 │ }
  224 │ 
  225 │ // Função auxiliar para verificar disponibilidade entre datas
  226 │ export const filterAvailableRoomsByDate = (
  227 │   rooms: Room[],
  228 │   checkIn: Date,
  229 │   checkOut: Date
  230 │ ): Room[] => {
  231 │   // Converter checkIn e checkOut para ISO strings
  232 │   const dateStrings = getDatesInRange(checkIn, checkOut);
  233 │   
  234 │   return rooms.filter(room => {
  235 │     // Se não tiver controle de disponibilidade específico, considera disponível
  236 │     if (!room.availabilityDates) return true;
  237 │     
  238 │     // Verificar se alguma data no intervalo está indisponível
  239 │     return !dateStrings.some(dateStr => 
  240 │       room.availabilityDates?.[dateStr] === false
  241 │     );
  242 │   });
  243 │ };
  244 │ 
  245 │ // Função para obter disponibilidade de um quarto específico
  246 │ export const getRoomAvailability = async (
  247 │   roomId: string, 
  248 │   startDate: Date, 
  249 │   endDate: Date
  250 │ ): Promise<{[date: string]: boolean}> => {
  251 │   try {
  252 │     const room = await getRoomById(roomId);
  253 │     if (!room) throw new Error(`Quarto com ID ${roomId} não encontrado`);
  254 │     
  255 │     // Gerar datas no intervalo
  256 │     const dateStrings = getDatesInRange(startDate, endDate);
  257 │     
  258 │     // Se não tiver configuração de disponibilidade específica, assume tudo disponível
  259 │     if (!room.availabilityDates) {
  260 │       return dateStrings.reduce((acc, date) => {
  261 │         acc[date] = true;
  262 │         return acc;
  263 │       }, {} as {[date: string]: boolean});
  264 │     }
  265 │     
  266 │     // Preencher com os dados de disponibilidade existentes
  267 │     return dateStrings.reduce((acc, date) => {
  268 │       acc[date] = room.availabilityDates?.[date] !== false; // disponível por padrão se não estiver explicitamente indisponível
  269 │       return acc;
  270 │     }, {} as {[date: string]: boolean});
  271 │   } catch (error) {
  272 │     console.error(`Erro ao verificar disponibilidade do quarto ${roomId}:`, error);
  273 │     throw error;
  274 │   }
  275 │ };
  276 │ 
  277 │ // Função para atualizar disponibilidade de um quarto
  278 │ export const updateRoomAvailability = async (
  279 │   roomId: string,
  280 │   availabilityDates: {[date: string]: boolean}
  281 │ ): Promise<boolean> => {
  282 │   try {
  283 │     await updateDocument('rooms', roomId, {
  284 │       availabilityDates,
  285 │       updatedAt: serverTimestamp()
  286 │     });
  287 │     return true;
  288 │   } catch (error) {
  289 │     console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  290 │     return false;
  291 │   }
  292 │ };
  293 │ 
  294 │ // Função auxiliar para gerar array de strings de data entre um intervalo
  295 │ export const getDatesInRange = (startDate: Date, endDate: Date): string[] => {
  296 │   const dates: string[] = [];
  297 │   const currentDate = new Date(startDate);
  298 │   
  299 │   // Normalizar para meia-noite no fuso horário local
  300 │   currentDate.setHours(0, 0, 0, 0);
  301 │   const endDateNormalized = new Date(endDate);
  302 │   endDateNormalized.setHours(0, 0, 0, 0);
  303 │   
  304 │   // Adicionar cada data no intervalo EXCETO o dia de checkout
  305 │   // Usando < em vez de <= para não incluir o dia de checkout
  306 │   while (currentDate < endDateNormalized) {
  307 │     dates.push(currentDate.toISOString().split('T')[0]); // Formato YYYY-MM-DD
  308 │     currentDate.setDate(currentDate.getDate() + 1);
  309 │   }
  310 │   
  311 │   return dates;
  312 │ };
  313 │ 
  314 │ export const getRoomById = async (id: string): Promise<Room | null> => {
  315 │   try {
  316 │     const room = await getDocument<Room>('rooms', id);
  317 │     
  318 │     if (!room) return null;
  319 │     
  320 │     console.log(`Firebase - getRoomById ${id} dados brutos:`, room);
  321 │     
  322 │     // Log específico para serviceFeePct
  323 │     console.log(`serviceFeePct no Firestore:`, room.serviceFeePct);
  324 │     
  325 │     // Garantir que todos os campos necessários estejam presentes
  326 │     return {
  327 │       ...room,
  328 │       name: room.name || '',
  329 │       type: room.type || 'standard',
  330 │       description: room.description || '',
  331 │       price: room.price || 0,
  332 │       capacity: room.capacity || 2,
  333 │       size: room.size || 0,
  334 │       available: room.available !== undefined ? room.available : true,
  335 │       serviceFeePct: room.serviceFeePct !== undefined ? room.serviceFeePct : 10,
  336 │       images: room.images || [],
  337 │       amenities: room.amenities || [],
  338 │       additionalServices: room.additionalServices || [],
  339 │       highlights: room.highlights || []
  340 │     };
  341 │   } catch (error) {
  342 │     console.error(`Erro ao buscar quarto com ID ${id}:`, error);
  343 │     return null;
  344 │   }
  345 │ }
  346 │ 
  347 │ export const createRoom = async (roomData: Omit<Room, 'id' | 'createdAt' | 'updatedAt'>): Promise<Room> => {
  348 │   try {
  349 │     console.log("createRoom - Dados recebidos:", roomData);
  350 │     
  351 │     const roomWithTimestamps = {
  352 │       ...roomData,
  353 │       available: roomData.available !== undefined ? roomData.available : true,
  354 │       featured: roomData.featured || false,
  355 │       amenities: roomData.amenities || [],
  356 │       additionalServices: roomData.additionalServices || [],
  357 │       highlights: roomData.highlights || [],
  358 │       createdAt: serverTimestamp(),
  359 │       updatedAt: serverTimestamp()
  360 │     }
  361 │     
  362 │     console.log("createRoom - Dados a serem salvos:", roomWithTimestamps);
  363 │     
  364 │     const id = await createDocument('rooms', roomWithTimestamps)
  365 │     
  366 │     return {
  367 │       id,
  368 │       ...roomData,
  369 │       amenities: roomData.amenities || [],
  370 │       additionalServices: roomData.additionalServices || [],
  371 │       highlights: roomData.highlights || [],
  372 │       createdAt: Timestamp.now(),
  373 │       updatedAt: Timestamp.now()
  374 │     }
  375 │   } catch (error) {
  376 │     console.error('Erro ao criar quarto:', error)
  377 │     throw error
  378 │   }
  379 │ }
  380 │ 
  381 │ export const updateRoom = async (id: string, roomData: Partial<Omit<Room, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Room> => {
  382 │   try {
  383 │     console.log(`updateRoom - ID: ${id}, Dados recebidos:`, roomData);
  384 │     
  385 │     // Garantir que estamos lidando explicitamente com o serviceFeePct se ele for 0
  386 │     if (roomData.serviceFeePct === 0) {
  387 │       console.log("updateRoom - Detectado serviceFeePct com valor 0, salvando explicitamente.", roomData.serviceFeePct);
  388 │     }
  389 │     
  390 │     // Adicionar timestamp de atualização
  391 │     const roomWithTimestamp = {
  392 │       ...roomData,
  393 │       amenities: roomData.amenities || [],
  394 │       additionalServices: roomData.additionalServices || [],
  395 │       highlights: roomData.highlights || [],
  396 │       updatedAt: serverTimestamp()
  397 │     }
  398 │     
  399 │     console.log(`updateRoom - Dados a serem salvos:`, roomWithTimestamp);
  400 │     
  401 │     await updateDocument('rooms', id, roomWithTimestamp)
  402 │     
  403 │     const updatedRoom = await getRoomById(id)
  404 │     if (!updatedRoom) {
  405 │       throw new Error(`Quarto com ID ${id} não encontrado após atualização`)
  406 │     }
  407 │     
  408 │     return updatedRoom
  409 │   } catch (error) {
  410 │     console.error('Erro ao atualizar quarto:', error)
  411 │     throw error
  412 │   }
  413 │ }
  414 │ 
  415 │ export const deleteRoom = async (id: string): Promise<boolean> => {
  416 │   return await deleteDocument('rooms', id)
  417 │ }
  418 │ 
  419 │ // Funções específicas para reservas
  420 │ export const createBooking = async (bookingData: any) => {
  421 │   try {
  422 │     const bookingsCollection = collection(db, 'bookings');
  423 │     const docRef = await addDoc(bookingsCollection, bookingData);
  424 │     
  425 │     // CORREÇÃO: Não bloquear a data no momento da criação da reserva
  426 │     // O bloqueio será feito apenas quando o pagamento for confirmado
  427 │     // através da função updateBookingStatus
  428 │     
  429 │     return docRef;
  430 │   } catch (error) {
  431 │     console.error('Erro ao criar reserva:', error);
  432 │     throw error;
  433 │   }
  434 │ };
  435 │ 
  436 │ // Nova função para atualizar status da reserva e bloquear as datas da estadia
  437 │ export const updateBookingStatus = async (
  438 │   bookingId: string, 
  439 │   newStatus: 'pending' | 'confirmed' | 'cancelled' | 'completed',
  440 │   newPaymentStatus: 'pending' | 'paid' | 'refunded'
  441 │ ): Promise<boolean> => {
  442 │   try {
  443 │     // Referência ao documento da reserva
  444 │     const bookingRef = doc(db, 'bookings', bookingId);
  445 │     const bookingSnap = await getDoc(bookingRef);
  446 │     
  447 │     if (!bookingSnap.exists()) {
  448 │       console.error(`Booking ${bookingId} não existe ao atualizar status`);
  449 │       return false;
  450 │     }
  451 │     
  452 │     const bookingData = bookingSnap.data();
  453 │     
  454 │     // Atualizar o status da reserva
  455 │     await updateDoc(bookingRef, {
  456 │       status: newStatus,
  457 │       paymentStatus: newPaymentStatus,
  458 │       updatedAt: serverTimestamp(),
  459 │       ...(newStatus === 'confirmed' && { confirmedAt: serverTimestamp() })
  460 │     });
  461 │     
  462 │     // Se a reserva está sendo confirmada, precisamos bloquear as datas
  463 │     if (newStatus === 'confirmed') {
  464 │       console.log(`Atualizando disponibilidade para reserva confirmada: ${bookingId}`);
  465 │       
  466 │       // Recuperar datas de check-in e check-out
  467 │       const checkIn = bookingData.checkIn.toDate();
  468 │       const checkOut = bookingData.checkOut.toDate();
  469 │       const roomId = bookingData.roomId;
  470 │       
  471 │       // Obter todas as datas entre check-in e check-out
  472 │       const dates: Date[] = [];
  473 │       const currentDate = new Date(checkIn);
  474 │       
  475 │       while (currentDate < checkOut) {
  476 │         dates.push(new Date(currentDate));
  477 │         currentDate.setDate(currentDate.getDate() + 1);
  478 │       }
  479 │       
  480 │       console.log(`Bloqueando ${dates.length} dias para quarto ${roomId}`);
  481 │       
  482 │       // Atualizar disponibilidade para cada data
  483 │       const availabilityUpdates: {[date: string]: boolean} = {};
  484 │       
  485 │       dates.forEach(date => {
  486 │         const dateString = date.toISOString().split('T')[0]; // formato YYYY-MM-DD
  487 │         availabilityUpdates[dateString] = false; // false significa indisponível
  488 │       });
  489 │       
  490 │       // Atualizar disponibilidade do quarto
  491 │       if (Object.keys(availabilityUpdates).length > 0) {
  492 │         try {
  493 │           // Obter o documento do quarto
  494 │           const roomRef = doc(db, 'rooms', roomId);
  495 │           const roomSnap = await getDoc(roomRef);
  496 │           
  497 │           if (roomSnap.exists()) {
  498 │             const roomData = roomSnap.data();
  499 │             const currentAvailability = roomData.availabilityDates || {};
  500 │             
  501 │             // Mesclar a disponibilidade atual com as novas atualizações
  502 │             const updatedAvailability = {
  503 │               ...currentAvailability,
  504 │               ...availabilityUpdates
  505 │             };
  506 │             
  507 │             // Atualizar o documento do quarto
  508 │             await updateDoc(roomRef, {
  509 │               availabilityDates: updatedAvailability,
  510 │               updatedAt: serverTimestamp()
  511 │             });
  512 │             
  513 │             console.log(`Disponibilidade atualizada com sucesso para quarto ${roomId}`);
  514 │             
  515 │             // Criar log da reserva
  516 │             await addDoc(collection(db, 'bookingLogs'), {
  517 │               bookingId,
  518 │               roomId,
  519 │               action: 'status_updated',
  520 │               previousStatus: bookingData.status,
  521 │               newStatus,
  522 │               previousPaymentStatus: bookingData.paymentStatus,
  523 │               newPaymentStatus,
  524 │               datesBlocked: Object.keys(availabilityUpdates),
  525 │               timestamp: serverTimestamp(),
  526 │               userId: bookingData.userId || 'system'
  527 │             });
  528 │           } else {
  529 │             console.error(`Quarto ${roomId} não encontrado ao atualizar disponibilidade`);
  530 │           }
  531 │         } catch (error) {
  532 │           console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  533 │         }
  534 │       }
  535 │     }
  536 │     
  537 │     return true;
  538 │   } catch (error) {
  539 │     console.error(`Erro ao atualizar status da reserva ${bookingId}:`, error);
  540 │     return false;
  541 │   }
  542 │ }
  543 │ 
  544 │ export const getUserBookings = async (userId: string): Promise<Booking[]> => {
  545 │   return getDocuments<Booking>('bookings', [
  546 │     where('userId', '==', userId),
  547 │     orderBy('createdAt', 'desc')
  548 │   ])
  549 │ }
  550 │ 
  551 │ export const getRecentBookings = async (count = 5): Promise<Booking[]> => {
  552 │   return getDocuments<Booking>('bookings', [
  553 │     orderBy('createdAt', 'desc'),
  554 │     limit(count)
  555 │   ])
  556 │ }
  557 │ 
  558 │ export const getRoomBookings = async (roomId: string): Promise<Booking[]> => {
  559 │   try {
  560 │     const constraints: QueryConstraint[] = [
  561 │       where('roomId', '==', roomId),
  562 │       orderBy('checkIn', 'asc')
  563 │     ];
  564 │     
  565 │     return await getDocuments<Booking>('bookings', constraints);
  566 │   } catch (error) {
  567 │     console.error(`Erro ao buscar reservas do quarto ${roomId}:`, error);
  568 │     return [];
  569 │   }
  570 │ };
  571 │ 
  572 │ // Funções específicas para contatos
  573 │ export const createContactMessage = async (contactData: Contact) => {
  574 │   try {
  575 │     const contactsCollection = collection(db, 'contacts')
  576 │     
  577 │     // Garantir que o status seja 'new' para novos contatos
  578 │     const contactWithDefaults = {
  579 │       ...contactData,
  580 │       status: contactData.status || 'new',
  581 │       createdAt: contactData.createdAt || Timestamp.now()
  582 │     }
  583 │     
  584 │     // Se tiver detalhes de reserva, adicionar metadados
  585 │     if (contactWithDefaults.reservationDetails) {
  586 │       // Ajustar subject para indicar que é relacionado a reserva
  587 │       if (!contactWithDefaults.subject.includes('Reserva')) {
  588 │         contactWithDefaults.subject = `Reserva: ${contactWithDefaults.subject}`;
  589 │       }
  590 │     }
  591 │     
  592 │     const docRef = await addDoc(contactsCollection, contactWithDefaults)
  593 │     return docRef
  594 │   } catch (error) {
  595 │     console.error('Erro ao criar mensagem de contato:', error)
  596 │     throw error
  597 │   }
  598 │ }
  599 │ 
  600 │ export const getNewContactMessages = async (): Promise<Contact[]> => {
  601 │   return getDocuments<Contact>('contacts', [
  602 │     where('status', '==', 'new'),
  603 │     orderBy('createdAt', 'desc')
  604 │   ])
  605 │ }
  606 │ 
  607 │ // Funções para Dashboard com dados reais
  608 │ 
  609 │ export const getDashboardStats = async () => {
  610 │   try {
  611 │     const [totalBookings, totalRevenue, occupancyRate, bookingsByPlatform] = await Promise.all([
  612 │       getTotalBookings(),
  613 │       getMonthlyRevenue(),
  614 │       getOccupancyRate(),
  615 │       getBookingsByPlatform()
  616 │     ]);
  617 │ 
  618 │     return {
  619 │       totalBookings,
  620 │       totalRevenue,
  621 │       occupancyRate,
  622 │       bookingsByPlatform
  623 │     };
  624 │   } catch (error) {
  625 │     console.error('Erro ao obter estatísticas do dashboard:', error);
  626 │     throw error;
  627 │   }
  628 │ };
  629 │ 
  630 │ // Obter total de reservas
  631 │ export const getTotalBookings = async () => {
  632 │   try {
  633 │     // Obter todas as reservas
  634 │     const bookings = await getDocuments<Booking>('bookings');
  635 │     
  636 │     // Contar reservas por status
  637 │     const confirmed = bookings.filter(b => b.status === 'confirmed').length;
  638 │     const pending = bookings.filter(b => b.status === 'pending').length;
  639 │     const cancelled = bookings.filter(b => b.status === 'cancelled').length;
  640 │     const completed = bookings.filter(b => b.status === 'completed').length;
  641 │     
  642 │     // Calcular crescimento em relação ao mês anterior (simulado por enquanto)
  643 │     // Em uma implementação real, você compararia com dados do mês anterior
  644 │     const growth = ((confirmed + completed) / (bookings.length || 1) * 100) - 50;
  645 │     
  646 │     return {
  647 │       total: bookings.length,
  648 │       confirmed,
  649 │       pending,
  650 │       cancelled,
  651 │       completed,
  652 │       growth: Math.round(growth) // Arredonda para número inteiro
  653 │     };
  654 │   } catch (error) {
  655 │     console.error('Erro ao obter total de reservas:', error);
  656 │     return {
  657 │       total: 0,
  658 │       confirmed: 0,
  659 │       pending: 0, 
  660 │       cancelled: 0,
  661 │       completed: 0,
  662 │       growth: 0
  663 │     };
  664 │   }
  665 │ };
  666 │ 
  667 │ // Obter receita mensal
  668 │ export const getMonthlyRevenue = async () => {
  669 │   try {
  670 │     const bookings = await getDocuments<Booking>('bookings');
  671 │     
  672 │     // Filtrar reservas confirmadas e concluídas
  673 │     const validBookings = bookings.filter(b => 
  674 │       b.status === 'confirmed' || b.status === 'completed'
  675 │     );
  676 │     
  677 │     // Calcular receita total
  678 │     const totalRevenue = validBookings.reduce((acc, booking) => acc + booking.totalPrice, 0);
  679 │     
  680 │     // Agrupar receita por mês
  681 │     const revenueByMonth = validBookings.reduce((acc, booking) => {
  682 │       const date = booking.checkIn.toDate();
  683 │       const month = date.getMonth(); // 0-11
  684 │       const year = date.getFullYear();
  685 │       const key = `${year}-${month}`;
  686 │       
  687 │       if (!acc[key]) {
  688 │         acc[key] = 0;
  689 │       }
  690 │       acc[key] += booking.totalPrice;
  691 │       return acc;
  692 │     }, {} as Record<string, number>);
  693 │     
  694 │     // Converter para formato de array para gráfico
  695 │     const monthNames = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
  696 │     
  697 │     const currentDate = new Date();
  698 │     const currentMonth = currentDate.getMonth();
  699 │     const currentYear = currentDate.getFullYear();
  700 │     
  701 │     const revenueData = [];
  702 │     
  703 │     // Gerar dados dos últimos 12 meses
  704 │     for (let i = 0; i < 12; i++) {
  705 │       const month = (currentMonth - i + 12) % 12;
  706 │       const year = currentMonth - i < 0 ? currentYear - 1 : currentYear;
  707 │       const key = `${year}-${month}`;
  708 │       
  709 │       revenueData.unshift({
  710 │         month: monthNames[month],
  711 │         value: revenueByMonth[key] || 0
  712 │       });
  713 │     }
  714 │     
  715 │     // Calcular crescimento em relação ao mês anterior
  716 │     const lastMonthRevenue = revenueData[revenueData.length - 2]?.value || 0;
  717 │     const currentMonthRevenue = revenueData[revenueData.length - 1]?.value || 0;
  718 │     
  719 │     const growth = lastMonthRevenue ? ((currentMonthRevenue - lastMonthRevenue) / lastMonthRevenue) * 100 : 0;
  720 │     
  721 │     return {
  722 │       monthly: currentMonthRevenue,
  723 │       total: totalRevenue,
  724 │       growth: Math.round(growth),
  725 │       revenueData
  726 │     };
  727 │   } catch (error) {
  728 │     console.error('Erro ao obter receita mensal:', error);
  729 │     return {
  730 │       monthly: 0,
  731 │       total: 0,
  732 │       growth: 0,
  733 │       revenueData: []
  734 │     };
  735 │   }
  736 │ };
  737 │ 
  738 │ // Calcular taxa de ocupação
  739 │ export const getOccupancyRate = async () => {
  740 │   try {
  741 │     // Obter todos os quartos
  742 │     const rooms = await getDocuments<Room>('rooms');
  743 │     const totalRooms = rooms.length;
  744 │     
  745 │     if (totalRooms === 0) {
  746 │       return { rate: 0, growth: 0 };
  747 │     }
  748 │     
  749 │     // Obter todas as reservas
  750 │     const bookings = await getDocuments<Booking>('bookings');
  751 │     
  752 │     // Filtrar reservas confirmadas e concluídas para o mês atual
  753 │     const currentDate = new Date();
  754 │     const currentMonth = currentDate.getMonth();
  755 │     const currentYear = currentDate.getFullYear();
  756 │     
  757 │     const currentMonthBookings = bookings.filter(booking => {
  758 │       const checkInDate = booking.checkIn.toDate();
  759 │       return (
  760 │         (booking.status === 'confirmed' || booking.status === 'completed') &&
  761 │         checkInDate.getMonth() === currentMonth &&
  762 │         checkInDate.getFullYear() === currentYear
  763 │       );
  764 │     });
  765 │     
  766 │     // Calcular dias ocupados por quarto
  767 │     const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
  768 │     const totalPossibleRoomDays = totalRooms * daysInMonth;
  769 │     
  770 │     // Contar dias ocupados (simplificado - em produção seria mais complexo)
  771 │     let occupiedDays = 0;
  772 │     
  773 │     currentMonthBookings.forEach(booking => {
  774 │       const checkIn = booking.checkIn.toDate();
  775 │       const checkOut = booking.checkOut.toDate();
  776 │       
  777 │       // Ajustar datas para considerar apenas o mês atual
  778 │       const startDate = new Date(Math.max(
  779 │         checkIn.getTime(),
  780 │         new Date(currentYear, currentMonth, 1).getTime()
  781 │       ));
  782 │       const endDate = new Date(Math.min(
  783 │         checkOut.getTime(),
  784 │         new Date(currentYear, currentMonth + 1, 0).getTime()
  785 │       ));
  786 │       
  787 │       // Calcular dias entre datas (incluindo check-in, excluindo check-out)
  788 │       const days = Math.max(0, Math.floor((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)));
  789 │       occupiedDays += days;
  790 │     });
  791 │     
  792 │     const occupancyRate = (occupiedDays / totalPossibleRoomDays) * 100;
  793 │     
  794 │     // Simulação de crescimento (em produção, compararia com mês anterior)
  795 │     const growth = occupancyRate > 50 ? 5 : -3;
  796 │     
  797 │     return {
  798 │       rate: Math.round(occupancyRate),
  799 │       growth: Math.round(growth)
  800 │     };
  801 │   } catch (error) {
  802 │     console.error('Erro ao calcular taxa de ocupação:', error);
  803 │     return { rate: 0, growth: 0 };
  804 │   }
  805 │ };
  806 │ 
  807 │ // Obter reservas agrupadas por plataforma
  808 │ export const getBookingsByPlatform = async () => {
  809 │   try {
  810 │     const bookings = await getDocuments<Booking>('bookings');
  811 │     
  812 │     // Categorizar reservas por origem
  813 │     const platforms = [
  814 │       { 
  815 │         platform: "Booking.com", 
  816 │         color: "#003580", 
  817 │         icon: "Globe",
  818 │         bookings: []
  819 │       },
  820 │       { 
  821 │         platform: "Airbnb", 
  822 │         color: "#FF5A5F", 
  823 │         icon: "Heart",
  824 │         bookings: []
  825 │       },
  826 │       { 
  827 │         platform: "Direto", 
  828 │         color: "#4CAF50", 
  829 │         icon: "Home",
  830 │         bookings: []
  831 │       }
  832 │     ];
  833 │     
  834 │     // Para fins de demonstração, colocar todas as reservas como "Direto" por enquanto
  835 │     // Em produção, usaria um campo "platformOrigin" ou similar na tabela de reservas
  836 │     const platformIndex = 2; // Índice da plataforma "Direto"
  837 │     
  838 │     bookings.forEach(booking => {
  839 │       // Transformar para o formato esperado pelo componente
  840 │       const transformedBooking = {
  841 │         id: booking.id || '',
  842 │         guestName: booking.guestName,
  843 │         roomName: booking.roomName,
  844 │         checkIn: booking.checkIn.toDate().toLocaleDateString('pt-PT'),
  845 │         checkOut: booking.checkOut.toDate().toLocaleDateString('pt-PT'),
  846 │         status: booking.status,
  847 │         value: new Intl.NumberFormat('pt-PT', {
  848 │           style: 'currency',
  849 │           currency: 'EUR'
  850 │         }).format(booking.totalPrice)
  851 │       };
  852 │       
  853 │       // Adicionar à plataforma "Direto"
  854 │       (platforms[platformIndex] as any).bookings.push(transformedBooking);
  855 │     });
  856 │     
  857 │     return platforms;
  858 │   } catch (error) {
  859 │     console.error('Erro ao obter reservas por plataforma:', error);
  860 │     return [];
  861 │   }
  862 │ };
  863 │ 
  864 │ // Função para obter o preço de um quarto para uma data específica
  865 │ export const getRoomPriceForDate = async (roomId: string, date: Date): Promise<number> => {
  866 │   try {
  867 │     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  868 │     
  869 │     if (!roomDoc.exists()) {
  870 │       throw new Error("Quarto não encontrado");
  871 │     }
  872 │     
  873 │     const roomData = roomDoc.data() as Room;
  874 │     const basePrice = roomData.price;
  875 │     
  876 │     if (!roomData.seasonalPrices || roomData.seasonalPrices.length === 0) {
  877 │       return basePrice;
  878 │     }
  879 │     
  880 │     // Verificar se a data está dentro de algum período sazonal
  881 │     for (const seasonalPrice of roomData.seasonalPrices) {
  882 │       const startDate = new Date(seasonalPrice.startDate);
  883 │       const endDate = new Date(seasonalPrice.endDate);
  884 │       
  885 │       if (date >= startDate && date <= endDate) {
  886 │         return seasonalPrice.price;
  887 │       }
  888 │     }
  889 │     
  890 │     // Se não cair em nenhum período sazonal, retorna o preço base
  891 │     return basePrice;
  892 │   } catch (error) {
  893 │     console.error("Erro ao obter preço do quarto:", error);
  894 │     throw error;
  895 │   }
  896 │ }
  897 │ 
  898 │ // Função para calcular o preço total de uma estadia
  899 │ export const calculateStayPrice = async (
  900 │   roomId: string, 
  901 │   checkIn: Date, 
  902 │   checkOut: Date
  903 │ ): Promise<{
  904 │   totalPrice: number;
  905 │   nightlyPrices: { date: string; price: number }[];
  906 │   serviceFee: number;
  907 │   totalWithFee: number;
  908 │ }> => {
  909 │   try {
  910 │     console.log(`🔍 Iniciando cálculo de preço para estadia: ${checkIn.toISOString().split('T')[0]} até ${checkOut.toISOString().split('T')[0]}`);
  911 │     
  912 │     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  913 │     
  914 │     if (!roomDoc.exists()) {
  915 │       throw new Error("Quarto não encontrado");
  916 │     }
  917 │     
  918 │     const roomData = roomDoc.data() as Room;
  919 │     console.log(`📝 Dados do quarto ${roomId}:`, {
  920 │       nome: roomData.name,
  921 │       precoBase: roomData.price,
  922 │       taxaServico: roomData.serviceFeePct || 0,
  923 │       temPrecosSazonais: !!roomData.seasonalPrices?.length
  924 │     });
  925 │     
  926 │     const nightlyPrices: { date: string; price: number }[] = [];
  927 │     let totalPrice = 0;
  928 │     
  929 │     // Calcular o número de noites - corrigido para usar o método correto de cálculo
  930 │     // O número de noites é a diferença em dias (estadia = checkout - checkin)
  931 │     const noites = differenceInDays(checkOut, checkIn);
  932 │     console.log(`🗓️ Número de noites calculado: ${noites}`);
  933 │     
  934 │     if (noites <= 0) {
  935 │       console.error(`⚠️ Erro: número de noites inválido (${noites})`);
  936 │       throw new Error("Data de check-out deve ser posterior à data de check-in");
  937 │     }
  938 │     
  939 │     // Para cada noite, verificar o preço aplicável (preço base ou sazonal)
  940 │     // Começamos exatamente do dia de check-in
  941 │     const currentDate = new Date(checkIn);
  942 │     currentDate.setHours(0, 0, 0, 0); // Normalizar para meia-noite
  943 │     
  944 │     // Processamos cada dia de estadia (noite)
  945 │     console.log(`📊 Calculando preços por noite:`);
  946 │     for (let i = 0; i < noites; i++) {
  947 │       // Obtemos o preço para esta data
  948 │       const dateCopy = new Date(currentDate);
  949 │       const priceForDate = await getRoomPriceForDate(roomId, dateCopy);
  950 │       const dateString = dateCopy.toISOString().split('T')[0]; // YYYY-MM-DD
  951 │       
  952 │       console.log(`   - ${dateString}: €${priceForDate}`);
  953 │       
  954 │       nightlyPrices.push({
  955 │         date: dateString,
  956 │         price: priceForDate
  957 │       });
  958 │       
  959 │       totalPrice += priceForDate;
  960 │       
  961 │       // Avançamos para o próximo dia
  962 │       currentDate.setDate(currentDate.getDate() + 1);
  963 │     }
  964 │     
  965 │     // Verificação de segurança para o cálculo do totalPrice
  966 │     const manualTotal = nightlyPrices.reduce((sum, night) => sum + night.price, 0);
  967 │     if (Math.abs(totalPrice - manualTotal) > 1) {
  968 │       console.error(`⚠️ Discrepância detectada no cálculo do preço total!`);
  969 │       console.error(`   - Total calculado iterativamente: €${totalPrice}`);
  970 │       console.error(`   - Total calculado via reduce: €${manualTotal}`);
  971 │       console.error(`   - Usando o valor recalculado para segurança!`);
  972 │       totalPrice = manualTotal;
  973 │     }
  974 │     
  975 │     // Calcular taxa de serviço
  976 │     const serviceFee = (totalPrice * (roomData.serviceFeePct || 0)) / 100;
  977 │     const totalWithFee = totalPrice + serviceFee;
  978 │     
  979 │     console.log(`💰 Resumo do cálculo:`);
  980 │     console.log(`   - Total das diárias: €${totalPrice}`);
  981 │     console.log(`   - Taxa de serviço (${roomData.serviceFeePct || 0}%): €${serviceFee}`);
  982 │     console.log(`   - Total com taxas: €${totalWithFee}`);
  983 │     
  984 │     return {
  985 │       totalPrice,
  986 │       nightlyPrices,
  987 │       serviceFee,
  988 │       totalWithFee
  989 │     };
  990 │   } catch (error) {
  991 │     console.error("❌ Erro ao calcular preço da estadia:", error);
  992 │     throw error;
  993 │   }
  994 │ } 
  995 │ import { 
  996 │   collection, 
  997 │   getDocs, 
  998 │   getDoc, 
  999 │   doc, 
      ·   ─┬─
      ·    ╰── `doc` redefined here
 1000 │   setDoc, 
 1001 │   addDoc, 
 1002 │   updateDoc, 
      ╰────

  × the name `setDoc` is defined multiple times
      ╭─[/home/runner/workspace/lib/firebase/firestore.ts:1:1]
    1 │ import {
    2 │   collection,
    3 │   doc,
    4 │   setDoc,
      ·   ───┬──
      ·      ╰── previous definition of `setDoc` here
    5 │   addDoc,
    6 │   getDoc,
    7 │   getDocs,
    8 │   updateDoc,
    9 │   deleteDoc,
   10 │   query,
   11 │   where,
   12 │   orderBy,
   13 │   limit,
   14 │   DocumentData,
   15 │   QueryConstraint,
   16 │   Timestamp,
   17 │   serverTimestamp
   18 │ } from 'firebase/firestore'
   19 │ import { db } from './config'
   20 │ import { Room, SeasonalPrice } from '@/lib/types'
   21 │ import { differenceInDays } from 'date-fns'
   22 │ 
   23 │ // Tipos de dados
   24 │ export interface Booking {
   25 │   id?: string
   26 │   userId?: string
   27 │   guestName: string
   28 │   guestEmail: string
   29 │   guestPhone: string
   30 │   roomId: string
   31 │   roomName: string
   32 │   checkIn: Timestamp
   33 │   checkOut: Timestamp
   34 │   adults: number
   35 │   children: number
   36 │   totalPrice: number
   37 │   status: 'pending' | 'confirmed' | 'cancelled' | 'completed'
   38 │   paymentStatus: 'pending' | 'paid' | 'refunded'
   39 │   specialRequests?: string
   40 │   createdAt?: Timestamp
   41 │   updatedAt?: Timestamp
   42 │ }
   43 │ 
   44 │ export interface Contact {
   45 │   id?: string
   46 │   name: string
   47 │   email: string
   48 │   phone?: string
   49 │   subject: string
   50 │   message: string
   51 │   status: 'new' | 'read' | 'replied'
   52 │   createdAt: Timestamp
   53 │   updatedAt?: Timestamp
   54 │   repliedAt?: Timestamp
   55 │   replyContent?: string
   56 │   reservationDetails?: {
   57 │     checkIn?: Timestamp
   58 │     checkOut?: Timestamp
   59 │     roomId?: string
   60 │     roomName?: string
   61 │     totalGuests?: number
   62 │     totalPrice?: number
   63 │   }
   64 │ }
   65 │ 
   66 │ // Funções genéricas para CRUD
   67 │ export const createDocument = async <T extends DocumentData>(
   68 │   collectionName: string,
   69 │   data: T
   70 │ ): Promise<string> => {
   71 │   const docRef = await addDoc(collection(db, collectionName), {
   72 │     ...data,
   73 │     createdAt: serverTimestamp(),
   74 │     updatedAt: serverTimestamp()
   75 │   })
   76 │   return docRef.id
   77 │ }
   78 │ 
   79 │ export const createDocumentWithId = async <T extends DocumentData>(
   80 │   collectionName: string,
   81 │   id: string,
   82 │   data: T
   83 │ ): Promise<void> => {
   84 │   await setDoc(doc(db, collectionName, id), {
   85 │     ...data,
   86 │     createdAt: serverTimestamp(),
   87 │     updatedAt: serverTimestamp()
   88 │   })
   89 │ }
   90 │ 
   91 │ export const getDocument = async <T>(
   92 │   collectionName: string,
   93 │   id: string
   94 │ ): Promise<T | null> => {
   95 │   const docRef = doc(db, collectionName, id)
   96 │   const docSnap = await getDoc(docRef)
   97 │   
   98 │   if (docSnap.exists()) {
   99 │     const data = docSnap.data();
  100 │     console.log("Dados brutos recuperados do Firestore para quarto:", id, data);
  101 │     
  102 │     if (data?.serviceFeePct !== undefined) {
  103 │       console.log("serviceFeePct antes da conversão:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
  104 │       // Garantir que serviceFeePct seja um número
  105 │       data.serviceFeePct = Number(data.serviceFeePct);
  106 │       console.log("serviceFeePct após conversão:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
  107 │     }
  108 │     
  109 │     return { id: docSnap.id, ...data } as T
  110 │   } else {
  111 │     return null
  112 │   }
  113 │ }
  114 │ 
  115 │ export const getDocuments = async <T>(
  116 │   collectionName: string,
  117 │   constraints: QueryConstraint[] = [],
  118 │   forceRefresh = false
  119 │ ): Promise<T[]> => {
  120 │   try {
  121 │     const collectionRef = collection(db, collectionName)
  122 │     const q = query(collectionRef, ...constraints)
  123 │     
  124 │     // Se forceRefresh for verdadeiro, adicionar opções que forçam uma nova consulta ao Firestore
  125 │     const querySnapshot = await getDocs(q)
  126 │     
  127 │     console.log(`Buscando documentos na coleção ${collectionName} - Força atualização: ${forceRefresh}`);
  128 │     
  129 │     return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }) as T)
  130 │   } catch (error) {
  131 │     console.error(`Erro ao buscar documentos da coleção ${collectionName}:`, error);
  132 │     return [];
  133 │   }
  134 │ }
  135 │ 
  136 │ export const updateDocument = async <T extends DocumentData>(
  137 │   collectionName: string,
  138 │   id: string,
  139 │   data: Partial<T>
  140 │ ): Promise<void> => {
  141 │   const docRef = doc(db, collectionName, id)
  142 │   await updateDoc(docRef, {
  143 │     ...data,
  144 │     updatedAt: serverTimestamp()
  145 │   })
  146 │ }
  147 │ 
  148 │ export const deleteDocument = async (
  149 │   collectionName: string,
  150 │   id: string
  151 │ ): Promise<boolean> => {
  152 │   const docRef = doc(db, collectionName, id)
  153 │   await deleteDoc(docRef)
  154 │   return true
  155 │ }
  156 │ 
  157 │ // Funções para gerenciar quartos
  158 │ export const getRooms = async (forceRefresh = false): Promise<Room[]> => {
  159 │   try {
  160 │     const constraints: QueryConstraint[] = []
  161 │     
  162 │     constraints.push(orderBy('name', 'asc'))
  163 │     
  164 │     const rooms = await getDocuments<Room>('rooms', constraints, forceRefresh)
  165 │     
  166 │     // Garantir que todos os campos necessários estejam presentes
  167 │     return rooms.map(room => {
  168 │       console.log(`Firebase - Quarto ${room.id} dados brutos:`, room);
  169 │       
  170 │       // Garantir que serviceFeePct seja um número
  171 │       const serviceFeePct = room.serviceFeePct !== undefined 
  172 │         ? Number(room.serviceFeePct) 
  173 │         : 10;
  174 │         
  175 │       console.log(`Firebase - Quarto ${room.id} serviceFeePct:`, {
  176 │         original: room.serviceFeePct,
  177 │         tipo: typeof room.serviceFeePct,
  178 │         convertido: serviceFeePct
  179 │       });
  180 │       
  181 │       return {
  182 │         id: room.id,
  183 │         name: room.name || '',
  184 │         type: room.type || 'standard',
  185 │         description: room.description || '',
  186 │         price: room.price || 0,
  187 │         capacity: room.capacity || 2,
  188 │         size: room.size || 0,
  189 │         available: room.available !== undefined ? room.available : true,
  190 │         serviceFeePct: serviceFeePct,
  191 │         images: room.images || [],
  192 │         amenities: room.amenities || [],
  193 │         additionalServices: room.additionalServices || [],
  194 │         highlights: room.highlights || [],
  195 │         createdAt: room.createdAt,
  196 │         updatedAt: room.updatedAt
  197 │       };
  198 │     });
  199 │   } catch (error) {
  200 │     console.error('Erro ao buscar quartos:', error)
  201 │     return []
  202 │   }
  203 │ }
  204 │ 
  205 │ export const getAvailableRooms = async (
  206 │   checkIn: Date,
  207 │   checkOut: Date
  208 │ ): Promise<Room[]> => {
  209 │   try {
  210 │     // Buscar todos os quartos que estão marcados como disponíveis em geral
  211 │     const constraints: QueryConstraint[] = [
  212 │       where('available', '==', true)
  213 │     ]
  214 │     
  215 │     const rooms = await getDocuments<Room>('rooms', constraints);
  216 │     
  217 │     // Filtrar os quartos que estão disponíveis nas datas específicas
  218 │     return filterAvailableRoomsByDate(rooms, checkIn, checkOut);
  219 │   } catch (error) {
  220 │     console.error('Erro ao buscar quartos disponíveis:', error)
  221 │     return []
  222 │   }
  223 │ }
  224 │ 
  225 │ // Função auxiliar para verificar disponibilidade entre datas
  226 │ export const filterAvailableRoomsByDate = (
  227 │   rooms: Room[],
  228 │   checkIn: Date,
  229 │   checkOut: Date
  230 │ ): Room[] => {
  231 │   // Converter checkIn e checkOut para ISO strings
  232 │   const dateStrings = getDatesInRange(checkIn, checkOut);
  233 │   
  234 │   return rooms.filter(room => {
  235 │     // Se não tiver controle de disponibilidade específico, considera disponível
  236 │     if (!room.availabilityDates) return true;
  237 │     
  238 │     // Verificar se alguma data no intervalo está indisponível
  239 │     return !dateStrings.some(dateStr => 
  240 │       room.availabilityDates?.[dateStr] === false
  241 │     );
  242 │   });
  243 │ };
  244 │ 
  245 │ // Função para obter disponibilidade de um quarto específico
  246 │ export const getRoomAvailability = async (
  247 │   roomId: string, 
  248 │   startDate: Date, 
  249 │   endDate: Date
  250 │ ): Promise<{[date: string]: boolean}> => {
  251 │   try {
  252 │     const room = await getRoomById(roomId);
  253 │     if (!room) throw new Error(`Quarto com ID ${roomId} não encontrado`);
  254 │     
  255 │     // Gerar datas no intervalo
  256 │     const dateStrings = getDatesInRange(startDate, endDate);
  257 │     
  258 │     // Se não tiver configuração de disponibilidade específica, assume tudo disponível
  259 │     if (!room.availabilityDates) {
  260 │       return dateStrings.reduce((acc, date) => {
  261 │         acc[date] = true;
  262 │         return acc;
  263 │       }, {} as {[date: string]: boolean});
  264 │     }
  265 │     
  266 │     // Preencher com os dados de disponibilidade existentes
  267 │     return dateStrings.reduce((acc, date) => {
  268 │       acc[date] = room.availabilityDates?.[date] !== false; // disponível por padrão se não estiver explicitamente indisponível
  269 │       return acc;
  270 │     }, {} as {[date: string]: boolean});
  271 │   } catch (error) {
  272 │     console.error(`Erro ao verificar disponibilidade do quarto ${roomId}:`, error);
  273 │     throw error;
  274 │   }
  275 │ };
  276 │ 
  277 │ // Função para atualizar disponibilidade de um quarto
  278 │ export const updateRoomAvailability = async (
  279 │   roomId: string,
  280 │   availabilityDates: {[date: string]: boolean}
  281 │ ): Promise<boolean> => {
  282 │   try {
  283 │     await updateDocument('rooms', roomId, {
  284 │       availabilityDates,
  285 │       updatedAt: serverTimestamp()
  286 │     });
  287 │     return true;
  288 │   } catch (error) {
  289 │     console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  290 │     return false;
  291 │   }
  292 │ };
  293 │ 
  294 │ // Função auxiliar para gerar array de strings de data entre um intervalo
  295 │ export const getDatesInRange = (startDate: Date, endDate: Date): string[] => {
  296 │   const dates: string[] = [];
  297 │   const currentDate = new Date(startDate);
  298 │   
  299 │   // Normalizar para meia-noite no fuso horário local
  300 │   currentDate.setHours(0, 0, 0, 0);
  301 │   const endDateNormalized = new Date(endDate);
  302 │   endDateNormalized.setHours(0, 0, 0, 0);
  303 │   
  304 │   // Adicionar cada data no intervalo EXCETO o dia de checkout
  305 │   // Usando < em vez de <= para não incluir o dia de checkout
  306 │   while (currentDate < endDateNormalized) {
  307 │     dates.push(currentDate.toISOString().split('T')[0]); // Formato YYYY-MM-DD
  308 │     currentDate.setDate(currentDate.getDate() + 1);
  309 │   }
  310 │   
  311 │   return dates;
  312 │ };
  313 │ 
  314 │ export const getRoomById = async (id: string): Promise<Room | null> => {
  315 │   try {
  316 │     const room = await getDocument<Room>('rooms', id);
  317 │     
  318 │     if (!room) return null;
  319 │     
  320 │     console.log(`Firebase - getRoomById ${id} dados brutos:`, room);
  321 │     
  322 │     // Log específico para serviceFeePct
  323 │     console.log(`serviceFeePct no Firestore:`, room.serviceFeePct);
  324 │     
  325 │     // Garantir que todos os campos necessários estejam presentes
  326 │     return {
  327 │       ...room,
  328 │       name: room.name || '',
  329 │       type: room.type || 'standard',
  330 │       description: room.description || '',
  331 │       price: room.price || 0,
  332 │       capacity: room.capacity || 2,
  333 │       size: room.size || 0,
  334 │       available: room.available !== undefined ? room.available : true,
  335 │       serviceFeePct: room.serviceFeePct !== undefined ? room.serviceFeePct : 10,
  336 │       images: room.images || [],
  337 │       amenities: room.amenities || [],
  338 │       additionalServices: room.additionalServices || [],
  339 │       highlights: room.highlights || []
  340 │     };
  341 │   } catch (error) {
  342 │     console.error(`Erro ao buscar quarto com ID ${id}:`, error);
  343 │     return null;
  344 │   }
  345 │ }
  346 │ 
  347 │ export const createRoom = async (roomData: Omit<Room, 'id' | 'createdAt' | 'updatedAt'>): Promise<Room> => {
  348 │   try {
  349 │     console.log("createRoom - Dados recebidos:", roomData);
  350 │     
  351 │     const roomWithTimestamps = {
  352 │       ...roomData,
  353 │       available: roomData.available !== undefined ? roomData.available : true,
  354 │       featured: roomData.featured || false,
  355 │       amenities: roomData.amenities || [],
  356 │       additionalServices: roomData.additionalServices || [],
  357 │       highlights: roomData.highlights || [],
  358 │       createdAt: serverTimestamp(),
  359 │       updatedAt: serverTimestamp()
  360 │     }
  361 │     
  362 │     console.log("createRoom - Dados a serem salvos:", roomWithTimestamps);
  363 │     
  364 │     const id = await createDocument('rooms', roomWithTimestamps)
  365 │     
  366 │     return {
  367 │       id,
  368 │       ...roomData,
  369 │       amenities: roomData.amenities || [],
  370 │       additionalServices: roomData.additionalServices || [],
  371 │       highlights: roomData.highlights || [],
  372 │       createdAt: Timestamp.now(),
  373 │       updatedAt: Timestamp.now()
  374 │     }
  375 │   } catch (error) {
  376 │     console.error('Erro ao criar quarto:', error)
  377 │     throw error
  378 │   }
  379 │ }
  380 │ 
  381 │ export const updateRoom = async (id: string, roomData: Partial<Omit<Room, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Room> => {
  382 │   try {
  383 │     console.log(`updateRoom - ID: ${id}, Dados recebidos:`, roomData);
  384 │     
  385 │     // Garantir que estamos lidando explicitamente com o serviceFeePct se ele for 0
  386 │     if (roomData.serviceFeePct === 0) {
  387 │       console.log("updateRoom - Detectado serviceFeePct com valor 0, salvando explicitamente.", roomData.serviceFeePct);
  388 │     }
  389 │     
  390 │     // Adicionar timestamp de atualização
  391 │     const roomWithTimestamp = {
  392 │       ...roomData,
  393 │       amenities: roomData.amenities || [],
  394 │       additionalServices: roomData.additionalServices || [],
  395 │       highlights: roomData.highlights || [],
  396 │       updatedAt: serverTimestamp()
  397 │     }
  398 │     
  399 │     console.log(`updateRoom - Dados a serem salvos:`, roomWithTimestamp);
  400 │     
  401 │     await updateDocument('rooms', id, roomWithTimestamp)
  402 │     
  403 │     const updatedRoom = await getRoomById(id)
  404 │     if (!updatedRoom) {
  405 │       throw new Error(`Quarto com ID ${id} não encontrado após atualização`)
  406 │     }
  407 │     
  408 │     return updatedRoom
  409 │   } catch (error) {
  410 │     console.error('Erro ao atualizar quarto:', error)
  411 │     throw error
  412 │   }
  413 │ }
  414 │ 
  415 │ export const deleteRoom = async (id: string): Promise<boolean> => {
  416 │   return await deleteDocument('rooms', id)
  417 │ }
  418 │ 
  419 │ // Funções específicas para reservas
  420 │ export const createBooking = async (bookingData: any) => {
  421 │   try {
  422 │     const bookingsCollection = collection(db, 'bookings');
  423 │     const docRef = await addDoc(bookingsCollection, bookingData);
  424 │     
  425 │     // CORREÇÃO: Não bloquear a data no momento da criação da reserva
  426 │     // O bloqueio será feito apenas quando o pagamento for confirmado
  427 │     // através da função updateBookingStatus
  428 │     
  429 │     return docRef;
  430 │   } catch (error) {
  431 │     console.error('Erro ao criar reserva:', error);
  432 │     throw error;
  433 │   }
  434 │ };
  435 │ 
  436 │ // Nova função para atualizar status da reserva e bloquear as datas da estadia
  437 │ export const updateBookingStatus = async (
  438 │   bookingId: string, 
  439 │   newStatus: 'pending' | 'confirmed' | 'cancelled' | 'completed',
  440 │   newPaymentStatus: 'pending' | 'paid' | 'refunded'
  441 │ ): Promise<boolean> => {
  442 │   try {
  443 │     // Referência ao documento da reserva
  444 │     const bookingRef = doc(db, 'bookings', bookingId);
  445 │     const bookingSnap = await getDoc(bookingRef);
  446 │     
  447 │     if (!bookingSnap.exists()) {
  448 │       console.error(`Booking ${bookingId} não existe ao atualizar status`);
  449 │       return false;
  450 │     }
  451 │     
  452 │     const bookingData = bookingSnap.data();
  453 │     
  454 │     // Atualizar o status da reserva
  455 │     await updateDoc(bookingRef, {
  456 │       status: newStatus,
  457 │       paymentStatus: newPaymentStatus,
  458 │       updatedAt: serverTimestamp(),
  459 │       ...(newStatus === 'confirmed' && { confirmedAt: serverTimestamp() })
  460 │     });
  461 │     
  462 │     // Se a reserva está sendo confirmada, precisamos bloquear as datas
  463 │     if (newStatus === 'confirmed') {
  464 │       console.log(`Atualizando disponibilidade para reserva confirmada: ${bookingId}`);
  465 │       
  466 │       // Recuperar datas de check-in e check-out
  467 │       const checkIn = bookingData.checkIn.toDate();
  468 │       const checkOut = bookingData.checkOut.toDate();
  469 │       const roomId = bookingData.roomId;
  470 │       
  471 │       // Obter todas as datas entre check-in e check-out
  472 │       const dates: Date[] = [];
  473 │       const currentDate = new Date(checkIn);
  474 │       
  475 │       while (currentDate < checkOut) {
  476 │         dates.push(new Date(currentDate));
  477 │         currentDate.setDate(currentDate.getDate() + 1);
  478 │       }
  479 │       
  480 │       console.log(`Bloqueando ${dates.length} dias para quarto ${roomId}`);
  481 │       
  482 │       // Atualizar disponibilidade para cada data
  483 │       const availabilityUpdates: {[date: string]: boolean} = {};
  484 │       
  485 │       dates.forEach(date => {
  486 │         const dateString = date.toISOString().split('T')[0]; // formato YYYY-MM-DD
  487 │         availabilityUpdates[dateString] = false; // false significa indisponível
  488 │       });
  489 │       
  490 │       // Atualizar disponibilidade do quarto
  491 │       if (Object.keys(availabilityUpdates).length > 0) {
  492 │         try {
  493 │           // Obter o documento do quarto
  494 │           const roomRef = doc(db, 'rooms', roomId);
  495 │           const roomSnap = await getDoc(roomRef);
  496 │           
  497 │           if (roomSnap.exists()) {
  498 │             const roomData = roomSnap.data();
  499 │             const currentAvailability = roomData.availabilityDates || {};
  500 │             
  501 │             // Mesclar a disponibilidade atual com as novas atualizações
  502 │             const updatedAvailability = {
  503 │               ...currentAvailability,
  504 │               ...availabilityUpdates
  505 │             };
  506 │             
  507 │             // Atualizar o documento do quarto
  508 │             await updateDoc(roomRef, {
  509 │               availabilityDates: updatedAvailability,
  510 │               updatedAt: serverTimestamp()
  511 │             });
  512 │             
  513 │             console.log(`Disponibilidade atualizada com sucesso para quarto ${roomId}`);
  514 │             
  515 │             // Criar log da reserva
  516 │             await addDoc(collection(db, 'bookingLogs'), {
  517 │               bookingId,
  518 │               roomId,
  519 │               action: 'status_updated',
  520 │               previousStatus: bookingData.status,
  521 │               newStatus,
  522 │               previousPaymentStatus: bookingData.paymentStatus,
  523 │               newPaymentStatus,
  524 │               datesBlocked: Object.keys(availabilityUpdates),
  525 │               timestamp: serverTimestamp(),
  526 │               userId: bookingData.userId || 'system'
  527 │             });
  528 │           } else {
  529 │             console.error(`Quarto ${roomId} não encontrado ao atualizar disponibilidade`);
  530 │           }
  531 │         } catch (error) {
  532 │           console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  533 │         }
  534 │       }
  535 │     }
  536 │     
  537 │     return true;
  538 │   } catch (error) {
  539 │     console.error(`Erro ao atualizar status da reserva ${bookingId}:`, error);
  540 │     return false;
  541 │   }
  542 │ }
  543 │ 
  544 │ export const getUserBookings = async (userId: string): Promise<Booking[]> => {
  545 │   return getDocuments<Booking>('bookings', [
  546 │     where('userId', '==', userId),
  547 │     orderBy('createdAt', 'desc')
  548 │   ])
  549 │ }
  550 │ 
  551 │ export const getRecentBookings = async (count = 5): Promise<Booking[]> => {
  552 │   return getDocuments<Booking>('bookings', [
  553 │     orderBy('createdAt', 'desc'),
  554 │     limit(count)
  555 │   ])
  556 │ }
  557 │ 
  558 │ export const getRoomBookings = async (roomId: string): Promise<Booking[]> => {
  559 │   try {
  560 │     const constraints: QueryConstraint[] = [
  561 │       where('roomId', '==', roomId),
  562 │       orderBy('checkIn', 'asc')
  563 │     ];
  564 │     
  565 │     return await getDocuments<Booking>('bookings', constraints);
  566 │   } catch (error) {
  567 │     console.error(`Erro ao buscar reservas do quarto ${roomId}:`, error);
  568 │     return [];
  569 │   }
  570 │ };
  571 │ 
  572 │ // Funções específicas para contatos
  573 │ export const createContactMessage = async (contactData: Contact) => {
  574 │   try {
  575 │     const contactsCollection = collection(db, 'contacts')
  576 │     
  577 │     // Garantir que o status seja 'new' para novos contatos
  578 │     const contactWithDefaults = {
  579 │       ...contactData,
  580 │       status: contactData.status || 'new',
  581 │       createdAt: contactData.createdAt || Timestamp.now()
  582 │     }
  583 │     
  584 │     // Se tiver detalhes de reserva, adicionar metadados
  585 │     if (contactWithDefaults.reservationDetails) {
  586 │       // Ajustar subject para indicar que é relacionado a reserva
  587 │       if (!contactWithDefaults.subject.includes('Reserva')) {
  588 │         contactWithDefaults.subject = `Reserva: ${contactWithDefaults.subject}`;
  589 │       }
  590 │     }
  591 │     
  592 │     const docRef = await addDoc(contactsCollection, contactWithDefaults)
  593 │     return docRef
  594 │   } catch (error) {
  595 │     console.error('Erro ao criar mensagem de contato:', error)
  596 │     throw error
  597 │   }
  598 │ }
  599 │ 
  600 │ export const getNewContactMessages = async (): Promise<Contact[]> => {
  601 │   return getDocuments<Contact>('contacts', [
  602 │     where('status', '==', 'new'),
  603 │     orderBy('createdAt', 'desc')
  604 │   ])
  605 │ }
  606 │ 
  607 │ // Funções para Dashboard com dados reais
  608 │ 
  609 │ export const getDashboardStats = async () => {
  610 │   try {
  611 │     const [totalBookings, totalRevenue, occupancyRate, bookingsByPlatform] = await Promise.all([
  612 │       getTotalBookings(),
  613 │       getMonthlyRevenue(),
  614 │       getOccupancyRate(),
  615 │       getBookingsByPlatform()
  616 │     ]);
  617 │ 
  618 │     return {
  619 │       totalBookings,
  620 │       totalRevenue,
  621 │       occupancyRate,
  622 │       bookingsByPlatform
  623 │     };
  624 │   } catch (error) {
  625 │     console.error('Erro ao obter estatísticas do dashboard:', error);
  626 │     throw error;
  627 │   }
  628 │ };
  629 │ 
  630 │ // Obter total de reservas
  631 │ export const getTotalBookings = async () => {
  632 │   try {
  633 │     // Obter todas as reservas
  634 │     const bookings = await getDocuments<Booking>('bookings');
  635 │     
  636 │     // Contar reservas por status
  637 │     const confirmed = bookings.filter(b => b.status === 'confirmed').length;
  638 │     const pending = bookings.filter(b => b.status === 'pending').length;
  639 │     const cancelled = bookings.filter(b => b.status === 'cancelled').length;
  640 │     const completed = bookings.filter(b => b.status === 'completed').length;
  641 │     
  642 │     // Calcular crescimento em relação ao mês anterior (simulado por enquanto)
  643 │     // Em uma implementação real, você compararia com dados do mês anterior
  644 │     const growth = ((confirmed + completed) / (bookings.length || 1) * 100) - 50;
  645 │     
  646 │     return {
  647 │       total: bookings.length,
  648 │       confirmed,
  649 │       pending,
  650 │       cancelled,
  651 │       completed,
  652 │       growth: Math.round(growth) // Arredonda para número inteiro
  653 │     };
  654 │   } catch (error) {
  655 │     console.error('Erro ao obter total de reservas:', error);
  656 │     return {
  657 │       total: 0,
  658 │       confirmed: 0,
  659 │       pending: 0, 
  660 │       cancelled: 0,
  661 │       completed: 0,
  662 │       growth: 0
  663 │     };
  664 │   }
  665 │ };
  666 │ 
  667 │ // Obter receita mensal
  668 │ export const getMonthlyRevenue = async () => {
  669 │   try {
  670 │     const bookings = await getDocuments<Booking>('bookings');
  671 │     
  672 │     // Filtrar reservas confirmadas e concluídas
  673 │     const validBookings = bookings.filter(b => 
  674 │       b.status === 'confirmed' || b.status === 'completed'
  675 │     );
  676 │     
  677 │     // Calcular receita total
  678 │     const totalRevenue = validBookings.reduce((acc, booking) => acc + booking.totalPrice, 0);
  679 │     
  680 │     // Agrupar receita por mês
  681 │     const revenueByMonth = validBookings.reduce((acc, booking) => {
  682 │       const date = booking.checkIn.toDate();
  683 │       const month = date.getMonth(); // 0-11
  684 │       const year = date.getFullYear();
  685 │       const key = `${year}-${month}`;
  686 │       
  687 │       if (!acc[key]) {
  688 │         acc[key] = 0;
  689 │       }
  690 │       acc[key] += booking.totalPrice;
  691 │       return acc;
  692 │     }, {} as Record<string, number>);
  693 │     
  694 │     // Converter para formato de array para gráfico
  695 │     const monthNames = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
  696 │     
  697 │     const currentDate = new Date();
  698 │     const currentMonth = currentDate.getMonth();
  699 │     const currentYear = currentDate.getFullYear();
  700 │     
  701 │     const revenueData = [];
  702 │     
  703 │     // Gerar dados dos últimos 12 meses
  704 │     for (let i = 0; i < 12; i++) {
  705 │       const month = (currentMonth - i + 12) % 12;
  706 │       const year = currentMonth - i < 0 ? currentYear - 1 : currentYear;
  707 │       const key = `${year}-${month}`;
  708 │       
  709 │       revenueData.unshift({
  710 │         month: monthNames[month],
  711 │         value: revenueByMonth[key] || 0
  712 │       });
  713 │     }
  714 │     
  715 │     // Calcular crescimento em relação ao mês anterior
  716 │     const lastMonthRevenue = revenueData[revenueData.length - 2]?.value || 0;
  717 │     const currentMonthRevenue = revenueData[revenueData.length - 1]?.value || 0;
  718 │     
  719 │     const growth = lastMonthRevenue ? ((currentMonthRevenue - lastMonthRevenue) / lastMonthRevenue) * 100 : 0;
  720 │     
  721 │     return {
  722 │       monthly: currentMonthRevenue,
  723 │       total: totalRevenue,
  724 │       growth: Math.round(growth),
  725 │       revenueData
  726 │     };
  727 │   } catch (error) {
  728 │     console.error('Erro ao obter receita mensal:', error);
  729 │     return {
  730 │       monthly: 0,
  731 │       total: 0,
  732 │       growth: 0,
  733 │       revenueData: []
  734 │     };
  735 │   }
  736 │ };
  737 │ 
  738 │ // Calcular taxa de ocupação
  739 │ export const getOccupancyRate = async () => {
  740 │   try {
  741 │     // Obter todos os quartos
  742 │     const rooms = await getDocuments<Room>('rooms');
  743 │     const totalRooms = rooms.length;
  744 │     
  745 │     if (totalRooms === 0) {
  746 │       return { rate: 0, growth: 0 };
  747 │     }
  748 │     
  749 │     // Obter todas as reservas
  750 │     const bookings = await getDocuments<Booking>('bookings');
  751 │     
  752 │     // Filtrar reservas confirmadas e concluídas para o mês atual
  753 │     const currentDate = new Date();
  754 │     const currentMonth = currentDate.getMonth();
  755 │     const currentYear = currentDate.getFullYear();
  756 │     
  757 │     const currentMonthBookings = bookings.filter(booking => {
  758 │       const checkInDate = booking.checkIn.toDate();
  759 │       return (
  760 │         (booking.status === 'confirmed' || booking.status === 'completed') &&
  761 │         checkInDate.getMonth() === currentMonth &&
  762 │         checkInDate.getFullYear() === currentYear
  763 │       );
  764 │     });
  765 │     
  766 │     // Calcular dias ocupados por quarto
  767 │     const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
  768 │     const totalPossibleRoomDays = totalRooms * daysInMonth;
  769 │     
  770 │     // Contar dias ocupados (simplificado - em produção seria mais complexo)
  771 │     let occupiedDays = 0;
  772 │     
  773 │     currentMonthBookings.forEach(booking => {
  774 │       const checkIn = booking.checkIn.toDate();
  775 │       const checkOut = booking.checkOut.toDate();
  776 │       
  777 │       // Ajustar datas para considerar apenas o mês atual
  778 │       const startDate = new Date(Math.max(
  779 │         checkIn.getTime(),
  780 │         new Date(currentYear, currentMonth, 1).getTime()
  781 │       ));
  782 │       const endDate = new Date(Math.min(
  783 │         checkOut.getTime(),
  784 │         new Date(currentYear, currentMonth + 1, 0).getTime()
  785 │       ));
  786 │       
  787 │       // Calcular dias entre datas (incluindo check-in, excluindo check-out)
  788 │       const days = Math.max(0, Math.floor((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)));
  789 │       occupiedDays += days;
  790 │     });
  791 │     
  792 │     const occupancyRate = (occupiedDays / totalPossibleRoomDays) * 100;
  793 │     
  794 │     // Simulação de crescimento (em produção, compararia com mês anterior)
  795 │     const growth = occupancyRate > 50 ? 5 : -3;
  796 │     
  797 │     return {
  798 │       rate: Math.round(occupancyRate),
  799 │       growth: Math.round(growth)
  800 │     };
  801 │   } catch (error) {
  802 │     console.error('Erro ao calcular taxa de ocupação:', error);
  803 │     return { rate: 0, growth: 0 };
  804 │   }
  805 │ };
  806 │ 
  807 │ // Obter reservas agrupadas por plataforma
  808 │ export const getBookingsByPlatform = async () => {
  809 │   try {
  810 │     const bookings = await getDocuments<Booking>('bookings');
  811 │     
  812 │     // Categorizar reservas por origem
  813 │     const platforms = [
  814 │       { 
  815 │         platform: "Booking.com", 
  816 │         color: "#003580", 
  817 │         icon: "Globe",
  818 │         bookings: []
  819 │       },
  820 │       { 
  821 │         platform: "Airbnb", 
  822 │         color: "#FF5A5F", 
  823 │         icon: "Heart",
  824 │         bookings: []
  825 │       },
  826 │       { 
  827 │         platform: "Direto", 
  828 │         color: "#4CAF50", 
  829 │         icon: "Home",
  830 │         bookings: []
  831 │       }
  832 │     ];
  833 │     
  834 │     // Para fins de demonstração, colocar todas as reservas como "Direto" por enquanto
  835 │     // Em produção, usaria um campo "platformOrigin" ou similar na tabela de reservas
  836 │     const platformIndex = 2; // Índice da plataforma "Direto"
  837 │     
  838 │     bookings.forEach(booking => {
  839 │       // Transformar para o formato esperado pelo componente
  840 │       const transformedBooking = {
  841 │         id: booking.id || '',
  842 │         guestName: booking.guestName,
  843 │         roomName: booking.roomName,
  844 │         checkIn: booking.checkIn.toDate().toLocaleDateString('pt-PT'),
  845 │         checkOut: booking.checkOut.toDate().toLocaleDateString('pt-PT'),
  846 │         status: booking.status,
  847 │         value: new Intl.NumberFormat('pt-PT', {
  848 │           style: 'currency',
  849 │           currency: 'EUR'
  850 │         }).format(booking.totalPrice)
  851 │       };
  852 │       
  853 │       // Adicionar à plataforma "Direto"
  854 │       (platforms[platformIndex] as any).bookings.push(transformedBooking);
  855 │     });
  856 │     
  857 │     return platforms;
  858 │   } catch (error) {
  859 │     console.error('Erro ao obter reservas por plataforma:', error);
  860 │     return [];
  861 │   }
  862 │ };
  863 │ 
  864 │ // Função para obter o preço de um quarto para uma data específica
  865 │ export const getRoomPriceForDate = async (roomId: string, date: Date): Promise<number> => {
  866 │   try {
  867 │     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  868 │     
  869 │     if (!roomDoc.exists()) {
  870 │       throw new Error("Quarto não encontrado");
  871 │     }
  872 │     
  873 │     const roomData = roomDoc.data() as Room;
  874 │     const basePrice = roomData.price;
  875 │     
  876 │     if (!roomData.seasonalPrices || roomData.seasonalPrices.length === 0) {
  877 │       return basePrice;
  878 │     }
  879 │     
  880 │     // Verificar se a data está dentro de algum período sazonal
  881 │     for (const seasonalPrice of roomData.seasonalPrices) {
  882 │       const startDate = new Date(seasonalPrice.startDate);
  883 │       const endDate = new Date(seasonalPrice.endDate);
  884 │       
  885 │       if (date >= startDate && date <= endDate) {
  886 │         return seasonalPrice.price;
  887 │       }
  888 │     }
  889 │     
  890 │     // Se não cair em nenhum período sazonal, retorna o preço base
  891 │     return basePrice;
  892 │   } catch (error) {
  893 │     console.error("Erro ao obter preço do quarto:", error);
  894 │     throw error;
  895 │   }
  896 │ }
  897 │ 
  898 │ // Função para calcular o preço total de uma estadia
  899 │ export const calculateStayPrice = async (
  900 │   roomId: string, 
  901 │   checkIn: Date, 
  902 │   checkOut: Date
  903 │ ): Promise<{
  904 │   totalPrice: number;
  905 │   nightlyPrices: { date: string; price: number }[];
  906 │   serviceFee: number;
  907 │   totalWithFee: number;
  908 │ }> => {
  909 │   try {
  910 │     console.log(`🔍 Iniciando cálculo de preço para estadia: ${checkIn.toISOString().split('T')[0]} até ${checkOut.toISOString().split('T')[0]}`);
  911 │     
  912 │     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  913 │     
  914 │     if (!roomDoc.exists()) {
  915 │       throw new Error("Quarto não encontrado");
  916 │     }
  917 │     
  918 │     const roomData = roomDoc.data() as Room;
  919 │     console.log(`📝 Dados do quarto ${roomId}:`, {
  920 │       nome: roomData.name,
  921 │       precoBase: roomData.price,
  922 │       taxaServico: roomData.serviceFeePct || 0,
  923 │       temPrecosSazonais: !!roomData.seasonalPrices?.length
  924 │     });
  925 │     
  926 │     const nightlyPrices: { date: string; price: number }[] = [];
  927 │     let totalPrice = 0;
  928 │     
  929 │     // Calcular o número de noites - corrigido para usar o método correto de cálculo
  930 │     // O número de noites é a diferença em dias (estadia = checkout - checkin)
  931 │     const noites = differenceInDays(checkOut, checkIn);
  932 │     console.log(`🗓️ Número de noites calculado: ${noites}`);
  933 │     
  934 │     if (noites <= 0) {
  935 │       console.error(`⚠️ Erro: número de noites inválido (${noites})`);
  936 │       throw new Error("Data de check-out deve ser posterior à data de check-in");
  937 │     }
  938 │     
  939 │     // Para cada noite, verificar o preço aplicável (preço base ou sazonal)
  940 │     // Começamos exatamente do dia de check-in
  941 │     const currentDate = new Date(checkIn);
  942 │     currentDate.setHours(0, 0, 0, 0); // Normalizar para meia-noite
  943 │     
  944 │     // Processamos cada dia de estadia (noite)
  945 │     console.log(`📊 Calculando preços por noite:`);
  946 │     for (let i = 0; i < noites; i++) {
  947 │       // Obtemos o preço para esta data
  948 │       const dateCopy = new Date(currentDate);
  949 │       const priceForDate = await getRoomPriceForDate(roomId, dateCopy);
  950 │       const dateString = dateCopy.toISOString().split('T')[0]; // YYYY-MM-DD
  951 │       
  952 │       console.log(`   - ${dateString}: €${priceForDate}`);
  953 │       
  954 │       nightlyPrices.push({
  955 │         date: dateString,
  956 │         price: priceForDate
  957 │       });
  958 │       
  959 │       totalPrice += priceForDate;
  960 │       
  961 │       // Avançamos para o próximo dia
  962 │       currentDate.setDate(currentDate.getDate() + 1);
  963 │     }
  964 │     
  965 │     // Verificação de segurança para o cálculo do totalPrice
  966 │     const manualTotal = nightlyPrices.reduce((sum, night) => sum + night.price, 0);
  967 │     if (Math.abs(totalPrice - manualTotal) > 1) {
  968 │       console.error(`⚠️ Discrepância detectada no cálculo do preço total!`);
  969 │       console.error(`   - Total calculado iterativamente: €${totalPrice}`);
  970 │       console.error(`   - Total calculado via reduce: €${manualTotal}`);
  971 │       console.error(`   - Usando o valor recalculado para segurança!`);
  972 │       totalPrice = manualTotal;
  973 │     }
  974 │     
  975 │     // Calcular taxa de serviço
  976 │     const serviceFee = (totalPrice * (roomData.serviceFeePct || 0)) / 100;
  977 │     const totalWithFee = totalPrice + serviceFee;
  978 │     
  979 │     console.log(`💰 Resumo do cálculo:`);
  980 │     console.log(`   - Total das diárias: €${totalPrice}`);
  981 │     console.log(`   - Taxa de serviço (${roomData.serviceFeePct || 0}%): €${serviceFee}`);
  982 │     console.log(`   - Total com taxas: €${totalWithFee}`);
  983 │     
  984 │     return {
  985 │       totalPrice,
  986 │       nightlyPrices,
  987 │       serviceFee,
  988 │       totalWithFee
  989 │     };
  990 │   } catch (error) {
  991 │     console.error("❌ Erro ao calcular preço da estadia:", error);
  992 │     throw error;
  993 │   }
  994 │ } 
  995 │ import { 
  996 │   collection, 
  997 │   getDocs, 
  998 │   getDoc, 
  999 │   doc, 
 1000 │   setDoc, 
      ·   ───┬──
      ·      ╰── `setDoc` redefined here
 1001 │   addDoc, 
 1002 │   updateDoc, 
 1003 │   deleteDoc,
      ╰────

  × the name `addDoc` is defined multiple times
      ╭─[/home/runner/workspace/lib/firebase/firestore.ts:2:1]
    2 │   collection,
    3 │   doc,
    4 │   setDoc,
    5 │   addDoc,
      ·   ───┬──
      ·      ╰── previous definition of `addDoc` here
    6 │   getDoc,
    7 │   getDocs,
    8 │   updateDoc,
    9 │   deleteDoc,
   10 │   query,
   11 │   where,
   12 │   orderBy,
   13 │   limit,
   14 │   DocumentData,
   15 │   QueryConstraint,
   16 │   Timestamp,
   17 │   serverTimestamp
   18 │ } from 'firebase/firestore'
   19 │ import { db } from './config'
   20 │ import { Room, SeasonalPrice } from '@/lib/types'
   21 │ import { differenceInDays } from 'date-fns'
   22 │ 
   23 │ // Tipos de dados
   24 │ export interface Booking {
   25 │   id?: string
   26 │   userId?: string
   27 │   guestName: string
   28 │   guestEmail: string
   29 │   guestPhone: string
   30 │   roomId: string
   31 │   roomName: string
   32 │   checkIn: Timestamp
   33 │   checkOut: Timestamp
   34 │   adults: number
   35 │   children: number
   36 │   totalPrice: number
   37 │   status: 'pending' | 'confirmed' | 'cancelled' | 'completed'
   38 │   paymentStatus: 'pending' | 'paid' | 'refunded'
   39 │   specialRequests?: string
   40 │   createdAt?: Timestamp
   41 │   updatedAt?: Timestamp
   42 │ }
   43 │ 
   44 │ export interface Contact {
   45 │   id?: string
   46 │   name: string
   47 │   email: string
   48 │   phone?: string
   49 │   subject: string
   50 │   message: string
   51 │   status: 'new' | 'read' | 'replied'
   52 │   createdAt: Timestamp
   53 │   updatedAt?: Timestamp
   54 │   repliedAt?: Timestamp
   55 │   replyContent?: string
   56 │   reservationDetails?: {
   57 │     checkIn?: Timestamp
   58 │     checkOut?: Timestamp
   59 │     roomId?: string
   60 │     roomName?: string
   61 │     totalGuests?: number
   62 │     totalPrice?: number
   63 │   }
   64 │ }
   65 │ 
   66 │ // Funções genéricas para CRUD
   67 │ export const createDocument = async <T extends DocumentData>(
   68 │   collectionName: string,
   69 │   data: T
   70 │ ): Promise<string> => {
   71 │   const docRef = await addDoc(collection(db, collectionName), {
   72 │     ...data,
   73 │     createdAt: serverTimestamp(),
   74 │     updatedAt: serverTimestamp()
   75 │   })
   76 │   return docRef.id
   77 │ }
   78 │ 
   79 │ export const createDocumentWithId = async <T extends DocumentData>(
   80 │   collectionName: string,
   81 │   id: string,
   82 │   data: T
   83 │ ): Promise<void> => {
   84 │   await setDoc(doc(db, collectionName, id), {
   85 │     ...data,
   86 │     createdAt: serverTimestamp(),
   87 │     updatedAt: serverTimestamp()
   88 │   })
   89 │ }
   90 │ 
   91 │ export const getDocument = async <T>(
   92 │   collectionName: string,
   93 │   id: string
   94 │ ): Promise<T | null> => {
   95 │   const docRef = doc(db, collectionName, id)
   96 │   const docSnap = await getDoc(docRef)
   97 │   
   98 │   if (docSnap.exists()) {
   99 │     const data = docSnap.data();
  100 │     console.log("Dados brutos recuperados do Firestore para quarto:", id, data);
  101 │     
  102 │     if (data?.serviceFeePct !== undefined) {
  103 │       console.log("serviceFeePct antes da conversão:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
  104 │       // Garantir que serviceFeePct seja um número
  105 │       data.serviceFeePct = Number(data.serviceFeePct);
  106 │       console.log("serviceFeePct após conversão:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
  107 │     }
  108 │     
  109 │     return { id: docSnap.id, ...data } as T
  110 │   } else {
  111 │     return null
  112 │   }
  113 │ }
  114 │ 
  115 │ export const getDocuments = async <T>(
  116 │   collectionName: string,
  117 │   constraints: QueryConstraint[] = [],
  118 │   forceRefresh = false
  119 │ ): Promise<T[]> => {
  120 │   try {
  121 │     const collectionRef = collection(db, collectionName)
  122 │     const q = query(collectionRef, ...constraints)
  123 │     
  124 │     // Se forceRefresh for verdadeiro, adicionar opções que forçam uma nova consulta ao Firestore
  125 │     const querySnapshot = await getDocs(q)
  126 │     
  127 │     console.log(`Buscando documentos na coleção ${collectionName} - Força atualização: ${forceRefresh}`);
  128 │     
  129 │     return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }) as T)
  130 │   } catch (error) {
  131 │     console.error(`Erro ao buscar documentos da coleção ${collectionName}:`, error);
  132 │     return [];
  133 │   }
  134 │ }
  135 │ 
  136 │ export const updateDocument = async <T extends DocumentData>(
  137 │   collectionName: string,
  138 │   id: string,
  139 │   data: Partial<T>
  140 │ ): Promise<void> => {
  141 │   const docRef = doc(db, collectionName, id)
  142 │   await updateDoc(docRef, {
  143 │     ...data,
  144 │     updatedAt: serverTimestamp()
  145 │   })
  146 │ }
  147 │ 
  148 │ export const deleteDocument = async (
  149 │   collectionName: string,
  150 │   id: string
  151 │ ): Promise<boolean> => {
  152 │   const docRef = doc(db, collectionName, id)
  153 │   await deleteDoc(docRef)
  154 │   return true
  155 │ }
  156 │ 
  157 │ // Funções para gerenciar quartos
  158 │ export const getRooms = async (forceRefresh = false): Promise<Room[]> => {
  159 │   try {
  160 │     const constraints: QueryConstraint[] = []
  161 │     
  162 │     constraints.push(orderBy('name', 'asc'))
  163 │     
  164 │     const rooms = await getDocuments<Room>('rooms', constraints, forceRefresh)
  165 │     
  166 │     // Garantir que todos os campos necessários estejam presentes
  167 │     return rooms.map(room => {
  168 │       console.log(`Firebase - Quarto ${room.id} dados brutos:`, room);
  169 │       
  170 │       // Garantir que serviceFeePct seja um número
  171 │       const serviceFeePct = room.serviceFeePct !== undefined 
  172 │         ? Number(room.serviceFeePct) 
  173 │         : 10;
  174 │         
  175 │       console.log(`Firebase - Quarto ${room.id} serviceFeePct:`, {
  176 │         original: room.serviceFeePct,
  177 │         tipo: typeof room.serviceFeePct,
  178 │         convertido: serviceFeePct
  179 │       });
  180 │       
  181 │       return {
  182 │         id: room.id,
  183 │         name: room.name || '',
  184 │         type: room.type || 'standard',
  185 │         description: room.description || '',
  186 │         price: room.price || 0,
  187 │         capacity: room.capacity || 2,
  188 │         size: room.size || 0,
  189 │         available: room.available !== undefined ? room.available : true,
  190 │         serviceFeePct: serviceFeePct,
  191 │         images: room.images || [],
  192 │         amenities: room.amenities || [],
  193 │         additionalServices: room.additionalServices || [],
  194 │         highlights: room.highlights || [],
  195 │         createdAt: room.createdAt,
  196 │         updatedAt: room.updatedAt
  197 │       };
  198 │     });
  199 │   } catch (error) {
  200 │     console.error('Erro ao buscar quartos:', error)
  201 │     return []
  202 │   }
  203 │ }
  204 │ 
  205 │ export const getAvailableRooms = async (
  206 │   checkIn: Date,
  207 │   checkOut: Date
  208 │ ): Promise<Room[]> => {
  209 │   try {
  210 │     // Buscar todos os quartos que estão marcados como disponíveis em geral
  211 │     const constraints: QueryConstraint[] = [
  212 │       where('available', '==', true)
  213 │     ]
  214 │     
  215 │     const rooms = await getDocuments<Room>('rooms', constraints);
  216 │     
  217 │     // Filtrar os quartos que estão disponíveis nas datas específicas
  218 │     return filterAvailableRoomsByDate(rooms, checkIn, checkOut);
  219 │   } catch (error) {
  220 │     console.error('Erro ao buscar quartos disponíveis:', error)
  221 │     return []
  222 │   }
  223 │ }
  224 │ 
  225 │ // Função auxiliar para verificar disponibilidade entre datas
  226 │ export const filterAvailableRoomsByDate = (
  227 │   rooms: Room[],
  228 │   checkIn: Date,
  229 │   checkOut: Date
  230 │ ): Room[] => {
  231 │   // Converter checkIn e checkOut para ISO strings
  232 │   const dateStrings = getDatesInRange(checkIn, checkOut);
  233 │   
  234 │   return rooms.filter(room => {
  235 │     // Se não tiver controle de disponibilidade específico, considera disponível
  236 │     if (!room.availabilityDates) return true;
  237 │     
  238 │     // Verificar se alguma data no intervalo está indisponível
  239 │     return !dateStrings.some(dateStr => 
  240 │       room.availabilityDates?.[dateStr] === false
  241 │     );
  242 │   });
  243 │ };
  244 │ 
  245 │ // Função para obter disponibilidade de um quarto específico
  246 │ export const getRoomAvailability = async (
  247 │   roomId: string, 
  248 │   startDate: Date, 
  249 │   endDate: Date
  250 │ ): Promise<{[date: string]: boolean}> => {
  251 │   try {
  252 │     const room = await getRoomById(roomId);
  253 │     if (!room) throw new Error(`Quarto com ID ${roomId} não encontrado`);
  254 │     
  255 │     // Gerar datas no intervalo
  256 │     const dateStrings = getDatesInRange(startDate, endDate);
  257 │     
  258 │     // Se não tiver configuração de disponibilidade específica, assume tudo disponível
  259 │     if (!room.availabilityDates) {
  260 │       return dateStrings.reduce((acc, date) => {
  261 │         acc[date] = true;
  262 │         return acc;
  263 │       }, {} as {[date: string]: boolean});
  264 │     }
  265 │     
  266 │     // Preencher com os dados de disponibilidade existentes
  267 │     return dateStrings.reduce((acc, date) => {
  268 │       acc[date] = room.availabilityDates?.[date] !== false; // disponível por padrão se não estiver explicitamente indisponível
  269 │       return acc;
  270 │     }, {} as {[date: string]: boolean});
  271 │   } catch (error) {
  272 │     console.error(`Erro ao verificar disponibilidade do quarto ${roomId}:`, error);
  273 │     throw error;
  274 │   }
  275 │ };
  276 │ 
  277 │ // Função para atualizar disponibilidade de um quarto
  278 │ export const updateRoomAvailability = async (
  279 │   roomId: string,
  280 │   availabilityDates: {[date: string]: boolean}
  281 │ ): Promise<boolean> => {
  282 │   try {
  283 │     await updateDocument('rooms', roomId, {
  284 │       availabilityDates,
  285 │       updatedAt: serverTimestamp()
  286 │     });
  287 │     return true;
  288 │   } catch (error) {
  289 │     console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  290 │     return false;
  291 │   }
  292 │ };
  293 │ 
  294 │ // Função auxiliar para gerar array de strings de data entre um intervalo
  295 │ export const getDatesInRange = (startDate: Date, endDate: Date): string[] => {
  296 │   const dates: string[] = [];
  297 │   const currentDate = new Date(startDate);
  298 │   
  299 │   // Normalizar para meia-noite no fuso horário local
  300 │   currentDate.setHours(0, 0, 0, 0);
  301 │   const endDateNormalized = new Date(endDate);
  302 │   endDateNormalized.setHours(0, 0, 0, 0);
  303 │   
  304 │   // Adicionar cada data no intervalo EXCETO o dia de checkout
  305 │   // Usando < em vez de <= para não incluir o dia de checkout
  306 │   while (currentDate < endDateNormalized) {
  307 │     dates.push(currentDate.toISOString().split('T')[0]); // Formato YYYY-MM-DD
  308 │     currentDate.setDate(currentDate.getDate() + 1);
  309 │   }
  310 │   
  311 │   return dates;
  312 │ };
  313 │ 
  314 │ export const getRoomById = async (id: string): Promise<Room | null> => {
  315 │   try {
  316 │     const room = await getDocument<Room>('rooms', id);
  317 │     
  318 │     if (!room) return null;
  319 │     
  320 │     console.log(`Firebase - getRoomById ${id} dados brutos:`, room);
  321 │     
  322 │     // Log específico para serviceFeePct
  323 │     console.log(`serviceFeePct no Firestore:`, room.serviceFeePct);
  324 │     
  325 │     // Garantir que todos os campos necessários estejam presentes
  326 │     return {
  327 │       ...room,
  328 │       name: room.name || '',
  329 │       type: room.type || 'standard',
  330 │       description: room.description || '',
  331 │       price: room.price || 0,
  332 │       capacity: room.capacity || 2,
  333 │       size: room.size || 0,
  334 │       available: room.available !== undefined ? room.available : true,
  335 │       serviceFeePct: room.serviceFeePct !== undefined ? room.serviceFeePct : 10,
  336 │       images: room.images || [],
  337 │       amenities: room.amenities || [],
  338 │       additionalServices: room.additionalServices || [],
  339 │       highlights: room.highlights || []
  340 │     };
  341 │   } catch (error) {
  342 │     console.error(`Erro ao buscar quarto com ID ${id}:`, error);
  343 │     return null;
  344 │   }
  345 │ }
  346 │ 
  347 │ export const createRoom = async (roomData: Omit<Room, 'id' | 'createdAt' | 'updatedAt'>): Promise<Room> => {
  348 │   try {
  349 │     console.log("createRoom - Dados recebidos:", roomData);
  350 │     
  351 │     const roomWithTimestamps = {
  352 │       ...roomData,
  353 │       available: roomData.available !== undefined ? roomData.available : true,
  354 │       featured: roomData.featured || false,
  355 │       amenities: roomData.amenities || [],
  356 │       additionalServices: roomData.additionalServices || [],
  357 │       highlights: roomData.highlights || [],
  358 │       createdAt: serverTimestamp(),
  359 │       updatedAt: serverTimestamp()
  360 │     }
  361 │     
  362 │     console.log("createRoom - Dados a serem salvos:", roomWithTimestamps);
  363 │     
  364 │     const id = await createDocument('rooms', roomWithTimestamps)
  365 │     
  366 │     return {
  367 │       id,
  368 │       ...roomData,
  369 │       amenities: roomData.amenities || [],
  370 │       additionalServices: roomData.additionalServices || [],
  371 │       highlights: roomData.highlights || [],
  372 │       createdAt: Timestamp.now(),
  373 │       updatedAt: Timestamp.now()
  374 │     }
  375 │   } catch (error) {
  376 │     console.error('Erro ao criar quarto:', error)
  377 │     throw error
  378 │   }
  379 │ }
  380 │ 
  381 │ export const updateRoom = async (id: string, roomData: Partial<Omit<Room, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Room> => {
  382 │   try {
  383 │     console.log(`updateRoom - ID: ${id}, Dados recebidos:`, roomData);
  384 │     
  385 │     // Garantir que estamos lidando explicitamente com o serviceFeePct se ele for 0
  386 │     if (roomData.serviceFeePct === 0) {
  387 │       console.log("updateRoom - Detectado serviceFeePct com valor 0, salvando explicitamente.", roomData.serviceFeePct);
  388 │     }
  389 │     
  390 │     // Adicionar timestamp de atualização
  391 │     const roomWithTimestamp = {
  392 │       ...roomData,
  393 │       amenities: roomData.amenities || [],
  394 │       additionalServices: roomData.additionalServices || [],
  395 │       highlights: roomData.highlights || [],
  396 │       updatedAt: serverTimestamp()
  397 │     }
  398 │     
  399 │     console.log(`updateRoom - Dados a serem salvos:`, roomWithTimestamp);
  400 │     
  401 │     await updateDocument('rooms', id, roomWithTimestamp)
  402 │     
  403 │     const updatedRoom = await getRoomById(id)
  404 │     if (!updatedRoom) {
  405 │       throw new Error(`Quarto com ID ${id} não encontrado após atualização`)
  406 │     }
  407 │     
  408 │     return updatedRoom
  409 │   } catch (error) {
  410 │     console.error('Erro ao atualizar quarto:', error)
  411 │     throw error
  412 │   }
  413 │ }
  414 │ 
  415 │ export const deleteRoom = async (id: string): Promise<boolean> => {
  416 │   return await deleteDocument('rooms', id)
  417 │ }
  418 │ 
  419 │ // Funções específicas para reservas
  420 │ export const createBooking = async (bookingData: any) => {
  421 │   try {
  422 │     const bookingsCollection = collection(db, 'bookings');
  423 │     const docRef = await addDoc(bookingsCollection, bookingData);
  424 │     
  425 │     // CORREÇÃO: Não bloquear a data no momento da criação da reserva
  426 │     // O bloqueio será feito apenas quando o pagamento for confirmado
  427 │     // através da função updateBookingStatus
  428 │     
  429 │     return docRef;
  430 │   } catch (error) {
  431 │     console.error('Erro ao criar reserva:', error);
  432 │     throw error;
  433 │   }
  434 │ };
  435 │ 
  436 │ // Nova função para atualizar status da reserva e bloquear as datas da estadia
  437 │ export const updateBookingStatus = async (
  438 │   bookingId: string, 
  439 │   newStatus: 'pending' | 'confirmed' | 'cancelled' | 'completed',
  440 │   newPaymentStatus: 'pending' | 'paid' | 'refunded'
  441 │ ): Promise<boolean> => {
  442 │   try {
  443 │     // Referência ao documento da reserva
  444 │     const bookingRef = doc(db, 'bookings', bookingId);
  445 │     const bookingSnap = await getDoc(bookingRef);
  446 │     
  447 │     if (!bookingSnap.exists()) {
  448 │       console.error(`Booking ${bookingId} não existe ao atualizar status`);
  449 │       return false;
  450 │     }
  451 │     
  452 │     const bookingData = bookingSnap.data();
  453 │     
  454 │     // Atualizar o status da reserva
  455 │     await updateDoc(bookingRef, {
  456 │       status: newStatus,
  457 │       paymentStatus: newPaymentStatus,
  458 │       updatedAt: serverTimestamp(),
  459 │       ...(newStatus === 'confirmed' && { confirmedAt: serverTimestamp() })
  460 │     });
  461 │     
  462 │     // Se a reserva está sendo confirmada, precisamos bloquear as datas
  463 │     if (newStatus === 'confirmed') {
  464 │       console.log(`Atualizando disponibilidade para reserva confirmada: ${bookingId}`);
  465 │       
  466 │       // Recuperar datas de check-in e check-out
  467 │       const checkIn = bookingData.checkIn.toDate();
  468 │       const checkOut = bookingData.checkOut.toDate();
  469 │       const roomId = bookingData.roomId;
  470 │       
  471 │       // Obter todas as datas entre check-in e check-out
  472 │       const dates: Date[] = [];
  473 │       const currentDate = new Date(checkIn);
  474 │       
  475 │       while (currentDate < checkOut) {
  476 │         dates.push(new Date(currentDate));
  477 │         currentDate.setDate(currentDate.getDate() + 1);
  478 │       }
  479 │       
  480 │       console.log(`Bloqueando ${dates.length} dias para quarto ${roomId}`);
  481 │       
  482 │       // Atualizar disponibilidade para cada data
  483 │       const availabilityUpdates: {[date: string]: boolean} = {};
  484 │       
  485 │       dates.forEach(date => {
  486 │         const dateString = date.toISOString().split('T')[0]; // formato YYYY-MM-DD
  487 │         availabilityUpdates[dateString] = false; // false significa indisponível
  488 │       });
  489 │       
  490 │       // Atualizar disponibilidade do quarto
  491 │       if (Object.keys(availabilityUpdates).length > 0) {
  492 │         try {
  493 │           // Obter o documento do quarto
  494 │           const roomRef = doc(db, 'rooms', roomId);
  495 │           const roomSnap = await getDoc(roomRef);
  496 │           
  497 │           if (roomSnap.exists()) {
  498 │             const roomData = roomSnap.data();
  499 │             const currentAvailability = roomData.availabilityDates || {};
  500 │             
  501 │             // Mesclar a disponibilidade atual com as novas atualizações
  502 │             const updatedAvailability = {
  503 │               ...currentAvailability,
  504 │               ...availabilityUpdates
  505 │             };
  506 │             
  507 │             // Atualizar o documento do quarto
  508 │             await updateDoc(roomRef, {
  509 │               availabilityDates: updatedAvailability,
  510 │               updatedAt: serverTimestamp()
  511 │             });
  512 │             
  513 │             console.log(`Disponibilidade atualizada com sucesso para quarto ${roomId}`);
  514 │             
  515 │             // Criar log da reserva
  516 │             await addDoc(collection(db, 'bookingLogs'), {
  517 │               bookingId,
  518 │               roomId,
  519 │               action: 'status_updated',
  520 │               previousStatus: bookingData.status,
  521 │               newStatus,
  522 │               previousPaymentStatus: bookingData.paymentStatus,
  523 │               newPaymentStatus,
  524 │               datesBlocked: Object.keys(availabilityUpdates),
  525 │               timestamp: serverTimestamp(),
  526 │               userId: bookingData.userId || 'system'
  527 │             });
  528 │           } else {
  529 │             console.error(`Quarto ${roomId} não encontrado ao atualizar disponibilidade`);
  530 │           }
  531 │         } catch (error) {
  532 │           console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  533 │         }
  534 │       }
  535 │     }
  536 │     
  537 │     return true;
  538 │   } catch (error) {
  539 │     console.error(`Erro ao atualizar status da reserva ${bookingId}:`, error);
  540 │     return false;
  541 │   }
  542 │ }
  543 │ 
  544 │ export const getUserBookings = async (userId: string): Promise<Booking[]> => {
  545 │   return getDocuments<Booking>('bookings', [
  546 │     where('userId', '==', userId),
  547 │     orderBy('createdAt', 'desc')
  548 │   ])
  549 │ }
  550 │ 
  551 │ export const getRecentBookings = async (count = 5): Promise<Booking[]> => {
  552 │   return getDocuments<Booking>('bookings', [
  553 │     orderBy('createdAt', 'desc'),
  554 │     limit(count)
  555 │   ])
  556 │ }
  557 │ 
  558 │ export const getRoomBookings = async (roomId: string): Promise<Booking[]> => {
  559 │   try {
  560 │     const constraints: QueryConstraint[] = [
  561 │       where('roomId', '==', roomId),
  562 │       orderBy('checkIn', 'asc')
  563 │     ];
  564 │     
  565 │     return await getDocuments<Booking>('bookings', constraints);
  566 │   } catch (error) {
  567 │     console.error(`Erro ao buscar reservas do quarto ${roomId}:`, error);
  568 │     return [];
  569 │   }
  570 │ };
  571 │ 
  572 │ // Funções específicas para contatos
  573 │ export const createContactMessage = async (contactData: Contact) => {
  574 │   try {
  575 │     const contactsCollection = collection(db, 'contacts')
  576 │     
  577 │     // Garantir que o status seja 'new' para novos contatos
  578 │     const contactWithDefaults = {
  579 │       ...contactData,
  580 │       status: contactData.status || 'new',
  581 │       createdAt: contactData.createdAt || Timestamp.now()
  582 │     }
  583 │     
  584 │     // Se tiver detalhes de reserva, adicionar metadados
  585 │     if (contactWithDefaults.reservationDetails) {
  586 │       // Ajustar subject para indicar que é relacionado a reserva
  587 │       if (!contactWithDefaults.subject.includes('Reserva')) {
  588 │         contactWithDefaults.subject = `Reserva: ${contactWithDefaults.subject}`;
  589 │       }
  590 │     }
  591 │     
  592 │     const docRef = await addDoc(contactsCollection, contactWithDefaults)
  593 │     return docRef
  594 │   } catch (error) {
  595 │     console.error('Erro ao criar mensagem de contato:', error)
  596 │     throw error
  597 │   }
  598 │ }
  599 │ 
  600 │ export const getNewContactMessages = async (): Promise<Contact[]> => {
  601 │   return getDocuments<Contact>('contacts', [
  602 │     where('status', '==', 'new'),
  603 │     orderBy('createdAt', 'desc')
  604 │   ])
  605 │ }
  606 │ 
  607 │ // Funções para Dashboard com dados reais
  608 │ 
  609 │ export const getDashboardStats = async () => {
  610 │   try {
  611 │     const [totalBookings, totalRevenue, occupancyRate, bookingsByPlatform] = await Promise.all([
  612 │       getTotalBookings(),
  613 │       getMonthlyRevenue(),
  614 │       getOccupancyRate(),
  615 │       getBookingsByPlatform()
  616 │     ]);
  617 │ 
  618 │     return {
  619 │       totalBookings,
  620 │       totalRevenue,
  621 │       occupancyRate,
  622 │       bookingsByPlatform
  623 │     };
  624 │   } catch (error) {
  625 │     console.error('Erro ao obter estatísticas do dashboard:', error);
  626 │     throw error;
  627 │   }
  628 │ };
  629 │ 
  630 │ // Obter total de reservas
  631 │ export const getTotalBookings = async () => {
  632 │   try {
  633 │     // Obter todas as reservas
  634 │     const bookings = await getDocuments<Booking>('bookings');
  635 │     
  636 │     // Contar reservas por status
  637 │     const confirmed = bookings.filter(b => b.status === 'confirmed').length;
  638 │     const pending = bookings.filter(b => b.status === 'pending').length;
  639 │     const cancelled = bookings.filter(b => b.status === 'cancelled').length;
  640 │     const completed = bookings.filter(b => b.status === 'completed').length;
  641 │     
  642 │     // Calcular crescimento em relação ao mês anterior (simulado por enquanto)
  643 │     // Em uma implementação real, você compararia com dados do mês anterior
  644 │     const growth = ((confirmed + completed) / (bookings.length || 1) * 100) - 50;
  645 │     
  646 │     return {
  647 │       total: bookings.length,
  648 │       confirmed,
  649 │       pending,
  650 │       cancelled,
  651 │       completed,
  652 │       growth: Math.round(growth) // Arredonda para número inteiro
  653 │     };
  654 │   } catch (error) {
  655 │     console.error('Erro ao obter total de reservas:', error);
  656 │     return {
  657 │       total: 0,
  658 │       confirmed: 0,
  659 │       pending: 0, 
  660 │       cancelled: 0,
  661 │       completed: 0,
  662 │       growth: 0
  663 │     };
  664 │   }
  665 │ };
  666 │ 
  667 │ // Obter receita mensal
  668 │ export const getMonthlyRevenue = async () => {
  669 │   try {
  670 │     const bookings = await getDocuments<Booking>('bookings');
  671 │     
  672 │     // Filtrar reservas confirmadas e concluídas
  673 │     const validBookings = bookings.filter(b => 
  674 │       b.status === 'confirmed' || b.status === 'completed'
  675 │     );
  676 │     
  677 │     // Calcular receita total
  678 │     const totalRevenue = validBookings.reduce((acc, booking) => acc + booking.totalPrice, 0);
  679 │     
  680 │     // Agrupar receita por mês
  681 │     const revenueByMonth = validBookings.reduce((acc, booking) => {
  682 │       const date = booking.checkIn.toDate();
  683 │       const month = date.getMonth(); // 0-11
  684 │       const year = date.getFullYear();
  685 │       const key = `${year}-${month}`;
  686 │       
  687 │       if (!acc[key]) {
  688 │         acc[key] = 0;
  689 │       }
  690 │       acc[key] += booking.totalPrice;
  691 │       return acc;
  692 │     }, {} as Record<string, number>);
  693 │     
  694 │     // Converter para formato de array para gráfico
  695 │     const monthNames = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
  696 │     
  697 │     const currentDate = new Date();
  698 │     const currentMonth = currentDate.getMonth();
  699 │     const currentYear = currentDate.getFullYear();
  700 │     
  701 │     const revenueData = [];
  702 │     
  703 │     // Gerar dados dos últimos 12 meses
  704 │     for (let i = 0; i < 12; i++) {
  705 │       const month = (currentMonth - i + 12) % 12;
  706 │       const year = currentMonth - i < 0 ? currentYear - 1 : currentYear;
  707 │       const key = `${year}-${month}`;
  708 │       
  709 │       revenueData.unshift({
  710 │         month: monthNames[month],
  711 │         value: revenueByMonth[key] || 0
  712 │       });
  713 │     }
  714 │     
  715 │     // Calcular crescimento em relação ao mês anterior
  716 │     const lastMonthRevenue = revenueData[revenueData.length - 2]?.value || 0;
  717 │     const currentMonthRevenue = revenueData[revenueData.length - 1]?.value || 0;
  718 │     
  719 │     const growth = lastMonthRevenue ? ((currentMonthRevenue - lastMonthRevenue) / lastMonthRevenue) * 100 : 0;
  720 │     
  721 │     return {
  722 │       monthly: currentMonthRevenue,
  723 │       total: totalRevenue,
  724 │       growth: Math.round(growth),
  725 │       revenueData
  726 │     };
  727 │   } catch (error) {
  728 │     console.error('Erro ao obter receita mensal:', error);
  729 │     return {
  730 │       monthly: 0,
  731 │       total: 0,
  732 │       growth: 0,
  733 │       revenueData: []
  734 │     };
  735 │   }
  736 │ };
  737 │ 
  738 │ // Calcular taxa de ocupação
  739 │ export const getOccupancyRate = async () => {
  740 │   try {
  741 │     // Obter todos os quartos
  742 │     const rooms = await getDocuments<Room>('rooms');
  743 │     const totalRooms = rooms.length;
  744 │     
  745 │     if (totalRooms === 0) {
  746 │       return { rate: 0, growth: 0 };
  747 │     }
  748 │     
  749 │     // Obter todas as reservas
  750 │     const bookings = await getDocuments<Booking>('bookings');
  751 │     
  752 │     // Filtrar reservas confirmadas e concluídas para o mês atual
  753 │     const currentDate = new Date();
  754 │     const currentMonth = currentDate.getMonth();
  755 │     const currentYear = currentDate.getFullYear();
  756 │     
  757 │     const currentMonthBookings = bookings.filter(booking => {
  758 │       const checkInDate = booking.checkIn.toDate();
  759 │       return (
  760 │         (booking.status === 'confirmed' || booking.status === 'completed') &&
  761 │         checkInDate.getMonth() === currentMonth &&
  762 │         checkInDate.getFullYear() === currentYear
  763 │       );
  764 │     });
  765 │     
  766 │     // Calcular dias ocupados por quarto
  767 │     const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
  768 │     const totalPossibleRoomDays = totalRooms * daysInMonth;
  769 │     
  770 │     // Contar dias ocupados (simplificado - em produção seria mais complexo)
  771 │     let occupiedDays = 0;
  772 │     
  773 │     currentMonthBookings.forEach(booking => {
  774 │       const checkIn = booking.checkIn.toDate();
  775 │       const checkOut = booking.checkOut.toDate();
  776 │       
  777 │       // Ajustar datas para considerar apenas o mês atual
  778 │       const startDate = new Date(Math.max(
  779 │         checkIn.getTime(),
  780 │         new Date(currentYear, currentMonth, 1).getTime()
  781 │       ));
  782 │       const endDate = new Date(Math.min(
  783 │         checkOut.getTime(),
  784 │         new Date(currentYear, currentMonth + 1, 0).getTime()
  785 │       ));
  786 │       
  787 │       // Calcular dias entre datas (incluindo check-in, excluindo check-out)
  788 │       const days = Math.max(0, Math.floor((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)));
  789 │       occupiedDays += days;
  790 │     });
  791 │     
  792 │     const occupancyRate = (occupiedDays / totalPossibleRoomDays) * 100;
  793 │     
  794 │     // Simulação de crescimento (em produção, compararia com mês anterior)
  795 │     const growth = occupancyRate > 50 ? 5 : -3;
  796 │     
  797 │     return {
  798 │       rate: Math.round(occupancyRate),
  799 │       growth: Math.round(growth)
  800 │     };
  801 │   } catch (error) {
  802 │     console.error('Erro ao calcular taxa de ocupação:', error);
  803 │     return { rate: 0, growth: 0 };
  804 │   }
  805 │ };
  806 │ 
  807 │ // Obter reservas agrupadas por plataforma
  808 │ export const getBookingsByPlatform = async () => {
  809 │   try {
  810 │     const bookings = await getDocuments<Booking>('bookings');
  811 │     
  812 │     // Categorizar reservas por origem
  813 │     const platforms = [
  814 │       { 
  815 │         platform: "Booking.com", 
  816 │         color: "#003580", 
  817 │         icon: "Globe",
  818 │         bookings: []
  819 │       },
  820 │       { 
  821 │         platform: "Airbnb", 
  822 │         color: "#FF5A5F", 
  823 │         icon: "Heart",
  824 │         bookings: []
  825 │       },
  826 │       { 
  827 │         platform: "Direto", 
  828 │         color: "#4CAF50", 
  829 │         icon: "Home",
  830 │         bookings: []
  831 │       }
  832 │     ];
  833 │     
  834 │     // Para fins de demonstração, colocar todas as reservas como "Direto" por enquanto
  835 │     // Em produção, usaria um campo "platformOrigin" ou similar na tabela de reservas
  836 │     const platformIndex = 2; // Índice da plataforma "Direto"
  837 │     
  838 │     bookings.forEach(booking => {
  839 │       // Transformar para o formato esperado pelo componente
  840 │       const transformedBooking = {
  841 │         id: booking.id || '',
  842 │         guestName: booking.guestName,
  843 │         roomName: booking.roomName,
  844 │         checkIn: booking.checkIn.toDate().toLocaleDateString('pt-PT'),
  845 │         checkOut: booking.checkOut.toDate().toLocaleDateString('pt-PT'),
  846 │         status: booking.status,
  847 │         value: new Intl.NumberFormat('pt-PT', {
  848 │           style: 'currency',
  849 │           currency: 'EUR'
  850 │         }).format(booking.totalPrice)
  851 │       };
  852 │       
  853 │       // Adicionar à plataforma "Direto"
  854 │       (platforms[platformIndex] as any).bookings.push(transformedBooking);
  855 │     });
  856 │     
  857 │     return platforms;
  858 │   } catch (error) {
  859 │     console.error('Erro ao obter reservas por plataforma:', error);
  860 │     return [];
  861 │   }
  862 │ };
  863 │ 
  864 │ // Função para obter o preço de um quarto para uma data específica
  865 │ export const getRoomPriceForDate = async (roomId: string, date: Date): Promise<number> => {
  866 │   try {
  867 │     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  868 │     
  869 │     if (!roomDoc.exists()) {
  870 │       throw new Error("Quarto não encontrado");
  871 │     }
  872 │     
  873 │     const roomData = roomDoc.data() as Room;
  874 │     const basePrice = roomData.price;
  875 │     
  876 │     if (!roomData.seasonalPrices || roomData.seasonalPrices.length === 0) {
  877 │       return basePrice;
  878 │     }
  879 │     
  880 │     // Verificar se a data está dentro de algum período sazonal
  881 │     for (const seasonalPrice of roomData.seasonalPrices) {
  882 │       const startDate = new Date(seasonalPrice.startDate);
  883 │       const endDate = new Date(seasonalPrice.endDate);
  884 │       
  885 │       if (date >= startDate && date <= endDate) {
  886 │         return seasonalPrice.price;
  887 │       }
  888 │     }
  889 │     
  890 │     // Se não cair em nenhum período sazonal, retorna o preço base
  891 │     return basePrice;
  892 │   } catch (error) {
  893 │     console.error("Erro ao obter preço do quarto:", error);
  894 │     throw error;
  895 │   }
  896 │ }
  897 │ 
  898 │ // Função para calcular o preço total de uma estadia
  899 │ export const calculateStayPrice = async (
  900 │   roomId: string, 
  901 │   checkIn: Date, 
  902 │   checkOut: Date
  903 │ ): Promise<{
  904 │   totalPrice: number;
  905 │   nightlyPrices: { date: string; price: number }[];
  906 │   serviceFee: number;
  907 │   totalWithFee: number;
  908 │ }> => {
  909 │   try {
  910 │     console.log(`🔍 Iniciando cálculo de preço para estadia: ${checkIn.toISOString().split('T')[0]} até ${checkOut.toISOString().split('T')[0]}`);
  911 │     
  912 │     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  913 │     
  914 │     if (!roomDoc.exists()) {
  915 │       throw new Error("Quarto não encontrado");
  916 │     }
  917 │     
  918 │     const roomData = roomDoc.data() as Room;
  919 │     console.log(`📝 Dados do quarto ${roomId}:`, {
  920 │       nome: roomData.name,
  921 │       precoBase: roomData.price,
  922 │       taxaServico: roomData.serviceFeePct || 0,
  923 │       temPrecosSazonais: !!roomData.seasonalPrices?.length
  924 │     });
  925 │     
  926 │     const nightlyPrices: { date: string; price: number }[] = [];
  927 │     let totalPrice = 0;
  928 │     
  929 │     // Calcular o número de noites - corrigido para usar o método correto de cálculo
  930 │     // O número de noites é a diferença em dias (estadia = checkout - checkin)
  931 │     const noites = differenceInDays(checkOut, checkIn);
  932 │     console.log(`🗓️ Número de noites calculado: ${noites}`);
  933 │     
  934 │     if (noites <= 0) {
  935 │       console.error(`⚠️ Erro: número de noites inválido (${noites})`);
  936 │       throw new Error("Data de check-out deve ser posterior à data de check-in");
  937 │     }
  938 │     
  939 │     // Para cada noite, verificar o preço aplicável (preço base ou sazonal)
  940 │     // Começamos exatamente do dia de check-in
  941 │     const currentDate = new Date(checkIn);
  942 │     currentDate.setHours(0, 0, 0, 0); // Normalizar para meia-noite
  943 │     
  944 │     // Processamos cada dia de estadia (noite)
  945 │     console.log(`📊 Calculando preços por noite:`);
  946 │     for (let i = 0; i < noites; i++) {
  947 │       // Obtemos o preço para esta data
  948 │       const dateCopy = new Date(currentDate);
  949 │       const priceForDate = await getRoomPriceForDate(roomId, dateCopy);
  950 │       const dateString = dateCopy.toISOString().split('T')[0]; // YYYY-MM-DD
  951 │       
  952 │       console.log(`   - ${dateString}: €${priceForDate}`);
  953 │       
  954 │       nightlyPrices.push({
  955 │         date: dateString,
  956 │         price: priceForDate
  957 │       });
  958 │       
  959 │       totalPrice += priceForDate;
  960 │       
  961 │       // Avançamos para o próximo dia
  962 │       currentDate.setDate(currentDate.getDate() + 1);
  963 │     }
  964 │     
  965 │     // Verificação de segurança para o cálculo do totalPrice
  966 │     const manualTotal = nightlyPrices.reduce((sum, night) => sum + night.price, 0);
  967 │     if (Math.abs(totalPrice - manualTotal) > 1) {
  968 │       console.error(`⚠️ Discrepância detectada no cálculo do preço total!`);
  969 │       console.error(`   - Total calculado iterativamente: €${totalPrice}`);
  970 │       console.error(`   - Total calculado via reduce: €${manualTotal}`);
  971 │       console.error(`   - Usando o valor recalculado para segurança!`);
  972 │       totalPrice = manualTotal;
  973 │     }
  974 │     
  975 │     // Calcular taxa de serviço
  976 │     const serviceFee = (totalPrice * (roomData.serviceFeePct || 0)) / 100;
  977 │     const totalWithFee = totalPrice + serviceFee;
  978 │     
  979 │     console.log(`💰 Resumo do cálculo:`);
  980 │     console.log(`   - Total das diárias: €${totalPrice}`);
  981 │     console.log(`   - Taxa de serviço (${roomData.serviceFeePct || 0}%): €${serviceFee}`);
  982 │     console.log(`   - Total com taxas: €${totalWithFee}`);
  983 │     
  984 │     return {
  985 │       totalPrice,
  986 │       nightlyPrices,
  987 │       serviceFee,
  988 │       totalWithFee
  989 │     };
  990 │   } catch (error) {
  991 │     console.error("❌ Erro ao calcular preço da estadia:", error);
  992 │     throw error;
  993 │   }
  994 │ } 
  995 │ import { 
  996 │   collection, 
  997 │   getDocs, 
  998 │   getDoc, 
  999 │   doc, 
 1000 │   setDoc, 
 1001 │   addDoc, 
      ·   ───┬──
      ·      ╰── `addDoc` redefined here
 1002 │   updateDoc, 
 1003 │   deleteDoc,
 1004 │   query,
      ╰────

  × the name `updateDoc` is defined multiple times
      ╭─[/home/runner/workspace/lib/firebase/firestore.ts:5:1]
    5 │   addDoc,
    6 │   getDoc,
    7 │   getDocs,
    8 │   updateDoc,
      ·   ────┬────
      ·       ╰── previous definition of `updateDoc` here
    9 │   deleteDoc,
   10 │   query,
   11 │   where,
   12 │   orderBy,
   13 │   limit,
   14 │   DocumentData,
   15 │   QueryConstraint,
   16 │   Timestamp,
   17 │   serverTimestamp
   18 │ } from 'firebase/firestore'
   19 │ import { db } from './config'
   20 │ import { Room, SeasonalPrice } from '@/lib/types'
   21 │ import { differenceInDays } from 'date-fns'
   22 │ 
   23 │ // Tipos de dados
   24 │ export interface Booking {
   25 │   id?: string
   26 │   userId?: string
   27 │   guestName: string
   28 │   guestEmail: string
   29 │   guestPhone: string
   30 │   roomId: string
   31 │   roomName: string
   32 │   checkIn: Timestamp
   33 │   checkOut: Timestamp
   34 │   adults: number
   35 │   children: number
   36 │   totalPrice: number
   37 │   status: 'pending' | 'confirmed' | 'cancelled' | 'completed'
   38 │   paymentStatus: 'pending' | 'paid' | 'refunded'
   39 │   specialRequests?: string
   40 │   createdAt?: Timestamp
   41 │   updatedAt?: Timestamp
   42 │ }
   43 │ 
   44 │ export interface Contact {
   45 │   id?: string
   46 │   name: string
   47 │   email: string
   48 │   phone?: string
   49 │   subject: string
   50 │   message: string
   51 │   status: 'new' | 'read' | 'replied'
   52 │   createdAt: Timestamp
   53 │   updatedAt?: Timestamp
   54 │   repliedAt?: Timestamp
   55 │   replyContent?: string
   56 │   reservationDetails?: {
   57 │     checkIn?: Timestamp
   58 │     checkOut?: Timestamp
   59 │     roomId?: string
   60 │     roomName?: string
   61 │     totalGuests?: number
   62 │     totalPrice?: number
   63 │   }
   64 │ }
   65 │ 
   66 │ // Funções genéricas para CRUD
   67 │ export const createDocument = async <T extends DocumentData>(
   68 │   collectionName: string,
   69 │   data: T
   70 │ ): Promise<string> => {
   71 │   const docRef = await addDoc(collection(db, collectionName), {
   72 │     ...data,
   73 │     createdAt: serverTimestamp(),
   74 │     updatedAt: serverTimestamp()
   75 │   })
   76 │   return docRef.id
   77 │ }
   78 │ 
   79 │ export const createDocumentWithId = async <T extends DocumentData>(
   80 │   collectionName: string,
   81 │   id: string,
   82 │   data: T
   83 │ ): Promise<void> => {
   84 │   await setDoc(doc(db, collectionName, id), {
   85 │     ...data,
   86 │     createdAt: serverTimestamp(),
   87 │     updatedAt: serverTimestamp()
   88 │   })
   89 │ }
   90 │ 
   91 │ export const getDocument = async <T>(
   92 │   collectionName: string,
   93 │   id: string
   94 │ ): Promise<T | null> => {
   95 │   const docRef = doc(db, collectionName, id)
   96 │   const docSnap = await getDoc(docRef)
   97 │   
   98 │   if (docSnap.exists()) {
   99 │     const data = docSnap.data();
  100 │     console.log("Dados brutos recuperados do Firestore para quarto:", id, data);
  101 │     
  102 │     if (data?.serviceFeePct !== undefined) {
  103 │       console.log("serviceFeePct antes da conversão:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
  104 │       // Garantir que serviceFeePct seja um número
  105 │       data.serviceFeePct = Number(data.serviceFeePct);
  106 │       console.log("serviceFeePct após conversão:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
  107 │     }
  108 │     
  109 │     return { id: docSnap.id, ...data } as T
  110 │   } else {
  111 │     return null
  112 │   }
  113 │ }
  114 │ 
  115 │ export const getDocuments = async <T>(
  116 │   collectionName: string,
  117 │   constraints: QueryConstraint[] = [],
  118 │   forceRefresh = false
  119 │ ): Promise<T[]> => {
  120 │   try {
  121 │     const collectionRef = collection(db, collectionName)
  122 │     const q = query(collectionRef, ...constraints)
  123 │     
  124 │     // Se forceRefresh for verdadeiro, adicionar opções que forçam uma nova consulta ao Firestore
  125 │     const querySnapshot = await getDocs(q)
  126 │     
  127 │     console.log(`Buscando documentos na coleção ${collectionName} - Força atualização: ${forceRefresh}`);
  128 │     
  129 │     return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }) as T)
  130 │   } catch (error) {
  131 │     console.error(`Erro ao buscar documentos da coleção ${collectionName}:`, error);
  132 │     return [];
  133 │   }
  134 │ }
  135 │ 
  136 │ export const updateDocument = async <T extends DocumentData>(
  137 │   collectionName: string,
  138 │   id: string,
  139 │   data: Partial<T>
  140 │ ): Promise<void> => {
  141 │   const docRef = doc(db, collectionName, id)
  142 │   await updateDoc(docRef, {
  143 │     ...data,
  144 │     updatedAt: serverTimestamp()
  145 │   })
  146 │ }
  147 │ 
  148 │ export const deleteDocument = async (
  149 │   collectionName: string,
  150 │   id: string
  151 │ ): Promise<boolean> => {
  152 │   const docRef = doc(db, collectionName, id)
  153 │   await deleteDoc(docRef)
  154 │   return true
  155 │ }
  156 │ 
  157 │ // Funções para gerenciar quartos
  158 │ export const getRooms = async (forceRefresh = false): Promise<Room[]> => {
  159 │   try {
  160 │     const constraints: QueryConstraint[] = []
  161 │     
  162 │     constraints.push(orderBy('name', 'asc'))
  163 │     
  164 │     const rooms = await getDocuments<Room>('rooms', constraints, forceRefresh)
  165 │     
  166 │     // Garantir que todos os campos necessários estejam presentes
  167 │     return rooms.map(room => {
  168 │       console.log(`Firebase - Quarto ${room.id} dados brutos:`, room);
  169 │       
  170 │       // Garantir que serviceFeePct seja um número
  171 │       const serviceFeePct = room.serviceFeePct !== undefined 
  172 │         ? Number(room.serviceFeePct) 
  173 │         : 10;
  174 │         
  175 │       console.log(`Firebase - Quarto ${room.id} serviceFeePct:`, {
  176 │         original: room.serviceFeePct,
  177 │         tipo: typeof room.serviceFeePct,
  178 │         convertido: serviceFeePct
  179 │       });
  180 │       
  181 │       return {
  182 │         id: room.id,
  183 │         name: room.name || '',
  184 │         type: room.type || 'standard',
  185 │         description: room.description || '',
  186 │         price: room.price || 0,
  187 │         capacity: room.capacity || 2,
  188 │         size: room.size || 0,
  189 │         available: room.available !== undefined ? room.available : true,
  190 │         serviceFeePct: serviceFeePct,
  191 │         images: room.images || [],
  192 │         amenities: room.amenities || [],
  193 │         additionalServices: room.additionalServices || [],
  194 │         highlights: room.highlights || [],
  195 │         createdAt: room.createdAt,
  196 │         updatedAt: room.updatedAt
  197 │       };
  198 │     });
  199 │   } catch (error) {
  200 │     console.error('Erro ao buscar quartos:', error)
  201 │     return []
  202 │   }
  203 │ }
  204 │ 
  205 │ export const getAvailableRooms = async (
  206 │   checkIn: Date,
  207 │   checkOut: Date
  208 │ ): Promise<Room[]> => {
  209 │   try {
  210 │     // Buscar todos os quartos que estão marcados como disponíveis em geral
  211 │     const constraints: QueryConstraint[] = [
  212 │       where('available', '==', true)
  213 │     ]
  214 │     
  215 │     const rooms = await getDocuments<Room>('rooms', constraints);
  216 │     
  217 │     // Filtrar os quartos que estão disponíveis nas datas específicas
  218 │     return filterAvailableRoomsByDate(rooms, checkIn, checkOut);
  219 │   } catch (error) {
  220 │     console.error('Erro ao buscar quartos disponíveis:', error)
  221 │     return []
  222 │   }
  223 │ }
  224 │ 
  225 │ // Função auxiliar para verificar disponibilidade entre datas
  226 │ export const filterAvailableRoomsByDate = (
  227 │   rooms: Room[],
  228 │   checkIn: Date,
  229 │   checkOut: Date
  230 │ ): Room[] => {
  231 │   // Converter checkIn e checkOut para ISO strings
  232 │   const dateStrings = getDatesInRange(checkIn, checkOut);
  233 │   
  234 │   return rooms.filter(room => {
  235 │     // Se não tiver controle de disponibilidade específico, considera disponível
  236 │     if (!room.availabilityDates) return true;
  237 │     
  238 │     // Verificar se alguma data no intervalo está indisponível
  239 │     return !dateStrings.some(dateStr => 
  240 │       room.availabilityDates?.[dateStr] === false
  241 │     );
  242 │   });
  243 │ };
  244 │ 
  245 │ // Função para obter disponibilidade de um quarto específico
  246 │ export const getRoomAvailability = async (
  247 │   roomId: string, 
  248 │   startDate: Date, 
  249 │   endDate: Date
  250 │ ): Promise<{[date: string]: boolean}> => {
  251 │   try {
  252 │     const room = await getRoomById(roomId);
  253 │     if (!room) throw new Error(`Quarto com ID ${roomId} não encontrado`);
  254 │     
  255 │     // Gerar datas no intervalo
  256 │     const dateStrings = getDatesInRange(startDate, endDate);
  257 │     
  258 │     // Se não tiver configuração de disponibilidade específica, assume tudo disponível
  259 │     if (!room.availabilityDates) {
  260 │       return dateStrings.reduce((acc, date) => {
  261 │         acc[date] = true;
  262 │         return acc;
  263 │       }, {} as {[date: string]: boolean});
  264 │     }
  265 │     
  266 │     // Preencher com os dados de disponibilidade existentes
  267 │     return dateStrings.reduce((acc, date) => {
  268 │       acc[date] = room.availabilityDates?.[date] !== false; // disponível por padrão se não estiver explicitamente indisponível
  269 │       return acc;
  270 │     }, {} as {[date: string]: boolean});
  271 │   } catch (error) {
  272 │     console.error(`Erro ao verificar disponibilidade do quarto ${roomId}:`, error);
  273 │     throw error;
  274 │   }
  275 │ };
  276 │ 
  277 │ // Função para atualizar disponibilidade de um quarto
  278 │ export const updateRoomAvailability = async (
  279 │   roomId: string,
  280 │   availabilityDates: {[date: string]: boolean}
  281 │ ): Promise<boolean> => {
  282 │   try {
  283 │     await updateDocument('rooms', roomId, {
  284 │       availabilityDates,
  285 │       updatedAt: serverTimestamp()
  286 │     });
  287 │     return true;
  288 │   } catch (error) {
  289 │     console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  290 │     return false;
  291 │   }
  292 │ };
  293 │ 
  294 │ // Função auxiliar para gerar array de strings de data entre um intervalo
  295 │ export const getDatesInRange = (startDate: Date, endDate: Date): string[] => {
  296 │   const dates: string[] = [];
  297 │   const currentDate = new Date(startDate);
  298 │   
  299 │   // Normalizar para meia-noite no fuso horário local
  300 │   currentDate.setHours(0, 0, 0, 0);
  301 │   const endDateNormalized = new Date(endDate);
  302 │   endDateNormalized.setHours(0, 0, 0, 0);
  303 │   
  304 │   // Adicionar cada data no intervalo EXCETO o dia de checkout
  305 │   // Usando < em vez de <= para não incluir o dia de checkout
  306 │   while (currentDate < endDateNormalized) {
  307 │     dates.push(currentDate.toISOString().split('T')[0]); // Formato YYYY-MM-DD
  308 │     currentDate.setDate(currentDate.getDate() + 1);
  309 │   }
  310 │   
  311 │   return dates;
  312 │ };
  313 │ 
  314 │ export const getRoomById = async (id: string): Promise<Room | null> => {
  315 │   try {
  316 │     const room = await getDocument<Room>('rooms', id);
  317 │     
  318 │     if (!room) return null;
  319 │     
  320 │     console.log(`Firebase - getRoomById ${id} dados brutos:`, room);
  321 │     
  322 │     // Log específico para serviceFeePct
  323 │     console.log(`serviceFeePct no Firestore:`, room.serviceFeePct);
  324 │     
  325 │     // Garantir que todos os campos necessários estejam presentes
  326 │     return {
  327 │       ...room,
  328 │       name: room.name || '',
  329 │       type: room.type || 'standard',
  330 │       description: room.description || '',
  331 │       price: room.price || 0,
  332 │       capacity: room.capacity || 2,
  333 │       size: room.size || 0,
  334 │       available: room.available !== undefined ? room.available : true,
  335 │       serviceFeePct: room.serviceFeePct !== undefined ? room.serviceFeePct : 10,
  336 │       images: room.images || [],
  337 │       amenities: room.amenities || [],
  338 │       additionalServices: room.additionalServices || [],
  339 │       highlights: room.highlights || []
  340 │     };
  341 │   } catch (error) {
  342 │     console.error(`Erro ao buscar quarto com ID ${id}:`, error);
  343 │     return null;
  344 │   }
  345 │ }
  346 │ 
  347 │ export const createRoom = async (roomData: Omit<Room, 'id' | 'createdAt' | 'updatedAt'>): Promise<Room> => {
  348 │   try {
  349 │     console.log("createRoom - Dados recebidos:", roomData);
  350 │     
  351 │     const roomWithTimestamps = {
  352 │       ...roomData,
  353 │       available: roomData.available !== undefined ? roomData.available : true,
  354 │       featured: roomData.featured || false,
  355 │       amenities: roomData.amenities || [],
  356 │       additionalServices: roomData.additionalServices || [],
  357 │       highlights: roomData.highlights || [],
  358 │       createdAt: serverTimestamp(),
  359 │       updatedAt: serverTimestamp()
  360 │     }
  361 │     
  362 │     console.log("createRoom - Dados a serem salvos:", roomWithTimestamps);
  363 │     
  364 │     const id = await createDocument('rooms', roomWithTimestamps)
  365 │     
  366 │     return {
  367 │       id,
  368 │       ...roomData,
  369 │       amenities: roomData.amenities || [],
  370 │       additionalServices: roomData.additionalServices || [],
  371 │       highlights: roomData.highlights || [],
  372 │       createdAt: Timestamp.now(),
  373 │       updatedAt: Timestamp.now()
  374 │     }
  375 │   } catch (error) {
  376 │     console.error('Erro ao criar quarto:', error)
  377 │     throw error
  378 │   }
  379 │ }
  380 │ 
  381 │ export const updateRoom = async (id: string, roomData: Partial<Omit<Room, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Room> => {
  382 │   try {
  383 │     console.log(`updateRoom - ID: ${id}, Dados recebidos:`, roomData);
  384 │     
  385 │     // Garantir que estamos lidando explicitamente com o serviceFeePct se ele for 0
  386 │     if (roomData.serviceFeePct === 0) {
  387 │       console.log("updateRoom - Detectado serviceFeePct com valor 0, salvando explicitamente.", roomData.serviceFeePct);
  388 │     }
  389 │     
  390 │     // Adicionar timestamp de atualização
  391 │     const roomWithTimestamp = {
  392 │       ...roomData,
  393 │       amenities: roomData.amenities || [],
  394 │       additionalServices: roomData.additionalServices || [],
  395 │       highlights: roomData.highlights || [],
  396 │       updatedAt: serverTimestamp()
  397 │     }
  398 │     
  399 │     console.log(`updateRoom - Dados a serem salvos:`, roomWithTimestamp);
  400 │     
  401 │     await updateDocument('rooms', id, roomWithTimestamp)
  402 │     
  403 │     const updatedRoom = await getRoomById(id)
  404 │     if (!updatedRoom) {
  405 │       throw new Error(`Quarto com ID ${id} não encontrado após atualização`)
  406 │     }
  407 │     
  408 │     return updatedRoom
  409 │   } catch (error) {
  410 │     console.error('Erro ao atualizar quarto:', error)
  411 │     throw error
  412 │   }
  413 │ }
  414 │ 
  415 │ export const deleteRoom = async (id: string): Promise<boolean> => {
  416 │   return await deleteDocument('rooms', id)
  417 │ }
  418 │ 
  419 │ // Funções específicas para reservas
  420 │ export const createBooking = async (bookingData: any) => {
  421 │   try {
  422 │     const bookingsCollection = collection(db, 'bookings');
  423 │     const docRef = await addDoc(bookingsCollection, bookingData);
  424 │     
  425 │     // CORREÇÃO: Não bloquear a data no momento da criação da reserva
  426 │     // O bloqueio será feito apenas quando o pagamento for confirmado
  427 │     // através da função updateBookingStatus
  428 │     
  429 │     return docRef;
  430 │   } catch (error) {
  431 │     console.error('Erro ao criar reserva:', error);
  432 │     throw error;
  433 │   }
  434 │ };
  435 │ 
  436 │ // Nova função para atualizar status da reserva e bloquear as datas da estadia
  437 │ export const updateBookingStatus = async (
  438 │   bookingId: string, 
  439 │   newStatus: 'pending' | 'confirmed' | 'cancelled' | 'completed',
  440 │   newPaymentStatus: 'pending' | 'paid' | 'refunded'
  441 │ ): Promise<boolean> => {
  442 │   try {
  443 │     // Referência ao documento da reserva
  444 │     const bookingRef = doc(db, 'bookings', bookingId);
  445 │     const bookingSnap = await getDoc(bookingRef);
  446 │     
  447 │     if (!bookingSnap.exists()) {
  448 │       console.error(`Booking ${bookingId} não existe ao atualizar status`);
  449 │       return false;
  450 │     }
  451 │     
  452 │     const bookingData = bookingSnap.data();
  453 │     
  454 │     // Atualizar o status da reserva
  455 │     await updateDoc(bookingRef, {
  456 │       status: newStatus,
  457 │       paymentStatus: newPaymentStatus,
  458 │       updatedAt: serverTimestamp(),
  459 │       ...(newStatus === 'confirmed' && { confirmedAt: serverTimestamp() })
  460 │     });
  461 │     
  462 │     // Se a reserva está sendo confirmada, precisamos bloquear as datas
  463 │     if (newStatus === 'confirmed') {
  464 │       console.log(`Atualizando disponibilidade para reserva confirmada: ${bookingId}`);
  465 │       
  466 │       // Recuperar datas de check-in e check-out
  467 │       const checkIn = bookingData.checkIn.toDate();
  468 │       const checkOut = bookingData.checkOut.toDate();
  469 │       const roomId = bookingData.roomId;
  470 │       
  471 │       // Obter todas as datas entre check-in e check-out
  472 │       const dates: Date[] = [];
  473 │       const currentDate = new Date(checkIn);
  474 │       
  475 │       while (currentDate < checkOut) {
  476 │         dates.push(new Date(currentDate));
  477 │         currentDate.setDate(currentDate.getDate() + 1);
  478 │       }
  479 │       
  480 │       console.log(`Bloqueando ${dates.length} dias para quarto ${roomId}`);
  481 │       
  482 │       // Atualizar disponibilidade para cada data
  483 │       const availabilityUpdates: {[date: string]: boolean} = {};
  484 │       
  485 │       dates.forEach(date => {
  486 │         const dateString = date.toISOString().split('T')[0]; // formato YYYY-MM-DD
  487 │         availabilityUpdates[dateString] = false; // false significa indisponível
  488 │       });
  489 │       
  490 │       // Atualizar disponibilidade do quarto
  491 │       if (Object.keys(availabilityUpdates).length > 0) {
  492 │         try {
  493 │           // Obter o documento do quarto
  494 │           const roomRef = doc(db, 'rooms', roomId);
  495 │           const roomSnap = await getDoc(roomRef);
  496 │           
  497 │           if (roomSnap.exists()) {
  498 │             const roomData = roomSnap.data();
  499 │             const currentAvailability = roomData.availabilityDates || {};
  500 │             
  501 │             // Mesclar a disponibilidade atual com as novas atualizações
  502 │             const updatedAvailability = {
  503 │               ...currentAvailability,
  504 │               ...availabilityUpdates
  505 │             };
  506 │             
  507 │             // Atualizar o documento do quarto
  508 │             await updateDoc(roomRef, {
  509 │               availabilityDates: updatedAvailability,
  510 │               updatedAt: serverTimestamp()
  511 │             });
  512 │             
  513 │             console.log(`Disponibilidade atualizada com sucesso para quarto ${roomId}`);
  514 │             
  515 │             // Criar log da reserva
  516 │             await addDoc(collection(db, 'bookingLogs'), {
  517 │               bookingId,
  518 │               roomId,
  519 │               action: 'status_updated',
  520 │               previousStatus: bookingData.status,
  521 │               newStatus,
  522 │               previousPaymentStatus: bookingData.paymentStatus,
  523 │               newPaymentStatus,
  524 │               datesBlocked: Object.keys(availabilityUpdates),
  525 │               timestamp: serverTimestamp(),
  526 │               userId: bookingData.userId || 'system'
  527 │             });
  528 │           } else {
  529 │             console.error(`Quarto ${roomId} não encontrado ao atualizar disponibilidade`);
  530 │           }
  531 │         } catch (error) {
  532 │           console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  533 │         }
  534 │       }
  535 │     }
  536 │     
  537 │     return true;
  538 │   } catch (error) {
  539 │     console.error(`Erro ao atualizar status da reserva ${bookingId}:`, error);
  540 │     return false;
  541 │   }
  542 │ }
  543 │ 
  544 │ export const getUserBookings = async (userId: string): Promise<Booking[]> => {
  545 │   return getDocuments<Booking>('bookings', [
  546 │     where('userId', '==', userId),
  547 │     orderBy('createdAt', 'desc')
  548 │   ])
  549 │ }
  550 │ 
  551 │ export const getRecentBookings = async (count = 5): Promise<Booking[]> => {
  552 │   return getDocuments<Booking>('bookings', [
  553 │     orderBy('createdAt', 'desc'),
  554 │     limit(count)
  555 │   ])
  556 │ }
  557 │ 
  558 │ export const getRoomBookings = async (roomId: string): Promise<Booking[]> => {
  559 │   try {
  560 │     const constraints: QueryConstraint[] = [
  561 │       where('roomId', '==', roomId),
  562 │       orderBy('checkIn', 'asc')
  563 │     ];
  564 │     
  565 │     return await getDocuments<Booking>('bookings', constraints);
  566 │   } catch (error) {
  567 │     console.error(`Erro ao buscar reservas do quarto ${roomId}:`, error);
  568 │     return [];
  569 │   }
  570 │ };
  571 │ 
  572 │ // Funções específicas para contatos
  573 │ export const createContactMessage = async (contactData: Contact) => {
  574 │   try {
  575 │     const contactsCollection = collection(db, 'contacts')
  576 │     
  577 │     // Garantir que o status seja 'new' para novos contatos
  578 │     const contactWithDefaults = {
  579 │       ...contactData,
  580 │       status: contactData.status || 'new',
  581 │       createdAt: contactData.createdAt || Timestamp.now()
  582 │     }
  583 │     
  584 │     // Se tiver detalhes de reserva, adicionar metadados
  585 │     if (contactWithDefaults.reservationDetails) {
  586 │       // Ajustar subject para indicar que é relacionado a reserva
  587 │       if (!contactWithDefaults.subject.includes('Reserva')) {
  588 │         contactWithDefaults.subject = `Reserva: ${contactWithDefaults.subject}`;
  589 │       }
  590 │     }
  591 │     
  592 │     const docRef = await addDoc(contactsCollection, contactWithDefaults)
  593 │     return docRef
  594 │   } catch (error) {
  595 │     console.error('Erro ao criar mensagem de contato:', error)
  596 │     throw error
  597 │   }
  598 │ }
  599 │ 
  600 │ export const getNewContactMessages = async (): Promise<Contact[]> => {
  601 │   return getDocuments<Contact>('contacts', [
  602 │     where('status', '==', 'new'),
  603 │     orderBy('createdAt', 'desc')
  604 │   ])
  605 │ }
  606 │ 
  607 │ // Funções para Dashboard com dados reais
  608 │ 
  609 │ export const getDashboardStats = async () => {
  610 │   try {
  611 │     const [totalBookings, totalRevenue, occupancyRate, bookingsByPlatform] = await Promise.all([
  612 │       getTotalBookings(),
  613 │       getMonthlyRevenue(),
  614 │       getOccupancyRate(),
  615 │       getBookingsByPlatform()
  616 │     ]);
  617 │ 
  618 │     return {
  619 │       totalBookings,
  620 │       totalRevenue,
  621 │       occupancyRate,
  622 │       bookingsByPlatform
  623 │     };
  624 │   } catch (error) {
  625 │     console.error('Erro ao obter estatísticas do dashboard:', error);
  626 │     throw error;
  627 │   }
  628 │ };
  629 │ 
  630 │ // Obter total de reservas
  631 │ export const getTotalBookings = async () => {
  632 │   try {
  633 │     // Obter todas as reservas
  634 │     const bookings = await getDocuments<Booking>('bookings');
  635 │     
  636 │     // Contar reservas por status
  637 │     const confirmed = bookings.filter(b => b.status === 'confirmed').length;
  638 │     const pending = bookings.filter(b => b.status === 'pending').length;
  639 │     const cancelled = bookings.filter(b => b.status === 'cancelled').length;
  640 │     const completed = bookings.filter(b => b.status === 'completed').length;
  641 │     
  642 │     // Calcular crescimento em relação ao mês anterior (simulado por enquanto)
  643 │     // Em uma implementação real, você compararia com dados do mês anterior
  644 │     const growth = ((confirmed + completed) / (bookings.length || 1) * 100) - 50;
  645 │     
  646 │     return {
  647 │       total: bookings.length,
  648 │       confirmed,
  649 │       pending,
  650 │       cancelled,
  651 │       completed,
  652 │       growth: Math.round(growth) // Arredonda para número inteiro
  653 │     };
  654 │   } catch (error) {
  655 │     console.error('Erro ao obter total de reservas:', error);
  656 │     return {
  657 │       total: 0,
  658 │       confirmed: 0,
  659 │       pending: 0, 
  660 │       cancelled: 0,
  661 │       completed: 0,
  662 │       growth: 0
  663 │     };
  664 │   }
  665 │ };
  666 │ 
  667 │ // Obter receita mensal
  668 │ export const getMonthlyRevenue = async () => {
  669 │   try {
  670 │     const bookings = await getDocuments<Booking>('bookings');
  671 │     
  672 │     // Filtrar reservas confirmadas e concluídas
  673 │     const validBookings = bookings.filter(b => 
  674 │       b.status === 'confirmed' || b.status === 'completed'
  675 │     );
  676 │     
  677 │     // Calcular receita total
  678 │     const totalRevenue = validBookings.reduce((acc, booking) => acc + booking.totalPrice, 0);
  679 │     
  680 │     // Agrupar receita por mês
  681 │     const revenueByMonth = validBookings.reduce((acc, booking) => {
  682 │       const date = booking.checkIn.toDate();
  683 │       const month = date.getMonth(); // 0-11
  684 │       const year = date.getFullYear();
  685 │       const key = `${year}-${month}`;
  686 │       
  687 │       if (!acc[key]) {
  688 │         acc[key] = 0;
  689 │       }
  690 │       acc[key] += booking.totalPrice;
  691 │       return acc;
  692 │     }, {} as Record<string, number>);
  693 │     
  694 │     // Converter para formato de array para gráfico
  695 │     const monthNames = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
  696 │     
  697 │     const currentDate = new Date();
  698 │     const currentMonth = currentDate.getMonth();
  699 │     const currentYear = currentDate.getFullYear();
  700 │     
  701 │     const revenueData = [];
  702 │     
  703 │     // Gerar dados dos últimos 12 meses
  704 │     for (let i = 0; i < 12; i++) {
  705 │       const month = (currentMonth - i + 12) % 12;
  706 │       const year = currentMonth - i < 0 ? currentYear - 1 : currentYear;
  707 │       const key = `${year}-${month}`;
  708 │       
  709 │       revenueData.unshift({
  710 │         month: monthNames[month],
  711 │         value: revenueByMonth[key] || 0
  712 │       });
  713 │     }
  714 │     
  715 │     // Calcular crescimento em relação ao mês anterior
  716 │     const lastMonthRevenue = revenueData[revenueData.length - 2]?.value || 0;
  717 │     const currentMonthRevenue = revenueData[revenueData.length - 1]?.value || 0;
  718 │     
  719 │     const growth = lastMonthRevenue ? ((currentMonthRevenue - lastMonthRevenue) / lastMonthRevenue) * 100 : 0;
  720 │     
  721 │     return {
  722 │       monthly: currentMonthRevenue,
  723 │       total: totalRevenue,
  724 │       growth: Math.round(growth),
  725 │       revenueData
  726 │     };
  727 │   } catch (error) {
  728 │     console.error('Erro ao obter receita mensal:', error);
  729 │     return {
  730 │       monthly: 0,
  731 │       total: 0,
  732 │       growth: 0,
  733 │       revenueData: []
  734 │     };
  735 │   }
  736 │ };
  737 │ 
  738 │ // Calcular taxa de ocupação
  739 │ export const getOccupancyRate = async () => {
  740 │   try {
  741 │     // Obter todos os quartos
  742 │     const rooms = await getDocuments<Room>('rooms');
  743 │     const totalRooms = rooms.length;
  744 │     
  745 │     if (totalRooms === 0) {
  746 │       return { rate: 0, growth: 0 };
  747 │     }
  748 │     
  749 │     // Obter todas as reservas
  750 │     const bookings = await getDocuments<Booking>('bookings');
  751 │     
  752 │     // Filtrar reservas confirmadas e concluídas para o mês atual
  753 │     const currentDate = new Date();
  754 │     const currentMonth = currentDate.getMonth();
  755 │     const currentYear = currentDate.getFullYear();
  756 │     
  757 │     const currentMonthBookings = bookings.filter(booking => {
  758 │       const checkInDate = booking.checkIn.toDate();
  759 │       return (
  760 │         (booking.status === 'confirmed' || booking.status === 'completed') &&
  761 │         checkInDate.getMonth() === currentMonth &&
  762 │         checkInDate.getFullYear() === currentYear
  763 │       );
  764 │     });
  765 │     
  766 │     // Calcular dias ocupados por quarto
  767 │     const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
  768 │     const totalPossibleRoomDays = totalRooms * daysInMonth;
  769 │     
  770 │     // Contar dias ocupados (simplificado - em produção seria mais complexo)
  771 │     let occupiedDays = 0;
  772 │     
  773 │     currentMonthBookings.forEach(booking => {
  774 │       const checkIn = booking.checkIn.toDate();
  775 │       const checkOut = booking.checkOut.toDate();
  776 │       
  777 │       // Ajustar datas para considerar apenas o mês atual
  778 │       const startDate = new Date(Math.max(
  779 │         checkIn.getTime(),
  780 │         new Date(currentYear, currentMonth, 1).getTime()
  781 │       ));
  782 │       const endDate = new Date(Math.min(
  783 │         checkOut.getTime(),
  784 │         new Date(currentYear, currentMonth + 1, 0).getTime()
  785 │       ));
  786 │       
  787 │       // Calcular dias entre datas (incluindo check-in, excluindo check-out)
  788 │       const days = Math.max(0, Math.floor((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)));
  789 │       occupiedDays += days;
  790 │     });
  791 │     
  792 │     const occupancyRate = (occupiedDays / totalPossibleRoomDays) * 100;
  793 │     
  794 │     // Simulação de crescimento (em produção, compararia com mês anterior)
  795 │     const growth = occupancyRate > 50 ? 5 : -3;
  796 │     
  797 │     return {
  798 │       rate: Math.round(occupancyRate),
  799 │       growth: Math.round(growth)
  800 │     };
  801 │   } catch (error) {
  802 │     console.error('Erro ao calcular taxa de ocupação:', error);
  803 │     return { rate: 0, growth: 0 };
  804 │   }
  805 │ };
  806 │ 
  807 │ // Obter reservas agrupadas por plataforma
  808 │ export const getBookingsByPlatform = async () => {
  809 │   try {
  810 │     const bookings = await getDocuments<Booking>('bookings');
  811 │     
  812 │     // Categorizar reservas por origem
  813 │     const platforms = [
  814 │       { 
  815 │         platform: "Booking.com", 
  816 │         color: "#003580", 
  817 │         icon: "Globe",
  818 │         bookings: []
  819 │       },
  820 │       { 
  821 │         platform: "Airbnb", 
  822 │         color: "#FF5A5F", 
  823 │         icon: "Heart",
  824 │         bookings: []
  825 │       },
  826 │       { 
  827 │         platform: "Direto", 
  828 │         color: "#4CAF50", 
  829 │         icon: "Home",
  830 │         bookings: []
  831 │       }
  832 │     ];
  833 │     
  834 │     // Para fins de demonstração, colocar todas as reservas como "Direto" por enquanto
  835 │     // Em produção, usaria um campo "platformOrigin" ou similar na tabela de reservas
  836 │     const platformIndex = 2; // Índice da plataforma "Direto"
  837 │     
  838 │     bookings.forEach(booking => {
  839 │       // Transformar para o formato esperado pelo componente
  840 │       const transformedBooking = {
  841 │         id: booking.id || '',
  842 │         guestName: booking.guestName,
  843 │         roomName: booking.roomName,
  844 │         checkIn: booking.checkIn.toDate().toLocaleDateString('pt-PT'),
  845 │         checkOut: booking.checkOut.toDate().toLocaleDateString('pt-PT'),
  846 │         status: booking.status,
  847 │         value: new Intl.NumberFormat('pt-PT', {
  848 │           style: 'currency',
  849 │           currency: 'EUR'
  850 │         }).format(booking.totalPrice)
  851 │       };
  852 │       
  853 │       // Adicionar à plataforma "Direto"
  854 │       (platforms[platformIndex] as any).bookings.push(transformedBooking);
  855 │     });
  856 │     
  857 │     return platforms;
  858 │   } catch (error) {
  859 │     console.error('Erro ao obter reservas por plataforma:', error);
  860 │     return [];
  861 │   }
  862 │ };
  863 │ 
  864 │ // Função para obter o preço de um quarto para uma data específica
  865 │ export const getRoomPriceForDate = async (roomId: string, date: Date): Promise<number> => {
  866 │   try {
  867 │     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  868 │     
  869 │     if (!roomDoc.exists()) {
  870 │       throw new Error("Quarto não encontrado");
  871 │     }
  872 │     
  873 │     const roomData = roomDoc.data() as Room;
  874 │     const basePrice = roomData.price;
  875 │     
  876 │     if (!roomData.seasonalPrices || roomData.seasonalPrices.length === 0) {
  877 │       return basePrice;
  878 │     }
  879 │     
  880 │     // Verificar se a data está dentro de algum período sazonal
  881 │     for (const seasonalPrice of roomData.seasonalPrices) {
  882 │       const startDate = new Date(seasonalPrice.startDate);
  883 │       const endDate = new Date(seasonalPrice.endDate);
  884 │       
  885 │       if (date >= startDate && date <= endDate) {
  886 │         return seasonalPrice.price;
  887 │       }
  888 │     }
  889 │     
  890 │     // Se não cair em nenhum período sazonal, retorna o preço base
  891 │     return basePrice;
  892 │   } catch (error) {
  893 │     console.error("Erro ao obter preço do quarto:", error);
  894 │     throw error;
  895 │   }
  896 │ }
  897 │ 
  898 │ // Função para calcular o preço total de uma estadia
  899 │ export const calculateStayPrice = async (
  900 │   roomId: string, 
  901 │   checkIn: Date, 
  902 │   checkOut: Date
  903 │ ): Promise<{
  904 │   totalPrice: number;
  905 │   nightlyPrices: { date: string; price: number }[];
  906 │   serviceFee: number;
  907 │   totalWithFee: number;
  908 │ }> => {
  909 │   try {
  910 │     console.log(`🔍 Iniciando cálculo de preço para estadia: ${checkIn.toISOString().split('T')[0]} até ${checkOut.toISOString().split('T')[0]}`);
  911 │     
  912 │     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  913 │     
  914 │     if (!roomDoc.exists()) {
  915 │       throw new Error("Quarto não encontrado");
  916 │     }
  917 │     
  918 │     const roomData = roomDoc.data() as Room;
  919 │     console.log(`📝 Dados do quarto ${roomId}:`, {
  920 │       nome: roomData.name,
  921 │       precoBase: roomData.price,
  922 │       taxaServico: roomData.serviceFeePct || 0,
  923 │       temPrecosSazonais: !!roomData.seasonalPrices?.length
  924 │     });
  925 │     
  926 │     const nightlyPrices: { date: string; price: number }[] = [];
  927 │     let totalPrice = 0;
  928 │     
  929 │     // Calcular o número de noites - corrigido para usar o método correto de cálculo
  930 │     // O número de noites é a diferença em dias (estadia = checkout - checkin)
  931 │     const noites = differenceInDays(checkOut, checkIn);
  932 │     console.log(`🗓️ Número de noites calculado: ${noites}`);
  933 │     
  934 │     if (noites <= 0) {
  935 │       console.error(`⚠️ Erro: número de noites inválido (${noites})`);
  936 │       throw new Error("Data de check-out deve ser posterior à data de check-in");
  937 │     }
  938 │     
  939 │     // Para cada noite, verificar o preço aplicável (preço base ou sazonal)
  940 │     // Começamos exatamente do dia de check-in
  941 │     const currentDate = new Date(checkIn);
  942 │     currentDate.setHours(0, 0, 0, 0); // Normalizar para meia-noite
  943 │     
  944 │     // Processamos cada dia de estadia (noite)
  945 │     console.log(`📊 Calculando preços por noite:`);
  946 │     for (let i = 0; i < noites; i++) {
  947 │       // Obtemos o preço para esta data
  948 │       const dateCopy = new Date(currentDate);
  949 │       const priceForDate = await getRoomPriceForDate(roomId, dateCopy);
  950 │       const dateString = dateCopy.toISOString().split('T')[0]; // YYYY-MM-DD
  951 │       
  952 │       console.log(`   - ${dateString}: €${priceForDate}`);
  953 │       
  954 │       nightlyPrices.push({
  955 │         date: dateString,
  956 │         price: priceForDate
  957 │       });
  958 │       
  959 │       totalPrice += priceForDate;
  960 │       
  961 │       // Avançamos para o próximo dia
  962 │       currentDate.setDate(currentDate.getDate() + 1);
  963 │     }
  964 │     
  965 │     // Verificação de segurança para o cálculo do totalPrice
  966 │     const manualTotal = nightlyPrices.reduce((sum, night) => sum + night.price, 0);
  967 │     if (Math.abs(totalPrice - manualTotal) > 1) {
  968 │       console.error(`⚠️ Discrepância detectada no cálculo do preço total!`);
  969 │       console.error(`   - Total calculado iterativamente: €${totalPrice}`);
  970 │       console.error(`   - Total calculado via reduce: €${manualTotal}`);
  971 │       console.error(`   - Usando o valor recalculado para segurança!`);
  972 │       totalPrice = manualTotal;
  973 │     }
  974 │     
  975 │     // Calcular taxa de serviço
  976 │     const serviceFee = (totalPrice * (roomData.serviceFeePct || 0)) / 100;
  977 │     const totalWithFee = totalPrice + serviceFee;
  978 │     
  979 │     console.log(`💰 Resumo do cálculo:`);
  980 │     console.log(`   - Total das diárias: €${totalPrice}`);
  981 │     console.log(`   - Taxa de serviço (${roomData.serviceFeePct || 0}%): €${serviceFee}`);
  982 │     console.log(`   - Total com taxas: €${totalWithFee}`);
  983 │     
  984 │     return {
  985 │       totalPrice,
  986 │       nightlyPrices,
  987 │       serviceFee,
  988 │       totalWithFee
  989 │     };
  990 │   } catch (error) {
  991 │     console.error("❌ Erro ao calcular preço da estadia:", error);
  992 │     throw error;
  993 │   }
  994 │ } 
  995 │ import { 
  996 │   collection, 
  997 │   getDocs, 
  998 │   getDoc, 
  999 │   doc, 
 1000 │   setDoc, 
 1001 │   addDoc, 
 1002 │   updateDoc, 
      ·   ────┬────
      ·       ╰── `updateDoc` redefined here
 1003 │   deleteDoc,
 1004 │   query,
 1005 │   where,
      ╰────

  × the name `deleteDoc` is defined multiple times
      ╭─[/home/runner/workspace/lib/firebase/firestore.ts:6:1]
    6 │   getDoc,
    7 │   getDocs,
    8 │   updateDoc,
    9 │   deleteDoc,
      ·   ────┬────
      ·       ╰── previous definition of `deleteDoc` here
   10 │   query,
   11 │   where,
   12 │   orderBy,
   13 │   limit,
   14 │   DocumentData,
   15 │   QueryConstraint,
   16 │   Timestamp,
   17 │   serverTimestamp
   18 │ } from 'firebase/firestore'
   19 │ import { db } from './config'
   20 │ import { Room, SeasonalPrice } from '@/lib/types'
   21 │ import { differenceInDays } from 'date-fns'
   22 │ 
   23 │ // Tipos de dados
   24 │ export interface Booking {
   25 │   id?: string
   26 │   userId?: string
   27 │   guestName: string
   28 │   guestEmail: string
   29 │   guestPhone: string
   30 │   roomId: string
   31 │   roomName: string
   32 │   checkIn: Timestamp
   33 │   checkOut: Timestamp
   34 │   adults: number
   35 │   children: number
   36 │   totalPrice: number
   37 │   status: 'pending' | 'confirmed' | 'cancelled' | 'completed'
   38 │   paymentStatus: 'pending' | 'paid' | 'refunded'
   39 │   specialRequests?: string
   40 │   createdAt?: Timestamp
   41 │   updatedAt?: Timestamp
   42 │ }
   43 │ 
   44 │ export interface Contact {
   45 │   id?: string
   46 │   name: string
   47 │   email: string
   48 │   phone?: string
   49 │   subject: string
   50 │   message: string
   51 │   status: 'new' | 'read' | 'replied'
   52 │   createdAt: Timestamp
   53 │   updatedAt?: Timestamp
   54 │   repliedAt?: Timestamp
   55 │   replyContent?: string
   56 │   reservationDetails?: {
   57 │     checkIn?: Timestamp
   58 │     checkOut?: Timestamp
   59 │     roomId?: string
   60 │     roomName?: string
   61 │     totalGuests?: number
   62 │     totalPrice?: number
   63 │   }
   64 │ }
   65 │ 
   66 │ // Funções genéricas para CRUD
   67 │ export const createDocument = async <T extends DocumentData>(
   68 │   collectionName: string,
   69 │   data: T
   70 │ ): Promise<string> => {
   71 │   const docRef = await addDoc(collection(db, collectionName), {
   72 │     ...data,
   73 │     createdAt: serverTimestamp(),
   74 │     updatedAt: serverTimestamp()
   75 │   })
   76 │   return docRef.id
   77 │ }
   78 │ 
   79 │ export const createDocumentWithId = async <T extends DocumentData>(
   80 │   collectionName: string,
   81 │   id: string,
   82 │   data: T
   83 │ ): Promise<void> => {
   84 │   await setDoc(doc(db, collectionName, id), {
   85 │     ...data,
   86 │     createdAt: serverTimestamp(),
   87 │     updatedAt: serverTimestamp()
   88 │   })
   89 │ }
   90 │ 
   91 │ export const getDocument = async <T>(
   92 │   collectionName: string,
   93 │   id: string
   94 │ ): Promise<T | null> => {
   95 │   const docRef = doc(db, collectionName, id)
   96 │   const docSnap = await getDoc(docRef)
   97 │   
   98 │   if (docSnap.exists()) {
   99 │     const data = docSnap.data();
  100 │     console.log("Dados brutos recuperados do Firestore para quarto:", id, data);
  101 │     
  102 │     if (data?.serviceFeePct !== undefined) {
  103 │       console.log("serviceFeePct antes da conversão:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
  104 │       // Garantir que serviceFeePct seja um número
  105 │       data.serviceFeePct = Number(data.serviceFeePct);
  106 │       console.log("serviceFeePct após conversão:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
  107 │     }
  108 │     
  109 │     return { id: docSnap.id, ...data } as T
  110 │   } else {
  111 │     return null
  112 │   }
  113 │ }
  114 │ 
  115 │ export const getDocuments = async <T>(
  116 │   collectionName: string,
  117 │   constraints: QueryConstraint[] = [],
  118 │   forceRefresh = false
  119 │ ): Promise<T[]> => {
  120 │   try {
  121 │     const collectionRef = collection(db, collectionName)
  122 │     const q = query(collectionRef, ...constraints)
  123 │     
  124 │     // Se forceRefresh for verdadeiro, adicionar opções que forçam uma nova consulta ao Firestore
  125 │     const querySnapshot = await getDocs(q)
  126 │     
  127 │     console.log(`Buscando documentos na coleção ${collectionName} - Força atualização: ${forceRefresh}`);
  128 │     
  129 │     return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }) as T)
  130 │   } catch (error) {
  131 │     console.error(`Erro ao buscar documentos da coleção ${collectionName}:`, error);
  132 │     return [];
  133 │   }
  134 │ }
  135 │ 
  136 │ export const updateDocument = async <T extends DocumentData>(
  137 │   collectionName: string,
  138 │   id: string,
  139 │   data: Partial<T>
  140 │ ): Promise<void> => {
  141 │   const docRef = doc(db, collectionName, id)
  142 │   await updateDoc(docRef, {
  143 │     ...data,
  144 │     updatedAt: serverTimestamp()
  145 │   })
  146 │ }
  147 │ 
  148 │ export const deleteDocument = async (
  149 │   collectionName: string,
  150 │   id: string
  151 │ ): Promise<boolean> => {
  152 │   const docRef = doc(db, collectionName, id)
  153 │   await deleteDoc(docRef)
  154 │   return true
  155 │ }
  156 │ 
  157 │ // Funções para gerenciar quartos
  158 │ export const getRooms = async (forceRefresh = false): Promise<Room[]> => {
  159 │   try {
  160 │     const constraints: QueryConstraint[] = []
  161 │     
  162 │     constraints.push(orderBy('name', 'asc'))
  163 │     
  164 │     const rooms = await getDocuments<Room>('rooms', constraints, forceRefresh)
  165 │     
  166 │     // Garantir que todos os campos necessários estejam presentes
  167 │     return rooms.map(room => {
  168 │       console.log(`Firebase - Quarto ${room.id} dados brutos:`, room);
  169 │       
  170 │       // Garantir que serviceFeePct seja um número
  171 │       const serviceFeePct = room.serviceFeePct !== undefined 
  172 │         ? Number(room.serviceFeePct) 
  173 │         : 10;
  174 │         
  175 │       console.log(`Firebase - Quarto ${room.id} serviceFeePct:`, {
  176 │         original: room.serviceFeePct,
  177 │         tipo: typeof room.serviceFeePct,
  178 │         convertido: serviceFeePct
  179 │       });
  180 │       
  181 │       return {
  182 │         id: room.id,
  183 │         name: room.name || '',
  184 │         type: room.type || 'standard',
  185 │         description: room.description || '',
  186 │         price: room.price || 0,
  187 │         capacity: room.capacity || 2,
  188 │         size: room.size || 0,
  189 │         available: room.available !== undefined ? room.available : true,
  190 │         serviceFeePct: serviceFeePct,
  191 │         images: room.images || [],
  192 │         amenities: room.amenities || [],
  193 │         additionalServices: room.additionalServices || [],
  194 │         highlights: room.highlights || [],
  195 │         createdAt: room.createdAt,
  196 │         updatedAt: room.updatedAt
  197 │       };
  198 │     });
  199 │   } catch (error) {
  200 │     console.error('Erro ao buscar quartos:', error)
  201 │     return []
  202 │   }
  203 │ }
  204 │ 
  205 │ export const getAvailableRooms = async (
  206 │   checkIn: Date,
  207 │   checkOut: Date
  208 │ ): Promise<Room[]> => {
  209 │   try {
  210 │     // Buscar todos os quartos que estão marcados como disponíveis em geral
  211 │     const constraints: QueryConstraint[] = [
  212 │       where('available', '==', true)
  213 │     ]
  214 │     
  215 │     const rooms = await getDocuments<Room>('rooms', constraints);
  216 │     
  217 │     // Filtrar os quartos que estão disponíveis nas datas específicas
  218 │     return filterAvailableRoomsByDate(rooms, checkIn, checkOut);
  219 │   } catch (error) {
  220 │     console.error('Erro ao buscar quartos disponíveis:', error)
  221 │     return []
  222 │   }
  223 │ }
  224 │ 
  225 │ // Função auxiliar para verificar disponibilidade entre datas
  226 │ export const filterAvailableRoomsByDate = (
  227 │   rooms: Room[],
  228 │   checkIn: Date,
  229 │   checkOut: Date
  230 │ ): Room[] => {
  231 │   // Converter checkIn e checkOut para ISO strings
  232 │   const dateStrings = getDatesInRange(checkIn, checkOut);
  233 │   
  234 │   return rooms.filter(room => {
  235 │     // Se não tiver controle de disponibilidade específico, considera disponível
  236 │     if (!room.availabilityDates) return true;
  237 │     
  238 │     // Verificar se alguma data no intervalo está indisponível
  239 │     return !dateStrings.some(dateStr => 
  240 │       room.availabilityDates?.[dateStr] === false
  241 │     );
  242 │   });
  243 │ };
  244 │ 
  245 │ // Função para obter disponibilidade de um quarto específico
  246 │ export const getRoomAvailability = async (
  247 │   roomId: string, 
  248 │   startDate: Date, 
  249 │   endDate: Date
  250 │ ): Promise<{[date: string]: boolean}> => {
  251 │   try {
  252 │     const room = await getRoomById(roomId);
  253 │     if (!room) throw new Error(`Quarto com ID ${roomId} não encontrado`);
  254 │     
  255 │     // Gerar datas no intervalo
  256 │     const dateStrings = getDatesInRange(startDate, endDate);
  257 │     
  258 │     // Se não tiver configuração de disponibilidade específica, assume tudo disponível
  259 │     if (!room.availabilityDates) {
  260 │       return dateStrings.reduce((acc, date) => {
  261 │         acc[date] = true;
  262 │         return acc;
  263 │       }, {} as {[date: string]: boolean});
  264 │     }
  265 │     
  266 │     // Preencher com os dados de disponibilidade existentes
  267 │     return dateStrings.reduce((acc, date) => {
  268 │       acc[date] = room.availabilityDates?.[date] !== false; // disponível por padrão se não estiver explicitamente indisponível
  269 │       return acc;
  270 │     }, {} as {[date: string]: boolean});
  271 │   } catch (error) {
  272 │     console.error(`Erro ao verificar disponibilidade do quarto ${roomId}:`, error);
  273 │     throw error;
  274 │   }
  275 │ };
  276 │ 
  277 │ // Função para atualizar disponibilidade de um quarto
  278 │ export const updateRoomAvailability = async (
  279 │   roomId: string,
  280 │   availabilityDates: {[date: string]: boolean}
  281 │ ): Promise<boolean> => {
  282 │   try {
  283 │     await updateDocument('rooms', roomId, {
  284 │       availabilityDates,
  285 │       updatedAt: serverTimestamp()
  286 │     });
  287 │     return true;
  288 │   } catch (error) {
  289 │     console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  290 │     return false;
  291 │   }
  292 │ };
  293 │ 
  294 │ // Função auxiliar para gerar array de strings de data entre um intervalo
  295 │ export const getDatesInRange = (startDate: Date, endDate: Date): string[] => {
  296 │   const dates: string[] = [];
  297 │   const currentDate = new Date(startDate);
  298 │   
  299 │   // Normalizar para meia-noite no fuso horário local
  300 │   currentDate.setHours(0, 0, 0, 0);
  301 │   const endDateNormalized = new Date(endDate);
  302 │   endDateNormalized.setHours(0, 0, 0, 0);
  303 │   
  304 │   // Adicionar cada data no intervalo EXCETO o dia de checkout
  305 │   // Usando < em vez de <= para não incluir o dia de checkout
  306 │   while (currentDate < endDateNormalized) {
  307 │     dates.push(currentDate.toISOString().split('T')[0]); // Formato YYYY-MM-DD
  308 │     currentDate.setDate(currentDate.getDate() + 1);
  309 │   }
  310 │   
  311 │   return dates;
  312 │ };
  313 │ 
  314 │ export const getRoomById = async (id: string): Promise<Room | null> => {
  315 │   try {
  316 │     const room = await getDocument<Room>('rooms', id);
  317 │     
  318 │     if (!room) return null;
  319 │     
  320 │     console.log(`Firebase - getRoomById ${id} dados brutos:`, room);
  321 │     
  322 │     // Log específico para serviceFeePct
  323 │     console.log(`serviceFeePct no Firestore:`, room.serviceFeePct);
  324 │     
  325 │     // Garantir que todos os campos necessários estejam presentes
  326 │     return {
  327 │       ...room,
  328 │       name: room.name || '',
  329 │       type: room.type || 'standard',
  330 │       description: room.description || '',
  331 │       price: room.price || 0,
  332 │       capacity: room.capacity || 2,
  333 │       size: room.size || 0,
  334 │       available: room.available !== undefined ? room.available : true,
  335 │       serviceFeePct: room.serviceFeePct !== undefined ? room.serviceFeePct : 10,
  336 │       images: room.images || [],
  337 │       amenities: room.amenities || [],
  338 │       additionalServices: room.additionalServices || [],
  339 │       highlights: room.highlights || []
  340 │     };
  341 │   } catch (error) {
  342 │     console.error(`Erro ao buscar quarto com ID ${id}:`, error);
  343 │     return null;
  344 │   }
  345 │ }
  346 │ 
  347 │ export const createRoom = async (roomData: Omit<Room, 'id' | 'createdAt' | 'updatedAt'>): Promise<Room> => {
  348 │   try {
  349 │     console.log("createRoom - Dados recebidos:", roomData);
  350 │     
  351 │     const roomWithTimestamps = {
  352 │       ...roomData,
  353 │       available: roomData.available !== undefined ? roomData.available : true,
  354 │       featured: roomData.featured || false,
  355 │       amenities: roomData.amenities || [],
  356 │       additionalServices: roomData.additionalServices || [],
  357 │       highlights: roomData.highlights || [],
  358 │       createdAt: serverTimestamp(),
  359 │       updatedAt: serverTimestamp()
  360 │     }
  361 │     
  362 │     console.log("createRoom - Dados a serem salvos:", roomWithTimestamps);
  363 │     
  364 │     const id = await createDocument('rooms', roomWithTimestamps)
  365 │     
  366 │     return {
  367 │       id,
  368 │       ...roomData,
  369 │       amenities: roomData.amenities || [],
  370 │       additionalServices: roomData.additionalServices || [],
  371 │       highlights: roomData.highlights || [],
  372 │       createdAt: Timestamp.now(),
  373 │       updatedAt: Timestamp.now()
  374 │     }
  375 │   } catch (error) {
  376 │     console.error('Erro ao criar quarto:', error)
  377 │     throw error
  378 │   }
  379 │ }
  380 │ 
  381 │ export const updateRoom = async (id: string, roomData: Partial<Omit<Room, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Room> => {
  382 │   try {
  383 │     console.log(`updateRoom - ID: ${id}, Dados recebidos:`, roomData);
  384 │     
  385 │     // Garantir que estamos lidando explicitamente com o serviceFeePct se ele for 0
  386 │     if (roomData.serviceFeePct === 0) {
  387 │       console.log("updateRoom - Detectado serviceFeePct com valor 0, salvando explicitamente.", roomData.serviceFeePct);
  388 │     }
  389 │     
  390 │     // Adicionar timestamp de atualização
  391 │     const roomWithTimestamp = {
  392 │       ...roomData,
  393 │       amenities: roomData.amenities || [],
  394 │       additionalServices: roomData.additionalServices || [],
  395 │       highlights: roomData.highlights || [],
  396 │       updatedAt: serverTimestamp()
  397 │     }
  398 │     
  399 │     console.log(`updateRoom - Dados a serem salvos:`, roomWithTimestamp);
  400 │     
  401 │     await updateDocument('rooms', id, roomWithTimestamp)
  402 │     
  403 │     const updatedRoom = await getRoomById(id)
  404 │     if (!updatedRoom) {
  405 │       throw new Error(`Quarto com ID ${id} não encontrado após atualização`)
  406 │     }
  407 │     
  408 │     return updatedRoom
  409 │   } catch (error) {
  410 │     console.error('Erro ao atualizar quarto:', error)
  411 │     throw error
  412 │   }
  413 │ }
  414 │ 
  415 │ export const deleteRoom = async (id: string): Promise<boolean> => {
  416 │   return await deleteDocument('rooms', id)
  417 │ }
  418 │ 
  419 │ // Funções específicas para reservas
  420 │ export const createBooking = async (bookingData: any) => {
  421 │   try {
  422 │     const bookingsCollection = collection(db, 'bookings');
  423 │     const docRef = await addDoc(bookingsCollection, bookingData);
  424 │     
  425 │     // CORREÇÃO: Não bloquear a data no momento da criação da reserva
  426 │     // O bloqueio será feito apenas quando o pagamento for confirmado
  427 │     // através da função updateBookingStatus
  428 │     
  429 │     return docRef;
  430 │   } catch (error) {
  431 │     console.error('Erro ao criar reserva:', error);
  432 │     throw error;
  433 │   }
  434 │ };
  435 │ 
  436 │ // Nova função para atualizar status da reserva e bloquear as datas da estadia
  437 │ export const updateBookingStatus = async (
  438 │   bookingId: string, 
  439 │   newStatus: 'pending' | 'confirmed' | 'cancelled' | 'completed',
  440 │   newPaymentStatus: 'pending' | 'paid' | 'refunded'
  441 │ ): Promise<boolean> => {
  442 │   try {
  443 │     // Referência ao documento da reserva
  444 │     const bookingRef = doc(db, 'bookings', bookingId);
  445 │     const bookingSnap = await getDoc(bookingRef);
  446 │     
  447 │     if (!bookingSnap.exists()) {
  448 │       console.error(`Booking ${bookingId} não existe ao atualizar status`);
  449 │       return false;
  450 │     }
  451 │     
  452 │     const bookingData = bookingSnap.data();
  453 │     
  454 │     // Atualizar o status da reserva
  455 │     await updateDoc(bookingRef, {
  456 │       status: newStatus,
  457 │       paymentStatus: newPaymentStatus,
  458 │       updatedAt: serverTimestamp(),
  459 │       ...(newStatus === 'confirmed' && { confirmedAt: serverTimestamp() })
  460 │     });
  461 │     
  462 │     // Se a reserva está sendo confirmada, precisamos bloquear as datas
  463 │     if (newStatus === 'confirmed') {
  464 │       console.log(`Atualizando disponibilidade para reserva confirmada: ${bookingId}`);
  465 │       
  466 │       // Recuperar datas de check-in e check-out
  467 │       const checkIn = bookingData.checkIn.toDate();
  468 │       const checkOut = bookingData.checkOut.toDate();
  469 │       const roomId = bookingData.roomId;
  470 │       
  471 │       // Obter todas as datas entre check-in e check-out
  472 │       const dates: Date[] = [];
  473 │       const currentDate = new Date(checkIn);
  474 │       
  475 │       while (currentDate < checkOut) {
  476 │         dates.push(new Date(currentDate));
  477 │         currentDate.setDate(currentDate.getDate() + 1);
  478 │       }
  479 │       
  480 │       console.log(`Bloqueando ${dates.length} dias para quarto ${roomId}`);
  481 │       
  482 │       // Atualizar disponibilidade para cada data
  483 │       const availabilityUpdates: {[date: string]: boolean} = {};
  484 │       
  485 │       dates.forEach(date => {
  486 │         const dateString = date.toISOString().split('T')[0]; // formato YYYY-MM-DD
  487 │         availabilityUpdates[dateString] = false; // false significa indisponível
  488 │       });
  489 │       
  490 │       // Atualizar disponibilidade do quarto
  491 │       if (Object.keys(availabilityUpdates).length > 0) {
  492 │         try {
  493 │           // Obter o documento do quarto
  494 │           const roomRef = doc(db, 'rooms', roomId);
  495 │           const roomSnap = await getDoc(roomRef);
  496 │           
  497 │           if (roomSnap.exists()) {
  498 │             const roomData = roomSnap.data();
  499 │             const currentAvailability = roomData.availabilityDates || {};
  500 │             
  501 │             // Mesclar a disponibilidade atual com as novas atualizações
  502 │             const updatedAvailability = {
  503 │               ...currentAvailability,
  504 │               ...availabilityUpdates
  505 │             };
  506 │             
  507 │             // Atualizar o documento do quarto
  508 │             await updateDoc(roomRef, {
  509 │               availabilityDates: updatedAvailability,
  510 │               updatedAt: serverTimestamp()
  511 │             });
  512 │             
  513 │             console.log(`Disponibilidade atualizada com sucesso para quarto ${roomId}`);
  514 │             
  515 │             // Criar log da reserva
  516 │             await addDoc(collection(db, 'bookingLogs'), {
  517 │               bookingId,
  518 │               roomId,
  519 │               action: 'status_updated',
  520 │               previousStatus: bookingData.status,
  521 │               newStatus,
  522 │               previousPaymentStatus: bookingData.paymentStatus,
  523 │               newPaymentStatus,
  524 │               datesBlocked: Object.keys(availabilityUpdates),
  525 │               timestamp: serverTimestamp(),
  526 │               userId: bookingData.userId || 'system'
  527 │             });
  528 │           } else {
  529 │             console.error(`Quarto ${roomId} não encontrado ao atualizar disponibilidade`);
  530 │           }
  531 │         } catch (error) {
  532 │           console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  533 │         }
  534 │       }
  535 │     }
  536 │     
  537 │     return true;
  538 │   } catch (error) {
  539 │     console.error(`Erro ao atualizar status da reserva ${bookingId}:`, error);
  540 │     return false;
  541 │   }
  542 │ }
  543 │ 
  544 │ export const getUserBookings = async (userId: string): Promise<Booking[]> => {
  545 │   return getDocuments<Booking>('bookings', [
  546 │     where('userId', '==', userId),
  547 │     orderBy('createdAt', 'desc')
  548 │   ])
  549 │ }
  550 │ 
  551 │ export const getRecentBookings = async (count = 5): Promise<Booking[]> => {
  552 │   return getDocuments<Booking>('bookings', [
  553 │     orderBy('createdAt', 'desc'),
  554 │     limit(count)
  555 │   ])
  556 │ }
  557 │ 
  558 │ export const getRoomBookings = async (roomId: string): Promise<Booking[]> => {
  559 │   try {
  560 │     const constraints: QueryConstraint[] = [
  561 │       where('roomId', '==', roomId),
  562 │       orderBy('checkIn', 'asc')
  563 │     ];
  564 │     
  565 │     return await getDocuments<Booking>('bookings', constraints);
  566 │   } catch (error) {
  567 │     console.error(`Erro ao buscar reservas do quarto ${roomId}:`, error);
  568 │     return [];
  569 │   }
  570 │ };
  571 │ 
  572 │ // Funções específicas para contatos
  573 │ export const createContactMessage = async (contactData: Contact) => {
  574 │   try {
  575 │     const contactsCollection = collection(db, 'contacts')
  576 │     
  577 │     // Garantir que o status seja 'new' para novos contatos
  578 │     const contactWithDefaults = {
  579 │       ...contactData,
  580 │       status: contactData.status || 'new',
  581 │       createdAt: contactData.createdAt || Timestamp.now()
  582 │     }
  583 │     
  584 │     // Se tiver detalhes de reserva, adicionar metadados
  585 │     if (contactWithDefaults.reservationDetails) {
  586 │       // Ajustar subject para indicar que é relacionado a reserva
  587 │       if (!contactWithDefaults.subject.includes('Reserva')) {
  588 │         contactWithDefaults.subject = `Reserva: ${contactWithDefaults.subject}`;
  589 │       }
  590 │     }
  591 │     
  592 │     const docRef = await addDoc(contactsCollection, contactWithDefaults)
  593 │     return docRef
  594 │   } catch (error) {
  595 │     console.error('Erro ao criar mensagem de contato:', error)
  596 │     throw error
  597 │   }
  598 │ }
  599 │ 
  600 │ export const getNewContactMessages = async (): Promise<Contact[]> => {
  601 │   return getDocuments<Contact>('contacts', [
  602 │     where('status', '==', 'new'),
  603 │     orderBy('createdAt', 'desc')
  604 │   ])
  605 │ }
  606 │ 
  607 │ // Funções para Dashboard com dados reais
  608 │ 
  609 │ export const getDashboardStats = async () => {
  610 │   try {
  611 │     const [totalBookings, totalRevenue, occupancyRate, bookingsByPlatform] = await Promise.all([
  612 │       getTotalBookings(),
  613 │       getMonthlyRevenue(),
  614 │       getOccupancyRate(),
  615 │       getBookingsByPlatform()
  616 │     ]);
  617 │ 
  618 │     return {
  619 │       totalBookings,
  620 │       totalRevenue,
  621 │       occupancyRate,
  622 │       bookingsByPlatform
  623 │     };
  624 │   } catch (error) {
  625 │     console.error('Erro ao obter estatísticas do dashboard:', error);
  626 │     throw error;
  627 │   }
  628 │ };
  629 │ 
  630 │ // Obter total de reservas
  631 │ export const getTotalBookings = async () => {
  632 │   try {
  633 │     // Obter todas as reservas
  634 │     const bookings = await getDocuments<Booking>('bookings');
  635 │     
  636 │     // Contar reservas por status
  637 │     const confirmed = bookings.filter(b => b.status === 'confirmed').length;
  638 │     const pending = bookings.filter(b => b.status === 'pending').length;
  639 │     const cancelled = bookings.filter(b => b.status === 'cancelled').length;
  640 │     const completed = bookings.filter(b => b.status === 'completed').length;
  641 │     
  642 │     // Calcular crescimento em relação ao mês anterior (simulado por enquanto)
  643 │     // Em uma implementação real, você compararia com dados do mês anterior
  644 │     const growth = ((confirmed + completed) / (bookings.length || 1) * 100) - 50;
  645 │     
  646 │     return {
  647 │       total: bookings.length,
  648 │       confirmed,
  649 │       pending,
  650 │       cancelled,
  651 │       completed,
  652 │       growth: Math.round(growth) // Arredonda para número inteiro
  653 │     };
  654 │   } catch (error) {
  655 │     console.error('Erro ao obter total de reservas:', error);
  656 │     return {
  657 │       total: 0,
  658 │       confirmed: 0,
  659 │       pending: 0, 
  660 │       cancelled: 0,
  661 │       completed: 0,
  662 │       growth: 0
  663 │     };
  664 │   }
  665 │ };
  666 │ 
  667 │ // Obter receita mensal
  668 │ export const getMonthlyRevenue = async () => {
  669 │   try {
  670 │     const bookings = await getDocuments<Booking>('bookings');
  671 │     
  672 │     // Filtrar reservas confirmadas e concluídas
  673 │     const validBookings = bookings.filter(b => 
  674 │       b.status === 'confirmed' || b.status === 'completed'
  675 │     );
  676 │     
  677 │     // Calcular receita total
  678 │     const totalRevenue = validBookings.reduce((acc, booking) => acc + booking.totalPrice, 0);
  679 │     
  680 │     // Agrupar receita por mês
  681 │     const revenueByMonth = validBookings.reduce((acc, booking) => {
  682 │       const date = booking.checkIn.toDate();
  683 │       const month = date.getMonth(); // 0-11
  684 │       const year = date.getFullYear();
  685 │       const key = `${year}-${month}`;
  686 │       
  687 │       if (!acc[key]) {
  688 │         acc[key] = 0;
  689 │       }
  690 │       acc[key] += booking.totalPrice;
  691 │       return acc;
  692 │     }, {} as Record<string, number>);
  693 │     
  694 │     // Converter para formato de array para gráfico
  695 │     const monthNames = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
  696 │     
  697 │     const currentDate = new Date();
  698 │     const currentMonth = currentDate.getMonth();
  699 │     const currentYear = currentDate.getFullYear();
  700 │     
  701 │     const revenueData = [];
  702 │     
  703 │     // Gerar dados dos últimos 12 meses
  704 │     for (let i = 0; i < 12; i++) {
  705 │       const month = (currentMonth - i + 12) % 12;
  706 │       const year = currentMonth - i < 0 ? currentYear - 1 : currentYear;
  707 │       const key = `${year}-${month}`;
  708 │       
  709 │       revenueData.unshift({
  710 │         month: monthNames[month],
  711 │         value: revenueByMonth[key] || 0
  712 │       });
  713 │     }
  714 │     
  715 │     // Calcular crescimento em relação ao mês anterior
  716 │     const lastMonthRevenue = revenueData[revenueData.length - 2]?.value || 0;
  717 │     const currentMonthRevenue = revenueData[revenueData.length - 1]?.value || 0;
  718 │     
  719 │     const growth = lastMonthRevenue ? ((currentMonthRevenue - lastMonthRevenue) / lastMonthRevenue) * 100 : 0;
  720 │     
  721 │     return {
  722 │       monthly: currentMonthRevenue,
  723 │       total: totalRevenue,
  724 │       growth: Math.round(growth),
  725 │       revenueData
  726 │     };
  727 │   } catch (error) {
  728 │     console.error('Erro ao obter receita mensal:', error);
  729 │     return {
  730 │       monthly: 0,
  731 │       total: 0,
  732 │       growth: 0,
  733 │       revenueData: []
  734 │     };
  735 │   }
  736 │ };
  737 │ 
  738 │ // Calcular taxa de ocupação
  739 │ export const getOccupancyRate = async () => {
  740 │   try {
  741 │     // Obter todos os quartos
  742 │     const rooms = await getDocuments<Room>('rooms');
  743 │     const totalRooms = rooms.length;
  744 │     
  745 │     if (totalRooms === 0) {
  746 │       return { rate: 0, growth: 0 };
  747 │     }
  748 │     
  749 │     // Obter todas as reservas
  750 │     const bookings = await getDocuments<Booking>('bookings');
  751 │     
  752 │     // Filtrar reservas confirmadas e concluídas para o mês atual
  753 │     const currentDate = new Date();
  754 │     const currentMonth = currentDate.getMonth();
  755 │     const currentYear = currentDate.getFullYear();
  756 │     
  757 │     const currentMonthBookings = bookings.filter(booking => {
  758 │       const checkInDate = booking.checkIn.toDate();
  759 │       return (
  760 │         (booking.status === 'confirmed' || booking.status === 'completed') &&
  761 │         checkInDate.getMonth() === currentMonth &&
  762 │         checkInDate.getFullYear() === currentYear
  763 │       );
  764 │     });
  765 │     
  766 │     // Calcular dias ocupados por quarto
  767 │     const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
  768 │     const totalPossibleRoomDays = totalRooms * daysInMonth;
  769 │     
  770 │     // Contar dias ocupados (simplificado - em produção seria mais complexo)
  771 │     let occupiedDays = 0;
  772 │     
  773 │     currentMonthBookings.forEach(booking => {
  774 │       const checkIn = booking.checkIn.toDate();
  775 │       const checkOut = booking.checkOut.toDate();
  776 │       
  777 │       // Ajustar datas para considerar apenas o mês atual
  778 │       const startDate = new Date(Math.max(
  779 │         checkIn.getTime(),
  780 │         new Date(currentYear, currentMonth, 1).getTime()
  781 │       ));
  782 │       const endDate = new Date(Math.min(
  783 │         checkOut.getTime(),
  784 │         new Date(currentYear, currentMonth + 1, 0).getTime()
  785 │       ));
  786 │       
  787 │       // Calcular dias entre datas (incluindo check-in, excluindo check-out)
  788 │       const days = Math.max(0, Math.floor((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)));
  789 │       occupiedDays += days;
  790 │     });
  791 │     
  792 │     const occupancyRate = (occupiedDays / totalPossibleRoomDays) * 100;
  793 │     
  794 │     // Simulação de crescimento (em produção, compararia com mês anterior)
  795 │     const growth = occupancyRate > 50 ? 5 : -3;
  796 │     
  797 │     return {
  798 │       rate: Math.round(occupancyRate),
  799 │       growth: Math.round(growth)
  800 │     };
  801 │   } catch (error) {
  802 │     console.error('Erro ao calcular taxa de ocupação:', error);
  803 │     return { rate: 0, growth: 0 };
  804 │   }
  805 │ };
  806 │ 
  807 │ // Obter reservas agrupadas por plataforma
  808 │ export const getBookingsByPlatform = async () => {
  809 │   try {
  810 │     const bookings = await getDocuments<Booking>('bookings');
  811 │     
  812 │     // Categorizar reservas por origem
  813 │     const platforms = [
  814 │       { 
  815 │         platform: "Booking.com", 
  816 │         color: "#003580", 
  817 │         icon: "Globe",
  818 │         bookings: []
  819 │       },
  820 │       { 
  821 │         platform: "Airbnb", 
  822 │         color: "#FF5A5F", 
  823 │         icon: "Heart",
  824 │         bookings: []
  825 │       },
  826 │       { 
  827 │         platform: "Direto", 
  828 │         color: "#4CAF50", 
  829 │         icon: "Home",
  830 │         bookings: []
  831 │       }
  832 │     ];
  833 │     
  834 │     // Para fins de demonstração, colocar todas as reservas como "Direto" por enquanto
  835 │     // Em produção, usaria um campo "platformOrigin" ou similar na tabela de reservas
  836 │     const platformIndex = 2; // Índice da plataforma "Direto"
  837 │     
  838 │     bookings.forEach(booking => {
  839 │       // Transformar para o formato esperado pelo componente
  840 │       const transformedBooking = {
  841 │         id: booking.id || '',
  842 │         guestName: booking.guestName,
  843 │         roomName: booking.roomName,
  844 │         checkIn: booking.checkIn.toDate().toLocaleDateString('pt-PT'),
  845 │         checkOut: booking.checkOut.toDate().toLocaleDateString('pt-PT'),
  846 │         status: booking.status,
  847 │         value: new Intl.NumberFormat('pt-PT', {
  848 │           style: 'currency',
  849 │           currency: 'EUR'
  850 │         }).format(booking.totalPrice)
  851 │       };
  852 │       
  853 │       // Adicionar à plataforma "Direto"
  854 │       (platforms[platformIndex] as any).bookings.push(transformedBooking);
  855 │     });
  856 │     
  857 │     return platforms;
  858 │   } catch (error) {
  859 │     console.error('Erro ao obter reservas por plataforma:', error);
  860 │     return [];
  861 │   }
  862 │ };
  863 │ 
  864 │ // Função para obter o preço de um quarto para uma data específica
  865 │ export const getRoomPriceForDate = async (roomId: string, date: Date): Promise<number> => {
  866 │   try {
  867 │     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  868 │     
  869 │     if (!roomDoc.exists()) {
  870 │       throw new Error("Quarto não encontrado");
  871 │     }
  872 │     
  873 │     const roomData = roomDoc.data() as Room;
  874 │     const basePrice = roomData.price;
  875 │     
  876 │     if (!roomData.seasonalPrices || roomData.seasonalPrices.length === 0) {
  877 │       return basePrice;
  878 │     }
  879 │     
  880 │     // Verificar se a data está dentro de algum período sazonal
  881 │     for (const seasonalPrice of roomData.seasonalPrices) {
  882 │       const startDate = new Date(seasonalPrice.startDate);
  883 │       const endDate = new Date(seasonalPrice.endDate);
  884 │       
  885 │       if (date >= startDate && date <= endDate) {
  886 │         return seasonalPrice.price;
  887 │       }
  888 │     }
  889 │     
  890 │     // Se não cair em nenhum período sazonal, retorna o preço base
  891 │     return basePrice;
  892 │   } catch (error) {
  893 │     console.error("Erro ao obter preço do quarto:", error);
  894 │     throw error;
  895 │   }
  896 │ }
  897 │ 
  898 │ // Função para calcular o preço total de uma estadia
  899 │ export const calculateStayPrice = async (
  900 │   roomId: string, 
  901 │   checkIn: Date, 
  902 │   checkOut: Date
  903 │ ): Promise<{
  904 │   totalPrice: number;
  905 │   nightlyPrices: { date: string; price: number }[];
  906 │   serviceFee: number;
  907 │   totalWithFee: number;
  908 │ }> => {
  909 │   try {
  910 │     console.log(`🔍 Iniciando cálculo de preço para estadia: ${checkIn.toISOString().split('T')[0]} até ${checkOut.toISOString().split('T')[0]}`);
  911 │     
  912 │     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  913 │     
  914 │     if (!roomDoc.exists()) {
  915 │       throw new Error("Quarto não encontrado");
  916 │     }
  917 │     
  918 │     const roomData = roomDoc.data() as Room;
  919 │     console.log(`📝 Dados do quarto ${roomId}:`, {
  920 │       nome: roomData.name,
  921 │       precoBase: roomData.price,
  922 │       taxaServico: roomData.serviceFeePct || 0,
  923 │       temPrecosSazonais: !!roomData.seasonalPrices?.length
  924 │     });
  925 │     
  926 │     const nightlyPrices: { date: string; price: number }[] = [];
  927 │     let totalPrice = 0;
  928 │     
  929 │     // Calcular o número de noites - corrigido para usar o método correto de cálculo
  930 │     // O número de noites é a diferença em dias (estadia = checkout - checkin)
  931 │     const noites = differenceInDays(checkOut, checkIn);
  932 │     console.log(`🗓️ Número de noites calculado: ${noites}`);
  933 │     
  934 │     if (noites <= 0) {
  935 │       console.error(`⚠️ Erro: número de noites inválido (${noites})`);
  936 │       throw new Error("Data de check-out deve ser posterior à data de check-in");
  937 │     }
  938 │     
  939 │     // Para cada noite, verificar o preço aplicável (preço base ou sazonal)
  940 │     // Começamos exatamente do dia de check-in
  941 │     const currentDate = new Date(checkIn);
  942 │     currentDate.setHours(0, 0, 0, 0); // Normalizar para meia-noite
  943 │     
  944 │     // Processamos cada dia de estadia (noite)
  945 │     console.log(`📊 Calculando preços por noite:`);
  946 │     for (let i = 0; i < noites; i++) {
  947 │       // Obtemos o preço para esta data
  948 │       const dateCopy = new Date(currentDate);
  949 │       const priceForDate = await getRoomPriceForDate(roomId, dateCopy);
  950 │       const dateString = dateCopy.toISOString().split('T')[0]; // YYYY-MM-DD
  951 │       
  952 │       console.log(`   - ${dateString}: €${priceForDate}`);
  953 │       
  954 │       nightlyPrices.push({
  955 │         date: dateString,
  956 │         price: priceForDate
  957 │       });
  958 │       
  959 │       totalPrice += priceForDate;
  960 │       
  961 │       // Avançamos para o próximo dia
  962 │       currentDate.setDate(currentDate.getDate() + 1);
  963 │     }
  964 │     
  965 │     // Verificação de segurança para o cálculo do totalPrice
  966 │     const manualTotal = nightlyPrices.reduce((sum, night) => sum + night.price, 0);
  967 │     if (Math.abs(totalPrice - manualTotal) > 1) {
  968 │       console.error(`⚠️ Discrepância detectada no cálculo do preço total!`);
  969 │       console.error(`   - Total calculado iterativamente: €${totalPrice}`);
  970 │       console.error(`   - Total calculado via reduce: €${manualTotal}`);
  971 │       console.error(`   - Usando o valor recalculado para segurança!`);
  972 │       totalPrice = manualTotal;
  973 │     }
  974 │     
  975 │     // Calcular taxa de serviço
  976 │     const serviceFee = (totalPrice * (roomData.serviceFeePct || 0)) / 100;
  977 │     const totalWithFee = totalPrice + serviceFee;
  978 │     
  979 │     console.log(`💰 Resumo do cálculo:`);
  980 │     console.log(`   - Total das diárias: €${totalPrice}`);
  981 │     console.log(`   - Taxa de serviço (${roomData.serviceFeePct || 0}%): €${serviceFee}`);
  982 │     console.log(`   - Total com taxas: €${totalWithFee}`);
  983 │     
  984 │     return {
  985 │       totalPrice,
  986 │       nightlyPrices,
  987 │       serviceFee,
  988 │       totalWithFee
  989 │     };
  990 │   } catch (error) {
  991 │     console.error("❌ Erro ao calcular preço da estadia:", error);
  992 │     throw error;
  993 │   }
  994 │ } 
  995 │ import { 
  996 │   collection, 
  997 │   getDocs, 
  998 │   getDoc, 
  999 │   doc, 
 1000 │   setDoc, 
 1001 │   addDoc, 
 1002 │   updateDoc, 
 1003 │   deleteDoc,
      ·   ────┬────
      ·       ╰── `deleteDoc` redefined here
 1004 │   query,
 1005 │   where,
 1006 │   orderBy,
      ╰────

  × the name `query` is defined multiple times
      ╭─[/home/runner/workspace/lib/firebase/firestore.ts:7:1]
    7 │   getDocs,
    8 │   updateDoc,
    9 │   deleteDoc,
   10 │   query,
      ·   ──┬──
      ·     ╰── previous definition of `query` here
   11 │   where,
   12 │   orderBy,
   13 │   limit,
   14 │   DocumentData,
   15 │   QueryConstraint,
   16 │   Timestamp,
   17 │   serverTimestamp
   18 │ } from 'firebase/firestore'
   19 │ import { db } from './config'
   20 │ import { Room, SeasonalPrice } from '@/lib/types'
   21 │ import { differenceInDays } from 'date-fns'
   22 │ 
   23 │ // Tipos de dados
   24 │ export interface Booking {
   25 │   id?: string
   26 │   userId?: string
   27 │   guestName: string
   28 │   guestEmail: string
   29 │   guestPhone: string
   30 │   roomId: string
   31 │   roomName: string
   32 │   checkIn: Timestamp
   33 │   checkOut: Timestamp
   34 │   adults: number
   35 │   children: number
   36 │   totalPrice: number
   37 │   status: 'pending' | 'confirmed' | 'cancelled' | 'completed'
   38 │   paymentStatus: 'pending' | 'paid' | 'refunded'
   39 │   specialRequests?: string
   40 │   createdAt?: Timestamp
   41 │   updatedAt?: Timestamp
   42 │ }
   43 │ 
   44 │ export interface Contact {
   45 │   id?: string
   46 │   name: string
   47 │   email: string
   48 │   phone?: string
   49 │   subject: string
   50 │   message: string
   51 │   status: 'new' | 'read' | 'replied'
   52 │   createdAt: Timestamp
   53 │   updatedAt?: Timestamp
   54 │   repliedAt?: Timestamp
   55 │   replyContent?: string
   56 │   reservationDetails?: {
   57 │     checkIn?: Timestamp
   58 │     checkOut?: Timestamp
   59 │     roomId?: string
   60 │     roomName?: string
   61 │     totalGuests?: number
   62 │     totalPrice?: number
   63 │   }
   64 │ }
   65 │ 
   66 │ // Funções genéricas para CRUD
   67 │ export const createDocument = async <T extends DocumentData>(
   68 │   collectionName: string,
   69 │   data: T
   70 │ ): Promise<string> => {
   71 │   const docRef = await addDoc(collection(db, collectionName), {
   72 │     ...data,
   73 │     createdAt: serverTimestamp(),
   74 │     updatedAt: serverTimestamp()
   75 │   })
   76 │   return docRef.id
   77 │ }
   78 │ 
   79 │ export const createDocumentWithId = async <T extends DocumentData>(
   80 │   collectionName: string,
   81 │   id: string,
   82 │   data: T
   83 │ ): Promise<void> => {
   84 │   await setDoc(doc(db, collectionName, id), {
   85 │     ...data,
   86 │     createdAt: serverTimestamp(),
   87 │     updatedAt: serverTimestamp()
   88 │   })
   89 │ }
   90 │ 
   91 │ export const getDocument = async <T>(
   92 │   collectionName: string,
   93 │   id: string
   94 │ ): Promise<T | null> => {
   95 │   const docRef = doc(db, collectionName, id)
   96 │   const docSnap = await getDoc(docRef)
   97 │   
   98 │   if (docSnap.exists()) {
   99 │     const data = docSnap.data();
  100 │     console.log("Dados brutos recuperados do Firestore para quarto:", id, data);
  101 │     
  102 │     if (data?.serviceFeePct !== undefined) {
  103 │       console.log("serviceFeePct antes da conversão:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
  104 │       // Garantir que serviceFeePct seja um número
  105 │       data.serviceFeePct = Number(data.serviceFeePct);
  106 │       console.log("serviceFeePct após conversão:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
  107 │     }
  108 │     
  109 │     return { id: docSnap.id, ...data } as T
  110 │   } else {
  111 │     return null
  112 │   }
  113 │ }
  114 │ 
  115 │ export const getDocuments = async <T>(
  116 │   collectionName: string,
  117 │   constraints: QueryConstraint[] = [],
  118 │   forceRefresh = false
  119 │ ): Promise<T[]> => {
  120 │   try {
  121 │     const collectionRef = collection(db, collectionName)
  122 │     const q = query(collectionRef, ...constraints)
  123 │     
  124 │     // Se forceRefresh for verdadeiro, adicionar opções que forçam uma nova consulta ao Firestore
  125 │     const querySnapshot = await getDocs(q)
  126 │     
  127 │     console.log(`Buscando documentos na coleção ${collectionName} - Força atualização: ${forceRefresh}`);
  128 │     
  129 │     return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }) as T)
  130 │   } catch (error) {
  131 │     console.error(`Erro ao buscar documentos da coleção ${collectionName}:`, error);
  132 │     return [];
  133 │   }
  134 │ }
  135 │ 
  136 │ export const updateDocument = async <T extends DocumentData>(
  137 │   collectionName: string,
  138 │   id: string,
  139 │   data: Partial<T>
  140 │ ): Promise<void> => {
  141 │   const docRef = doc(db, collectionName, id)
  142 │   await updateDoc(docRef, {
  143 │     ...data,
  144 │     updatedAt: serverTimestamp()
  145 │   })
  146 │ }
  147 │ 
  148 │ export const deleteDocument = async (
  149 │   collectionName: string,
  150 │   id: string
  151 │ ): Promise<boolean> => {
  152 │   const docRef = doc(db, collectionName, id)
  153 │   await deleteDoc(docRef)
  154 │   return true
  155 │ }
  156 │ 
  157 │ // Funções para gerenciar quartos
  158 │ export const getRooms = async (forceRefresh = false): Promise<Room[]> => {
  159 │   try {
  160 │     const constraints: QueryConstraint[] = []
  161 │     
  162 │     constraints.push(orderBy('name', 'asc'))
  163 │     
  164 │     const rooms = await getDocuments<Room>('rooms', constraints, forceRefresh)
  165 │     
  166 │     // Garantir que todos os campos necessários estejam presentes
  167 │     return rooms.map(room => {
  168 │       console.log(`Firebase - Quarto ${room.id} dados brutos:`, room);
  169 │       
  170 │       // Garantir que serviceFeePct seja um número
  171 │       const serviceFeePct = room.serviceFeePct !== undefined 
  172 │         ? Number(room.serviceFeePct) 
  173 │         : 10;
  174 │         
  175 │       console.log(`Firebase - Quarto ${room.id} serviceFeePct:`, {
  176 │         original: room.serviceFeePct,
  177 │         tipo: typeof room.serviceFeePct,
  178 │         convertido: serviceFeePct
  179 │       });
  180 │       
  181 │       return {
  182 │         id: room.id,
  183 │         name: room.name || '',
  184 │         type: room.type || 'standard',
  185 │         description: room.description || '',
  186 │         price: room.price || 0,
  187 │         capacity: room.capacity || 2,
  188 │         size: room.size || 0,
  189 │         available: room.available !== undefined ? room.available : true,
  190 │         serviceFeePct: serviceFeePct,
  191 │         images: room.images || [],
  192 │         amenities: room.amenities || [],
  193 │         additionalServices: room.additionalServices || [],
  194 │         highlights: room.highlights || [],
  195 │         createdAt: room.createdAt,
  196 │         updatedAt: room.updatedAt
  197 │       };
  198 │     });
  199 │   } catch (error) {
  200 │     console.error('Erro ao buscar quartos:', error)
  201 │     return []
  202 │   }
  203 │ }
  204 │ 
  205 │ export const getAvailableRooms = async (
  206 │   checkIn: Date,
  207 │   checkOut: Date
  208 │ ): Promise<Room[]> => {
  209 │   try {
  210 │     // Buscar todos os quartos que estão marcados como disponíveis em geral
  211 │     const constraints: QueryConstraint[] = [
  212 │       where('available', '==', true)
  213 │     ]
  214 │     
  215 │     const rooms = await getDocuments<Room>('rooms', constraints);
  216 │     
  217 │     // Filtrar os quartos que estão disponíveis nas datas específicas
  218 │     return filterAvailableRoomsByDate(rooms, checkIn, checkOut);
  219 │   } catch (error) {
  220 │     console.error('Erro ao buscar quartos disponíveis:', error)
  221 │     return []
  222 │   }
  223 │ }
  224 │ 
  225 │ // Função auxiliar para verificar disponibilidade entre datas
  226 │ export const filterAvailableRoomsByDate = (
  227 │   rooms: Room[],
  228 │   checkIn: Date,
  229 │   checkOut: Date
  230 │ ): Room[] => {
  231 │   // Converter checkIn e checkOut para ISO strings
  232 │   const dateStrings = getDatesInRange(checkIn, checkOut);
  233 │   
  234 │   return rooms.filter(room => {
  235 │     // Se não tiver controle de disponibilidade específico, considera disponível
  236 │     if (!room.availabilityDates) return true;
  237 │     
  238 │     // Verificar se alguma data no intervalo está indisponível
  239 │     return !dateStrings.some(dateStr => 
  240 │       room.availabilityDates?.[dateStr] === false
  241 │     );
  242 │   });
  243 │ };
  244 │ 
  245 │ // Função para obter disponibilidade de um quarto específico
  246 │ export const getRoomAvailability = async (
  247 │   roomId: string, 
  248 │   startDate: Date, 
  249 │   endDate: Date
  250 │ ): Promise<{[date: string]: boolean}> => {
  251 │   try {
  252 │     const room = await getRoomById(roomId);
  253 │     if (!room) throw new Error(`Quarto com ID ${roomId} não encontrado`);
  254 │     
  255 │     // Gerar datas no intervalo
  256 │     const dateStrings = getDatesInRange(startDate, endDate);
  257 │     
  258 │     // Se não tiver configuração de disponibilidade específica, assume tudo disponível
  259 │     if (!room.availabilityDates) {
  260 │       return dateStrings.reduce((acc, date) => {
  261 │         acc[date] = true;
  262 │         return acc;
  263 │       }, {} as {[date: string]: boolean});
  264 │     }
  265 │     
  266 │     // Preencher com os dados de disponibilidade existentes
  267 │     return dateStrings.reduce((acc, date) => {
  268 │       acc[date] = room.availabilityDates?.[date] !== false; // disponível por padrão se não estiver explicitamente indisponível
  269 │       return acc;
  270 │     }, {} as {[date: string]: boolean});
  271 │   } catch (error) {
  272 │     console.error(`Erro ao verificar disponibilidade do quarto ${roomId}:`, error);
  273 │     throw error;
  274 │   }
  275 │ };
  276 │ 
  277 │ // Função para atualizar disponibilidade de um quarto
  278 │ export const updateRoomAvailability = async (
  279 │   roomId: string,
  280 │   availabilityDates: {[date: string]: boolean}
  281 │ ): Promise<boolean> => {
  282 │   try {
  283 │     await updateDocument('rooms', roomId, {
  284 │       availabilityDates,
  285 │       updatedAt: serverTimestamp()
  286 │     });
  287 │     return true;
  288 │   } catch (error) {
  289 │     console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  290 │     return false;
  291 │   }
  292 │ };
  293 │ 
  294 │ // Função auxiliar para gerar array de strings de data entre um intervalo
  295 │ export const getDatesInRange = (startDate: Date, endDate: Date): string[] => {
  296 │   const dates: string[] = [];
  297 │   const currentDate = new Date(startDate);
  298 │   
  299 │   // Normalizar para meia-noite no fuso horário local
  300 │   currentDate.setHours(0, 0, 0, 0);
  301 │   const endDateNormalized = new Date(endDate);
  302 │   endDateNormalized.setHours(0, 0, 0, 0);
  303 │   
  304 │   // Adicionar cada data no intervalo EXCETO o dia de checkout
  305 │   // Usando < em vez de <= para não incluir o dia de checkout
  306 │   while (currentDate < endDateNormalized) {
  307 │     dates.push(currentDate.toISOString().split('T')[0]); // Formato YYYY-MM-DD
  308 │     currentDate.setDate(currentDate.getDate() + 1);
  309 │   }
  310 │   
  311 │   return dates;
  312 │ };
  313 │ 
  314 │ export const getRoomById = async (id: string): Promise<Room | null> => {
  315 │   try {
  316 │     const room = await getDocument<Room>('rooms', id);
  317 │     
  318 │     if (!room) return null;
  319 │     
  320 │     console.log(`Firebase - getRoomById ${id} dados brutos:`, room);
  321 │     
  322 │     // Log específico para serviceFeePct
  323 │     console.log(`serviceFeePct no Firestore:`, room.serviceFeePct);
  324 │     
  325 │     // Garantir que todos os campos necessários estejam presentes
  326 │     return {
  327 │       ...room,
  328 │       name: room.name || '',
  329 │       type: room.type || 'standard',
  330 │       description: room.description || '',
  331 │       price: room.price || 0,
  332 │       capacity: room.capacity || 2,
  333 │       size: room.size || 0,
  334 │       available: room.available !== undefined ? room.available : true,
  335 │       serviceFeePct: room.serviceFeePct !== undefined ? room.serviceFeePct : 10,
  336 │       images: room.images || [],
  337 │       amenities: room.amenities || [],
  338 │       additionalServices: room.additionalServices || [],
  339 │       highlights: room.highlights || []
  340 │     };
  341 │   } catch (error) {
  342 │     console.error(`Erro ao buscar quarto com ID ${id}:`, error);
  343 │     return null;
  344 │   }
  345 │ }
  346 │ 
  347 │ export const createRoom = async (roomData: Omit<Room, 'id' | 'createdAt' | 'updatedAt'>): Promise<Room> => {
  348 │   try {
  349 │     console.log("createRoom - Dados recebidos:", roomData);
  350 │     
  351 │     const roomWithTimestamps = {
  352 │       ...roomData,
  353 │       available: roomData.available !== undefined ? roomData.available : true,
  354 │       featured: roomData.featured || false,
  355 │       amenities: roomData.amenities || [],
  356 │       additionalServices: roomData.additionalServices || [],
  357 │       highlights: roomData.highlights || [],
  358 │       createdAt: serverTimestamp(),
  359 │       updatedAt: serverTimestamp()
  360 │     }
  361 │     
  362 │     console.log("createRoom - Dados a serem salvos:", roomWithTimestamps);
  363 │     
  364 │     const id = await createDocument('rooms', roomWithTimestamps)
  365 │     
  366 │     return {
  367 │       id,
  368 │       ...roomData,
  369 │       amenities: roomData.amenities || [],
  370 │       additionalServices: roomData.additionalServices || [],
  371 │       highlights: roomData.highlights || [],
  372 │       createdAt: Timestamp.now(),
  373 │       updatedAt: Timestamp.now()
  374 │     }
  375 │   } catch (error) {
  376 │     console.error('Erro ao criar quarto:', error)
  377 │     throw error
  378 │   }
  379 │ }
  380 │ 
  381 │ export const updateRoom = async (id: string, roomData: Partial<Omit<Room, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Room> => {
  382 │   try {
  383 │     console.log(`updateRoom - ID: ${id}, Dados recebidos:`, roomData);
  384 │     
  385 │     // Garantir que estamos lidando explicitamente com o serviceFeePct se ele for 0
  386 │     if (roomData.serviceFeePct === 0) {
  387 │       console.log("updateRoom - Detectado serviceFeePct com valor 0, salvando explicitamente.", roomData.serviceFeePct);
  388 │     }
  389 │     
  390 │     // Adicionar timestamp de atualização
  391 │     const roomWithTimestamp = {
  392 │       ...roomData,
  393 │       amenities: roomData.amenities || [],
  394 │       additionalServices: roomData.additionalServices || [],
  395 │       highlights: roomData.highlights || [],
  396 │       updatedAt: serverTimestamp()
  397 │     }
  398 │     
  399 │     console.log(`updateRoom - Dados a serem salvos:`, roomWithTimestamp);
  400 │     
  401 │     await updateDocument('rooms', id, roomWithTimestamp)
  402 │     
  403 │     const updatedRoom = await getRoomById(id)
  404 │     if (!updatedRoom) {
  405 │       throw new Error(`Quarto com ID ${id} não encontrado após atualização`)
  406 │     }
  407 │     
  408 │     return updatedRoom
  409 │   } catch (error) {
  410 │     console.error('Erro ao atualizar quarto:', error)
  411 │     throw error
  412 │   }
  413 │ }
  414 │ 
  415 │ export const deleteRoom = async (id: string): Promise<boolean> => {
  416 │   return await deleteDocument('rooms', id)
  417 │ }
  418 │ 
  419 │ // Funções específicas para reservas
  420 │ export const createBooking = async (bookingData: any) => {
  421 │   try {
  422 │     const bookingsCollection = collection(db, 'bookings');
  423 │     const docRef = await addDoc(bookingsCollection, bookingData);
  424 │     
  425 │     // CORREÇÃO: Não bloquear a data no momento da criação da reserva
  426 │     // O bloqueio será feito apenas quando o pagamento for confirmado
  427 │     // através da função updateBookingStatus
  428 │     
  429 │     return docRef;
  430 │   } catch (error) {
  431 │     console.error('Erro ao criar reserva:', error);
  432 │     throw error;
  433 │   }
  434 │ };
  435 │ 
  436 │ // Nova função para atualizar status da reserva e bloquear as datas da estadia
  437 │ export const updateBookingStatus = async (
  438 │   bookingId: string, 
  439 │   newStatus: 'pending' | 'confirmed' | 'cancelled' | 'completed',
  440 │   newPaymentStatus: 'pending' | 'paid' | 'refunded'
  441 │ ): Promise<boolean> => {
  442 │   try {
  443 │     // Referência ao documento da reserva
  444 │     const bookingRef = doc(db, 'bookings', bookingId);
  445 │     const bookingSnap = await getDoc(bookingRef);
  446 │     
  447 │     if (!bookingSnap.exists()) {
  448 │       console.error(`Booking ${bookingId} não existe ao atualizar status`);
  449 │       return false;
  450 │     }
  451 │     
  452 │     const bookingData = bookingSnap.data();
  453 │     
  454 │     // Atualizar o status da reserva
  455 │     await updateDoc(bookingRef, {
  456 │       status: newStatus,
  457 │       paymentStatus: newPaymentStatus,
  458 │       updatedAt: serverTimestamp(),
  459 │       ...(newStatus === 'confirmed' && { confirmedAt: serverTimestamp() })
  460 │     });
  461 │     
  462 │     // Se a reserva está sendo confirmada, precisamos bloquear as datas
  463 │     if (newStatus === 'confirmed') {
  464 │       console.log(`Atualizando disponibilidade para reserva confirmada: ${bookingId}`);
  465 │       
  466 │       // Recuperar datas de check-in e check-out
  467 │       const checkIn = bookingData.checkIn.toDate();
  468 │       const checkOut = bookingData.checkOut.toDate();
  469 │       const roomId = bookingData.roomId;
  470 │       
  471 │       // Obter todas as datas entre check-in e check-out
  472 │       const dates: Date[] = [];
  473 │       const currentDate = new Date(checkIn);
  474 │       
  475 │       while (currentDate < checkOut) {
  476 │         dates.push(new Date(currentDate));
  477 │         currentDate.setDate(currentDate.getDate() + 1);
  478 │       }
  479 │       
  480 │       console.log(`Bloqueando ${dates.length} dias para quarto ${roomId}`);
  481 │       
  482 │       // Atualizar disponibilidade para cada data
  483 │       const availabilityUpdates: {[date: string]: boolean} = {};
  484 │       
  485 │       dates.forEach(date => {
  486 │         const dateString = date.toISOString().split('T')[0]; // formato YYYY-MM-DD
  487 │         availabilityUpdates[dateString] = false; // false significa indisponível
  488 │       });
  489 │       
  490 │       // Atualizar disponibilidade do quarto
  491 │       if (Object.keys(availabilityUpdates).length > 0) {
  492 │         try {
  493 │           // Obter o documento do quarto
  494 │           const roomRef = doc(db, 'rooms', roomId);
  495 │           const roomSnap = await getDoc(roomRef);
  496 │           
  497 │           if (roomSnap.exists()) {
  498 │             const roomData = roomSnap.data();
  499 │             const currentAvailability = roomData.availabilityDates || {};
  500 │             
  501 │             // Mesclar a disponibilidade atual com as novas atualizações
  502 │             const updatedAvailability = {
  503 │               ...currentAvailability,
  504 │               ...availabilityUpdates
  505 │             };
  506 │             
  507 │             // Atualizar o documento do quarto
  508 │             await updateDoc(roomRef, {
  509 │               availabilityDates: updatedAvailability,
  510 │               updatedAt: serverTimestamp()
  511 │             });
  512 │             
  513 │             console.log(`Disponibilidade atualizada com sucesso para quarto ${roomId}`);
  514 │             
  515 │             // Criar log da reserva
  516 │             await addDoc(collection(db, 'bookingLogs'), {
  517 │               bookingId,
  518 │               roomId,
  519 │               action: 'status_updated',
  520 │               previousStatus: bookingData.status,
  521 │               newStatus,
  522 │               previousPaymentStatus: bookingData.paymentStatus,
  523 │               newPaymentStatus,
  524 │               datesBlocked: Object.keys(availabilityUpdates),
  525 │               timestamp: serverTimestamp(),
  526 │               userId: bookingData.userId || 'system'
  527 │             });
  528 │           } else {
  529 │             console.error(`Quarto ${roomId} não encontrado ao atualizar disponibilidade`);
  530 │           }
  531 │         } catch (error) {
  532 │           console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  533 │         }
  534 │       }
  535 │     }
  536 │     
  537 │     return true;
  538 │   } catch (error) {
  539 │     console.error(`Erro ao atualizar status da reserva ${bookingId}:`, error);
  540 │     return false;
  541 │   }
  542 │ }
  543 │ 
  544 │ export const getUserBookings = async (userId: string): Promise<Booking[]> => {
  545 │   return getDocuments<Booking>('bookings', [
  546 │     where('userId', '==', userId),
  547 │     orderBy('createdAt', 'desc')
  548 │   ])
  549 │ }
  550 │ 
  551 │ export const getRecentBookings = async (count = 5): Promise<Booking[]> => {
  552 │   return getDocuments<Booking>('bookings', [
  553 │     orderBy('createdAt', 'desc'),
  554 │     limit(count)
  555 │   ])
  556 │ }
  557 │ 
  558 │ export const getRoomBookings = async (roomId: string): Promise<Booking[]> => {
  559 │   try {
  560 │     const constraints: QueryConstraint[] = [
  561 │       where('roomId', '==', roomId),
  562 │       orderBy('checkIn', 'asc')
  563 │     ];
  564 │     
  565 │     return await getDocuments<Booking>('bookings', constraints);
  566 │   } catch (error) {
  567 │     console.error(`Erro ao buscar reservas do quarto ${roomId}:`, error);
  568 │     return [];
  569 │   }
  570 │ };
  571 │ 
  572 │ // Funções específicas para contatos
  573 │ export const createContactMessage = async (contactData: Contact) => {
  574 │   try {
  575 │     const contactsCollection = collection(db, 'contacts')
  576 │     
  577 │     // Garantir que o status seja 'new' para novos contatos
  578 │     const contactWithDefaults = {
  579 │       ...contactData,
  580 │       status: contactData.status || 'new',
  581 │       createdAt: contactData.createdAt || Timestamp.now()
  582 │     }
  583 │     
  584 │     // Se tiver detalhes de reserva, adicionar metadados
  585 │     if (contactWithDefaults.reservationDetails) {
  586 │       // Ajustar subject para indicar que é relacionado a reserva
  587 │       if (!contactWithDefaults.subject.includes('Reserva')) {
  588 │         contactWithDefaults.subject = `Reserva: ${contactWithDefaults.subject}`;
  589 │       }
  590 │     }
  591 │     
  592 │     const docRef = await addDoc(contactsCollection, contactWithDefaults)
  593 │     return docRef
  594 │   } catch (error) {
  595 │     console.error('Erro ao criar mensagem de contato:', error)
  596 │     throw error
  597 │   }
  598 │ }
  599 │ 
  600 │ export const getNewContactMessages = async (): Promise<Contact[]> => {
  601 │   return getDocuments<Contact>('contacts', [
  602 │     where('status', '==', 'new'),
  603 │     orderBy('createdAt', 'desc')
  604 │   ])
  605 │ }
  606 │ 
  607 │ // Funções para Dashboard com dados reais
  608 │ 
  609 │ export const getDashboardStats = async () => {
  610 │   try {
  611 │     const [totalBookings, totalRevenue, occupancyRate, bookingsByPlatform] = await Promise.all([
  612 │       getTotalBookings(),
  613 │       getMonthlyRevenue(),
  614 │       getOccupancyRate(),
  615 │       getBookingsByPlatform()
  616 │     ]);
  617 │ 
  618 │     return {
  619 │       totalBookings,
  620 │       totalRevenue,
  621 │       occupancyRate,
  622 │       bookingsByPlatform
  623 │     };
  624 │   } catch (error) {
  625 │     console.error('Erro ao obter estatísticas do dashboard:', error);
  626 │     throw error;
  627 │   }
  628 │ };
  629 │ 
  630 │ // Obter total de reservas
  631 │ export const getTotalBookings = async () => {
  632 │   try {
  633 │     // Obter todas as reservas
  634 │     const bookings = await getDocuments<Booking>('bookings');
  635 │     
  636 │     // Contar reservas por status
  637 │     const confirmed = bookings.filter(b => b.status === 'confirmed').length;
  638 │     const pending = bookings.filter(b => b.status === 'pending').length;
  639 │     const cancelled = bookings.filter(b => b.status === 'cancelled').length;
  640 │     const completed = bookings.filter(b => b.status === 'completed').length;
  641 │     
  642 │     // Calcular crescimento em relação ao mês anterior (simulado por enquanto)
  643 │     // Em uma implementação real, você compararia com dados do mês anterior
  644 │     const growth = ((confirmed + completed) / (bookings.length || 1) * 100) - 50;
  645 │     
  646 │     return {
  647 │       total: bookings.length,
  648 │       confirmed,
  649 │       pending,
  650 │       cancelled,
  651 │       completed,
  652 │       growth: Math.round(growth) // Arredonda para número inteiro
  653 │     };
  654 │   } catch (error) {
  655 │     console.error('Erro ao obter total de reservas:', error);
  656 │     return {
  657 │       total: 0,
  658 │       confirmed: 0,
  659 │       pending: 0, 
  660 │       cancelled: 0,
  661 │       completed: 0,
  662 │       growth: 0
  663 │     };
  664 │   }
  665 │ };
  666 │ 
  667 │ // Obter receita mensal
  668 │ export const getMonthlyRevenue = async () => {
  669 │   try {
  670 │     const bookings = await getDocuments<Booking>('bookings');
  671 │     
  672 │     // Filtrar reservas confirmadas e concluídas
  673 │     const validBookings = bookings.filter(b => 
  674 │       b.status === 'confirmed' || b.status === 'completed'
  675 │     );
  676 │     
  677 │     // Calcular receita total
  678 │     const totalRevenue = validBookings.reduce((acc, booking) => acc + booking.totalPrice, 0);
  679 │     
  680 │     // Agrupar receita por mês
  681 │     const revenueByMonth = validBookings.reduce((acc, booking) => {
  682 │       const date = booking.checkIn.toDate();
  683 │       const month = date.getMonth(); // 0-11
  684 │       const year = date.getFullYear();
  685 │       const key = `${year}-${month}`;
  686 │       
  687 │       if (!acc[key]) {
  688 │         acc[key] = 0;
  689 │       }
  690 │       acc[key] += booking.totalPrice;
  691 │       return acc;
  692 │     }, {} as Record<string, number>);
  693 │     
  694 │     // Converter para formato de array para gráfico
  695 │     const monthNames = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
  696 │     
  697 │     const currentDate = new Date();
  698 │     const currentMonth = currentDate.getMonth();
  699 │     const currentYear = currentDate.getFullYear();
  700 │     
  701 │     const revenueData = [];
  702 │     
  703 │     // Gerar dados dos últimos 12 meses
  704 │     for (let i = 0; i < 12; i++) {
  705 │       const month = (currentMonth - i + 12) % 12;
  706 │       const year = currentMonth - i < 0 ? currentYear - 1 : currentYear;
  707 │       const key = `${year}-${month}`;
  708 │       
  709 │       revenueData.unshift({
  710 │         month: monthNames[month],
  711 │         value: revenueByMonth[key] || 0
  712 │       });
  713 │     }
  714 │     
  715 │     // Calcular crescimento em relação ao mês anterior
  716 │     const lastMonthRevenue = revenueData[revenueData.length - 2]?.value || 0;
  717 │     const currentMonthRevenue = revenueData[revenueData.length - 1]?.value || 0;
  718 │     
  719 │     const growth = lastMonthRevenue ? ((currentMonthRevenue - lastMonthRevenue) / lastMonthRevenue) * 100 : 0;
  720 │     
  721 │     return {
  722 │       monthly: currentMonthRevenue,
  723 │       total: totalRevenue,
  724 │       growth: Math.round(growth),
  725 │       revenueData
  726 │     };
  727 │   } catch (error) {
  728 │     console.error('Erro ao obter receita mensal:', error);
  729 │     return {
  730 │       monthly: 0,
  731 │       total: 0,
  732 │       growth: 0,
  733 │       revenueData: []
  734 │     };
  735 │   }
  736 │ };
  737 │ 
  738 │ // Calcular taxa de ocupação
  739 │ export const getOccupancyRate = async () => {
  740 │   try {
  741 │     // Obter todos os quartos
  742 │     const rooms = await getDocuments<Room>('rooms');
  743 │     const totalRooms = rooms.length;
  744 │     
  745 │     if (totalRooms === 0) {
  746 │       return { rate: 0, growth: 0 };
  747 │     }
  748 │     
  749 │     // Obter todas as reservas
  750 │     const bookings = await getDocuments<Booking>('bookings');
  751 │     
  752 │     // Filtrar reservas confirmadas e concluídas para o mês atual
  753 │     const currentDate = new Date();
  754 │     const currentMonth = currentDate.getMonth();
  755 │     const currentYear = currentDate.getFullYear();
  756 │     
  757 │     const currentMonthBookings = bookings.filter(booking => {
  758 │       const checkInDate = booking.checkIn.toDate();
  759 │       return (
  760 │         (booking.status === 'confirmed' || booking.status === 'completed') &&
  761 │         checkInDate.getMonth() === currentMonth &&
  762 │         checkInDate.getFullYear() === currentYear
  763 │       );
  764 │     });
  765 │     
  766 │     // Calcular dias ocupados por quarto
  767 │     const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
  768 │     const totalPossibleRoomDays = totalRooms * daysInMonth;
  769 │     
  770 │     // Contar dias ocupados (simplificado - em produção seria mais complexo)
  771 │     let occupiedDays = 0;
  772 │     
  773 │     currentMonthBookings.forEach(booking => {
  774 │       const checkIn = booking.checkIn.toDate();
  775 │       const checkOut = booking.checkOut.toDate();
  776 │       
  777 │       // Ajustar datas para considerar apenas o mês atual
  778 │       const startDate = new Date(Math.max(
  779 │         checkIn.getTime(),
  780 │         new Date(currentYear, currentMonth, 1).getTime()
  781 │       ));
  782 │       const endDate = new Date(Math.min(
  783 │         checkOut.getTime(),
  784 │         new Date(currentYear, currentMonth + 1, 0).getTime()
  785 │       ));
  786 │       
  787 │       // Calcular dias entre datas (incluindo check-in, excluindo check-out)
  788 │       const days = Math.max(0, Math.floor((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)));
  789 │       occupiedDays += days;
  790 │     });
  791 │     
  792 │     const occupancyRate = (occupiedDays / totalPossibleRoomDays) * 100;
  793 │     
  794 │     // Simulação de crescimento (em produção, compararia com mês anterior)
  795 │     const growth = occupancyRate > 50 ? 5 : -3;
  796 │     
  797 │     return {
  798 │       rate: Math.round(occupancyRate),
  799 │       growth: Math.round(growth)
  800 │     };
  801 │   } catch (error) {
  802 │     console.error('Erro ao calcular taxa de ocupação:', error);
  803 │     return { rate: 0, growth: 0 };
  804 │   }
  805 │ };
  806 │ 
  807 │ // Obter reservas agrupadas por plataforma
  808 │ export const getBookingsByPlatform = async () => {
  809 │   try {
  810 │     const bookings = await getDocuments<Booking>('bookings');
  811 │     
  812 │     // Categorizar reservas por origem
  813 │     const platforms = [
  814 │       { 
  815 │         platform: "Booking.com", 
  816 │         color: "#003580", 
  817 │         icon: "Globe",
  818 │         bookings: []
  819 │       },
  820 │       { 
  821 │         platform: "Airbnb", 
  822 │         color: "#FF5A5F", 
  823 │         icon: "Heart",
  824 │         bookings: []
  825 │       },
  826 │       { 
  827 │         platform: "Direto", 
  828 │         color: "#4CAF50", 
  829 │         icon: "Home",
  830 │         bookings: []
  831 │       }
  832 │     ];
  833 │     
  834 │     // Para fins de demonstração, colocar todas as reservas como "Direto" por enquanto
  835 │     // Em produção, usaria um campo "platformOrigin" ou similar na tabela de reservas
  836 │     const platformIndex = 2; // Índice da plataforma "Direto"
  837 │     
  838 │     bookings.forEach(booking => {
  839 │       // Transformar para o formato esperado pelo componente
  840 │       const transformedBooking = {
  841 │         id: booking.id || '',
  842 │         guestName: booking.guestName,
  843 │         roomName: booking.roomName,
  844 │         checkIn: booking.checkIn.toDate().toLocaleDateString('pt-PT'),
  845 │         checkOut: booking.checkOut.toDate().toLocaleDateString('pt-PT'),
  846 │         status: booking.status,
  847 │         value: new Intl.NumberFormat('pt-PT', {
  848 │           style: 'currency',
  849 │           currency: 'EUR'
  850 │         }).format(booking.totalPrice)
  851 │       };
  852 │       
  853 │       // Adicionar à plataforma "Direto"
  854 │       (platforms[platformIndex] as any).bookings.push(transformedBooking);
  855 │     });
  856 │     
  857 │     return platforms;
  858 │   } catch (error) {
  859 │     console.error('Erro ao obter reservas por plataforma:', error);
  860 │     return [];
  861 │   }
  862 │ };
  863 │ 
  864 │ // Função para obter o preço de um quarto para uma data específica
  865 │ export const getRoomPriceForDate = async (roomId: string, date: Date): Promise<number> => {
  866 │   try {
  867 │     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  868 │     
  869 │     if (!roomDoc.exists()) {
  870 │       throw new Error("Quarto não encontrado");
  871 │     }
  872 │     
  873 │     const roomData = roomDoc.data() as Room;
  874 │     const basePrice = roomData.price;
  875 │     
  876 │     if (!roomData.seasonalPrices || roomData.seasonalPrices.length === 0) {
  877 │       return basePrice;
  878 │     }
  879 │     
  880 │     // Verificar se a data está dentro de algum período sazonal
  881 │     for (const seasonalPrice of roomData.seasonalPrices) {
  882 │       const startDate = new Date(seasonalPrice.startDate);
  883 │       const endDate = new Date(seasonalPrice.endDate);
  884 │       
  885 │       if (date >= startDate && date <= endDate) {
  886 │         return seasonalPrice.price;
  887 │       }
  888 │     }
  889 │     
  890 │     // Se não cair em nenhum período sazonal, retorna o preço base
  891 │     return basePrice;
  892 │   } catch (error) {
  893 │     console.error("Erro ao obter preço do quarto:", error);
  894 │     throw error;
  895 │   }
  896 │ }
  897 │ 
  898 │ // Função para calcular o preço total de uma estadia
  899 │ export const calculateStayPrice = async (
  900 │   roomId: string, 
  901 │   checkIn: Date, 
  902 │   checkOut: Date
  903 │ ): Promise<{
  904 │   totalPrice: number;
  905 │   nightlyPrices: { date: string; price: number }[];
  906 │   serviceFee: number;
  907 │   totalWithFee: number;
  908 │ }> => {
  909 │   try {
  910 │     console.log(`🔍 Iniciando cálculo de preço para estadia: ${checkIn.toISOString().split('T')[0]} até ${checkOut.toISOString().split('T')[0]}`);
  911 │     
  912 │     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  913 │     
  914 │     if (!roomDoc.exists()) {
  915 │       throw new Error("Quarto não encontrado");
  916 │     }
  917 │     
  918 │     const roomData = roomDoc.data() as Room;
  919 │     console.log(`📝 Dados do quarto ${roomId}:`, {
  920 │       nome: roomData.name,
  921 │       precoBase: roomData.price,
  922 │       taxaServico: roomData.serviceFeePct || 0,
  923 │       temPrecosSazonais: !!roomData.seasonalPrices?.length
  924 │     });
  925 │     
  926 │     const nightlyPrices: { date: string; price: number }[] = [];
  927 │     let totalPrice = 0;
  928 │     
  929 │     // Calcular o número de noites - corrigido para usar o método correto de cálculo
  930 │     // O número de noites é a diferença em dias (estadia = checkout - checkin)
  931 │     const noites = differenceInDays(checkOut, checkIn);
  932 │     console.log(`🗓️ Número de noites calculado: ${noites}`);
  933 │     
  934 │     if (noites <= 0) {
  935 │       console.error(`⚠️ Erro: número de noites inválido (${noites})`);
  936 │       throw new Error("Data de check-out deve ser posterior à data de check-in");
  937 │     }
  938 │     
  939 │     // Para cada noite, verificar o preço aplicável (preço base ou sazonal)
  940 │     // Começamos exatamente do dia de check-in
  941 │     const currentDate = new Date(checkIn);
  942 │     currentDate.setHours(0, 0, 0, 0); // Normalizar para meia-noite
  943 │     
  944 │     // Processamos cada dia de estadia (noite)
  945 │     console.log(`📊 Calculando preços por noite:`);
  946 │     for (let i = 0; i < noites; i++) {
  947 │       // Obtemos o preço para esta data
  948 │       const dateCopy = new Date(currentDate);
  949 │       const priceForDate = await getRoomPriceForDate(roomId, dateCopy);
  950 │       const dateString = dateCopy.toISOString().split('T')[0]; // YYYY-MM-DD
  951 │       
  952 │       console.log(`   - ${dateString}: €${priceForDate}`);
  953 │       
  954 │       nightlyPrices.push({
  955 │         date: dateString,
  956 │         price: priceForDate
  957 │       });
  958 │       
  959 │       totalPrice += priceForDate;
  960 │       
  961 │       // Avançamos para o próximo dia
  962 │       currentDate.setDate(currentDate.getDate() + 1);
  963 │     }
  964 │     
  965 │     // Verificação de segurança para o cálculo do totalPrice
  966 │     const manualTotal = nightlyPrices.reduce((sum, night) => sum + night.price, 0);
  967 │     if (Math.abs(totalPrice - manualTotal) > 1) {
  968 │       console.error(`⚠️ Discrepância detectada no cálculo do preço total!`);
  969 │       console.error(`   - Total calculado iterativamente: €${totalPrice}`);
  970 │       console.error(`   - Total calculado via reduce: €${manualTotal}`);
  971 │       console.error(`   - Usando o valor recalculado para segurança!`);
  972 │       totalPrice = manualTotal;
  973 │     }
  974 │     
  975 │     // Calcular taxa de serviço
  976 │     const serviceFee = (totalPrice * (roomData.serviceFeePct || 0)) / 100;
  977 │     const totalWithFee = totalPrice + serviceFee;
  978 │     
  979 │     console.log(`💰 Resumo do cálculo:`);
  980 │     console.log(`   - Total das diárias: €${totalPrice}`);
  981 │     console.log(`   - Taxa de serviço (${roomData.serviceFeePct || 0}%): €${serviceFee}`);
  982 │     console.log(`   - Total com taxas: €${totalWithFee}`);
  983 │     
  984 │     return {
  985 │       totalPrice,
  986 │       nightlyPrices,
  987 │       serviceFee,
  988 │       totalWithFee
  989 │     };
  990 │   } catch (error) {
  991 │     console.error("❌ Erro ao calcular preço da estadia:", error);
  992 │     throw error;
  993 │   }
  994 │ } 
  995 │ import { 
  996 │   collection, 
  997 │   getDocs, 
  998 │   getDoc, 
  999 │   doc, 
 1000 │   setDoc, 
 1001 │   addDoc, 
 1002 │   updateDoc, 
 1003 │   deleteDoc,
 1004 │   query,
      ·   ──┬──
      ·     ╰── `query` redefined here
 1005 │   where,
 1006 │   orderBy,
 1007 │   limit,
      ╰────

  × the name `where` is defined multiple times
      ╭─[/home/runner/workspace/lib/firebase/firestore.ts:8:1]
    8 │   updateDoc,
    9 │   deleteDoc,
   10 │   query,
   11 │   where,
      ·   ──┬──
      ·     ╰── previous definition of `where` here
   12 │   orderBy,
   13 │   limit,
   14 │   DocumentData,
   15 │   QueryConstraint,
   16 │   Timestamp,
   17 │   serverTimestamp
   18 │ } from 'firebase/firestore'
   19 │ import { db } from './config'
   20 │ import { Room, SeasonalPrice } from '@/lib/types'
   21 │ import { differenceInDays } from 'date-fns'
   22 │ 
   23 │ // Tipos de dados
   24 │ export interface Booking {
   25 │   id?: string
   26 │   userId?: string
   27 │   guestName: string
   28 │   guestEmail: string
   29 │   guestPhone: string
   30 │   roomId: string
   31 │   roomName: string
   32 │   checkIn: Timestamp
   33 │   checkOut: Timestamp
   34 │   adults: number
   35 │   children: number
   36 │   totalPrice: number
   37 │   status: 'pending' | 'confirmed' | 'cancelled' | 'completed'
   38 │   paymentStatus: 'pending' | 'paid' | 'refunded'
   39 │   specialRequests?: string
   40 │   createdAt?: Timestamp
   41 │   updatedAt?: Timestamp
   42 │ }
   43 │ 
   44 │ export interface Contact {
   45 │   id?: string
   46 │   name: string
   47 │   email: string
   48 │   phone?: string
   49 │   subject: string
   50 │   message: string
   51 │   status: 'new' | 'read' | 'replied'
   52 │   createdAt: Timestamp
   53 │   updatedAt?: Timestamp
   54 │   repliedAt?: Timestamp
   55 │   replyContent?: string
   56 │   reservationDetails?: {
   57 │     checkIn?: Timestamp
   58 │     checkOut?: Timestamp
   59 │     roomId?: string
   60 │     roomName?: string
   61 │     totalGuests?: number
   62 │     totalPrice?: number
   63 │   }
   64 │ }
   65 │ 
   66 │ // Funções genéricas para CRUD
   67 │ export const createDocument = async <T extends DocumentData>(
   68 │   collectionName: string,
   69 │   data: T
   70 │ ): Promise<string> => {
   71 │   const docRef = await addDoc(collection(db, collectionName), {
   72 │     ...data,
   73 │     createdAt: serverTimestamp(),
   74 │     updatedAt: serverTimestamp()
   75 │   })
   76 │   return docRef.id
   77 │ }
   78 │ 
   79 │ export const createDocumentWithId = async <T extends DocumentData>(
   80 │   collectionName: string,
   81 │   id: string,
   82 │   data: T
   83 │ ): Promise<void> => {
   84 │   await setDoc(doc(db, collectionName, id), {
   85 │     ...data,
   86 │     createdAt: serverTimestamp(),
   87 │     updatedAt: serverTimestamp()
   88 │   })
   89 │ }
   90 │ 
   91 │ export const getDocument = async <T>(
   92 │   collectionName: string,
   93 │   id: string
   94 │ ): Promise<T | null> => {
   95 │   const docRef = doc(db, collectionName, id)
   96 │   const docSnap = await getDoc(docRef)
   97 │   
   98 │   if (docSnap.exists()) {
   99 │     const data = docSnap.data();
  100 │     console.log("Dados brutos recuperados do Firestore para quarto:", id, data);
  101 │     
  102 │     if (data?.serviceFeePct !== undefined) {
  103 │       console.log("serviceFeePct antes da conversão:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
  104 │       // Garantir que serviceFeePct seja um número
  105 │       data.serviceFeePct = Number(data.serviceFeePct);
  106 │       console.log("serviceFeePct após conversão:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
  107 │     }
  108 │     
  109 │     return { id: docSnap.id, ...data } as T
  110 │   } else {
  111 │     return null
  112 │   }
  113 │ }
  114 │ 
  115 │ export const getDocuments = async <T>(
  116 │   collectionName: string,
  117 │   constraints: QueryConstraint[] = [],
  118 │   forceRefresh = false
  119 │ ): Promise<T[]> => {
  120 │   try {
  121 │     const collectionRef = collection(db, collectionName)
  122 │     const q = query(collectionRef, ...constraints)
  123 │     
  124 │     // Se forceRefresh for verdadeiro, adicionar opções que forçam uma nova consulta ao Firestore
  125 │     const querySnapshot = await getDocs(q)
  126 │     
  127 │     console.log(`Buscando documentos na coleção ${collectionName} - Força atualização: ${forceRefresh}`);
  128 │     
  129 │     return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }) as T)
  130 │   } catch (error) {
  131 │     console.error(`Erro ao buscar documentos da coleção ${collectionName}:`, error);
  132 │     return [];
  133 │   }
  134 │ }
  135 │ 
  136 │ export const updateDocument = async <T extends DocumentData>(
  137 │   collectionName: string,
  138 │   id: string,
  139 │   data: Partial<T>
  140 │ ): Promise<void> => {
  141 │   const docRef = doc(db, collectionName, id)
  142 │   await updateDoc(docRef, {
  143 │     ...data,
  144 │     updatedAt: serverTimestamp()
  145 │   })
  146 │ }
  147 │ 
  148 │ export const deleteDocument = async (
  149 │   collectionName: string,
  150 │   id: string
  151 │ ): Promise<boolean> => {
  152 │   const docRef = doc(db, collectionName, id)
  153 │   await deleteDoc(docRef)
  154 │   return true
  155 │ }
  156 │ 
  157 │ // Funções para gerenciar quartos
  158 │ export const getRooms = async (forceRefresh = false): Promise<Room[]> => {
  159 │   try {
  160 │     const constraints: QueryConstraint[] = []
  161 │     
  162 │     constraints.push(orderBy('name', 'asc'))
  163 │     
  164 │     const rooms = await getDocuments<Room>('rooms', constraints, forceRefresh)
  165 │     
  166 │     // Garantir que todos os campos necessários estejam presentes
  167 │     return rooms.map(room => {
  168 │       console.log(`Firebase - Quarto ${room.id} dados brutos:`, room);
  169 │       
  170 │       // Garantir que serviceFeePct seja um número
  171 │       const serviceFeePct = room.serviceFeePct !== undefined 
  172 │         ? Number(room.serviceFeePct) 
  173 │         : 10;
  174 │         
  175 │       console.log(`Firebase - Quarto ${room.id} serviceFeePct:`, {
  176 │         original: room.serviceFeePct,
  177 │         tipo: typeof room.serviceFeePct,
  178 │         convertido: serviceFeePct
  179 │       });
  180 │       
  181 │       return {
  182 │         id: room.id,
  183 │         name: room.name || '',
  184 │         type: room.type || 'standard',
  185 │         description: room.description || '',
  186 │         price: room.price || 0,
  187 │         capacity: room.capacity || 2,
  188 │         size: room.size || 0,
  189 │         available: room.available !== undefined ? room.available : true,
  190 │         serviceFeePct: serviceFeePct,
  191 │         images: room.images || [],
  192 │         amenities: room.amenities || [],
  193 │         additionalServices: room.additionalServices || [],
  194 │         highlights: room.highlights || [],
  195 │         createdAt: room.createdAt,
  196 │         updatedAt: room.updatedAt
  197 │       };
  198 │     });
  199 │   } catch (error) {
  200 │     console.error('Erro ao buscar quartos:', error)
  201 │     return []
  202 │   }
  203 │ }
  204 │ 
  205 │ export const getAvailableRooms = async (
  206 │   checkIn: Date,
  207 │   checkOut: Date
  208 │ ): Promise<Room[]> => {
  209 │   try {
  210 │     // Buscar todos os quartos que estão marcados como disponíveis em geral
  211 │     const constraints: QueryConstraint[] = [
  212 │       where('available', '==', true)
  213 │     ]
  214 │     
  215 │     const rooms = await getDocuments<Room>('rooms', constraints);
  216 │     
  217 │     // Filtrar os quartos que estão disponíveis nas datas específicas
  218 │     return filterAvailableRoomsByDate(rooms, checkIn, checkOut);
  219 │   } catch (error) {
  220 │     console.error('Erro ao buscar quartos disponíveis:', error)
  221 │     return []
  222 │   }
  223 │ }
  224 │ 
  225 │ // Função auxiliar para verificar disponibilidade entre datas
  226 │ export const filterAvailableRoomsByDate = (
  227 │   rooms: Room[],
  228 │   checkIn: Date,
  229 │   checkOut: Date
  230 │ ): Room[] => {
  231 │   // Converter checkIn e checkOut para ISO strings
  232 │   const dateStrings = getDatesInRange(checkIn, checkOut);
  233 │   
  234 │   return rooms.filter(room => {
  235 │     // Se não tiver controle de disponibilidade específico, considera disponível
  236 │     if (!room.availabilityDates) return true;
  237 │     
  238 │     // Verificar se alguma data no intervalo está indisponível
  239 │     return !dateStrings.some(dateStr => 
  240 │       room.availabilityDates?.[dateStr] === false
  241 │     );
  242 │   });
  243 │ };
  244 │ 
  245 │ // Função para obter disponibilidade de um quarto específico
  246 │ export const getRoomAvailability = async (
  247 │   roomId: string, 
  248 │   startDate: Date, 
  249 │   endDate: Date
  250 │ ): Promise<{[date: string]: boolean}> => {
  251 │   try {
  252 │     const room = await getRoomById(roomId);
  253 │     if (!room) throw new Error(`Quarto com ID ${roomId} não encontrado`);
  254 │     
  255 │     // Gerar datas no intervalo
  256 │     const dateStrings = getDatesInRange(startDate, endDate);
  257 │     
  258 │     // Se não tiver configuração de disponibilidade específica, assume tudo disponível
  259 │     if (!room.availabilityDates) {
  260 │       return dateStrings.reduce((acc, date) => {
  261 │         acc[date] = true;
  262 │         return acc;
  263 │       }, {} as {[date: string]: boolean});
  264 │     }
  265 │     
  266 │     // Preencher com os dados de disponibilidade existentes
  267 │     return dateStrings.reduce((acc, date) => {
  268 │       acc[date] = room.availabilityDates?.[date] !== false; // disponível por padrão se não estiver explicitamente indisponível
  269 │       return acc;
  270 │     }, {} as {[date: string]: boolean});
  271 │   } catch (error) {
  272 │     console.error(`Erro ao verificar disponibilidade do quarto ${roomId}:`, error);
  273 │     throw error;
  274 │   }
  275 │ };
  276 │ 
  277 │ // Função para atualizar disponibilidade de um quarto
  278 │ export const updateRoomAvailability = async (
  279 │   roomId: string,
  280 │   availabilityDates: {[date: string]: boolean}
  281 │ ): Promise<boolean> => {
  282 │   try {
  283 │     await updateDocument('rooms', roomId, {
  284 │       availabilityDates,
  285 │       updatedAt: serverTimestamp()
  286 │     });
  287 │     return true;
  288 │   } catch (error) {
  289 │     console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  290 │     return false;
  291 │   }
  292 │ };
  293 │ 
  294 │ // Função auxiliar para gerar array de strings de data entre um intervalo
  295 │ export const getDatesInRange = (startDate: Date, endDate: Date): string[] => {
  296 │   const dates: string[] = [];
  297 │   const currentDate = new Date(startDate);
  298 │   
  299 │   // Normalizar para meia-noite no fuso horário local
  300 │   currentDate.setHours(0, 0, 0, 0);
  301 │   const endDateNormalized = new Date(endDate);
  302 │   endDateNormalized.setHours(0, 0, 0, 0);
  303 │   
  304 │   // Adicionar cada data no intervalo EXCETO o dia de checkout
  305 │   // Usando < em vez de <= para não incluir o dia de checkout
  306 │   while (currentDate < endDateNormalized) {
  307 │     dates.push(currentDate.toISOString().split('T')[0]); // Formato YYYY-MM-DD
  308 │     currentDate.setDate(currentDate.getDate() + 1);
  309 │   }
  310 │   
  311 │   return dates;
  312 │ };
  313 │ 
  314 │ export const getRoomById = async (id: string): Promise<Room | null> => {
  315 │   try {
  316 │     const room = await getDocument<Room>('rooms', id);
  317 │     
  318 │     if (!room) return null;
  319 │     
  320 │     console.log(`Firebase - getRoomById ${id} dados brutos:`, room);
  321 │     
  322 │     // Log específico para serviceFeePct
  323 │     console.log(`serviceFeePct no Firestore:`, room.serviceFeePct);
  324 │     
  325 │     // Garantir que todos os campos necessários estejam presentes
  326 │     return {
  327 │       ...room,
  328 │       name: room.name || '',
  329 │       type: room.type || 'standard',
  330 │       description: room.description || '',
  331 │       price: room.price || 0,
  332 │       capacity: room.capacity || 2,
  333 │       size: room.size || 0,
  334 │       available: room.available !== undefined ? room.available : true,
  335 │       serviceFeePct: room.serviceFeePct !== undefined ? room.serviceFeePct : 10,
  336 │       images: room.images || [],
  337 │       amenities: room.amenities || [],
  338 │       additionalServices: room.additionalServices || [],
  339 │       highlights: room.highlights || []
  340 │     };
  341 │   } catch (error) {
  342 │     console.error(`Erro ao buscar quarto com ID ${id}:`, error);
  343 │     return null;
  344 │   }
  345 │ }
  346 │ 
  347 │ export const createRoom = async (roomData: Omit<Room, 'id' | 'createdAt' | 'updatedAt'>): Promise<Room> => {
  348 │   try {
  349 │     console.log("createRoom - Dados recebidos:", roomData);
  350 │     
  351 │     const roomWithTimestamps = {
  352 │       ...roomData,
  353 │       available: roomData.available !== undefined ? roomData.available : true,
  354 │       featured: roomData.featured || false,
  355 │       amenities: roomData.amenities || [],
  356 │       additionalServices: roomData.additionalServices || [],
  357 │       highlights: roomData.highlights || [],
  358 │       createdAt: serverTimestamp(),
  359 │       updatedAt: serverTimestamp()
  360 │     }
  361 │     
  362 │     console.log("createRoom - Dados a serem salvos:", roomWithTimestamps);
  363 │     
  364 │     const id = await createDocument('rooms', roomWithTimestamps)
  365 │     
  366 │     return {
  367 │       id,
  368 │       ...roomData,
  369 │       amenities: roomData.amenities || [],
  370 │       additionalServices: roomData.additionalServices || [],
  371 │       highlights: roomData.highlights || [],
  372 │       createdAt: Timestamp.now(),
  373 │       updatedAt: Timestamp.now()
  374 │     }
  375 │   } catch (error) {
  376 │     console.error('Erro ao criar quarto:', error)
  377 │     throw error
  378 │   }
  379 │ }
  380 │ 
  381 │ export const updateRoom = async (id: string, roomData: Partial<Omit<Room, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Room> => {
  382 │   try {
  383 │     console.log(`updateRoom - ID: ${id}, Dados recebidos:`, roomData);
  384 │     
  385 │     // Garantir que estamos lidando explicitamente com o serviceFeePct se ele for 0
  386 │     if (roomData.serviceFeePct === 0) {
  387 │       console.log("updateRoom - Detectado serviceFeePct com valor 0, salvando explicitamente.", roomData.serviceFeePct);
  388 │     }
  389 │     
  390 │     // Adicionar timestamp de atualização
  391 │     const roomWithTimestamp = {
  392 │       ...roomData,
  393 │       amenities: roomData.amenities || [],
  394 │       additionalServices: roomData.additionalServices || [],
  395 │       highlights: roomData.highlights || [],
  396 │       updatedAt: serverTimestamp()
  397 │     }
  398 │     
  399 │     console.log(`updateRoom - Dados a serem salvos:`, roomWithTimestamp);
  400 │     
  401 │     await updateDocument('rooms', id, roomWithTimestamp)
  402 │     
  403 │     const updatedRoom = await getRoomById(id)
  404 │     if (!updatedRoom) {
  405 │       throw new Error(`Quarto com ID ${id} não encontrado após atualização`)
  406 │     }
  407 │     
  408 │     return updatedRoom
  409 │   } catch (error) {
  410 │     console.error('Erro ao atualizar quarto:', error)
  411 │     throw error
  412 │   }
  413 │ }
  414 │ 
  415 │ export const deleteRoom = async (id: string): Promise<boolean> => {
  416 │   return await deleteDocument('rooms', id)
  417 │ }
  418 │ 
  419 │ // Funções específicas para reservas
  420 │ export const createBooking = async (bookingData: any) => {
  421 │   try {
  422 │     const bookingsCollection = collection(db, 'bookings');
  423 │     const docRef = await addDoc(bookingsCollection, bookingData);
  424 │     
  425 │     // CORREÇÃO: Não bloquear a data no momento da criação da reserva
  426 │     // O bloqueio será feito apenas quando o pagamento for confirmado
  427 │     // através da função updateBookingStatus
  428 │     
  429 │     return docRef;
  430 │   } catch (error) {
  431 │     console.error('Erro ao criar reserva:', error);
  432 │     throw error;
  433 │   }
  434 │ };
  435 │ 
  436 │ // Nova função para atualizar status da reserva e bloquear as datas da estadia
  437 │ export const updateBookingStatus = async (
  438 │   bookingId: string, 
  439 │   newStatus: 'pending' | 'confirmed' | 'cancelled' | 'completed',
  440 │   newPaymentStatus: 'pending' | 'paid' | 'refunded'
  441 │ ): Promise<boolean> => {
  442 │   try {
  443 │     // Referência ao documento da reserva
  444 │     const bookingRef = doc(db, 'bookings', bookingId);
  445 │     const bookingSnap = await getDoc(bookingRef);
  446 │     
  447 │     if (!bookingSnap.exists()) {
  448 │       console.error(`Booking ${bookingId} não existe ao atualizar status`);
  449 │       return false;
  450 │     }
  451 │     
  452 │     const bookingData = bookingSnap.data();
  453 │     
  454 │     // Atualizar o status da reserva
  455 │     await updateDoc(bookingRef, {
  456 │       status: newStatus,
  457 │       paymentStatus: newPaymentStatus,
  458 │       updatedAt: serverTimestamp(),
  459 │       ...(newStatus === 'confirmed' && { confirmedAt: serverTimestamp() })
  460 │     });
  461 │     
  462 │     // Se a reserva está sendo confirmada, precisamos bloquear as datas
  463 │     if (newStatus === 'confirmed') {
  464 │       console.log(`Atualizando disponibilidade para reserva confirmada: ${bookingId}`);
  465 │       
  466 │       // Recuperar datas de check-in e check-out
  467 │       const checkIn = bookingData.checkIn.toDate();
  468 │       const checkOut = bookingData.checkOut.toDate();
  469 │       const roomId = bookingData.roomId;
  470 │       
  471 │       // Obter todas as datas entre check-in e check-out
  472 │       const dates: Date[] = [];
  473 │       const currentDate = new Date(checkIn);
  474 │       
  475 │       while (currentDate < checkOut) {
  476 │         dates.push(new Date(currentDate));
  477 │         currentDate.setDate(currentDate.getDate() + 1);
  478 │       }
  479 │       
  480 │       console.log(`Bloqueando ${dates.length} dias para quarto ${roomId}`);
  481 │       
  482 │       // Atualizar disponibilidade para cada data
  483 │       const availabilityUpdates: {[date: string]: boolean} = {};
  484 │       
  485 │       dates.forEach(date => {
  486 │         const dateString = date.toISOString().split('T')[0]; // formato YYYY-MM-DD
  487 │         availabilityUpdates[dateString] = false; // false significa indisponível
  488 │       });
  489 │       
  490 │       // Atualizar disponibilidade do quarto
  491 │       if (Object.keys(availabilityUpdates).length > 0) {
  492 │         try {
  493 │           // Obter o documento do quarto
  494 │           const roomRef = doc(db, 'rooms', roomId);
  495 │           const roomSnap = await getDoc(roomRef);
  496 │           
  497 │           if (roomSnap.exists()) {
  498 │             const roomData = roomSnap.data();
  499 │             const currentAvailability = roomData.availabilityDates || {};
  500 │             
  501 │             // Mesclar a disponibilidade atual com as novas atualizações
  502 │             const updatedAvailability = {
  503 │               ...currentAvailability,
  504 │               ...availabilityUpdates
  505 │             };
  506 │             
  507 │             // Atualizar o documento do quarto
  508 │             await updateDoc(roomRef, {
  509 │               availabilityDates: updatedAvailability,
  510 │               updatedAt: serverTimestamp()
  511 │             });
  512 │             
  513 │             console.log(`Disponibilidade atualizada com sucesso para quarto ${roomId}`);
  514 │             
  515 │             // Criar log da reserva
  516 │             await addDoc(collection(db, 'bookingLogs'), {
  517 │               bookingId,
  518 │               roomId,
  519 │               action: 'status_updated',
  520 │               previousStatus: bookingData.status,
  521 │               newStatus,
  522 │               previousPaymentStatus: bookingData.paymentStatus,
  523 │               newPaymentStatus,
  524 │               datesBlocked: Object.keys(availabilityUpdates),
  525 │               timestamp: serverTimestamp(),
  526 │               userId: bookingData.userId || 'system'
  527 │             });
  528 │           } else {
  529 │             console.error(`Quarto ${roomId} não encontrado ao atualizar disponibilidade`);
  530 │           }
  531 │         } catch (error) {
  532 │           console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  533 │         }
  534 │       }
  535 │     }
  536 │     
  537 │     return true;
  538 │   } catch (error) {
  539 │     console.error(`Erro ao atualizar status da reserva ${bookingId}:`, error);
  540 │     return false;
  541 │   }
  542 │ }
  543 │ 
  544 │ export const getUserBookings = async (userId: string): Promise<Booking[]> => {
  545 │   return getDocuments<Booking>('bookings', [
  546 │     where('userId', '==', userId),
  547 │     orderBy('createdAt', 'desc')
  548 │   ])
  549 │ }
  550 │ 
  551 │ export const getRecentBookings = async (count = 5): Promise<Booking[]> => {
  552 │   return getDocuments<Booking>('bookings', [
  553 │     orderBy('createdAt', 'desc'),
  554 │     limit(count)
  555 │   ])
  556 │ }
  557 │ 
  558 │ export const getRoomBookings = async (roomId: string): Promise<Booking[]> => {
  559 │   try {
  560 │     const constraints: QueryConstraint[] = [
  561 │       where('roomId', '==', roomId),
  562 │       orderBy('checkIn', 'asc')
  563 │     ];
  564 │     
  565 │     return await getDocuments<Booking>('bookings', constraints);
  566 │   } catch (error) {
  567 │     console.error(`Erro ao buscar reservas do quarto ${roomId}:`, error);
  568 │     return [];
  569 │   }
  570 │ };
  571 │ 
  572 │ // Funções específicas para contatos
  573 │ export const createContactMessage = async (contactData: Contact) => {
  574 │   try {
  575 │     const contactsCollection = collection(db, 'contacts')
  576 │     
  577 │     // Garantir que o status seja 'new' para novos contatos
  578 │     const contactWithDefaults = {
  579 │       ...contactData,
  580 │       status: contactData.status || 'new',
  581 │       createdAt: contactData.createdAt || Timestamp.now()
  582 │     }
  583 │     
  584 │     // Se tiver detalhes de reserva, adicionar metadados
  585 │     if (contactWithDefaults.reservationDetails) {
  586 │       // Ajustar subject para indicar que é relacionado a reserva
  587 │       if (!contactWithDefaults.subject.includes('Reserva')) {
  588 │         contactWithDefaults.subject = `Reserva: ${contactWithDefaults.subject}`;
  589 │       }
  590 │     }
  591 │     
  592 │     const docRef = await addDoc(contactsCollection, contactWithDefaults)
  593 │     return docRef
  594 │   } catch (error) {
  595 │     console.error('Erro ao criar mensagem de contato:', error)
  596 │     throw error
  597 │   }
  598 │ }
  599 │ 
  600 │ export const getNewContactMessages = async (): Promise<Contact[]> => {
  601 │   return getDocuments<Contact>('contacts', [
  602 │     where('status', '==', 'new'),
  603 │     orderBy('createdAt', 'desc')
  604 │   ])
  605 │ }
  606 │ 
  607 │ // Funções para Dashboard com dados reais
  608 │ 
  609 │ export const getDashboardStats = async () => {
  610 │   try {
  611 │     const [totalBookings, totalRevenue, occupancyRate, bookingsByPlatform] = await Promise.all([
  612 │       getTotalBookings(),
  613 │       getMonthlyRevenue(),
  614 │       getOccupancyRate(),
  615 │       getBookingsByPlatform()
  616 │     ]);
  617 │ 
  618 │     return {
  619 │       totalBookings,
  620 │       totalRevenue,
  621 │       occupancyRate,
  622 │       bookingsByPlatform
  623 │     };
  624 │   } catch (error) {
  625 │     console.error('Erro ao obter estatísticas do dashboard:', error);
  626 │     throw error;
  627 │   }
  628 │ };
  629 │ 
  630 │ // Obter total de reservas
  631 │ export const getTotalBookings = async () => {
  632 │   try {
  633 │     // Obter todas as reservas
  634 │     const bookings = await getDocuments<Booking>('bookings');
  635 │     
  636 │     // Contar reservas por status
  637 │     const confirmed = bookings.filter(b => b.status === 'confirmed').length;
  638 │     const pending = bookings.filter(b => b.status === 'pending').length;
  639 │     const cancelled = bookings.filter(b => b.status === 'cancelled').length;
  640 │     const completed = bookings.filter(b => b.status === 'completed').length;
  641 │     
  642 │     // Calcular crescimento em relação ao mês anterior (simulado por enquanto)
  643 │     // Em uma implementação real, você compararia com dados do mês anterior
  644 │     const growth = ((confirmed + completed) / (bookings.length || 1) * 100) - 50;
  645 │     
  646 │     return {
  647 │       total: bookings.length,
  648 │       confirmed,
  649 │       pending,
  650 │       cancelled,
  651 │       completed,
  652 │       growth: Math.round(growth) // Arredonda para número inteiro
  653 │     };
  654 │   } catch (error) {
  655 │     console.error('Erro ao obter total de reservas:', error);
  656 │     return {
  657 │       total: 0,
  658 │       confirmed: 0,
  659 │       pending: 0, 
  660 │       cancelled: 0,
  661 │       completed: 0,
  662 │       growth: 0
  663 │     };
  664 │   }
  665 │ };
  666 │ 
  667 │ // Obter receita mensal
  668 │ export const getMonthlyRevenue = async () => {
  669 │   try {
  670 │     const bookings = await getDocuments<Booking>('bookings');
  671 │     
  672 │     // Filtrar reservas confirmadas e concluídas
  673 │     const validBookings = bookings.filter(b => 
  674 │       b.status === 'confirmed' || b.status === 'completed'
  675 │     );
  676 │     
  677 │     // Calcular receita total
  678 │     const totalRevenue = validBookings.reduce((acc, booking) => acc + booking.totalPrice, 0);
  679 │     
  680 │     // Agrupar receita por mês
  681 │     const revenueByMonth = validBookings.reduce((acc, booking) => {
  682 │       const date = booking.checkIn.toDate();
  683 │       const month = date.getMonth(); // 0-11
  684 │       const year = date.getFullYear();
  685 │       const key = `${year}-${month}`;
  686 │       
  687 │       if (!acc[key]) {
  688 │         acc[key] = 0;
  689 │       }
  690 │       acc[key] += booking.totalPrice;
  691 │       return acc;
  692 │     }, {} as Record<string, number>);
  693 │     
  694 │     // Converter para formato de array para gráfico
  695 │     const monthNames = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
  696 │     
  697 │     const currentDate = new Date();
  698 │     const currentMonth = currentDate.getMonth();
  699 │     const currentYear = currentDate.getFullYear();
  700 │     
  701 │     const revenueData = [];
  702 │     
  703 │     // Gerar dados dos últimos 12 meses
  704 │     for (let i = 0; i < 12; i++) {
  705 │       const month = (currentMonth - i + 12) % 12;
  706 │       const year = currentMonth - i < 0 ? currentYear - 1 : currentYear;
  707 │       const key = `${year}-${month}`;
  708 │       
  709 │       revenueData.unshift({
  710 │         month: monthNames[month],
  711 │         value: revenueByMonth[key] || 0
  712 │       });
  713 │     }
  714 │     
  715 │     // Calcular crescimento em relação ao mês anterior
  716 │     const lastMonthRevenue = revenueData[revenueData.length - 2]?.value || 0;
  717 │     const currentMonthRevenue = revenueData[revenueData.length - 1]?.value || 0;
  718 │     
  719 │     const growth = lastMonthRevenue ? ((currentMonthRevenue - lastMonthRevenue) / lastMonthRevenue) * 100 : 0;
  720 │     
  721 │     return {
  722 │       monthly: currentMonthRevenue,
  723 │       total: totalRevenue,
  724 │       growth: Math.round(growth),
  725 │       revenueData
  726 │     };
  727 │   } catch (error) {
  728 │     console.error('Erro ao obter receita mensal:', error);
  729 │     return {
  730 │       monthly: 0,
  731 │       total: 0,
  732 │       growth: 0,
  733 │       revenueData: []
  734 │     };
  735 │   }
  736 │ };
  737 │ 
  738 │ // Calcular taxa de ocupação
  739 │ export const getOccupancyRate = async () => {
  740 │   try {
  741 │     // Obter todos os quartos
  742 │     const rooms = await getDocuments<Room>('rooms');
  743 │     const totalRooms = rooms.length;
  744 │     
  745 │     if (totalRooms === 0) {
  746 │       return { rate: 0, growth: 0 };
  747 │     }
  748 │     
  749 │     // Obter todas as reservas
  750 │     const bookings = await getDocuments<Booking>('bookings');
  751 │     
  752 │     // Filtrar reservas confirmadas e concluídas para o mês atual
  753 │     const currentDate = new Date();
  754 │     const currentMonth = currentDate.getMonth();
  755 │     const currentYear = currentDate.getFullYear();
  756 │     
  757 │     const currentMonthBookings = bookings.filter(booking => {
  758 │       const checkInDate = booking.checkIn.toDate();
  759 │       return (
  760 │         (booking.status === 'confirmed' || booking.status === 'completed') &&
  761 │         checkInDate.getMonth() === currentMonth &&
  762 │         checkInDate.getFullYear() === currentYear
  763 │       );
  764 │     });
  765 │     
  766 │     // Calcular dias ocupados por quarto
  767 │     const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
  768 │     const totalPossibleRoomDays = totalRooms * daysInMonth;
  769 │     
  770 │     // Contar dias ocupados (simplificado - em produção seria mais complexo)
  771 │     let occupiedDays = 0;
  772 │     
  773 │     currentMonthBookings.forEach(booking => {
  774 │       const checkIn = booking.checkIn.toDate();
  775 │       const checkOut = booking.checkOut.toDate();
  776 │       
  777 │       // Ajustar datas para considerar apenas o mês atual
  778 │       const startDate = new Date(Math.max(
  779 │         checkIn.getTime(),
  780 │         new Date(currentYear, currentMonth, 1).getTime()
  781 │       ));
  782 │       const endDate = new Date(Math.min(
  783 │         checkOut.getTime(),
  784 │         new Date(currentYear, currentMonth + 1, 0).getTime()
  785 │       ));
  786 │       
  787 │       // Calcular dias entre datas (incluindo check-in, excluindo check-out)
  788 │       const days = Math.max(0, Math.floor((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)));
  789 │       occupiedDays += days;
  790 │     });
  791 │     
  792 │     const occupancyRate = (occupiedDays / totalPossibleRoomDays) * 100;
  793 │     
  794 │     // Simulação de crescimento (em produção, compararia com mês anterior)
  795 │     const growth = occupancyRate > 50 ? 5 : -3;
  796 │     
  797 │     return {
  798 │       rate: Math.round(occupancyRate),
  799 │       growth: Math.round(growth)
  800 │     };
  801 │   } catch (error) {
  802 │     console.error('Erro ao calcular taxa de ocupação:', error);
  803 │     return { rate: 0, growth: 0 };
  804 │   }
  805 │ };
  806 │ 
  807 │ // Obter reservas agrupadas por plataforma
  808 │ export const getBookingsByPlatform = async () => {
  809 │   try {
  810 │     const bookings = await getDocuments<Booking>('bookings');
  811 │     
  812 │     // Categorizar reservas por origem
  813 │     const platforms = [
  814 │       { 
  815 │         platform: "Booking.com", 
  816 │         color: "#003580", 
  817 │         icon: "Globe",
  818 │         bookings: []
  819 │       },
  820 │       { 
  821 │         platform: "Airbnb", 
  822 │         color: "#FF5A5F", 
  823 │         icon: "Heart",
  824 │         bookings: []
  825 │       },
  826 │       { 
  827 │         platform: "Direto", 
  828 │         color: "#4CAF50", 
  829 │         icon: "Home",
  830 │         bookings: []
  831 │       }
  832 │     ];
  833 │     
  834 │     // Para fins de demonstração, colocar todas as reservas como "Direto" por enquanto
  835 │     // Em produção, usaria um campo "platformOrigin" ou similar na tabela de reservas
  836 │     const platformIndex = 2; // Índice da plataforma "Direto"
  837 │     
  838 │     bookings.forEach(booking => {
  839 │       // Transformar para o formato esperado pelo componente
  840 │       const transformedBooking = {
  841 │         id: booking.id || '',
  842 │         guestName: booking.guestName,
  843 │         roomName: booking.roomName,
  844 │         checkIn: booking.checkIn.toDate().toLocaleDateString('pt-PT'),
  845 │         checkOut: booking.checkOut.toDate().toLocaleDateString('pt-PT'),
  846 │         status: booking.status,
  847 │         value: new Intl.NumberFormat('pt-PT', {
  848 │           style: 'currency',
  849 │           currency: 'EUR'
  850 │         }).format(booking.totalPrice)
  851 │       };
  852 │       
  853 │       // Adicionar à plataforma "Direto"
  854 │       (platforms[platformIndex] as any).bookings.push(transformedBooking);
  855 │     });
  856 │     
  857 │     return platforms;
  858 │   } catch (error) {
  859 │     console.error('Erro ao obter reservas por plataforma:', error);
  860 │     return [];
  861 │   }
  862 │ };
  863 │ 
  864 │ // Função para obter o preço de um quarto para uma data específica
  865 │ export const getRoomPriceForDate = async (roomId: string, date: Date): Promise<number> => {
  866 │   try {
  867 │     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  868 │     
  869 │     if (!roomDoc.exists()) {
  870 │       throw new Error("Quarto não encontrado");
  871 │     }
  872 │     
  873 │     const roomData = roomDoc.data() as Room;
  874 │     const basePrice = roomData.price;
  875 │     
  876 │     if (!roomData.seasonalPrices || roomData.seasonalPrices.length === 0) {
  877 │       return basePrice;
  878 │     }
  879 │     
  880 │     // Verificar se a data está dentro de algum período sazonal
  881 │     for (const seasonalPrice of roomData.seasonalPrices) {
  882 │       const startDate = new Date(seasonalPrice.startDate);
  883 │       const endDate = new Date(seasonalPrice.endDate);
  884 │       
  885 │       if (date >= startDate && date <= endDate) {
  886 │         return seasonalPrice.price;
  887 │       }
  888 │     }
  889 │     
  890 │     // Se não cair em nenhum período sazonal, retorna o preço base
  891 │     return basePrice;
  892 │   } catch (error) {
  893 │     console.error("Erro ao obter preço do quarto:", error);
  894 │     throw error;
  895 │   }
  896 │ }
  897 │ 
  898 │ // Função para calcular o preço total de uma estadia
  899 │ export const calculateStayPrice = async (
  900 │   roomId: string, 
  901 │   checkIn: Date, 
  902 │   checkOut: Date
  903 │ ): Promise<{
  904 │   totalPrice: number;
  905 │   nightlyPrices: { date: string; price: number }[];
  906 │   serviceFee: number;
  907 │   totalWithFee: number;
  908 │ }> => {
  909 │   try {
  910 │     console.log(`🔍 Iniciando cálculo de preço para estadia: ${checkIn.toISOString().split('T')[0]} até ${checkOut.toISOString().split('T')[0]}`);
  911 │     
  912 │     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  913 │     
  914 │     if (!roomDoc.exists()) {
  915 │       throw new Error("Quarto não encontrado");
  916 │     }
  917 │     
  918 │     const roomData = roomDoc.data() as Room;
  919 │     console.log(`📝 Dados do quarto ${roomId}:`, {
  920 │       nome: roomData.name,
  921 │       precoBase: roomData.price,
  922 │       taxaServico: roomData.serviceFeePct || 0,
  923 │       temPrecosSazonais: !!roomData.seasonalPrices?.length
  924 │     });
  925 │     
  926 │     const nightlyPrices: { date: string; price: number }[] = [];
  927 │     let totalPrice = 0;
  928 │     
  929 │     // Calcular o número de noites - corrigido para usar o método correto de cálculo
  930 │     // O número de noites é a diferença em dias (estadia = checkout - checkin)
  931 │     const noites = differenceInDays(checkOut, checkIn);
  932 │     console.log(`🗓️ Número de noites calculado: ${noites}`);
  933 │     
  934 │     if (noites <= 0) {
  935 │       console.error(`⚠️ Erro: número de noites inválido (${noites})`);
  936 │       throw new Error("Data de check-out deve ser posterior à data de check-in");
  937 │     }
  938 │     
  939 │     // Para cada noite, verificar o preço aplicável (preço base ou sazonal)
  940 │     // Começamos exatamente do dia de check-in
  941 │     const currentDate = new Date(checkIn);
  942 │     currentDate.setHours(0, 0, 0, 0); // Normalizar para meia-noite
  943 │     
  944 │     // Processamos cada dia de estadia (noite)
  945 │     console.log(`📊 Calculando preços por noite:`);
  946 │     for (let i = 0; i < noites; i++) {
  947 │       // Obtemos o preço para esta data
  948 │       const dateCopy = new Date(currentDate);
  949 │       const priceForDate = await getRoomPriceForDate(roomId, dateCopy);
  950 │       const dateString = dateCopy.toISOString().split('T')[0]; // YYYY-MM-DD
  951 │       
  952 │       console.log(`   - ${dateString}: €${priceForDate}`);
  953 │       
  954 │       nightlyPrices.push({
  955 │         date: dateString,
  956 │         price: priceForDate
  957 │       });
  958 │       
  959 │       totalPrice += priceForDate;
  960 │       
  961 │       // Avançamos para o próximo dia
  962 │       currentDate.setDate(currentDate.getDate() + 1);
  963 │     }
  964 │     
  965 │     // Verificação de segurança para o cálculo do totalPrice
  966 │     const manualTotal = nightlyPrices.reduce((sum, night) => sum + night.price, 0);
  967 │     if (Math.abs(totalPrice - manualTotal) > 1) {
  968 │       console.error(`⚠️ Discrepância detectada no cálculo do preço total!`);
  969 │       console.error(`   - Total calculado iterativamente: €${totalPrice}`);
  970 │       console.error(`   - Total calculado via reduce: €${manualTotal}`);
  971 │       console.error(`   - Usando o valor recalculado para segurança!`);
  972 │       totalPrice = manualTotal;
  973 │     }
  974 │     
  975 │     // Calcular taxa de serviço
  976 │     const serviceFee = (totalPrice * (roomData.serviceFeePct || 0)) / 100;
  977 │     const totalWithFee = totalPrice + serviceFee;
  978 │     
  979 │     console.log(`💰 Resumo do cálculo:`);
  980 │     console.log(`   - Total das diárias: €${totalPrice}`);
  981 │     console.log(`   - Taxa de serviço (${roomData.serviceFeePct || 0}%): €${serviceFee}`);
  982 │     console.log(`   - Total com taxas: €${totalWithFee}`);
  983 │     
  984 │     return {
  985 │       totalPrice,
  986 │       nightlyPrices,
  987 │       serviceFee,
  988 │       totalWithFee
  989 │     };
  990 │   } catch (error) {
  991 │     console.error("❌ Erro ao calcular preço da estadia:", error);
  992 │     throw error;
  993 │   }
  994 │ } 
  995 │ import { 
  996 │   collection, 
  997 │   getDocs, 
  998 │   getDoc, 
  999 │   doc, 
 1000 │   setDoc, 
 1001 │   addDoc, 
 1002 │   updateDoc, 
 1003 │   deleteDoc,
 1004 │   query,
 1005 │   where,
      ·   ──┬──
      ·     ╰── `where` redefined here
 1006 │   orderBy,
 1007 │   limit,
 1008 │   serverTimestamp
      ╰────

  × the name `orderBy` is defined multiple times
      ╭─[/home/runner/workspace/lib/firebase/firestore.ts:9:1]
    9 │   deleteDoc,
   10 │   query,
   11 │   where,
   12 │   orderBy,
      ·   ───┬───
      ·      ╰── previous definition of `orderBy` here
   13 │   limit,
   14 │   DocumentData,
   15 │   QueryConstraint,
   16 │   Timestamp,
   17 │   serverTimestamp
   18 │ } from 'firebase/firestore'
   19 │ import { db } from './config'
   20 │ import { Room, SeasonalPrice } from '@/lib/types'
   21 │ import { differenceInDays } from 'date-fns'
   22 │ 
   23 │ // Tipos de dados
   24 │ export interface Booking {
   25 │   id?: string
   26 │   userId?: string
   27 │   guestName: string
   28 │   guestEmail: string
   29 │   guestPhone: string
   30 │   roomId: string
   31 │   roomName: string
   32 │   checkIn: Timestamp
   33 │   checkOut: Timestamp
   34 │   adults: number
   35 │   children: number
   36 │   totalPrice: number
   37 │   status: 'pending' | 'confirmed' | 'cancelled' | 'completed'
   38 │   paymentStatus: 'pending' | 'paid' | 'refunded'
   39 │   specialRequests?: string
   40 │   createdAt?: Timestamp
   41 │   updatedAt?: Timestamp
   42 │ }
   43 │ 
   44 │ export interface Contact {
   45 │   id?: string
   46 │   name: string
   47 │   email: string
   48 │   phone?: string
   49 │   subject: string
   50 │   message: string
   51 │   status: 'new' | 'read' | 'replied'
   52 │   createdAt: Timestamp
   53 │   updatedAt?: Timestamp
   54 │   repliedAt?: Timestamp
   55 │   replyContent?: string
   56 │   reservationDetails?: {
   57 │     checkIn?: Timestamp
   58 │     checkOut?: Timestamp
   59 │     roomId?: string
   60 │     roomName?: string
   61 │     totalGuests?: number
   62 │     totalPrice?: number
   63 │   }
   64 │ }
   65 │ 
   66 │ // Funções genéricas para CRUD
   67 │ export const createDocument = async <T extends DocumentData>(
   68 │   collectionName: string,
   69 │   data: T
   70 │ ): Promise<string> => {
   71 │   const docRef = await addDoc(collection(db, collectionName), {
   72 │     ...data,
   73 │     createdAt: serverTimestamp(),
   74 │     updatedAt: serverTimestamp()
   75 │   })
   76 │   return docRef.id
   77 │ }
   78 │ 
   79 │ export const createDocumentWithId = async <T extends DocumentData>(
   80 │   collectionName: string,
   81 │   id: string,
   82 │   data: T
   83 │ ): Promise<void> => {
   84 │   await setDoc(doc(db, collectionName, id), {
   85 │     ...data,
   86 │     createdAt: serverTimestamp(),
   87 │     updatedAt: serverTimestamp()
   88 │   })
   89 │ }
   90 │ 
   91 │ export const getDocument = async <T>(
   92 │   collectionName: string,
   93 │   id: string
   94 │ ): Promise<T | null> => {
   95 │   const docRef = doc(db, collectionName, id)
   96 │   const docSnap = await getDoc(docRef)
   97 │   
   98 │   if (docSnap.exists()) {
   99 │     const data = docSnap.data();
  100 │     console.log("Dados brutos recuperados do Firestore para quarto:", id, data);
  101 │     
  102 │     if (data?.serviceFeePct !== undefined) {
  103 │       console.log("serviceFeePct antes da conversão:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
  104 │       // Garantir que serviceFeePct seja um número
  105 │       data.serviceFeePct = Number(data.serviceFeePct);
  106 │       console.log("serviceFeePct após conversão:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
  107 │     }
  108 │     
  109 │     return { id: docSnap.id, ...data } as T
  110 │   } else {
  111 │     return null
  112 │   }
  113 │ }
  114 │ 
  115 │ export const getDocuments = async <T>(
  116 │   collectionName: string,
  117 │   constraints: QueryConstraint[] = [],
  118 │   forceRefresh = false
  119 │ ): Promise<T[]> => {
  120 │   try {
  121 │     const collectionRef = collection(db, collectionName)
  122 │     const q = query(collectionRef, ...constraints)
  123 │     
  124 │     // Se forceRefresh for verdadeiro, adicionar opções que forçam uma nova consulta ao Firestore
  125 │     const querySnapshot = await getDocs(q)
  126 │     
  127 │     console.log(`Buscando documentos na coleção ${collectionName} - Força atualização: ${forceRefresh}`);
  128 │     
  129 │     return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }) as T)
  130 │   } catch (error) {
  131 │     console.error(`Erro ao buscar documentos da coleção ${collectionName}:`, error);
  132 │     return [];
  133 │   }
  134 │ }
  135 │ 
  136 │ export const updateDocument = async <T extends DocumentData>(
  137 │   collectionName: string,
  138 │   id: string,
  139 │   data: Partial<T>
  140 │ ): Promise<void> => {
  141 │   const docRef = doc(db, collectionName, id)
  142 │   await updateDoc(docRef, {
  143 │     ...data,
  144 │     updatedAt: serverTimestamp()
  145 │   })
  146 │ }
  147 │ 
  148 │ export const deleteDocument = async (
  149 │   collectionName: string,
  150 │   id: string
  151 │ ): Promise<boolean> => {
  152 │   const docRef = doc(db, collectionName, id)
  153 │   await deleteDoc(docRef)
  154 │   return true
  155 │ }
  156 │ 
  157 │ // Funções para gerenciar quartos
  158 │ export const getRooms = async (forceRefresh = false): Promise<Room[]> => {
  159 │   try {
  160 │     const constraints: QueryConstraint[] = []
  161 │     
  162 │     constraints.push(orderBy('name', 'asc'))
  163 │     
  164 │     const rooms = await getDocuments<Room>('rooms', constraints, forceRefresh)
  165 │     
  166 │     // Garantir que todos os campos necessários estejam presentes
  167 │     return rooms.map(room => {
  168 │       console.log(`Firebase - Quarto ${room.id} dados brutos:`, room);
  169 │       
  170 │       // Garantir que serviceFeePct seja um número
  171 │       const serviceFeePct = room.serviceFeePct !== undefined 
  172 │         ? Number(room.serviceFeePct) 
  173 │         : 10;
  174 │         
  175 │       console.log(`Firebase - Quarto ${room.id} serviceFeePct:`, {
  176 │         original: room.serviceFeePct,
  177 │         tipo: typeof room.serviceFeePct,
  178 │         convertido: serviceFeePct
  179 │       });
  180 │       
  181 │       return {
  182 │         id: room.id,
  183 │         name: room.name || '',
  184 │         type: room.type || 'standard',
  185 │         description: room.description || '',
  186 │         price: room.price || 0,
  187 │         capacity: room.capacity || 2,
  188 │         size: room.size || 0,
  189 │         available: room.available !== undefined ? room.available : true,
  190 │         serviceFeePct: serviceFeePct,
  191 │         images: room.images || [],
  192 │         amenities: room.amenities || [],
  193 │         additionalServices: room.additionalServices || [],
  194 │         highlights: room.highlights || [],
  195 │         createdAt: room.createdAt,
  196 │         updatedAt: room.updatedAt
  197 │       };
  198 │     });
  199 │   } catch (error) {
  200 │     console.error('Erro ao buscar quartos:', error)
  201 │     return []
  202 │   }
  203 │ }
  204 │ 
  205 │ export const getAvailableRooms = async (
  206 │   checkIn: Date,
  207 │   checkOut: Date
  208 │ ): Promise<Room[]> => {
  209 │   try {
  210 │     // Buscar todos os quartos que estão marcados como disponíveis em geral
  211 │     const constraints: QueryConstraint[] = [
  212 │       where('available', '==', true)
  213 │     ]
  214 │     
  215 │     const rooms = await getDocuments<Room>('rooms', constraints);
  216 │     
  217 │     // Filtrar os quartos que estão disponíveis nas datas específicas
  218 │     return filterAvailableRoomsByDate(rooms, checkIn, checkOut);
  219 │   } catch (error) {
  220 │     console.error('Erro ao buscar quartos disponíveis:', error)
  221 │     return []
  222 │   }
  223 │ }
  224 │ 
  225 │ // Função auxiliar para verificar disponibilidade entre datas
  226 │ export const filterAvailableRoomsByDate = (
  227 │   rooms: Room[],
  228 │   checkIn: Date,
  229 │   checkOut: Date
  230 │ ): Room[] => {
  231 │   // Converter checkIn e checkOut para ISO strings
  232 │   const dateStrings = getDatesInRange(checkIn, checkOut);
  233 │   
  234 │   return rooms.filter(room => {
  235 │     // Se não tiver controle de disponibilidade específico, considera disponível
  236 │     if (!room.availabilityDates) return true;
  237 │     
  238 │     // Verificar se alguma data no intervalo está indisponível
  239 │     return !dateStrings.some(dateStr => 
  240 │       room.availabilityDates?.[dateStr] === false
  241 │     );
  242 │   });
  243 │ };
  244 │ 
  245 │ // Função para obter disponibilidade de um quarto específico
  246 │ export const getRoomAvailability = async (
  247 │   roomId: string, 
  248 │   startDate: Date, 
  249 │   endDate: Date
  250 │ ): Promise<{[date: string]: boolean}> => {
  251 │   try {
  252 │     const room = await getRoomById(roomId);
  253 │     if (!room) throw new Error(`Quarto com ID ${roomId} não encontrado`);
  254 │     
  255 │     // Gerar datas no intervalo
  256 │     const dateStrings = getDatesInRange(startDate, endDate);
  257 │     
  258 │     // Se não tiver configuração de disponibilidade específica, assume tudo disponível
  259 │     if (!room.availabilityDates) {
  260 │       return dateStrings.reduce((acc, date) => {
  261 │         acc[date] = true;
  262 │         return acc;
  263 │       }, {} as {[date: string]: boolean});
  264 │     }
  265 │     
  266 │     // Preencher com os dados de disponibilidade existentes
  267 │     return dateStrings.reduce((acc, date) => {
  268 │       acc[date] = room.availabilityDates?.[date] !== false; // disponível por padrão se não estiver explicitamente indisponível
  269 │       return acc;
  270 │     }, {} as {[date: string]: boolean});
  271 │   } catch (error) {
  272 │     console.error(`Erro ao verificar disponibilidade do quarto ${roomId}:`, error);
  273 │     throw error;
  274 │   }
  275 │ };
  276 │ 
  277 │ // Função para atualizar disponibilidade de um quarto
  278 │ export const updateRoomAvailability = async (
  279 │   roomId: string,
  280 │   availabilityDates: {[date: string]: boolean}
  281 │ ): Promise<boolean> => {
  282 │   try {
  283 │     await updateDocument('rooms', roomId, {
  284 │       availabilityDates,
  285 │       updatedAt: serverTimestamp()
  286 │     });
  287 │     return true;
  288 │   } catch (error) {
  289 │     console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  290 │     return false;
  291 │   }
  292 │ };
  293 │ 
  294 │ // Função auxiliar para gerar array de strings de data entre um intervalo
  295 │ export const getDatesInRange = (startDate: Date, endDate: Date): string[] => {
  296 │   const dates: string[] = [];
  297 │   const currentDate = new Date(startDate);
  298 │   
  299 │   // Normalizar para meia-noite no fuso horário local
  300 │   currentDate.setHours(0, 0, 0, 0);
  301 │   const endDateNormalized = new Date(endDate);
  302 │   endDateNormalized.setHours(0, 0, 0, 0);
  303 │   
  304 │   // Adicionar cada data no intervalo EXCETO o dia de checkout
  305 │   // Usando < em vez de <= para não incluir o dia de checkout
  306 │   while (currentDate < endDateNormalized) {
  307 │     dates.push(currentDate.toISOString().split('T')[0]); // Formato YYYY-MM-DD
  308 │     currentDate.setDate(currentDate.getDate() + 1);
  309 │   }
  310 │   
  311 │   return dates;
  312 │ };
  313 │ 
  314 │ export const getRoomById = async (id: string): Promise<Room | null> => {
  315 │   try {
  316 │     const room = await getDocument<Room>('rooms', id);
  317 │     
  318 │     if (!room) return null;
  319 │     
  320 │     console.log(`Firebase - getRoomById ${id} dados brutos:`, room);
  321 │     
  322 │     // Log específico para serviceFeePct
  323 │     console.log(`serviceFeePct no Firestore:`, room.serviceFeePct);
  324 │     
  325 │     // Garantir que todos os campos necessários estejam presentes
  326 │     return {
  327 │       ...room,
  328 │       name: room.name || '',
  329 │       type: room.type || 'standard',
  330 │       description: room.description || '',
  331 │       price: room.price || 0,
  332 │       capacity: room.capacity || 2,
  333 │       size: room.size || 0,
  334 │       available: room.available !== undefined ? room.available : true,
  335 │       serviceFeePct: room.serviceFeePct !== undefined ? room.serviceFeePct : 10,
  336 │       images: room.images || [],
  337 │       amenities: room.amenities || [],
  338 │       additionalServices: room.additionalServices || [],
  339 │       highlights: room.highlights || []
  340 │     };
  341 │   } catch (error) {
  342 │     console.error(`Erro ao buscar quarto com ID ${id}:`, error);
  343 │     return null;
  344 │   }
  345 │ }
  346 │ 
  347 │ export const createRoom = async (roomData: Omit<Room, 'id' | 'createdAt' | 'updatedAt'>): Promise<Room> => {
  348 │   try {
  349 │     console.log("createRoom - Dados recebidos:", roomData);
  350 │     
  351 │     const roomWithTimestamps = {
  352 │       ...roomData,
  353 │       available: roomData.available !== undefined ? roomData.available : true,
  354 │       featured: roomData.featured || false,
  355 │       amenities: roomData.amenities || [],
  356 │       additionalServices: roomData.additionalServices || [],
  357 │       highlights: roomData.highlights || [],
  358 │       createdAt: serverTimestamp(),
  359 │       updatedAt: serverTimestamp()
  360 │     }
  361 │     
  362 │     console.log("createRoom - Dados a serem salvos:", roomWithTimestamps);
  363 │     
  364 │     const id = await createDocument('rooms', roomWithTimestamps)
  365 │     
  366 │     return {
  367 │       id,
  368 │       ...roomData,
  369 │       amenities: roomData.amenities || [],
  370 │       additionalServices: roomData.additionalServices || [],
  371 │       highlights: roomData.highlights || [],
  372 │       createdAt: Timestamp.now(),
  373 │       updatedAt: Timestamp.now()
  374 │     }
  375 │   } catch (error) {
  376 │     console.error('Erro ao criar quarto:', error)
  377 │     throw error
  378 │   }
  379 │ }
  380 │ 
  381 │ export const updateRoom = async (id: string, roomData: Partial<Omit<Room, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Room> => {
  382 │   try {
  383 │     console.log(`updateRoom - ID: ${id}, Dados recebidos:`, roomData);
  384 │     
  385 │     // Garantir que estamos lidando explicitamente com o serviceFeePct se ele for 0
  386 │     if (roomData.serviceFeePct === 0) {
  387 │       console.log("updateRoom - Detectado serviceFeePct com valor 0, salvando explicitamente.", roomData.serviceFeePct);
  388 │     }
  389 │     
  390 │     // Adicionar timestamp de atualização
  391 │     const roomWithTimestamp = {
  392 │       ...roomData,
  393 │       amenities: roomData.amenities || [],
  394 │       additionalServices: roomData.additionalServices || [],
  395 │       highlights: roomData.highlights || [],
  396 │       updatedAt: serverTimestamp()
  397 │     }
  398 │     
  399 │     console.log(`updateRoom - Dados a serem salvos:`, roomWithTimestamp);
  400 │     
  401 │     await updateDocument('rooms', id, roomWithTimestamp)
  402 │     
  403 │     const updatedRoom = await getRoomById(id)
  404 │     if (!updatedRoom) {
  405 │       throw new Error(`Quarto com ID ${id} não encontrado após atualização`)
  406 │     }
  407 │     
  408 │     return updatedRoom
  409 │   } catch (error) {
  410 │     console.error('Erro ao atualizar quarto:', error)
  411 │     throw error
  412 │   }
  413 │ }
  414 │ 
  415 │ export const deleteRoom = async (id: string): Promise<boolean> => {
  416 │   return await deleteDocument('rooms', id)
  417 │ }
  418 │ 
  419 │ // Funções específicas para reservas
  420 │ export const createBooking = async (bookingData: any) => {
  421 │   try {
  422 │     const bookingsCollection = collection(db, 'bookings');
  423 │     const docRef = await addDoc(bookingsCollection, bookingData);
  424 │     
  425 │     // CORREÇÃO: Não bloquear a data no momento da criação da reserva
  426 │     // O bloqueio será feito apenas quando o pagamento for confirmado
  427 │     // através da função updateBookingStatus
  428 │     
  429 │     return docRef;
  430 │   } catch (error) {
  431 │     console.error('Erro ao criar reserva:', error);
  432 │     throw error;
  433 │   }
  434 │ };
  435 │ 
  436 │ // Nova função para atualizar status da reserva e bloquear as datas da estadia
  437 │ export const updateBookingStatus = async (
  438 │   bookingId: string, 
  439 │   newStatus: 'pending' | 'confirmed' | 'cancelled' | 'completed',
  440 │   newPaymentStatus: 'pending' | 'paid' | 'refunded'
  441 │ ): Promise<boolean> => {
  442 │   try {
  443 │     // Referência ao documento da reserva
  444 │     const bookingRef = doc(db, 'bookings', bookingId);
  445 │     const bookingSnap = await getDoc(bookingRef);
  446 │     
  447 │     if (!bookingSnap.exists()) {
  448 │       console.error(`Booking ${bookingId} não existe ao atualizar status`);
  449 │       return false;
  450 │     }
  451 │     
  452 │     const bookingData = bookingSnap.data();
  453 │     
  454 │     // Atualizar o status da reserva
  455 │     await updateDoc(bookingRef, {
  456 │       status: newStatus,
  457 │       paymentStatus: newPaymentStatus,
  458 │       updatedAt: serverTimestamp(),
  459 │       ...(newStatus === 'confirmed' && { confirmedAt: serverTimestamp() })
  460 │     });
  461 │     
  462 │     // Se a reserva está sendo confirmada, precisamos bloquear as datas
  463 │     if (newStatus === 'confirmed') {
  464 │       console.log(`Atualizando disponibilidade para reserva confirmada: ${bookingId}`);
  465 │       
  466 │       // Recuperar datas de check-in e check-out
  467 │       const checkIn = bookingData.checkIn.toDate();
  468 │       const checkOut = bookingData.checkOut.toDate();
  469 │       const roomId = bookingData.roomId;
  470 │       
  471 │       // Obter todas as datas entre check-in e check-out
  472 │       const dates: Date[] = [];
  473 │       const currentDate = new Date(checkIn);
  474 │       
  475 │       while (currentDate < checkOut) {
  476 │         dates.push(new Date(currentDate));
  477 │         currentDate.setDate(currentDate.getDate() + 1);
  478 │       }
  479 │       
  480 │       console.log(`Bloqueando ${dates.length} dias para quarto ${roomId}`);
  481 │       
  482 │       // Atualizar disponibilidade para cada data
  483 │       const availabilityUpdates: {[date: string]: boolean} = {};
  484 │       
  485 │       dates.forEach(date => {
  486 │         const dateString = date.toISOString().split('T')[0]; // formato YYYY-MM-DD
  487 │         availabilityUpdates[dateString] = false; // false significa indisponível
  488 │       });
  489 │       
  490 │       // Atualizar disponibilidade do quarto
  491 │       if (Object.keys(availabilityUpdates).length > 0) {
  492 │         try {
  493 │           // Obter o documento do quarto
  494 │           const roomRef = doc(db, 'rooms', roomId);
  495 │           const roomSnap = await getDoc(roomRef);
  496 │           
  497 │           if (roomSnap.exists()) {
  498 │             const roomData = roomSnap.data();
  499 │             const currentAvailability = roomData.availabilityDates || {};
  500 │             
  501 │             // Mesclar a disponibilidade atual com as novas atualizações
  502 │             const updatedAvailability = {
  503 │               ...currentAvailability,
  504 │               ...availabilityUpdates
  505 │             };
  506 │             
  507 │             // Atualizar o documento do quarto
  508 │             await updateDoc(roomRef, {
  509 │               availabilityDates: updatedAvailability,
  510 │               updatedAt: serverTimestamp()
  511 │             });
  512 │             
  513 │             console.log(`Disponibilidade atualizada com sucesso para quarto ${roomId}`);
  514 │             
  515 │             // Criar log da reserva
  516 │             await addDoc(collection(db, 'bookingLogs'), {
  517 │               bookingId,
  518 │               roomId,
  519 │               action: 'status_updated',
  520 │               previousStatus: bookingData.status,
  521 │               newStatus,
  522 │               previousPaymentStatus: bookingData.paymentStatus,
  523 │               newPaymentStatus,
  524 │               datesBlocked: Object.keys(availabilityUpdates),
  525 │               timestamp: serverTimestamp(),
  526 │               userId: bookingData.userId || 'system'
  527 │             });
  528 │           } else {
  529 │             console.error(`Quarto ${roomId} não encontrado ao atualizar disponibilidade`);
  530 │           }
  531 │         } catch (error) {
  532 │           console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  533 │         }
  534 │       }
  535 │     }
  536 │     
  537 │     return true;
  538 │   } catch (error) {
  539 │     console.error(`Erro ao atualizar status da reserva ${bookingId}:`, error);
  540 │     return false;
  541 │   }
  542 │ }
  543 │ 
  544 │ export const getUserBookings = async (userId: string): Promise<Booking[]> => {
  545 │   return getDocuments<Booking>('bookings', [
  546 │     where('userId', '==', userId),
  547 │     orderBy('createdAt', 'desc')
  548 │   ])
  549 │ }
  550 │ 
  551 │ export const getRecentBookings = async (count = 5): Promise<Booking[]> => {
  552 │   return getDocuments<Booking>('bookings', [
  553 │     orderBy('createdAt', 'desc'),
  554 │     limit(count)
  555 │   ])
  556 │ }
  557 │ 
  558 │ export const getRoomBookings = async (roomId: string): Promise<Booking[]> => {
  559 │   try {
  560 │     const constraints: QueryConstraint[] = [
  561 │       where('roomId', '==', roomId),
  562 │       orderBy('checkIn', 'asc')
  563 │     ];
  564 │     
  565 │     return await getDocuments<Booking>('bookings', constraints);
  566 │   } catch (error) {
  567 │     console.error(`Erro ao buscar reservas do quarto ${roomId}:`, error);
  568 │     return [];
  569 │   }
  570 │ };
  571 │ 
  572 │ // Funções específicas para contatos
  573 │ export const createContactMessage = async (contactData: Contact) => {
  574 │   try {
  575 │     const contactsCollection = collection(db, 'contacts')
  576 │     
  577 │     // Garantir que o status seja 'new' para novos contatos
  578 │     const contactWithDefaults = {
  579 │       ...contactData,
  580 │       status: contactData.status || 'new',
  581 │       createdAt: contactData.createdAt || Timestamp.now()
  582 │     }
  583 │     
  584 │     // Se tiver detalhes de reserva, adicionar metadados
  585 │     if (contactWithDefaults.reservationDetails) {
  586 │       // Ajustar subject para indicar que é relacionado a reserva
  587 │       if (!contactWithDefaults.subject.includes('Reserva')) {
  588 │         contactWithDefaults.subject = `Reserva: ${contactWithDefaults.subject}`;
  589 │       }
  590 │     }
  591 │     
  592 │     const docRef = await addDoc(contactsCollection, contactWithDefaults)
  593 │     return docRef
  594 │   } catch (error) {
  595 │     console.error('Erro ao criar mensagem de contato:', error)
  596 │     throw error
  597 │   }
  598 │ }
  599 │ 
  600 │ export const getNewContactMessages = async (): Promise<Contact[]> => {
  601 │   return getDocuments<Contact>('contacts', [
  602 │     where('status', '==', 'new'),
  603 │     orderBy('createdAt', 'desc')
  604 │   ])
  605 │ }
  606 │ 
  607 │ // Funções para Dashboard com dados reais
  608 │ 
  609 │ export const getDashboardStats = async () => {
  610 │   try {
  611 │     const [totalBookings, totalRevenue, occupancyRate, bookingsByPlatform] = await Promise.all([
  612 │       getTotalBookings(),
  613 │       getMonthlyRevenue(),
  614 │       getOccupancyRate(),
  615 │       getBookingsByPlatform()
  616 │     ]);
  617 │ 
  618 │     return {
  619 │       totalBookings,
  620 │       totalRevenue,
  621 │       occupancyRate,
  622 │       bookingsByPlatform
  623 │     };
  624 │   } catch (error) {
  625 │     console.error('Erro ao obter estatísticas do dashboard:', error);
  626 │     throw error;
  627 │   }
  628 │ };
  629 │ 
  630 │ // Obter total de reservas
  631 │ export const getTotalBookings = async () => {
  632 │   try {
  633 │     // Obter todas as reservas
  634 │     const bookings = await getDocuments<Booking>('bookings');
  635 │     
  636 │     // Contar reservas por status
  637 │     const confirmed = bookings.filter(b => b.status === 'confirmed').length;
  638 │     const pending = bookings.filter(b => b.status === 'pending').length;
  639 │     const cancelled = bookings.filter(b => b.status === 'cancelled').length;
  640 │     const completed = bookings.filter(b => b.status === 'completed').length;
  641 │     
  642 │     // Calcular crescimento em relação ao mês anterior (simulado por enquanto)
  643 │     // Em uma implementação real, você compararia com dados do mês anterior
  644 │     const growth = ((confirmed + completed) / (bookings.length || 1) * 100) - 50;
  645 │     
  646 │     return {
  647 │       total: bookings.length,
  648 │       confirmed,
  649 │       pending,
  650 │       cancelled,
  651 │       completed,
  652 │       growth: Math.round(growth) // Arredonda para número inteiro
  653 │     };
  654 │   } catch (error) {
  655 │     console.error('Erro ao obter total de reservas:', error);
  656 │     return {
  657 │       total: 0,
  658 │       confirmed: 0,
  659 │       pending: 0, 
  660 │       cancelled: 0,
  661 │       completed: 0,
  662 │       growth: 0
  663 │     };
  664 │   }
  665 │ };
  666 │ 
  667 │ // Obter receita mensal
  668 │ export const getMonthlyRevenue = async () => {
  669 │   try {
  670 │     const bookings = await getDocuments<Booking>('bookings');
  671 │     
  672 │     // Filtrar reservas confirmadas e concluídas
  673 │     const validBookings = bookings.filter(b => 
  674 │       b.status === 'confirmed' || b.status === 'completed'
  675 │     );
  676 │     
  677 │     // Calcular receita total
  678 │     const totalRevenue = validBookings.reduce((acc, booking) => acc + booking.totalPrice, 0);
  679 │     
  680 │     // Agrupar receita por mês
  681 │     const revenueByMonth = validBookings.reduce((acc, booking) => {
  682 │       const date = booking.checkIn.toDate();
  683 │       const month = date.getMonth(); // 0-11
  684 │       const year = date.getFullYear();
  685 │       const key = `${year}-${month}`;
  686 │       
  687 │       if (!acc[key]) {
  688 │         acc[key] = 0;
  689 │       }
  690 │       acc[key] += booking.totalPrice;
  691 │       return acc;
  692 │     }, {} as Record<string, number>);
  693 │     
  694 │     // Converter para formato de array para gráfico
  695 │     const monthNames = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
  696 │     
  697 │     const currentDate = new Date();
  698 │     const currentMonth = currentDate.getMonth();
  699 │     const currentYear = currentDate.getFullYear();
  700 │     
  701 │     const revenueData = [];
  702 │     
  703 │     // Gerar dados dos últimos 12 meses
  704 │     for (let i = 0; i < 12; i++) {
  705 │       const month = (currentMonth - i + 12) % 12;
  706 │       const year = currentMonth - i < 0 ? currentYear - 1 : currentYear;
  707 │       const key = `${year}-${month}`;
  708 │       
  709 │       revenueData.unshift({
  710 │         month: monthNames[month],
  711 │         value: revenueByMonth[key] || 0
  712 │       });
  713 │     }
  714 │     
  715 │     // Calcular crescimento em relação ao mês anterior
  716 │     const lastMonthRevenue = revenueData[revenueData.length - 2]?.value || 0;
  717 │     const currentMonthRevenue = revenueData[revenueData.length - 1]?.value || 0;
  718 │     
  719 │     const growth = lastMonthRevenue ? ((currentMonthRevenue - lastMonthRevenue) / lastMonthRevenue) * 100 : 0;
  720 │     
  721 │     return {
  722 │       monthly: currentMonthRevenue,
  723 │       total: totalRevenue,
  724 │       growth: Math.round(growth),
  725 │       revenueData
  726 │     };
  727 │   } catch (error) {
  728 │     console.error('Erro ao obter receita mensal:', error);
  729 │     return {
  730 │       monthly: 0,
  731 │       total: 0,
  732 │       growth: 0,
  733 │       revenueData: []
  734 │     };
  735 │   }
  736 │ };
  737 │ 
  738 │ // Calcular taxa de ocupação
  739 │ export const getOccupancyRate = async () => {
  740 │   try {
  741 │     // Obter todos os quartos
  742 │     const rooms = await getDocuments<Room>('rooms');
  743 │     const totalRooms = rooms.length;
  744 │     
  745 │     if (totalRooms === 0) {
  746 │       return { rate: 0, growth: 0 };
  747 │     }
  748 │     
  749 │     // Obter todas as reservas
  750 │     const bookings = await getDocuments<Booking>('bookings');
  751 │     
  752 │     // Filtrar reservas confirmadas e concluídas para o mês atual
  753 │     const currentDate = new Date();
  754 │     const currentMonth = currentDate.getMonth();
  755 │     const currentYear = currentDate.getFullYear();
  756 │     
  757 │     const currentMonthBookings = bookings.filter(booking => {
  758 │       const checkInDate = booking.checkIn.toDate();
  759 │       return (
  760 │         (booking.status === 'confirmed' || booking.status === 'completed') &&
  761 │         checkInDate.getMonth() === currentMonth &&
  762 │         checkInDate.getFullYear() === currentYear
  763 │       );
  764 │     });
  765 │     
  766 │     // Calcular dias ocupados por quarto
  767 │     const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
  768 │     const totalPossibleRoomDays = totalRooms * daysInMonth;
  769 │     
  770 │     // Contar dias ocupados (simplificado - em produção seria mais complexo)
  771 │     let occupiedDays = 0;
  772 │     
  773 │     currentMonthBookings.forEach(booking => {
  774 │       const checkIn = booking.checkIn.toDate();
  775 │       const checkOut = booking.checkOut.toDate();
  776 │       
  777 │       // Ajustar datas para considerar apenas o mês atual
  778 │       const startDate = new Date(Math.max(
  779 │         checkIn.getTime(),
  780 │         new Date(currentYear, currentMonth, 1).getTime()
  781 │       ));
  782 │       const endDate = new Date(Math.min(
  783 │         checkOut.getTime(),
  784 │         new Date(currentYear, currentMonth + 1, 0).getTime()
  785 │       ));
  786 │       
  787 │       // Calcular dias entre datas (incluindo check-in, excluindo check-out)
  788 │       const days = Math.max(0, Math.floor((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)));
  789 │       occupiedDays += days;
  790 │     });
  791 │     
  792 │     const occupancyRate = (occupiedDays / totalPossibleRoomDays) * 100;
  793 │     
  794 │     // Simulação de crescimento (em produção, compararia com mês anterior)
  795 │     const growth = occupancyRate > 50 ? 5 : -3;
  796 │     
  797 │     return {
  798 │       rate: Math.round(occupancyRate),
  799 │       growth: Math.round(growth)
  800 │     };
  801 │   } catch (error) {
  802 │     console.error('Erro ao calcular taxa de ocupação:', error);
  803 │     return { rate: 0, growth: 0 };
  804 │   }
  805 │ };
  806 │ 
  807 │ // Obter reservas agrupadas por plataforma
  808 │ export const getBookingsByPlatform = async () => {
  809 │   try {
  810 │     const bookings = await getDocuments<Booking>('bookings');
  811 │     
  812 │     // Categorizar reservas por origem
  813 │     const platforms = [
  814 │       { 
  815 │         platform: "Booking.com", 
  816 │         color: "#003580", 
  817 │         icon: "Globe",
  818 │         bookings: []
  819 │       },
  820 │       { 
  821 │         platform: "Airbnb", 
  822 │         color: "#FF5A5F", 
  823 │         icon: "Heart",
  824 │         bookings: []
  825 │       },
  826 │       { 
  827 │         platform: "Direto", 
  828 │         color: "#4CAF50", 
  829 │         icon: "Home",
  830 │         bookings: []
  831 │       }
  832 │     ];
  833 │     
  834 │     // Para fins de demonstração, colocar todas as reservas como "Direto" por enquanto
  835 │     // Em produção, usaria um campo "platformOrigin" ou similar na tabela de reservas
  836 │     const platformIndex = 2; // Índice da plataforma "Direto"
  837 │     
  838 │     bookings.forEach(booking => {
  839 │       // Transformar para o formato esperado pelo componente
  840 │       const transformedBooking = {
  841 │         id: booking.id || '',
  842 │         guestName: booking.guestName,
  843 │         roomName: booking.roomName,
  844 │         checkIn: booking.checkIn.toDate().toLocaleDateString('pt-PT'),
  845 │         checkOut: booking.checkOut.toDate().toLocaleDateString('pt-PT'),
  846 │         status: booking.status,
  847 │         value: new Intl.NumberFormat('pt-PT', {
  848 │           style: 'currency',
  849 │           currency: 'EUR'
  850 │         }).format(booking.totalPrice)
  851 │       };
  852 │       
  853 │       // Adicionar à plataforma "Direto"
  854 │       (platforms[platformIndex] as any).bookings.push(transformedBooking);
  855 │     });
  856 │     
  857 │     return platforms;
  858 │   } catch (error) {
  859 │     console.error('Erro ao obter reservas por plataforma:', error);
  860 │     return [];
  861 │   }
  862 │ };
  863 │ 
  864 │ // Função para obter o preço de um quarto para uma data específica
  865 │ export const getRoomPriceForDate = async (roomId: string, date: Date): Promise<number> => {
  866 │   try {
  867 │     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  868 │     
  869 │     if (!roomDoc.exists()) {
  870 │       throw new Error("Quarto não encontrado");
  871 │     }
  872 │     
  873 │     const roomData = roomDoc.data() as Room;
  874 │     const basePrice = roomData.price;
  875 │     
  876 │     if (!roomData.seasonalPrices || roomData.seasonalPrices.length === 0) {
  877 │       return basePrice;
  878 │     }
  879 │     
  880 │     // Verificar se a data está dentro de algum período sazonal
  881 │     for (const seasonalPrice of roomData.seasonalPrices) {
  882 │       const startDate = new Date(seasonalPrice.startDate);
  883 │       const endDate = new Date(seasonalPrice.endDate);
  884 │       
  885 │       if (date >= startDate && date <= endDate) {
  886 │         return seasonalPrice.price;
  887 │       }
  888 │     }
  889 │     
  890 │     // Se não cair em nenhum período sazonal, retorna o preço base
  891 │     return basePrice;
  892 │   } catch (error) {
  893 │     console.error("Erro ao obter preço do quarto:", error);
  894 │     throw error;
  895 │   }
  896 │ }
  897 │ 
  898 │ // Função para calcular o preço total de uma estadia
  899 │ export const calculateStayPrice = async (
  900 │   roomId: string, 
  901 │   checkIn: Date, 
  902 │   checkOut: Date
  903 │ ): Promise<{
  904 │   totalPrice: number;
  905 │   nightlyPrices: { date: string; price: number }[];
  906 │   serviceFee: number;
  907 │   totalWithFee: number;
  908 │ }> => {
  909 │   try {
  910 │     console.log(`🔍 Iniciando cálculo de preço para estadia: ${checkIn.toISOString().split('T')[0]} até ${checkOut.toISOString().split('T')[0]}`);
  911 │     
  912 │     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  913 │     
  914 │     if (!roomDoc.exists()) {
  915 │       throw new Error("Quarto não encontrado");
  916 │     }
  917 │     
  918 │     const roomData = roomDoc.data() as Room;
  919 │     console.log(`📝 Dados do quarto ${roomId}:`, {
  920 │       nome: roomData.name,
  921 │       precoBase: roomData.price,
  922 │       taxaServico: roomData.serviceFeePct || 0,
  923 │       temPrecosSazonais: !!roomData.seasonalPrices?.length
  924 │     });
  925 │     
  926 │     const nightlyPrices: { date: string; price: number }[] = [];
  927 │     let totalPrice = 0;
  928 │     
  929 │     // Calcular o número de noites - corrigido para usar o método correto de cálculo
  930 │     // O número de noites é a diferença em dias (estadia = checkout - checkin)
  931 │     const noites = differenceInDays(checkOut, checkIn);
  932 │     console.log(`🗓️ Número de noites calculado: ${noites}`);
  933 │     
  934 │     if (noites <= 0) {
  935 │       console.error(`⚠️ Erro: número de noites inválido (${noites})`);
  936 │       throw new Error("Data de check-out deve ser posterior à data de check-in");
  937 │     }
  938 │     
  939 │     // Para cada noite, verificar o preço aplicável (preço base ou sazonal)
  940 │     // Começamos exatamente do dia de check-in
  941 │     const currentDate = new Date(checkIn);
  942 │     currentDate.setHours(0, 0, 0, 0); // Normalizar para meia-noite
  943 │     
  944 │     // Processamos cada dia de estadia (noite)
  945 │     console.log(`📊 Calculando preços por noite:`);
  946 │     for (let i = 0; i < noites; i++) {
  947 │       // Obtemos o preço para esta data
  948 │       const dateCopy = new Date(currentDate);
  949 │       const priceForDate = await getRoomPriceForDate(roomId, dateCopy);
  950 │       const dateString = dateCopy.toISOString().split('T')[0]; // YYYY-MM-DD
  951 │       
  952 │       console.log(`   - ${dateString}: €${priceForDate}`);
  953 │       
  954 │       nightlyPrices.push({
  955 │         date: dateString,
  956 │         price: priceForDate
  957 │       });
  958 │       
  959 │       totalPrice += priceForDate;
  960 │       
  961 │       // Avançamos para o próximo dia
  962 │       currentDate.setDate(currentDate.getDate() + 1);
  963 │     }
  964 │     
  965 │     // Verificação de segurança para o cálculo do totalPrice
  966 │     const manualTotal = nightlyPrices.reduce((sum, night) => sum + night.price, 0);
  967 │     if (Math.abs(totalPrice - manualTotal) > 1) {
  968 │       console.error(`⚠️ Discrepância detectada no cálculo do preço total!`);
  969 │       console.error(`   - Total calculado iterativamente: €${totalPrice}`);
  970 │       console.error(`   - Total calculado via reduce: €${manualTotal}`);
  971 │       console.error(`   - Usando o valor recalculado para segurança!`);
  972 │       totalPrice = manualTotal;
  973 │     }
  974 │     
  975 │     // Calcular taxa de serviço
  976 │     const serviceFee = (totalPrice * (roomData.serviceFeePct || 0)) / 100;
  977 │     const totalWithFee = totalPrice + serviceFee;
  978 │     
  979 │     console.log(`💰 Resumo do cálculo:`);
  980 │     console.log(`   - Total das diárias: €${totalPrice}`);
  981 │     console.log(`   - Taxa de serviço (${roomData.serviceFeePct || 0}%): €${serviceFee}`);
  982 │     console.log(`   - Total com taxas: €${totalWithFee}`);
  983 │     
  984 │     return {
  985 │       totalPrice,
  986 │       nightlyPrices,
  987 │       serviceFee,
  988 │       totalWithFee
  989 │     };
  990 │   } catch (error) {
  991 │     console.error("❌ Erro ao calcular preço da estadia:", error);
  992 │     throw error;
  993 │   }
  994 │ } 
  995 │ import { 
  996 │   collection, 
  997 │   getDocs, 
  998 │   getDoc, 
  999 │   doc, 
 1000 │   setDoc, 
 1001 │   addDoc, 
 1002 │   updateDoc, 
 1003 │   deleteDoc,
 1004 │   query,
 1005 │   where,
 1006 │   orderBy,
      ·   ───┬───
      ·      ╰── `orderBy` redefined here
 1007 │   limit,
 1008 │   serverTimestamp
 1009 │ } from 'firebase/firestore';
      ╰────

  × the name `limit` is defined multiple times
      ╭─[/home/runner/workspace/lib/firebase/firestore.ts:10:1]
   10 │   query,
   11 │   where,
   12 │   orderBy,
   13 │   limit,
      ·   ──┬──
      ·     ╰── previous definition of `limit` here
   14 │   DocumentData,
   15 │   QueryConstraint,
   16 │   Timestamp,
   17 │   serverTimestamp
   18 │ } from 'firebase/firestore'
   19 │ import { db } from './config'
   20 │ import { Room, SeasonalPrice } from '@/lib/types'
   21 │ import { differenceInDays } from 'date-fns'
   22 │ 
   23 │ // Tipos de dados
   24 │ export interface Booking {
   25 │   id?: string
   26 │   userId?: string
   27 │   guestName: string
   28 │   guestEmail: string
   29 │   guestPhone: string
   30 │   roomId: string
   31 │   roomName: string
   32 │   checkIn: Timestamp
   33 │   checkOut: Timestamp
   34 │   adults: number
   35 │   children: number
   36 │   totalPrice: number
   37 │   status: 'pending' | 'confirmed' | 'cancelled' | 'completed'
   38 │   paymentStatus: 'pending' | 'paid' | 'refunded'
   39 │   specialRequests?: string
   40 │   createdAt?: Timestamp
   41 │   updatedAt?: Timestamp
   42 │ }
   43 │ 
   44 │ export interface Contact {
   45 │   id?: string
   46 │   name: string
   47 │   email: string
   48 │   phone?: string
   49 │   subject: string
   50 │   message: string
   51 │   status: 'new' | 'read' | 'replied'
   52 │   createdAt: Timestamp
   53 │   updatedAt?: Timestamp
   54 │   repliedAt?: Timestamp
   55 │   replyContent?: string
   56 │   reservationDetails?: {
   57 │     checkIn?: Timestamp
   58 │     checkOut?: Timestamp
   59 │     roomId?: string
   60 │     roomName?: string
   61 │     totalGuests?: number
   62 │     totalPrice?: number
   63 │   }
   64 │ }
   65 │ 
   66 │ // Funções genéricas para CRUD
   67 │ export const createDocument = async <T extends DocumentData>(
   68 │   collectionName: string,
   69 │   data: T
   70 │ ): Promise<string> => {
   71 │   const docRef = await addDoc(collection(db, collectionName), {
   72 │     ...data,
   73 │     createdAt: serverTimestamp(),
   74 │     updatedAt: serverTimestamp()
   75 │   })
   76 │   return docRef.id
   77 │ }
   78 │ 
   79 │ export const createDocumentWithId = async <T extends DocumentData>(
   80 │   collectionName: string,
   81 │   id: string,
   82 │   data: T
   83 │ ): Promise<void> => {
   84 │   await setDoc(doc(db, collectionName, id), {
   85 │     ...data,
   86 │     createdAt: serverTimestamp(),
   87 │     updatedAt: serverTimestamp()
   88 │   })
   89 │ }
   90 │ 
   91 │ export const getDocument = async <T>(
   92 │   collectionName: string,
   93 │   id: string
   94 │ ): Promise<T | null> => {
   95 │   const docRef = doc(db, collectionName, id)
   96 │   const docSnap = await getDoc(docRef)
   97 │   
   98 │   if (docSnap.exists()) {
   99 │     const data = docSnap.data();
  100 │     console.log("Dados brutos recuperados do Firestore para quarto:", id, data);
  101 │     
  102 │     if (data?.serviceFeePct !== undefined) {
  103 │       console.log("serviceFeePct antes da conversão:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
  104 │       // Garantir que serviceFeePct seja um número
  105 │       data.serviceFeePct = Number(data.serviceFeePct);
  106 │       console.log("serviceFeePct após conversão:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
  107 │     }
  108 │     
  109 │     return { id: docSnap.id, ...data } as T
  110 │   } else {
  111 │     return null
  112 │   }
  113 │ }
  114 │ 
  115 │ export const getDocuments = async <T>(
  116 │   collectionName: string,
  117 │   constraints: QueryConstraint[] = [],
  118 │   forceRefresh = false
  119 │ ): Promise<T[]> => {
  120 │   try {
  121 │     const collectionRef = collection(db, collectionName)
  122 │     const q = query(collectionRef, ...constraints)
  123 │     
  124 │     // Se forceRefresh for verdadeiro, adicionar opções que forçam uma nova consulta ao Firestore
  125 │     const querySnapshot = await getDocs(q)
  126 │     
  127 │     console.log(`Buscando documentos na coleção ${collectionName} - Força atualização: ${forceRefresh}`);
  128 │     
  129 │     return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }) as T)
  130 │   } catch (error) {
  131 │     console.error(`Erro ao buscar documentos da coleção ${collectionName}:`, error);
  132 │     return [];
  133 │   }
  134 │ }
  135 │ 
  136 │ export const updateDocument = async <T extends DocumentData>(
  137 │   collectionName: string,
  138 │   id: string,
  139 │   data: Partial<T>
  140 │ ): Promise<void> => {
  141 │   const docRef = doc(db, collectionName, id)
  142 │   await updateDoc(docRef, {
  143 │     ...data,
  144 │     updatedAt: serverTimestamp()
  145 │   })
  146 │ }
  147 │ 
  148 │ export const deleteDocument = async (
  149 │   collectionName: string,
  150 │   id: string
  151 │ ): Promise<boolean> => {
  152 │   const docRef = doc(db, collectionName, id)
  153 │   await deleteDoc(docRef)
  154 │   return true
  155 │ }
  156 │ 
  157 │ // Funções para gerenciar quartos
  158 │ export const getRooms = async (forceRefresh = false): Promise<Room[]> => {
  159 │   try {
  160 │     const constraints: QueryConstraint[] = []
  161 │     
  162 │     constraints.push(orderBy('name', 'asc'))
  163 │     
  164 │     const rooms = await getDocuments<Room>('rooms', constraints, forceRefresh)
  165 │     
  166 │     // Garantir que todos os campos necessários estejam presentes
  167 │     return rooms.map(room => {
  168 │       console.log(`Firebase - Quarto ${room.id} dados brutos:`, room);
  169 │       
  170 │       // Garantir que serviceFeePct seja um número
  171 │       const serviceFeePct = room.serviceFeePct !== undefined 
  172 │         ? Number(room.serviceFeePct) 
  173 │         : 10;
  174 │         
  175 │       console.log(`Firebase - Quarto ${room.id} serviceFeePct:`, {
  176 │         original: room.serviceFeePct,
  177 │         tipo: typeof room.serviceFeePct,
  178 │         convertido: serviceFeePct
  179 │       });
  180 │       
  181 │       return {
  182 │         id: room.id,
  183 │         name: room.name || '',
  184 │         type: room.type || 'standard',
  185 │         description: room.description || '',
  186 │         price: room.price || 0,
  187 │         capacity: room.capacity || 2,
  188 │         size: room.size || 0,
  189 │         available: room.available !== undefined ? room.available : true,
  190 │         serviceFeePct: serviceFeePct,
  191 │         images: room.images || [],
  192 │         amenities: room.amenities || [],
  193 │         additionalServices: room.additionalServices || [],
  194 │         highlights: room.highlights || [],
  195 │         createdAt: room.createdAt,
  196 │         updatedAt: room.updatedAt
  197 │       };
  198 │     });
  199 │   } catch (error) {
  200 │     console.error('Erro ao buscar quartos:', error)
  201 │     return []
  202 │   }
  203 │ }
  204 │ 
  205 │ export const getAvailableRooms = async (
  206 │   checkIn: Date,
  207 │   checkOut: Date
  208 │ ): Promise<Room[]> => {
  209 │   try {
  210 │     // Buscar todos os quartos que estão marcados como disponíveis em geral
  211 │     const constraints: QueryConstraint[] = [
  212 │       where('available', '==', true)
  213 │     ]
  214 │     
  215 │     const rooms = await getDocuments<Room>('rooms', constraints);
  216 │     
  217 │     // Filtrar os quartos que estão disponíveis nas datas específicas
  218 │     return filterAvailableRoomsByDate(rooms, checkIn, checkOut);
  219 │   } catch (error) {
  220 │     console.error('Erro ao buscar quartos disponíveis:', error)
  221 │     return []
  222 │   }
  223 │ }
  224 │ 
  225 │ // Função auxiliar para verificar disponibilidade entre datas
  226 │ export const filterAvailableRoomsByDate = (
  227 │   rooms: Room[],
  228 │   checkIn: Date,
  229 │   checkOut: Date
  230 │ ): Room[] => {
  231 │   // Converter checkIn e checkOut para ISO strings
  232 │   const dateStrings = getDatesInRange(checkIn, checkOut);
  233 │   
  234 │   return rooms.filter(room => {
  235 │     // Se não tiver controle de disponibilidade específico, considera disponível
  236 │     if (!room.availabilityDates) return true;
  237 │     
  238 │     // Verificar se alguma data no intervalo está indisponível
  239 │     return !dateStrings.some(dateStr => 
  240 │       room.availabilityDates?.[dateStr] === false
  241 │     );
  242 │   });
  243 │ };
  244 │ 
  245 │ // Função para obter disponibilidade de um quarto específico
  246 │ export const getRoomAvailability = async (
  247 │   roomId: string, 
  248 │   startDate: Date, 
  249 │   endDate: Date
  250 │ ): Promise<{[date: string]: boolean}> => {
  251 │   try {
  252 │     const room = await getRoomById(roomId);
  253 │     if (!room) throw new Error(`Quarto com ID ${roomId} não encontrado`);
  254 │     
  255 │     // Gerar datas no intervalo
  256 │     const dateStrings = getDatesInRange(startDate, endDate);
  257 │     
  258 │     // Se não tiver configuração de disponibilidade específica, assume tudo disponível
  259 │     if (!room.availabilityDates) {
  260 │       return dateStrings.reduce((acc, date) => {
  261 │         acc[date] = true;
  262 │         return acc;
  263 │       }, {} as {[date: string]: boolean});
  264 │     }
  265 │     
  266 │     // Preencher com os dados de disponibilidade existentes
  267 │     return dateStrings.reduce((acc, date) => {
  268 │       acc[date] = room.availabilityDates?.[date] !== false; // disponível por padrão se não estiver explicitamente indisponível
  269 │       return acc;
  270 │     }, {} as {[date: string]: boolean});
  271 │   } catch (error) {
  272 │     console.error(`Erro ao verificar disponibilidade do quarto ${roomId}:`, error);
  273 │     throw error;
  274 │   }
  275 │ };
  276 │ 
  277 │ // Função para atualizar disponibilidade de um quarto
  278 │ export const updateRoomAvailability = async (
  279 │   roomId: string,
  280 │   availabilityDates: {[date: string]: boolean}
  281 │ ): Promise<boolean> => {
  282 │   try {
  283 │     await updateDocument('rooms', roomId, {
  284 │       availabilityDates,
  285 │       updatedAt: serverTimestamp()
  286 │     });
  287 │     return true;
  288 │   } catch (error) {
  289 │     console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  290 │     return false;
  291 │   }
  292 │ };
  293 │ 
  294 │ // Função auxiliar para gerar array de strings de data entre um intervalo
  295 │ export const getDatesInRange = (startDate: Date, endDate: Date): string[] => {
  296 │   const dates: string[] = [];
  297 │   const currentDate = new Date(startDate);
  298 │   
  299 │   // Normalizar para meia-noite no fuso horário local
  300 │   currentDate.setHours(0, 0, 0, 0);
  301 │   const endDateNormalized = new Date(endDate);
  302 │   endDateNormalized.setHours(0, 0, 0, 0);
  303 │   
  304 │   // Adicionar cada data no intervalo EXCETO o dia de checkout
  305 │   // Usando < em vez de <= para não incluir o dia de checkout
  306 │   while (currentDate < endDateNormalized) {
  307 │     dates.push(currentDate.toISOString().split('T')[0]); // Formato YYYY-MM-DD
  308 │     currentDate.setDate(currentDate.getDate() + 1);
  309 │   }
  310 │   
  311 │   return dates;
  312 │ };
  313 │ 
  314 │ export const getRoomById = async (id: string): Promise<Room | null> => {
  315 │   try {
  316 │     const room = await getDocument<Room>('rooms', id);
  317 │     
  318 │     if (!room) return null;
  319 │     
  320 │     console.log(`Firebase - getRoomById ${id} dados brutos:`, room);
  321 │     
  322 │     // Log específico para serviceFeePct
  323 │     console.log(`serviceFeePct no Firestore:`, room.serviceFeePct);
  324 │     
  325 │     // Garantir que todos os campos necessários estejam presentes
  326 │     return {
  327 │       ...room,
  328 │       name: room.name || '',
  329 │       type: room.type || 'standard',
  330 │       description: room.description || '',
  331 │       price: room.price || 0,
  332 │       capacity: room.capacity || 2,
  333 │       size: room.size || 0,
  334 │       available: room.available !== undefined ? room.available : true,
  335 │       serviceFeePct: room.serviceFeePct !== undefined ? room.serviceFeePct : 10,
  336 │       images: room.images || [],
  337 │       amenities: room.amenities || [],
  338 │       additionalServices: room.additionalServices || [],
  339 │       highlights: room.highlights || []
  340 │     };
  341 │   } catch (error) {
  342 │     console.error(`Erro ao buscar quarto com ID ${id}:`, error);
  343 │     return null;
  344 │   }
  345 │ }
  346 │ 
  347 │ export const createRoom = async (roomData: Omit<Room, 'id' | 'createdAt' | 'updatedAt'>): Promise<Room> => {
  348 │   try {
  349 │     console.log("createRoom - Dados recebidos:", roomData);
  350 │     
  351 │     const roomWithTimestamps = {
  352 │       ...roomData,
  353 │       available: roomData.available !== undefined ? roomData.available : true,
  354 │       featured: roomData.featured || false,
  355 │       amenities: roomData.amenities || [],
  356 │       additionalServices: roomData.additionalServices || [],
  357 │       highlights: roomData.highlights || [],
  358 │       createdAt: serverTimestamp(),
  359 │       updatedAt: serverTimestamp()
  360 │     }
  361 │     
  362 │     console.log("createRoom - Dados a serem salvos:", roomWithTimestamps);
  363 │     
  364 │     const id = await createDocument('rooms', roomWithTimestamps)
  365 │     
  366 │     return {
  367 │       id,
  368 │       ...roomData,
  369 │       amenities: roomData.amenities || [],
  370 │       additionalServices: roomData.additionalServices || [],
  371 │       highlights: roomData.highlights || [],
  372 │       createdAt: Timestamp.now(),
  373 │       updatedAt: Timestamp.now()
  374 │     }
  375 │   } catch (error) {
  376 │     console.error('Erro ao criar quarto:', error)
  377 │     throw error
  378 │   }
  379 │ }
  380 │ 
  381 │ export const updateRoom = async (id: string, roomData: Partial<Omit<Room, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Room> => {
  382 │   try {
  383 │     console.log(`updateRoom - ID: ${id}, Dados recebidos:`, roomData);
  384 │     
  385 │     // Garantir que estamos lidando explicitamente com o serviceFeePct se ele for 0
  386 │     if (roomData.serviceFeePct === 0) {
  387 │       console.log("updateRoom - Detectado serviceFeePct com valor 0, salvando explicitamente.", roomData.serviceFeePct);
  388 │     }
  389 │     
  390 │     // Adicionar timestamp de atualização
  391 │     const roomWithTimestamp = {
  392 │       ...roomData,
  393 │       amenities: roomData.amenities || [],
  394 │       additionalServices: roomData.additionalServices || [],
  395 │       highlights: roomData.highlights || [],
  396 │       updatedAt: serverTimestamp()
  397 │     }
  398 │     
  399 │     console.log(`updateRoom - Dados a serem salvos:`, roomWithTimestamp);
  400 │     
  401 │     await updateDocument('rooms', id, roomWithTimestamp)
  402 │     
  403 │     const updatedRoom = await getRoomById(id)
  404 │     if (!updatedRoom) {
  405 │       throw new Error(`Quarto com ID ${id} não encontrado após atualização`)
  406 │     }
  407 │     
  408 │     return updatedRoom
  409 │   } catch (error) {
  410 │     console.error('Erro ao atualizar quarto:', error)
  411 │     throw error
  412 │   }
  413 │ }
  414 │ 
  415 │ export const deleteRoom = async (id: string): Promise<boolean> => {
  416 │   return await deleteDocument('rooms', id)
  417 │ }
  418 │ 
  419 │ // Funções específicas para reservas
  420 │ export const createBooking = async (bookingData: any) => {
  421 │   try {
  422 │     const bookingsCollection = collection(db, 'bookings');
  423 │     const docRef = await addDoc(bookingsCollection, bookingData);
  424 │     
  425 │     // CORREÇÃO: Não bloquear a data no momento da criação da reserva
  426 │     // O bloqueio será feito apenas quando o pagamento for confirmado
  427 │     // através da função updateBookingStatus
  428 │     
  429 │     return docRef;
  430 │   } catch (error) {
  431 │     console.error('Erro ao criar reserva:', error);
  432 │     throw error;
  433 │   }
  434 │ };
  435 │ 
  436 │ // Nova função para atualizar status da reserva e bloquear as datas da estadia
  437 │ export const updateBookingStatus = async (
  438 │   bookingId: string, 
  439 │   newStatus: 'pending' | 'confirmed' | 'cancelled' | 'completed',
  440 │   newPaymentStatus: 'pending' | 'paid' | 'refunded'
  441 │ ): Promise<boolean> => {
  442 │   try {
  443 │     // Referência ao documento da reserva
  444 │     const bookingRef = doc(db, 'bookings', bookingId);
  445 │     const bookingSnap = await getDoc(bookingRef);
  446 │     
  447 │     if (!bookingSnap.exists()) {
  448 │       console.error(`Booking ${bookingId} não existe ao atualizar status`);
  449 │       return false;
  450 │     }
  451 │     
  452 │     const bookingData = bookingSnap.data();
  453 │     
  454 │     // Atualizar o status da reserva
  455 │     await updateDoc(bookingRef, {
  456 │       status: newStatus,
  457 │       paymentStatus: newPaymentStatus,
  458 │       updatedAt: serverTimestamp(),
  459 │       ...(newStatus === 'confirmed' && { confirmedAt: serverTimestamp() })
  460 │     });
  461 │     
  462 │     // Se a reserva está sendo confirmada, precisamos bloquear as datas
  463 │     if (newStatus === 'confirmed') {
  464 │       console.log(`Atualizando disponibilidade para reserva confirmada: ${bookingId}`);
  465 │       
  466 │       // Recuperar datas de check-in e check-out
  467 │       const checkIn = bookingData.checkIn.toDate();
  468 │       const checkOut = bookingData.checkOut.toDate();
  469 │       const roomId = bookingData.roomId;
  470 │       
  471 │       // Obter todas as datas entre check-in e check-out
  472 │       const dates: Date[] = [];
  473 │       const currentDate = new Date(checkIn);
  474 │       
  475 │       while (currentDate < checkOut) {
  476 │         dates.push(new Date(currentDate));
  477 │         currentDate.setDate(currentDate.getDate() + 1);
  478 │       }
  479 │       
  480 │       console.log(`Bloqueando ${dates.length} dias para quarto ${roomId}`);
  481 │       
  482 │       // Atualizar disponibilidade para cada data
  483 │       const availabilityUpdates: {[date: string]: boolean} = {};
  484 │       
  485 │       dates.forEach(date => {
  486 │         const dateString = date.toISOString().split('T')[0]; // formato YYYY-MM-DD
  487 │         availabilityUpdates[dateString] = false; // false significa indisponível
  488 │       });
  489 │       
  490 │       // Atualizar disponibilidade do quarto
  491 │       if (Object.keys(availabilityUpdates).length > 0) {
  492 │         try {
  493 │           // Obter o documento do quarto
  494 │           const roomRef = doc(db, 'rooms', roomId);
  495 │           const roomSnap = await getDoc(roomRef);
  496 │           
  497 │           if (roomSnap.exists()) {
  498 │             const roomData = roomSnap.data();
  499 │             const currentAvailability = roomData.availabilityDates || {};
  500 │             
  501 │             // Mesclar a disponibilidade atual com as novas atualizações
  502 │             const updatedAvailability = {
  503 │               ...currentAvailability,
  504 │               ...availabilityUpdates
  505 │             };
  506 │             
  507 │             // Atualizar o documento do quarto
  508 │             await updateDoc(roomRef, {
  509 │               availabilityDates: updatedAvailability,
  510 │               updatedAt: serverTimestamp()
  511 │             });
  512 │             
  513 │             console.log(`Disponibilidade atualizada com sucesso para quarto ${roomId}`);
  514 │             
  515 │             // Criar log da reserva
  516 │             await addDoc(collection(db, 'bookingLogs'), {
  517 │               bookingId,
  518 │               roomId,
  519 │               action: 'status_updated',
  520 │               previousStatus: bookingData.status,
  521 │               newStatus,
  522 │               previousPaymentStatus: bookingData.paymentStatus,
  523 │               newPaymentStatus,
  524 │               datesBlocked: Object.keys(availabilityUpdates),
  525 │               timestamp: serverTimestamp(),
  526 │               userId: bookingData.userId || 'system'
  527 │             });
  528 │           } else {
  529 │             console.error(`Quarto ${roomId} não encontrado ao atualizar disponibilidade`);
  530 │           }
  531 │         } catch (error) {
  532 │           console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  533 │         }
  534 │       }
  535 │     }
  536 │     
  537 │     return true;
  538 │   } catch (error) {
  539 │     console.error(`Erro ao atualizar status da reserva ${bookingId}:`, error);
  540 │     return false;
  541 │   }
  542 │ }
  543 │ 
  544 │ export const getUserBookings = async (userId: string): Promise<Booking[]> => {
  545 │   return getDocuments<Booking>('bookings', [
  546 │     where('userId', '==', userId),
  547 │     orderBy('createdAt', 'desc')
  548 │   ])
  549 │ }
  550 │ 
  551 │ export const getRecentBookings = async (count = 5): Promise<Booking[]> => {
  552 │   return getDocuments<Booking>('bookings', [
  553 │     orderBy('createdAt', 'desc'),
  554 │     limit(count)
  555 │   ])
  556 │ }
  557 │ 
  558 │ export const getRoomBookings = async (roomId: string): Promise<Booking[]> => {
  559 │   try {
  560 │     const constraints: QueryConstraint[] = [
  561 │       where('roomId', '==', roomId),
  562 │       orderBy('checkIn', 'asc')
  563 │     ];
  564 │     
  565 │     return await getDocuments<Booking>('bookings', constraints);
  566 │   } catch (error) {
  567 │     console.error(`Erro ao buscar reservas do quarto ${roomId}:`, error);
  568 │     return [];
  569 │   }
  570 │ };
  571 │ 
  572 │ // Funções específicas para contatos
  573 │ export const createContactMessage = async (contactData: Contact) => {
  574 │   try {
  575 │     const contactsCollection = collection(db, 'contacts')
  576 │     
  577 │     // Garantir que o status seja 'new' para novos contatos
  578 │     const contactWithDefaults = {
  579 │       ...contactData,
  580 │       status: contactData.status || 'new',
  581 │       createdAt: contactData.createdAt || Timestamp.now()
  582 │     }
  583 │     
  584 │     // Se tiver detalhes de reserva, adicionar metadados
  585 │     if (contactWithDefaults.reservationDetails) {
  586 │       // Ajustar subject para indicar que é relacionado a reserva
  587 │       if (!contactWithDefaults.subject.includes('Reserva')) {
  588 │         contactWithDefaults.subject = `Reserva: ${contactWithDefaults.subject}`;
  589 │       }
  590 │     }
  591 │     
  592 │     const docRef = await addDoc(contactsCollection, contactWithDefaults)
  593 │     return docRef
  594 │   } catch (error) {
  595 │     console.error('Erro ao criar mensagem de contato:', error)
  596 │     throw error
  597 │   }
  598 │ }
  599 │ 
  600 │ export const getNewContactMessages = async (): Promise<Contact[]> => {
  601 │   return getDocuments<Contact>('contacts', [
  602 │     where('status', '==', 'new'),
  603 │     orderBy('createdAt', 'desc')
  604 │   ])
  605 │ }
  606 │ 
  607 │ // Funções para Dashboard com dados reais
  608 │ 
  609 │ export const getDashboardStats = async () => {
  610 │   try {
  611 │     const [totalBookings, totalRevenue, occupancyRate, bookingsByPlatform] = await Promise.all([
  612 │       getTotalBookings(),
  613 │       getMonthlyRevenue(),
  614 │       getOccupancyRate(),
  615 │       getBookingsByPlatform()
  616 │     ]);
  617 │ 
  618 │     return {
  619 │       totalBookings,
  620 │       totalRevenue,
  621 │       occupancyRate,
  622 │       bookingsByPlatform
  623 │     };
  624 │   } catch (error) {
  625 │     console.error('Erro ao obter estatísticas do dashboard:', error);
  626 │     throw error;
  627 │   }
  628 │ };
  629 │ 
  630 │ // Obter total de reservas
  631 │ export const getTotalBookings = async () => {
  632 │   try {
  633 │     // Obter todas as reservas
  634 │     const bookings = await getDocuments<Booking>('bookings');
  635 │     
  636 │     // Contar reservas por status
  637 │     const confirmed = bookings.filter(b => b.status === 'confirmed').length;
  638 │     const pending = bookings.filter(b => b.status === 'pending').length;
  639 │     const cancelled = bookings.filter(b => b.status === 'cancelled').length;
  640 │     const completed = bookings.filter(b => b.status === 'completed').length;
  641 │     
  642 │     // Calcular crescimento em relação ao mês anterior (simulado por enquanto)
  643 │     // Em uma implementação real, você compararia com dados do mês anterior
  644 │     const growth = ((confirmed + completed) / (bookings.length || 1) * 100) - 50;
  645 │     
  646 │     return {
  647 │       total: bookings.length,
  648 │       confirmed,
  649 │       pending,
  650 │       cancelled,
  651 │       completed,
  652 │       growth: Math.round(growth) // Arredonda para número inteiro
  653 │     };
  654 │   } catch (error) {
  655 │     console.error('Erro ao obter total de reservas:', error);
  656 │     return {
  657 │       total: 0,
  658 │       confirmed: 0,
  659 │       pending: 0, 
  660 │       cancelled: 0,
  661 │       completed: 0,
  662 │       growth: 0
  663 │     };
  664 │   }
  665 │ };
  666 │ 
  667 │ // Obter receita mensal
  668 │ export const getMonthlyRevenue = async () => {
  669 │   try {
  670 │     const bookings = await getDocuments<Booking>('bookings');
  671 │     
  672 │     // Filtrar reservas confirmadas e concluídas
  673 │     const validBookings = bookings.filter(b => 
  674 │       b.status === 'confirmed' || b.status === 'completed'
  675 │     );
  676 │     
  677 │     // Calcular receita total
  678 │     const totalRevenue = validBookings.reduce((acc, booking) => acc + booking.totalPrice, 0);
  679 │     
  680 │     // Agrupar receita por mês
  681 │     const revenueByMonth = validBookings.reduce((acc, booking) => {
  682 │       const date = booking.checkIn.toDate();
  683 │       const month = date.getMonth(); // 0-11
  684 │       const year = date.getFullYear();
  685 │       const key = `${year}-${month}`;
  686 │       
  687 │       if (!acc[key]) {
  688 │         acc[key] = 0;
  689 │       }
  690 │       acc[key] += booking.totalPrice;
  691 │       return acc;
  692 │     }, {} as Record<string, number>);
  693 │     
  694 │     // Converter para formato de array para gráfico
  695 │     const monthNames = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
  696 │     
  697 │     const currentDate = new Date();
  698 │     const currentMonth = currentDate.getMonth();
  699 │     const currentYear = currentDate.getFullYear();
  700 │     
  701 │     const revenueData = [];
  702 │     
  703 │     // Gerar dados dos últimos 12 meses
  704 │     for (let i = 0; i < 12; i++) {
  705 │       const month = (currentMonth - i + 12) % 12;
  706 │       const year = currentMonth - i < 0 ? currentYear - 1 : currentYear;
  707 │       const key = `${year}-${month}`;
  708 │       
  709 │       revenueData.unshift({
  710 │         month: monthNames[month],
  711 │         value: revenueByMonth[key] || 0
  712 │       });
  713 │     }
  714 │     
  715 │     // Calcular crescimento em relação ao mês anterior
  716 │     const lastMonthRevenue = revenueData[revenueData.length - 2]?.value || 0;
  717 │     const currentMonthRevenue = revenueData[revenueData.length - 1]?.value || 0;
  718 │     
  719 │     const growth = lastMonthRevenue ? ((currentMonthRevenue - lastMonthRevenue) / lastMonthRevenue) * 100 : 0;
  720 │     
  721 │     return {
  722 │       monthly: currentMonthRevenue,
  723 │       total: totalRevenue,
  724 │       growth: Math.round(growth),
  725 │       revenueData
  726 │     };
  727 │   } catch (error) {
  728 │     console.error('Erro ao obter receita mensal:', error);
  729 │     return {
  730 │       monthly: 0,
  731 │       total: 0,
  732 │       growth: 0,
  733 │       revenueData: []
  734 │     };
  735 │   }
  736 │ };
  737 │ 
  738 │ // Calcular taxa de ocupação
  739 │ export const getOccupancyRate = async () => {
  740 │   try {
  741 │     // Obter todos os quartos
  742 │     const rooms = await getDocuments<Room>('rooms');
  743 │     const totalRooms = rooms.length;
  744 │     
  745 │     if (totalRooms === 0) {
  746 │       return { rate: 0, growth: 0 };
  747 │     }
  748 │     
  749 │     // Obter todas as reservas
  750 │     const bookings = await getDocuments<Booking>('bookings');
  751 │     
  752 │     // Filtrar reservas confirmadas e concluídas para o mês atual
  753 │     const currentDate = new Date();
  754 │     const currentMonth = currentDate.getMonth();
  755 │     const currentYear = currentDate.getFullYear();
  756 │     
  757 │     const currentMonthBookings = bookings.filter(booking => {
  758 │       const checkInDate = booking.checkIn.toDate();
  759 │       return (
  760 │         (booking.status === 'confirmed' || booking.status === 'completed') &&
  761 │         checkInDate.getMonth() === currentMonth &&
  762 │         checkInDate.getFullYear() === currentYear
  763 │       );
  764 │     });
  765 │     
  766 │     // Calcular dias ocupados por quarto
  767 │     const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
  768 │     const totalPossibleRoomDays = totalRooms * daysInMonth;
  769 │     
  770 │     // Contar dias ocupados (simplificado - em produção seria mais complexo)
  771 │     let occupiedDays = 0;
  772 │     
  773 │     currentMonthBookings.forEach(booking => {
  774 │       const checkIn = booking.checkIn.toDate();
  775 │       const checkOut = booking.checkOut.toDate();
  776 │       
  777 │       // Ajustar datas para considerar apenas o mês atual
  778 │       const startDate = new Date(Math.max(
  779 │         checkIn.getTime(),
  780 │         new Date(currentYear, currentMonth, 1).getTime()
  781 │       ));
  782 │       const endDate = new Date(Math.min(
  783 │         checkOut.getTime(),
  784 │         new Date(currentYear, currentMonth + 1, 0).getTime()
  785 │       ));
  786 │       
  787 │       // Calcular dias entre datas (incluindo check-in, excluindo check-out)
  788 │       const days = Math.max(0, Math.floor((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)));
  789 │       occupiedDays += days;
  790 │     });
  791 │     
  792 │     const occupancyRate = (occupiedDays / totalPossibleRoomDays) * 100;
  793 │     
  794 │     // Simulação de crescimento (em produção, compararia com mês anterior)
  795 │     const growth = occupancyRate > 50 ? 5 : -3;
  796 │     
  797 │     return {
  798 │       rate: Math.round(occupancyRate),
  799 │       growth: Math.round(growth)
  800 │     };
  801 │   } catch (error) {
  802 │     console.error('Erro ao calcular taxa de ocupação:', error);
  803 │     return { rate: 0, growth: 0 };
  804 │   }
  805 │ };
  806 │ 
  807 │ // Obter reservas agrupadas por plataforma
  808 │ export const getBookingsByPlatform = async () => {
  809 │   try {
  810 │     const bookings = await getDocuments<Booking>('bookings');
  811 │     
  812 │     // Categorizar reservas por origem
  813 │     const platforms = [
  814 │       { 
  815 │         platform: "Booking.com", 
  816 │         color: "#003580", 
  817 │         icon: "Globe",
  818 │         bookings: []
  819 │       },
  820 │       { 
  821 │         platform: "Airbnb", 
  822 │         color: "#FF5A5F", 
  823 │         icon: "Heart",
  824 │         bookings: []
  825 │       },
  826 │       { 
  827 │         platform: "Direto", 
  828 │         color: "#4CAF50", 
  829 │         icon: "Home",
  830 │         bookings: []
  831 │       }
  832 │     ];
  833 │     
  834 │     // Para fins de demonstração, colocar todas as reservas como "Direto" por enquanto
  835 │     // Em produção, usaria um campo "platformOrigin" ou similar na tabela de reservas
  836 │     const platformIndex = 2; // Índice da plataforma "Direto"
  837 │     
  838 │     bookings.forEach(booking => {
  839 │       // Transformar para o formato esperado pelo componente
  840 │       const transformedBooking = {
  841 │         id: booking.id || '',
  842 │         guestName: booking.guestName,
  843 │         roomName: booking.roomName,
  844 │         checkIn: booking.checkIn.toDate().toLocaleDateString('pt-PT'),
  845 │         checkOut: booking.checkOut.toDate().toLocaleDateString('pt-PT'),
  846 │         status: booking.status,
  847 │         value: new Intl.NumberFormat('pt-PT', {
  848 │           style: 'currency',
  849 │           currency: 'EUR'
  850 │         }).format(booking.totalPrice)
  851 │       };
  852 │       
  853 │       // Adicionar à plataforma "Direto"
  854 │       (platforms[platformIndex] as any).bookings.push(transformedBooking);
  855 │     });
  856 │     
  857 │     return platforms;
  858 │   } catch (error) {
  859 │     console.error('Erro ao obter reservas por plataforma:', error);
  860 │     return [];
  861 │   }
  862 │ };
  863 │ 
  864 │ // Função para obter o preço de um quarto para uma data específica
  865 │ export const getRoomPriceForDate = async (roomId: string, date: Date): Promise<number> => {
  866 │   try {
  867 │     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  868 │     
  869 │     if (!roomDoc.exists()) {
  870 │       throw new Error("Quarto não encontrado");
  871 │     }
  872 │     
  873 │     const roomData = roomDoc.data() as Room;
  874 │     const basePrice = roomData.price;
  875 │     
  876 │     if (!roomData.seasonalPrices || roomData.seasonalPrices.length === 0) {
  877 │       return basePrice;
  878 │     }
  879 │     
  880 │     // Verificar se a data está dentro de algum período sazonal
  881 │     for (const seasonalPrice of roomData.seasonalPrices) {
  882 │       const startDate = new Date(seasonalPrice.startDate);
  883 │       const endDate = new Date(seasonalPrice.endDate);
  884 │       
  885 │       if (date >= startDate && date <= endDate) {
  886 │         return seasonalPrice.price;
  887 │       }
  888 │     }
  889 │     
  890 │     // Se não cair em nenhum período sazonal, retorna o preço base
  891 │     return basePrice;
  892 │   } catch (error) {
  893 │     console.error("Erro ao obter preço do quarto:", error);
  894 │     throw error;
  895 │   }
  896 │ }
  897 │ 
  898 │ // Função para calcular o preço total de uma estadia
  899 │ export const calculateStayPrice = async (
  900 │   roomId: string, 
  901 │   checkIn: Date, 
  902 │   checkOut: Date
  903 │ ): Promise<{
  904 │   totalPrice: number;
  905 │   nightlyPrices: { date: string; price: number }[];
  906 │   serviceFee: number;
  907 │   totalWithFee: number;
  908 │ }> => {
  909 │   try {
  910 │     console.log(`🔍 Iniciando cálculo de preço para estadia: ${checkIn.toISOString().split('T')[0]} até ${checkOut.toISOString().split('T')[0]}`);
  911 │     
  912 │     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  913 │     
  914 │     if (!roomDoc.exists()) {
  915 │       throw new Error("Quarto não encontrado");
  916 │     }
  917 │     
  918 │     const roomData = roomDoc.data() as Room;
  919 │     console.log(`📝 Dados do quarto ${roomId}:`, {
  920 │       nome: roomData.name,
  921 │       precoBase: roomData.price,
  922 │       taxaServico: roomData.serviceFeePct || 0,
  923 │       temPrecosSazonais: !!roomData.seasonalPrices?.length
  924 │     });
  925 │     
  926 │     const nightlyPrices: { date: string; price: number }[] = [];
  927 │     let totalPrice = 0;
  928 │     
  929 │     // Calcular o número de noites - corrigido para usar o método correto de cálculo
  930 │     // O número de noites é a diferença em dias (estadia = checkout - checkin)
  931 │     const noites = differenceInDays(checkOut, checkIn);
  932 │     console.log(`🗓️ Número de noites calculado: ${noites}`);
  933 │     
  934 │     if (noites <= 0) {
  935 │       console.error(`⚠️ Erro: número de noites inválido (${noites})`);
  936 │       throw new Error("Data de check-out deve ser posterior à data de check-in");
  937 │     }
  938 │     
  939 │     // Para cada noite, verificar o preço aplicável (preço base ou sazonal)
  940 │     // Começamos exatamente do dia de check-in
  941 │     const currentDate = new Date(checkIn);
  942 │     currentDate.setHours(0, 0, 0, 0); // Normalizar para meia-noite
  943 │     
  944 │     // Processamos cada dia de estadia (noite)
  945 │     console.log(`📊 Calculando preços por noite:`);
  946 │     for (let i = 0; i < noites; i++) {
  947 │       // Obtemos o preço para esta data
  948 │       const dateCopy = new Date(currentDate);
  949 │       const priceForDate = await getRoomPriceForDate(roomId, dateCopy);
  950 │       const dateString = dateCopy.toISOString().split('T')[0]; // YYYY-MM-DD
  951 │       
  952 │       console.log(`   - ${dateString}: €${priceForDate}`);
  953 │       
  954 │       nightlyPrices.push({
  955 │         date: dateString,
  956 │         price: priceForDate
  957 │       });
  958 │       
  959 │       totalPrice += priceForDate;
  960 │       
  961 │       // Avançamos para o próximo dia
  962 │       currentDate.setDate(currentDate.getDate() + 1);
  963 │     }
  964 │     
  965 │     // Verificação de segurança para o cálculo do totalPrice
  966 │     const manualTotal = nightlyPrices.reduce((sum, night) => sum + night.price, 0);
  967 │     if (Math.abs(totalPrice - manualTotal) > 1) {
  968 │       console.error(`⚠️ Discrepância detectada no cálculo do preço total!`);
  969 │       console.error(`   - Total calculado iterativamente: €${totalPrice}`);
  970 │       console.error(`   - Total calculado via reduce: €${manualTotal}`);
  971 │       console.error(`   - Usando o valor recalculado para segurança!`);
  972 │       totalPrice = manualTotal;
  973 │     }
  974 │     
  975 │     // Calcular taxa de serviço
  976 │     const serviceFee = (totalPrice * (roomData.serviceFeePct || 0)) / 100;
  977 │     const totalWithFee = totalPrice + serviceFee;
  978 │     
  979 │     console.log(`💰 Resumo do cálculo:`);
  980 │     console.log(`   - Total das diárias: €${totalPrice}`);
  981 │     console.log(`   - Taxa de serviço (${roomData.serviceFeePct || 0}%): €${serviceFee}`);
  982 │     console.log(`   - Total com taxas: €${totalWithFee}`);
  983 │     
  984 │     return {
  985 │       totalPrice,
  986 │       nightlyPrices,
  987 │       serviceFee,
  988 │       totalWithFee
  989 │     };
  990 │   } catch (error) {
  991 │     console.error("❌ Erro ao calcular preço da estadia:", error);
  992 │     throw error;
  993 │   }
  994 │ } 
  995 │ import { 
  996 │   collection, 
  997 │   getDocs, 
  998 │   getDoc, 
  999 │   doc, 
 1000 │   setDoc, 
 1001 │   addDoc, 
 1002 │   updateDoc, 
 1003 │   deleteDoc,
 1004 │   query,
 1005 │   where,
 1006 │   orderBy,
 1007 │   limit,
      ·   ──┬──
      ·     ╰── `limit` redefined here
 1008 │   serverTimestamp
 1009 │ } from 'firebase/firestore';
 1010 │ import { db } from './config';
      ╰────

  × the name `serverTimestamp` is defined multiple times
      ╭─[/home/runner/workspace/lib/firebase/firestore.ts:14:1]
   14 │   DocumentData,
   15 │   QueryConstraint,
   16 │   Timestamp,
   17 │   serverTimestamp
      ·   ───────┬───────
      ·          ╰── previous definition of `serverTimestamp` here
   18 │ } from 'firebase/firestore'
   19 │ import { db } from './config'
   20 │ import { Room, SeasonalPrice } from '@/lib/types'
   21 │ import { differenceInDays } from 'date-fns'
   22 │ 
   23 │ // Tipos de dados
   24 │ export interface Booking {
   25 │   id?: string
   26 │   userId?: string
   27 │   guestName: string
   28 │   guestEmail: string
   29 │   guestPhone: string
   30 │   roomId: string
   31 │   roomName: string
   32 │   checkIn: Timestamp
   33 │   checkOut: Timestamp
   34 │   adults: number
   35 │   children: number
   36 │   totalPrice: number
   37 │   status: 'pending' | 'confirmed' | 'cancelled' | 'completed'
   38 │   paymentStatus: 'pending' | 'paid' | 'refunded'
   39 │   specialRequests?: string
   40 │   createdAt?: Timestamp
   41 │   updatedAt?: Timestamp
   42 │ }
   43 │ 
   44 │ export interface Contact {
   45 │   id?: string
   46 │   name: string
   47 │   email: string
   48 │   phone?: string
   49 │   subject: string
   50 │   message: string
   51 │   status: 'new' | 'read' | 'replied'
   52 │   createdAt: Timestamp
   53 │   updatedAt?: Timestamp
   54 │   repliedAt?: Timestamp
   55 │   replyContent?: string
   56 │   reservationDetails?: {
   57 │     checkIn?: Timestamp
   58 │     checkOut?: Timestamp
   59 │     roomId?: string
   60 │     roomName?: string
   61 │     totalGuests?: number
   62 │     totalPrice?: number
   63 │   }
   64 │ }
   65 │ 
   66 │ // Funções genéricas para CRUD
   67 │ export const createDocument = async <T extends DocumentData>(
   68 │   collectionName: string,
   69 │   data: T
   70 │ ): Promise<string> => {
   71 │   const docRef = await addDoc(collection(db, collectionName), {
   72 │     ...data,
   73 │     createdAt: serverTimestamp(),
   74 │     updatedAt: serverTimestamp()
   75 │   })
   76 │   return docRef.id
   77 │ }
   78 │ 
   79 │ export const createDocumentWithId = async <T extends DocumentData>(
   80 │   collectionName: string,
   81 │   id: string,
   82 │   data: T
   83 │ ): Promise<void> => {
   84 │   await setDoc(doc(db, collectionName, id), {
   85 │     ...data,
   86 │     createdAt: serverTimestamp(),
   87 │     updatedAt: serverTimestamp()
   88 │   })
   89 │ }
   90 │ 
   91 │ export const getDocument = async <T>(
   92 │   collectionName: string,
   93 │   id: string
   94 │ ): Promise<T | null> => {
   95 │   const docRef = doc(db, collectionName, id)
   96 │   const docSnap = await getDoc(docRef)
   97 │   
   98 │   if (docSnap.exists()) {
   99 │     const data = docSnap.data();
  100 │     console.log("Dados brutos recuperados do Firestore para quarto:", id, data);
  101 │     
  102 │     if (data?.serviceFeePct !== undefined) {
  103 │       console.log("serviceFeePct antes da conversão:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
  104 │       // Garantir que serviceFeePct seja um número
  105 │       data.serviceFeePct = Number(data.serviceFeePct);
  106 │       console.log("serviceFeePct após conversão:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
  107 │     }
  108 │     
  109 │     return { id: docSnap.id, ...data } as T
  110 │   } else {
  111 │     return null
  112 │   }
  113 │ }
  114 │ 
  115 │ export const getDocuments = async <T>(
  116 │   collectionName: string,
  117 │   constraints: QueryConstraint[] = [],
  118 │   forceRefresh = false
  119 │ ): Promise<T[]> => {
  120 │   try {
  121 │     const collectionRef = collection(db, collectionName)
  122 │     const q = query(collectionRef, ...constraints)
  123 │     
  124 │     // Se forceRefresh for verdadeiro, adicionar opções que forçam uma nova consulta ao Firestore
  125 │     const querySnapshot = await getDocs(q)
  126 │     
  127 │     console.log(`Buscando documentos na coleção ${collectionName} - Força atualização: ${forceRefresh}`);
  128 │     
  129 │     return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }) as T)
  130 │   } catch (error) {
  131 │     console.error(`Erro ao buscar documentos da coleção ${collectionName}:`, error);
  132 │     return [];
  133 │   }
  134 │ }
  135 │ 
  136 │ export const updateDocument = async <T extends DocumentData>(
  137 │   collectionName: string,
  138 │   id: string,
  139 │   data: Partial<T>
  140 │ ): Promise<void> => {
  141 │   const docRef = doc(db, collectionName, id)
  142 │   await updateDoc(docRef, {
  143 │     ...data,
  144 │     updatedAt: serverTimestamp()
  145 │   })
  146 │ }
  147 │ 
  148 │ export const deleteDocument = async (
  149 │   collectionName: string,
  150 │   id: string
  151 │ ): Promise<boolean> => {
  152 │   const docRef = doc(db, collectionName, id)
  153 │   await deleteDoc(docRef)
  154 │   return true
  155 │ }
  156 │ 
  157 │ // Funções para gerenciar quartos
  158 │ export const getRooms = async (forceRefresh = false): Promise<Room[]> => {
  159 │   try {
  160 │     const constraints: QueryConstraint[] = []
  161 │     
  162 │     constraints.push(orderBy('name', 'asc'))
  163 │     
  164 │     const rooms = await getDocuments<Room>('rooms', constraints, forceRefresh)
  165 │     
  166 │     // Garantir que todos os campos necessários estejam presentes
  167 │     return rooms.map(room => {
  168 │       console.log(`Firebase - Quarto ${room.id} dados brutos:`, room);
  169 │       
  170 │       // Garantir que serviceFeePct seja um número
  171 │       const serviceFeePct = room.serviceFeePct !== undefined 
  172 │         ? Number(room.serviceFeePct) 
  173 │         : 10;
  174 │         
  175 │       console.log(`Firebase - Quarto ${room.id} serviceFeePct:`, {
  176 │         original: room.serviceFeePct,
  177 │         tipo: typeof room.serviceFeePct,
  178 │         convertido: serviceFeePct
  179 │       });
  180 │       
  181 │       return {
  182 │         id: room.id,
  183 │         name: room.name || '',
  184 │         type: room.type || 'standard',
  185 │         description: room.description || '',
  186 │         price: room.price || 0,
  187 │         capacity: room.capacity || 2,
  188 │         size: room.size || 0,
  189 │         available: room.available !== undefined ? room.available : true,
  190 │         serviceFeePct: serviceFeePct,
  191 │         images: room.images || [],
  192 │         amenities: room.amenities || [],
  193 │         additionalServices: room.additionalServices || [],
  194 │         highlights: room.highlights || [],
  195 │         createdAt: room.createdAt,
  196 │         updatedAt: room.updatedAt
  197 │       };
  198 │     });
  199 │   } catch (error) {
  200 │     console.error('Erro ao buscar quartos:', error)
  201 │     return []
  202 │   }
  203 │ }
  204 │ 
  205 │ export const getAvailableRooms = async (
  206 │   checkIn: Date,
  207 │   checkOut: Date
  208 │ ): Promise<Room[]> => {
  209 │   try {
  210 │     // Buscar todos os quartos que estão marcados como disponíveis em geral
  211 │     const constraints: QueryConstraint[] = [
  212 │       where('available', '==', true)
  213 │     ]
  214 │     
  215 │     const rooms = await getDocuments<Room>('rooms', constraints);
  216 │     
  217 │     // Filtrar os quartos que estão disponíveis nas datas específicas
  218 │     return filterAvailableRoomsByDate(rooms, checkIn, checkOut);
  219 │   } catch (error) {
  220 │     console.error('Erro ao buscar quartos disponíveis:', error)
  221 │     return []
  222 │   }
  223 │ }
  224 │ 
  225 │ // Função auxiliar para verificar disponibilidade entre datas
  226 │ export const filterAvailableRoomsByDate = (
  227 │   rooms: Room[],
  228 │   checkIn: Date,
  229 │   checkOut: Date
  230 │ ): Room[] => {
  231 │   // Converter checkIn e checkOut para ISO strings
  232 │   const dateStrings = getDatesInRange(checkIn, checkOut);
  233 │   
  234 │   return rooms.filter(room => {
  235 │     // Se não tiver controle de disponibilidade específico, considera disponível
  236 │     if (!room.availabilityDates) return true;
  237 │     
  238 │     // Verificar se alguma data no intervalo está indisponível
  239 │     return !dateStrings.some(dateStr => 
  240 │       room.availabilityDates?.[dateStr] === false
  241 │     );
  242 │   });
  243 │ };
  244 │ 
  245 │ // Função para obter disponibilidade de um quarto específico
  246 │ export const getRoomAvailability = async (
  247 │   roomId: string, 
  248 │   startDate: Date, 
  249 │   endDate: Date
  250 │ ): Promise<{[date: string]: boolean}> => {
  251 │   try {
  252 │     const room = await getRoomById(roomId);
  253 │     if (!room) throw new Error(`Quarto com ID ${roomId} não encontrado`);
  254 │     
  255 │     // Gerar datas no intervalo
  256 │     const dateStrings = getDatesInRange(startDate, endDate);
  257 │     
  258 │     // Se não tiver configuração de disponibilidade específica, assume tudo disponível
  259 │     if (!room.availabilityDates) {
  260 │       return dateStrings.reduce((acc, date) => {
  261 │         acc[date] = true;
  262 │         return acc;
  263 │       }, {} as {[date: string]: boolean});
  264 │     }
  265 │     
  266 │     // Preencher com os dados de disponibilidade existentes
  267 │     return dateStrings.reduce((acc, date) => {
  268 │       acc[date] = room.availabilityDates?.[date] !== false; // disponível por padrão se não estiver explicitamente indisponível
  269 │       return acc;
  270 │     }, {} as {[date: string]: boolean});
  271 │   } catch (error) {
  272 │     console.error(`Erro ao verificar disponibilidade do quarto ${roomId}:`, error);
  273 │     throw error;
  274 │   }
  275 │ };
  276 │ 
  277 │ // Função para atualizar disponibilidade de um quarto
  278 │ export const updateRoomAvailability = async (
  279 │   roomId: string,
  280 │   availabilityDates: {[date: string]: boolean}
  281 │ ): Promise<boolean> => {
  282 │   try {
  283 │     await updateDocument('rooms', roomId, {
  284 │       availabilityDates,
  285 │       updatedAt: serverTimestamp()
  286 │     });
  287 │     return true;
  288 │   } catch (error) {
  289 │     console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  290 │     return false;
  291 │   }
  292 │ };
  293 │ 
  294 │ // Função auxiliar para gerar array de strings de data entre um intervalo
  295 │ export const getDatesInRange = (startDate: Date, endDate: Date): string[] => {
  296 │   const dates: string[] = [];
  297 │   const currentDate = new Date(startDate);
  298 │   
  299 │   // Normalizar para meia-noite no fuso horário local
  300 │   currentDate.setHours(0, 0, 0, 0);
  301 │   const endDateNormalized = new Date(endDate);
  302 │   endDateNormalized.setHours(0, 0, 0, 0);
  303 │   
  304 │   // Adicionar cada data no intervalo EXCETO o dia de checkout
  305 │   // Usando < em vez de <= para não incluir o dia de checkout
  306 │   while (currentDate < endDateNormalized) {
  307 │     dates.push(currentDate.toISOString().split('T')[0]); // Formato YYYY-MM-DD
  308 │     currentDate.setDate(currentDate.getDate() + 1);
  309 │   }
  310 │   
  311 │   return dates;
  312 │ };
  313 │ 
  314 │ export const getRoomById = async (id: string): Promise<Room | null> => {
  315 │   try {
  316 │     const room = await getDocument<Room>('rooms', id);
  317 │     
  318 │     if (!room) return null;
  319 │     
  320 │     console.log(`Firebase - getRoomById ${id} dados brutos:`, room);
  321 │     
  322 │     // Log específico para serviceFeePct
  323 │     console.log(`serviceFeePct no Firestore:`, room.serviceFeePct);
  324 │     
  325 │     // Garantir que todos os campos necessários estejam presentes
  326 │     return {
  327 │       ...room,
  328 │       name: room.name || '',
  329 │       type: room.type || 'standard',
  330 │       description: room.description || '',
  331 │       price: room.price || 0,
  332 │       capacity: room.capacity || 2,
  333 │       size: room.size || 0,
  334 │       available: room.available !== undefined ? room.available : true,
  335 │       serviceFeePct: room.serviceFeePct !== undefined ? room.serviceFeePct : 10,
  336 │       images: room.images || [],
  337 │       amenities: room.amenities || [],
  338 │       additionalServices: room.additionalServices || [],
  339 │       highlights: room.highlights || []
  340 │     };
  341 │   } catch (error) {
  342 │     console.error(`Erro ao buscar quarto com ID ${id}:`, error);
  343 │     return null;
  344 │   }
  345 │ }
  346 │ 
  347 │ export const createRoom = async (roomData: Omit<Room, 'id' | 'createdAt' | 'updatedAt'>): Promise<Room> => {
  348 │   try {
  349 │     console.log("createRoom - Dados recebidos:", roomData);
  350 │     
  351 │     const roomWithTimestamps = {
  352 │       ...roomData,
  353 │       available: roomData.available !== undefined ? roomData.available : true,
  354 │       featured: roomData.featured || false,
  355 │       amenities: roomData.amenities || [],
  356 │       additionalServices: roomData.additionalServices || [],
  357 │       highlights: roomData.highlights || [],
  358 │       createdAt: serverTimestamp(),
  359 │       updatedAt: serverTimestamp()
  360 │     }
  361 │     
  362 │     console.log("createRoom - Dados a serem salvos:", roomWithTimestamps);
  363 │     
  364 │     const id = await createDocument('rooms', roomWithTimestamps)
  365 │     
  366 │     return {
  367 │       id,
  368 │       ...roomData,
  369 │       amenities: roomData.amenities || [],
  370 │       additionalServices: roomData.additionalServices || [],
  371 │       highlights: roomData.highlights || [],
  372 │       createdAt: Timestamp.now(),
  373 │       updatedAt: Timestamp.now()
  374 │     }
  375 │   } catch (error) {
  376 │     console.error('Erro ao criar quarto:', error)
  377 │     throw error
  378 │   }
  379 │ }
  380 │ 
  381 │ export const updateRoom = async (id: string, roomData: Partial<Omit<Room, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Room> => {
  382 │   try {
  383 │     console.log(`updateRoom - ID: ${id}, Dados recebidos:`, roomData);
  384 │     
  385 │     // Garantir que estamos lidando explicitamente com o serviceFeePct se ele for 0
  386 │     if (roomData.serviceFeePct === 0) {
  387 │       console.log("updateRoom - Detectado serviceFeePct com valor 0, salvando explicitamente.", roomData.serviceFeePct);
  388 │     }
  389 │     
  390 │     // Adicionar timestamp de atualização
  391 │     const roomWithTimestamp = {
  392 │       ...roomData,
  393 │       amenities: roomData.amenities || [],
  394 │       additionalServices: roomData.additionalServices || [],
  395 │       highlights: roomData.highlights || [],
  396 │       updatedAt: serverTimestamp()
  397 │     }
  398 │     
  399 │     console.log(`updateRoom - Dados a serem salvos:`, roomWithTimestamp);
  400 │     
  401 │     await updateDocument('rooms', id, roomWithTimestamp)
  402 │     
  403 │     const updatedRoom = await getRoomById(id)
  404 │     if (!updatedRoom) {
  405 │       throw new Error(`Quarto com ID ${id} não encontrado após atualização`)
  406 │     }
  407 │     
  408 │     return updatedRoom
  409 │   } catch (error) {
  410 │     console.error('Erro ao atualizar quarto:', error)
  411 │     throw error
  412 │   }
  413 │ }
  414 │ 
  415 │ export const deleteRoom = async (id: string): Promise<boolean> => {
  416 │   return await deleteDocument('rooms', id)
  417 │ }
  418 │ 
  419 │ // Funções específicas para reservas
  420 │ export const createBooking = async (bookingData: any) => {
  421 │   try {
  422 │     const bookingsCollection = collection(db, 'bookings');
  423 │     const docRef = await addDoc(bookingsCollection, bookingData);
  424 │     
  425 │     // CORREÇÃO: Não bloquear a data no momento da criação da reserva
  426 │     // O bloqueio será feito apenas quando o pagamento for confirmado
  427 │     // através da função updateBookingStatus
  428 │     
  429 │     return docRef;
  430 │   } catch (error) {
  431 │     console.error('Erro ao criar reserva:', error);
  432 │     throw error;
  433 │   }
  434 │ };
  435 │ 
  436 │ // Nova função para atualizar status da reserva e bloquear as datas da estadia
  437 │ export const updateBookingStatus = async (
  438 │   bookingId: string, 
  439 │   newStatus: 'pending' | 'confirmed' | 'cancelled' | 'completed',
  440 │   newPaymentStatus: 'pending' | 'paid' | 'refunded'
  441 │ ): Promise<boolean> => {
  442 │   try {
  443 │     // Referência ao documento da reserva
  444 │     const bookingRef = doc(db, 'bookings', bookingId);
  445 │     const bookingSnap = await getDoc(bookingRef);
  446 │     
  447 │     if (!bookingSnap.exists()) {
  448 │       console.error(`Booking ${bookingId} não existe ao atualizar status`);
  449 │       return false;
  450 │     }
  451 │     
  452 │     const bookingData = bookingSnap.data();
  453 │     
  454 │     // Atualizar o status da reserva
  455 │     await updateDoc(bookingRef, {
  456 │       status: newStatus,
  457 │       paymentStatus: newPaymentStatus,
  458 │       updatedAt: serverTimestamp(),
  459 │       ...(newStatus === 'confirmed' && { confirmedAt: serverTimestamp() })
  460 │     });
  461 │     
  462 │     // Se a reserva está sendo confirmada, precisamos bloquear as datas
  463 │     if (newStatus === 'confirmed') {
  464 │       console.log(`Atualizando disponibilidade para reserva confirmada: ${bookingId}`);
  465 │       
  466 │       // Recuperar datas de check-in e check-out
  467 │       const checkIn = bookingData.checkIn.toDate();
  468 │       const checkOut = bookingData.checkOut.toDate();
  469 │       const roomId = bookingData.roomId;
  470 │       
  471 │       // Obter todas as datas entre check-in e check-out
  472 │       const dates: Date[] = [];
  473 │       const currentDate = new Date(checkIn);
  474 │       
  475 │       while (currentDate < checkOut) {
  476 │         dates.push(new Date(currentDate));
  477 │         currentDate.setDate(currentDate.getDate() + 1);
  478 │       }
  479 │       
  480 │       console.log(`Bloqueando ${dates.length} dias para quarto ${roomId}`);
  481 │       
  482 │       // Atualizar disponibilidade para cada data
  483 │       const availabilityUpdates: {[date: string]: boolean} = {};
  484 │       
  485 │       dates.forEach(date => {
  486 │         const dateString = date.toISOString().split('T')[0]; // formato YYYY-MM-DD
  487 │         availabilityUpdates[dateString] = false; // false significa indisponível
  488 │       });
  489 │       
  490 │       // Atualizar disponibilidade do quarto
  491 │       if (Object.keys(availabilityUpdates).length > 0) {
  492 │         try {
  493 │           // Obter o documento do quarto
  494 │           const roomRef = doc(db, 'rooms', roomId);
  495 │           const roomSnap = await getDoc(roomRef);
  496 │           
  497 │           if (roomSnap.exists()) {
  498 │             const roomData = roomSnap.data();
  499 │             const currentAvailability = roomData.availabilityDates || {};
  500 │             
  501 │             // Mesclar a disponibilidade atual com as novas atualizações
  502 │             const updatedAvailability = {
  503 │               ...currentAvailability,
  504 │               ...availabilityUpdates
  505 │             };
  506 │             
  507 │             // Atualizar o documento do quarto
  508 │             await updateDoc(roomRef, {
  509 │               availabilityDates: updatedAvailability,
  510 │               updatedAt: serverTimestamp()
  511 │             });
  512 │             
  513 │             console.log(`Disponibilidade atualizada com sucesso para quarto ${roomId}`);
  514 │             
  515 │             // Criar log da reserva
  516 │             await addDoc(collection(db, 'bookingLogs'), {
  517 │               bookingId,
  518 │               roomId,
  519 │               action: 'status_updated',
  520 │               previousStatus: bookingData.status,
  521 │               newStatus,
  522 │               previousPaymentStatus: bookingData.paymentStatus,
  523 │               newPaymentStatus,
  524 │               datesBlocked: Object.keys(availabilityUpdates),
  525 │               timestamp: serverTimestamp(),
  526 │               userId: bookingData.userId || 'system'
  527 │             });
  528 │           } else {
  529 │             console.error(`Quarto ${roomId} não encontrado ao atualizar disponibilidade`);
  530 │           }
  531 │         } catch (error) {
  532 │           console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  533 │         }
  534 │       }
  535 │     }
  536 │     
  537 │     return true;
  538 │   } catch (error) {
  539 │     console.error(`Erro ao atualizar status da reserva ${bookingId}:`, error);
  540 │     return false;
  541 │   }
  542 │ }
  543 │ 
  544 │ export const getUserBookings = async (userId: string): Promise<Booking[]> => {
  545 │   return getDocuments<Booking>('bookings', [
  546 │     where('userId', '==', userId),
  547 │     orderBy('createdAt', 'desc')
  548 │   ])
  549 │ }
  550 │ 
  551 │ export const getRecentBookings = async (count = 5): Promise<Booking[]> => {
  552 │   return getDocuments<Booking>('bookings', [
  553 │     orderBy('createdAt', 'desc'),
  554 │     limit(count)
  555 │   ])
  556 │ }
  557 │ 
  558 │ export const getRoomBookings = async (roomId: string): Promise<Booking[]> => {
  559 │   try {
  560 │     const constraints: QueryConstraint[] = [
  561 │       where('roomId', '==', roomId),
  562 │       orderBy('checkIn', 'asc')
  563 │     ];
  564 │     
  565 │     return await getDocuments<Booking>('bookings', constraints);
  566 │   } catch (error) {
  567 │     console.error(`Erro ao buscar reservas do quarto ${roomId}:`, error);
  568 │     return [];
  569 │   }
  570 │ };
  571 │ 
  572 │ // Funções específicas para contatos
  573 │ export const createContactMessage = async (contactData: Contact) => {
  574 │   try {
  575 │     const contactsCollection = collection(db, 'contacts')
  576 │     
  577 │     // Garantir que o status seja 'new' para novos contatos
  578 │     const contactWithDefaults = {
  579 │       ...contactData,
  580 │       status: contactData.status || 'new',
  581 │       createdAt: contactData.createdAt || Timestamp.now()
  582 │     }
  583 │     
  584 │     // Se tiver detalhes de reserva, adicionar metadados
  585 │     if (contactWithDefaults.reservationDetails) {
  586 │       // Ajustar subject para indicar que é relacionado a reserva
  587 │       if (!contactWithDefaults.subject.includes('Reserva')) {
  588 │         contactWithDefaults.subject = `Reserva: ${contactWithDefaults.subject}`;
  589 │       }
  590 │     }
  591 │     
  592 │     const docRef = await addDoc(contactsCollection, contactWithDefaults)
  593 │     return docRef
  594 │   } catch (error) {
  595 │     console.error('Erro ao criar mensagem de contato:', error)
  596 │     throw error
  597 │   }
  598 │ }
  599 │ 
  600 │ export const getNewContactMessages = async (): Promise<Contact[]> => {
  601 │   return getDocuments<Contact>('contacts', [
  602 │     where('status', '==', 'new'),
  603 │     orderBy('createdAt', 'desc')
  604 │   ])
  605 │ }
  606 │ 
  607 │ // Funções para Dashboard com dados reais
  608 │ 
  609 │ export const getDashboardStats = async () => {
  610 │   try {
  611 │     const [totalBookings, totalRevenue, occupancyRate, bookingsByPlatform] = await Promise.all([
  612 │       getTotalBookings(),
  613 │       getMonthlyRevenue(),
  614 │       getOccupancyRate(),
  615 │       getBookingsByPlatform()
  616 │     ]);
  617 │ 
  618 │     return {
  619 │       totalBookings,
  620 │       totalRevenue,
  621 │       occupancyRate,
  622 │       bookingsByPlatform
  623 │     };
  624 │   } catch (error) {
  625 │     console.error('Erro ao obter estatísticas do dashboard:', error);
  626 │     throw error;
  627 │   }
  628 │ };
  629 │ 
  630 │ // Obter total de reservas
  631 │ export const getTotalBookings = async () => {
  632 │   try {
  633 │     // Obter todas as reservas
  634 │     const bookings = await getDocuments<Booking>('bookings');
  635 │     
  636 │     // Contar reservas por status
  637 │     const confirmed = bookings.filter(b => b.status === 'confirmed').length;
  638 │     const pending = bookings.filter(b => b.status === 'pending').length;
  639 │     const cancelled = bookings.filter(b => b.status === 'cancelled').length;
  640 │     const completed = bookings.filter(b => b.status === 'completed').length;
  641 │     
  642 │     // Calcular crescimento em relação ao mês anterior (simulado por enquanto)
  643 │     // Em uma implementação real, você compararia com dados do mês anterior
  644 │     const growth = ((confirmed + completed) / (bookings.length || 1) * 100) - 50;
  645 │     
  646 │     return {
  647 │       total: bookings.length,
  648 │       confirmed,
  649 │       pending,
  650 │       cancelled,
  651 │       completed,
  652 │       growth: Math.round(growth) // Arredonda para número inteiro
  653 │     };
  654 │   } catch (error) {
  655 │     console.error('Erro ao obter total de reservas:', error);
  656 │     return {
  657 │       total: 0,
  658 │       confirmed: 0,
  659 │       pending: 0, 
  660 │       cancelled: 0,
  661 │       completed: 0,
  662 │       growth: 0
  663 │     };
  664 │   }
  665 │ };
  666 │ 
  667 │ // Obter receita mensal
  668 │ export const getMonthlyRevenue = async () => {
  669 │   try {
  670 │     const bookings = await getDocuments<Booking>('bookings');
  671 │     
  672 │     // Filtrar reservas confirmadas e concluídas
  673 │     const validBookings = bookings.filter(b => 
  674 │       b.status === 'confirmed' || b.status === 'completed'
  675 │     );
  676 │     
  677 │     // Calcular receita total
  678 │     const totalRevenue = validBookings.reduce((acc, booking) => acc + booking.totalPrice, 0);
  679 │     
  680 │     // Agrupar receita por mês
  681 │     const revenueByMonth = validBookings.reduce((acc, booking) => {
  682 │       const date = booking.checkIn.toDate();
  683 │       const month = date.getMonth(); // 0-11
  684 │       const year = date.getFullYear();
  685 │       const key = `${year}-${month}`;
  686 │       
  687 │       if (!acc[key]) {
  688 │         acc[key] = 0;
  689 │       }
  690 │       acc[key] += booking.totalPrice;
  691 │       return acc;
  692 │     }, {} as Record<string, number>);
  693 │     
  694 │     // Converter para formato de array para gráfico
  695 │     const monthNames = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
  696 │     
  697 │     const currentDate = new Date();
  698 │     const currentMonth = currentDate.getMonth();
  699 │     const currentYear = currentDate.getFullYear();
  700 │     
  701 │     const revenueData = [];
  702 │     
  703 │     // Gerar dados dos últimos 12 meses
  704 │     for (let i = 0; i < 12; i++) {
  705 │       const month = (currentMonth - i + 12) % 12;
  706 │       const year = currentMonth - i < 0 ? currentYear - 1 : currentYear;
  707 │       const key = `${year}-${month}`;
  708 │       
  709 │       revenueData.unshift({
  710 │         month: monthNames[month],
  711 │         value: revenueByMonth[key] || 0
  712 │       });
  713 │     }
  714 │     
  715 │     // Calcular crescimento em relação ao mês anterior
  716 │     const lastMonthRevenue = revenueData[revenueData.length - 2]?.value || 0;
  717 │     const currentMonthRevenue = revenueData[revenueData.length - 1]?.value || 0;
  718 │     
  719 │     const growth = lastMonthRevenue ? ((currentMonthRevenue - lastMonthRevenue) / lastMonthRevenue) * 100 : 0;
  720 │     
  721 │     return {
  722 │       monthly: currentMonthRevenue,
  723 │       total: totalRevenue,
  724 │       growth: Math.round(growth),
  725 │       revenueData
  726 │     };
  727 │   } catch (error) {
  728 │     console.error('Erro ao obter receita mensal:', error);
  729 │     return {
  730 │       monthly: 0,
  731 │       total: 0,
  732 │       growth: 0,
  733 │       revenueData: []
  734 │     };
  735 │   }
  736 │ };
  737 │ 
  738 │ // Calcular taxa de ocupação
  739 │ export const getOccupancyRate = async () => {
  740 │   try {
  741 │     // Obter todos os quartos
  742 │     const rooms = await getDocuments<Room>('rooms');
  743 │     const totalRooms = rooms.length;
  744 │     
  745 │     if (totalRooms === 0) {
  746 │       return { rate: 0, growth: 0 };
  747 │     }
  748 │     
  749 │     // Obter todas as reservas
  750 │     const bookings = await getDocuments<Booking>('bookings');
  751 │     
  752 │     // Filtrar reservas confirmadas e concluídas para o mês atual
  753 │     const currentDate = new Date();
  754 │     const currentMonth = currentDate.getMonth();
  755 │     const currentYear = currentDate.getFullYear();
  756 │     
  757 │     const currentMonthBookings = bookings.filter(booking => {
  758 │       const checkInDate = booking.checkIn.toDate();
  759 │       return (
  760 │         (booking.status === 'confirmed' || booking.status === 'completed') &&
  761 │         checkInDate.getMonth() === currentMonth &&
  762 │         checkInDate.getFullYear() === currentYear
  763 │       );
  764 │     });
  765 │     
  766 │     // Calcular dias ocupados por quarto
  767 │     const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
  768 │     const totalPossibleRoomDays = totalRooms * daysInMonth;
  769 │     
  770 │     // Contar dias ocupados (simplificado - em produção seria mais complexo)
  771 │     let occupiedDays = 0;
  772 │     
  773 │     currentMonthBookings.forEach(booking => {
  774 │       const checkIn = booking.checkIn.toDate();
  775 │       const checkOut = booking.checkOut.toDate();
  776 │       
  777 │       // Ajustar datas para considerar apenas o mês atual
  778 │       const startDate = new Date(Math.max(
  779 │         checkIn.getTime(),
  780 │         new Date(currentYear, currentMonth, 1).getTime()
  781 │       ));
  782 │       const endDate = new Date(Math.min(
  783 │         checkOut.getTime(),
  784 │         new Date(currentYear, currentMonth + 1, 0).getTime()
  785 │       ));
  786 │       
  787 │       // Calcular dias entre datas (incluindo check-in, excluindo check-out)
  788 │       const days = Math.max(0, Math.floor((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)));
  789 │       occupiedDays += days;
  790 │     });
  791 │     
  792 │     const occupancyRate = (occupiedDays / totalPossibleRoomDays) * 100;
  793 │     
  794 │     // Simulação de crescimento (em produção, compararia com mês anterior)
  795 │     const growth = occupancyRate > 50 ? 5 : -3;
  796 │     
  797 │     return {
  798 │       rate: Math.round(occupancyRate),
  799 │       growth: Math.round(growth)
  800 │     };
  801 │   } catch (error) {
  802 │     console.error('Erro ao calcular taxa de ocupação:', error);
  803 │     return { rate: 0, growth: 0 };
  804 │   }
  805 │ };
  806 │ 
  807 │ // Obter reservas agrupadas por plataforma
  808 │ export const getBookingsByPlatform = async () => {
  809 │   try {
  810 │     const bookings = await getDocuments<Booking>('bookings');
  811 │     
  812 │     // Categorizar reservas por origem
  813 │     const platforms = [
  814 │       { 
  815 │         platform: "Booking.com", 
  816 │         color: "#003580", 
  817 │         icon: "Globe",
  818 │         bookings: []
  819 │       },
  820 │       { 
  821 │         platform: "Airbnb", 
  822 │         color: "#FF5A5F", 
  823 │         icon: "Heart",
  824 │         bookings: []
  825 │       },
  826 │       { 
  827 │         platform: "Direto", 
  828 │         color: "#4CAF50", 
  829 │         icon: "Home",
  830 │         bookings: []
  831 │       }
  832 │     ];
  833 │     
  834 │     // Para fins de demonstração, colocar todas as reservas como "Direto" por enquanto
  835 │     // Em produção, usaria um campo "platformOrigin" ou similar na tabela de reservas
  836 │     const platformIndex = 2; // Índice da plataforma "Direto"
  837 │     
  838 │     bookings.forEach(booking => {
  839 │       // Transformar para o formato esperado pelo componente
  840 │       const transformedBooking = {
  841 │         id: booking.id || '',
  842 │         guestName: booking.guestName,
  843 │         roomName: booking.roomName,
  844 │         checkIn: booking.checkIn.toDate().toLocaleDateString('pt-PT'),
  845 │         checkOut: booking.checkOut.toDate().toLocaleDateString('pt-PT'),
  846 │         status: booking.status,
  847 │         value: new Intl.NumberFormat('pt-PT', {
  848 │           style: 'currency',
  849 │           currency: 'EUR'
  850 │         }).format(booking.totalPrice)
  851 │       };
  852 │       
  853 │       // Adicionar à plataforma "Direto"
  854 │       (platforms[platformIndex] as any).bookings.push(transformedBooking);
  855 │     });
  856 │     
  857 │     return platforms;
  858 │   } catch (error) {
  859 │     console.error('Erro ao obter reservas por plataforma:', error);
  860 │     return [];
  861 │   }
  862 │ };
  863 │ 
  864 │ // Função para obter o preço de um quarto para uma data específica
  865 │ export const getRoomPriceForDate = async (roomId: string, date: Date): Promise<number> => {
  866 │   try {
  867 │     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  868 │     
  869 │     if (!roomDoc.exists()) {
  870 │       throw new Error("Quarto não encontrado");
  871 │     }
  872 │     
  873 │     const roomData = roomDoc.data() as Room;
  874 │     const basePrice = roomData.price;
  875 │     
  876 │     if (!roomData.seasonalPrices || roomData.seasonalPrices.length === 0) {
  877 │       return basePrice;
  878 │     }
  879 │     
  880 │     // Verificar se a data está dentro de algum período sazonal
  881 │     for (const seasonalPrice of roomData.seasonalPrices) {
  882 │       const startDate = new Date(seasonalPrice.startDate);
  883 │       const endDate = new Date(seasonalPrice.endDate);
  884 │       
  885 │       if (date >= startDate && date <= endDate) {
  886 │         return seasonalPrice.price;
  887 │       }
  888 │     }
  889 │     
  890 │     // Se não cair em nenhum período sazonal, retorna o preço base
  891 │     return basePrice;
  892 │   } catch (error) {
  893 │     console.error("Erro ao obter preço do quarto:", error);
  894 │     throw error;
  895 │   }
  896 │ }
  897 │ 
  898 │ // Função para calcular o preço total de uma estadia
  899 │ export const calculateStayPrice = async (
  900 │   roomId: string, 
  901 │   checkIn: Date, 
  902 │   checkOut: Date
  903 │ ): Promise<{
  904 │   totalPrice: number;
  905 │   nightlyPrices: { date: string; price: number }[];
  906 │   serviceFee: number;
  907 │   totalWithFee: number;
  908 │ }> => {
  909 │   try {
  910 │     console.log(`🔍 Iniciando cálculo de preço para estadia: ${checkIn.toISOString().split('T')[0]} até ${checkOut.toISOString().split('T')[0]}`);
  911 │     
  912 │     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  913 │     
  914 │     if (!roomDoc.exists()) {
  915 │       throw new Error("Quarto não encontrado");
  916 │     }
  917 │     
  918 │     const roomData = roomDoc.data() as Room;
  919 │     console.log(`📝 Dados do quarto ${roomId}:`, {
  920 │       nome: roomData.name,
  921 │       precoBase: roomData.price,
  922 │       taxaServico: roomData.serviceFeePct || 0,
  923 │       temPrecosSazonais: !!roomData.seasonalPrices?.length
  924 │     });
  925 │     
  926 │     const nightlyPrices: { date: string; price: number }[] = [];
  927 │     let totalPrice = 0;
  928 │     
  929 │     // Calcular o número de noites - corrigido para usar o método correto de cálculo
  930 │     // O número de noites é a diferença em dias (estadia = checkout - checkin)
  931 │     const noites = differenceInDays(checkOut, checkIn);
  932 │     console.log(`🗓️ Número de noites calculado: ${noites}`);
  933 │     
  934 │     if (noites <= 0) {
  935 │       console.error(`⚠️ Erro: número de noites inválido (${noites})`);
  936 │       throw new Error("Data de check-out deve ser posterior à data de check-in");
  937 │     }
  938 │     
  939 │     // Para cada noite, verificar o preço aplicável (preço base ou sazonal)
  940 │     // Começamos exatamente do dia de check-in
  941 │     const currentDate = new Date(checkIn);
  942 │     currentDate.setHours(0, 0, 0, 0); // Normalizar para meia-noite
  943 │     
  944 │     // Processamos cada dia de estadia (noite)
  945 │     console.log(`📊 Calculando preços por noite:`);
  946 │     for (let i = 0; i < noites; i++) {
  947 │       // Obtemos o preço para esta data
  948 │       const dateCopy = new Date(currentDate);
  949 │       const priceForDate = await getRoomPriceForDate(roomId, dateCopy);
  950 │       const dateString = dateCopy.toISOString().split('T')[0]; // YYYY-MM-DD
  951 │       
  952 │       console.log(`   - ${dateString}: €${priceForDate}`);
  953 │       
  954 │       nightlyPrices.push({
  955 │         date: dateString,
  956 │         price: priceForDate
  957 │       });
  958 │       
  959 │       totalPrice += priceForDate;
  960 │       
  961 │       // Avançamos para o próximo dia
  962 │       currentDate.setDate(currentDate.getDate() + 1);
  963 │     }
  964 │     
  965 │     // Verificação de segurança para o cálculo do totalPrice
  966 │     const manualTotal = nightlyPrices.reduce((sum, night) => sum + night.price, 0);
  967 │     if (Math.abs(totalPrice - manualTotal) > 1) {
  968 │       console.error(`⚠️ Discrepância detectada no cálculo do preço total!`);
  969 │       console.error(`   - Total calculado iterativamente: €${totalPrice}`);
  970 │       console.error(`   - Total calculado via reduce: €${manualTotal}`);
  971 │       console.error(`   - Usando o valor recalculado para segurança!`);
  972 │       totalPrice = manualTotal;
  973 │     }
  974 │     
  975 │     // Calcular taxa de serviço
  976 │     const serviceFee = (totalPrice * (roomData.serviceFeePct || 0)) / 100;
  977 │     const totalWithFee = totalPrice + serviceFee;
  978 │     
  979 │     console.log(`💰 Resumo do cálculo:`);
  980 │     console.log(`   - Total das diárias: €${totalPrice}`);
  981 │     console.log(`   - Taxa de serviço (${roomData.serviceFeePct || 0}%): €${serviceFee}`);
  982 │     console.log(`   - Total com taxas: €${totalWithFee}`);
  983 │     
  984 │     return {
  985 │       totalPrice,
  986 │       nightlyPrices,
  987 │       serviceFee,
  988 │       totalWithFee
  989 │     };
  990 │   } catch (error) {
  991 │     console.error("❌ Erro ao calcular preço da estadia:", error);
  992 │     throw error;
  993 │   }
  994 │ } 
  995 │ import { 
  996 │   collection, 
  997 │   getDocs, 
  998 │   getDoc, 
  999 │   doc, 
 1000 │   setDoc, 
 1001 │   addDoc, 
 1002 │   updateDoc, 
 1003 │   deleteDoc,
 1004 │   query,
 1005 │   where,
 1006 │   orderBy,
 1007 │   limit,
 1008 │   serverTimestamp
      ·   ───────┬───────
      ·          ╰── `serverTimestamp` redefined here
 1009 │ } from 'firebase/firestore';
 1010 │ import { db } from './config';
      ╰────

  × the name `db` is defined multiple times
      ╭─[/home/runner/workspace/lib/firebase/firestore.ts:16:1]
   16 │   Timestamp,
   17 │   serverTimestamp
   18 │ } from 'firebase/firestore'
   19 │ import { db } from './config'
      ·          ─┬
      ·           ╰── previous definition of `db` here
   20 │ import { Room, SeasonalPrice } from '@/lib/types'
   21 │ import { differenceInDays } from 'date-fns'
   22 │ 
   23 │ // Tipos de dados
   24 │ export interface Booking {
   25 │   id?: string
   26 │   userId?: string
   27 │   guestName: string
   28 │   guestEmail: string
   29 │   guestPhone: string
   30 │   roomId: string
   31 │   roomName: string
   32 │   checkIn: Timestamp
   33 │   checkOut: Timestamp
   34 │   adults: number
   35 │   children: number
   36 │   totalPrice: number
   37 │   status: 'pending' | 'confirmed' | 'cancelled' | 'completed'
   38 │   paymentStatus: 'pending' | 'paid' | 'refunded'
   39 │   specialRequests?: string
   40 │   createdAt?: Timestamp
   41 │   updatedAt?: Timestamp
   42 │ }
   43 │ 
   44 │ export interface Contact {
   45 │   id?: string
   46 │   name: string
   47 │   email: string
   48 │   phone?: string
   49 │   subject: string
   50 │   message: string
   51 │   status: 'new' | 'read' | 'replied'
   52 │   createdAt: Timestamp
   53 │   updatedAt?: Timestamp
   54 │   repliedAt?: Timestamp
   55 │   replyContent?: string
   56 │   reservationDetails?: {
   57 │     checkIn?: Timestamp
   58 │     checkOut?: Timestamp
   59 │     roomId?: string
   60 │     roomName?: string
   61 │     totalGuests?: number
   62 │     totalPrice?: number
   63 │   }
   64 │ }
   65 │ 
   66 │ // Funções genéricas para CRUD
   67 │ export const createDocument = async <T extends DocumentData>(
   68 │   collectionName: string,
   69 │   data: T
   70 │ ): Promise<string> => {
   71 │   const docRef = await addDoc(collection(db, collectionName), {
   72 │     ...data,
   73 │     createdAt: serverTimestamp(),
   74 │     updatedAt: serverTimestamp()
   75 │   })
   76 │   return docRef.id
   77 │ }
   78 │ 
   79 │ export const createDocumentWithId = async <T extends DocumentData>(
   80 │   collectionName: string,
   81 │   id: string,
   82 │   data: T
   83 │ ): Promise<void> => {
   84 │   await setDoc(doc(db, collectionName, id), {
   85 │     ...data,
   86 │     createdAt: serverTimestamp(),
   87 │     updatedAt: serverTimestamp()
   88 │   })
   89 │ }
   90 │ 
   91 │ export const getDocument = async <T>(
   92 │   collectionName: string,
   93 │   id: string
   94 │ ): Promise<T | null> => {
   95 │   const docRef = doc(db, collectionName, id)
   96 │   const docSnap = await getDoc(docRef)
   97 │   
   98 │   if (docSnap.exists()) {
   99 │     const data = docSnap.data();
  100 │     console.log("Dados brutos recuperados do Firestore para quarto:", id, data);
  101 │     
  102 │     if (data?.serviceFeePct !== undefined) {
  103 │       console.log("serviceFeePct antes da conversão:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
  104 │       // Garantir que serviceFeePct seja um número
  105 │       data.serviceFeePct = Number(data.serviceFeePct);
  106 │       console.log("serviceFeePct após conversão:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
  107 │     }
  108 │     
  109 │     return { id: docSnap.id, ...data } as T
  110 │   } else {
  111 │     return null
  112 │   }
  113 │ }
  114 │ 
  115 │ export const getDocuments = async <T>(
  116 │   collectionName: string,
  117 │   constraints: QueryConstraint[] = [],
  118 │   forceRefresh = false
  119 │ ): Promise<T[]> => {
  120 │   try {
  121 │     const collectionRef = collection(db, collectionName)
  122 │     const q = query(collectionRef, ...constraints)
  123 │     
  124 │     // Se forceRefresh for verdadeiro, adicionar opções que forçam uma nova consulta ao Firestore
  125 │     const querySnapshot = await getDocs(q)
  126 │     
  127 │     console.log(`Buscando documentos na coleção ${collectionName} - Força atualização: ${forceRefresh}`);
  128 │     
  129 │     return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }) as T)
  130 │   } catch (error) {
  131 │     console.error(`Erro ao buscar documentos da coleção ${collectionName}:`, error);
  132 │     return [];
  133 │   }
  134 │ }
  135 │ 
  136 │ export const updateDocument = async <T extends DocumentData>(
  137 │   collectionName: string,
  138 │   id: string,
  139 │   data: Partial<T>
  140 │ ): Promise<void> => {
  141 │   const docRef = doc(db, collectionName, id)
  142 │   await updateDoc(docRef, {
  143 │     ...data,
  144 │     updatedAt: serverTimestamp()
  145 │   })
  146 │ }
  147 │ 
  148 │ export const deleteDocument = async (
  149 │   collectionName: string,
  150 │   id: string
  151 │ ): Promise<boolean> => {
  152 │   const docRef = doc(db, collectionName, id)
  153 │   await deleteDoc(docRef)
  154 │   return true
  155 │ }
  156 │ 
  157 │ // Funções para gerenciar quartos
  158 │ export const getRooms = async (forceRefresh = false): Promise<Room[]> => {
  159 │   try {
  160 │     const constraints: QueryConstraint[] = []
  161 │     
  162 │     constraints.push(orderBy('name', 'asc'))
  163 │     
  164 │     const rooms = await getDocuments<Room>('rooms', constraints, forceRefresh)
  165 │     
  166 │     // Garantir que todos os campos necessários estejam presentes
  167 │     return rooms.map(room => {
  168 │       console.log(`Firebase - Quarto ${room.id} dados brutos:`, room);
  169 │       
  170 │       // Garantir que serviceFeePct seja um número
  171 │       const serviceFeePct = room.serviceFeePct !== undefined 
  172 │         ? Number(room.serviceFeePct) 
  173 │         : 10;
  174 │         
  175 │       console.log(`Firebase - Quarto ${room.id} serviceFeePct:`, {
  176 │         original: room.serviceFeePct,
  177 │         tipo: typeof room.serviceFeePct,
  178 │         convertido: serviceFeePct
  179 │       });
  180 │       
  181 │       return {
  182 │         id: room.id,
  183 │         name: room.name || '',
  184 │         type: room.type || 'standard',
  185 │         description: room.description || '',
  186 │         price: room.price || 0,
  187 │         capacity: room.capacity || 2,
  188 │         size: room.size || 0,
  189 │         available: room.available !== undefined ? room.available : true,
  190 │         serviceFeePct: serviceFeePct,
  191 │         images: room.images || [],
  192 │         amenities: room.amenities || [],
  193 │         additionalServices: room.additionalServices || [],
  194 │         highlights: room.highlights || [],
  195 │         createdAt: room.createdAt,
  196 │         updatedAt: room.updatedAt
  197 │       };
  198 │     });
  199 │   } catch (error) {
  200 │     console.error('Erro ao buscar quartos:', error)
  201 │     return []
  202 │   }
  203 │ }
  204 │ 
  205 │ export const getAvailableRooms = async (
  206 │   checkIn: Date,
  207 │   checkOut: Date
  208 │ ): Promise<Room[]> => {
  209 │   try {
  210 │     // Buscar todos os quartos que estão marcados como disponíveis em geral
  211 │     const constraints: QueryConstraint[] = [
  212 │       where('available', '==', true)
  213 │     ]
  214 │     
  215 │     const rooms = await getDocuments<Room>('rooms', constraints);
  216 │     
  217 │     // Filtrar os quartos que estão disponíveis nas datas específicas
  218 │     return filterAvailableRoomsByDate(rooms, checkIn, checkOut);
  219 │   } catch (error) {
  220 │     console.error('Erro ao buscar quartos disponíveis:', error)
  221 │     return []
  222 │   }
  223 │ }
  224 │ 
  225 │ // Função auxiliar para verificar disponibilidade entre datas
  226 │ export const filterAvailableRoomsByDate = (
  227 │   rooms: Room[],
  228 │   checkIn: Date,
  229 │   checkOut: Date
  230 │ ): Room[] => {
  231 │   // Converter checkIn e checkOut para ISO strings
  232 │   const dateStrings = getDatesInRange(checkIn, checkOut);
  233 │   
  234 │   return rooms.filter(room => {
  235 │     // Se não tiver controle de disponibilidade específico, considera disponível
  236 │     if (!room.availabilityDates) return true;
  237 │     
  238 │     // Verificar se alguma data no intervalo está indisponível
  239 │     return !dateStrings.some(dateStr => 
  240 │       room.availabilityDates?.[dateStr] === false
  241 │     );
  242 │   });
  243 │ };
  244 │ 
  245 │ // Função para obter disponibilidade de um quarto específico
  246 │ export const getRoomAvailability = async (
  247 │   roomId: string, 
  248 │   startDate: Date, 
  249 │   endDate: Date
  250 │ ): Promise<{[date: string]: boolean}> => {
  251 │   try {
  252 │     const room = await getRoomById(roomId);
  253 │     if (!room) throw new Error(`Quarto com ID ${roomId} não encontrado`);
  254 │     
  255 │     // Gerar datas no intervalo
  256 │     const dateStrings = getDatesInRange(startDate, endDate);
  257 │     
  258 │     // Se não tiver configuração de disponibilidade específica, assume tudo disponível
  259 │     if (!room.availabilityDates) {
  260 │       return dateStrings.reduce((acc, date) => {
  261 │         acc[date] = true;
  262 │         return acc;
  263 │       }, {} as {[date: string]: boolean});
  264 │     }
  265 │     
  266 │     // Preencher com os dados de disponibilidade existentes
  267 │     return dateStrings.reduce((acc, date) => {
  268 │       acc[date] = room.availabilityDates?.[date] !== false; // disponível por padrão se não estiver explicitamente indisponível
  269 │       return acc;
  270 │     }, {} as {[date: string]: boolean});
  271 │   } catch (error) {
  272 │     console.error(`Erro ao verificar disponibilidade do quarto ${roomId}:`, error);
  273 │     throw error;
  274 │   }
  275 │ };
  276 │ 
  277 │ // Função para atualizar disponibilidade de um quarto
  278 │ export const updateRoomAvailability = async (
  279 │   roomId: string,
  280 │   availabilityDates: {[date: string]: boolean}
  281 │ ): Promise<boolean> => {
  282 │   try {
  283 │     await updateDocument('rooms', roomId, {
  284 │       availabilityDates,
  285 │       updatedAt: serverTimestamp()
  286 │     });
  287 │     return true;
  288 │   } catch (error) {
  289 │     console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  290 │     return false;
  291 │   }
  292 │ };
  293 │ 
  294 │ // Função auxiliar para gerar array de strings de data entre um intervalo
  295 │ export const getDatesInRange = (startDate: Date, endDate: Date): string[] => {
  296 │   const dates: string[] = [];
  297 │   const currentDate = new Date(startDate);
  298 │   
  299 │   // Normalizar para meia-noite no fuso horário local
  300 │   currentDate.setHours(0, 0, 0, 0);
  301 │   const endDateNormalized = new Date(endDate);
  302 │   endDateNormalized.setHours(0, 0, 0, 0);
  303 │   
  304 │   // Adicionar cada data no intervalo EXCETO o dia de checkout
  305 │   // Usando < em vez de <= para não incluir o dia de checkout
  306 │   while (currentDate < endDateNormalized) {
  307 │     dates.push(currentDate.toISOString().split('T')[0]); // Formato YYYY-MM-DD
  308 │     currentDate.setDate(currentDate.getDate() + 1);
  309 │   }
  310 │   
  311 │   return dates;
  312 │ };
  313 │ 
  314 │ export const getRoomById = async (id: string): Promise<Room | null> => {
  315 │   try {
  316 │     const room = await getDocument<Room>('rooms', id);
  317 │     
  318 │     if (!room) return null;
  319 │     
  320 │     console.log(`Firebase - getRoomById ${id} dados brutos:`, room);
  321 │     
  322 │     // Log específico para serviceFeePct
  323 │     console.log(`serviceFeePct no Firestore:`, room.serviceFeePct);
  324 │     
  325 │     // Garantir que todos os campos necessários estejam presentes
  326 │     return {
  327 │       ...room,
  328 │       name: room.name || '',
  329 │       type: room.type || 'standard',
  330 │       description: room.description || '',
  331 │       price: room.price || 0,
  332 │       capacity: room.capacity || 2,
  333 │       size: room.size || 0,
  334 │       available: room.available !== undefined ? room.available : true,
  335 │       serviceFeePct: room.serviceFeePct !== undefined ? room.serviceFeePct : 10,
  336 │       images: room.images || [],
  337 │       amenities: room.amenities || [],
  338 │       additionalServices: room.additionalServices || [],
  339 │       highlights: room.highlights || []
  340 │     };
  341 │   } catch (error) {
  342 │     console.error(`Erro ao buscar quarto com ID ${id}:`, error);
  343 │     return null;
  344 │   }
  345 │ }
  346 │ 
  347 │ export const createRoom = async (roomData: Omit<Room, 'id' | 'createdAt' | 'updatedAt'>): Promise<Room> => {
  348 │   try {
  349 │     console.log("createRoom - Dados recebidos:", roomData);
  350 │     
  351 │     const roomWithTimestamps = {
  352 │       ...roomData,
  353 │       available: roomData.available !== undefined ? roomData.available : true,
  354 │       featured: roomData.featured || false,
  355 │       amenities: roomData.amenities || [],
  356 │       additionalServices: roomData.additionalServices || [],
  357 │       highlights: roomData.highlights || [],
  358 │       createdAt: serverTimestamp(),
  359 │       updatedAt: serverTimestamp()
  360 │     }
  361 │     
  362 │     console.log("createRoom - Dados a serem salvos:", roomWithTimestamps);
  363 │     
  364 │     const id = await createDocument('rooms', roomWithTimestamps)
  365 │     
  366 │     return {
  367 │       id,
  368 │       ...roomData,
  369 │       amenities: roomData.amenities || [],
  370 │       additionalServices: roomData.additionalServices || [],
  371 │       highlights: roomData.highlights || [],
  372 │       createdAt: Timestamp.now(),
  373 │       updatedAt: Timestamp.now()
  374 │     }
  375 │   } catch (error) {
  376 │     console.error('Erro ao criar quarto:', error)
  377 │     throw error
  378 │   }
  379 │ }
  380 │ 
  381 │ export const updateRoom = async (id: string, roomData: Partial<Omit<Room, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Room> => {
  382 │   try {
  383 │     console.log(`updateRoom - ID: ${id}, Dados recebidos:`, roomData);
  384 │     
  385 │     // Garantir que estamos lidando explicitamente com o serviceFeePct se ele for 0
  386 │     if (roomData.serviceFeePct === 0) {
  387 │       console.log("updateRoom - Detectado serviceFeePct com valor 0, salvando explicitamente.", roomData.serviceFeePct);
  388 │     }
  389 │     
  390 │     // Adicionar timestamp de atualização
  391 │     const roomWithTimestamp = {
  392 │       ...roomData,
  393 │       amenities: roomData.amenities || [],
  394 │       additionalServices: roomData.additionalServices || [],
  395 │       highlights: roomData.highlights || [],
  396 │       updatedAt: serverTimestamp()
  397 │     }
  398 │     
  399 │     console.log(`updateRoom - Dados a serem salvos:`, roomWithTimestamp);
  400 │     
  401 │     await updateDocument('rooms', id, roomWithTimestamp)
  402 │     
  403 │     const updatedRoom = await getRoomById(id)
  404 │     if (!updatedRoom) {
  405 │       throw new Error(`Quarto com ID ${id} não encontrado após atualização`)
  406 │     }
  407 │     
  408 │     return updatedRoom
  409 │   } catch (error) {
  410 │     console.error('Erro ao atualizar quarto:', error)
  411 │     throw error
  412 │   }
  413 │ }
  414 │ 
  415 │ export const deleteRoom = async (id: string): Promise<boolean> => {
  416 │   return await deleteDocument('rooms', id)
  417 │ }
  418 │ 
  419 │ // Funções específicas para reservas
  420 │ export const createBooking = async (bookingData: any) => {
  421 │   try {
  422 │     const bookingsCollection = collection(db, 'bookings');
  423 │     const docRef = await addDoc(bookingsCollection, bookingData);
  424 │     
  425 │     // CORREÇÃO: Não bloquear a data no momento da criação da reserva
  426 │     // O bloqueio será feito apenas quando o pagamento for confirmado
  427 │     // através da função updateBookingStatus
  428 │     
  429 │     return docRef;
  430 │   } catch (error) {
  431 │     console.error('Erro ao criar reserva:', error);
  432 │     throw error;
  433 │   }
  434 │ };
  435 │ 
  436 │ // Nova função para atualizar status da reserva e bloquear as datas da estadia
  437 │ export const updateBookingStatus = async (
  438 │   bookingId: string, 
  439 │   newStatus: 'pending' | 'confirmed' | 'cancelled' | 'completed',
  440 │   newPaymentStatus: 'pending' | 'paid' | 'refunded'
  441 │ ): Promise<boolean> => {
  442 │   try {
  443 │     // Referência ao documento da reserva
  444 │     const bookingRef = doc(db, 'bookings', bookingId);
  445 │     const bookingSnap = await getDoc(bookingRef);
  446 │     
  447 │     if (!bookingSnap.exists()) {
  448 │       console.error(`Booking ${bookingId} não existe ao atualizar status`);
  449 │       return false;
  450 │     }
  451 │     
  452 │     const bookingData = bookingSnap.data();
  453 │     
  454 │     // Atualizar o status da reserva
  455 │     await updateDoc(bookingRef, {
  456 │       status: newStatus,
  457 │       paymentStatus: newPaymentStatus,
  458 │       updatedAt: serverTimestamp(),
  459 │       ...(newStatus === 'confirmed' && { confirmedAt: serverTimestamp() })
  460 │     });
  461 │     
  462 │     // Se a reserva está sendo confirmada, precisamos bloquear as datas
  463 │     if (newStatus === 'confirmed') {
  464 │       console.log(`Atualizando disponibilidade para reserva confirmada: ${bookingId}`);
  465 │       
  466 │       // Recuperar datas de check-in e check-out
  467 │       const checkIn = bookingData.checkIn.toDate();
  468 │       const checkOut = bookingData.checkOut.toDate();
  469 │       const roomId = bookingData.roomId;
  470 │       
  471 │       // Obter todas as datas entre check-in e check-out
  472 │       const dates: Date[] = [];
  473 │       const currentDate = new Date(checkIn);
  474 │       
  475 │       while (currentDate < checkOut) {
  476 │         dates.push(new Date(currentDate));
  477 │         currentDate.setDate(currentDate.getDate() + 1);
  478 │       }
  479 │       
  480 │       console.log(`Bloqueando ${dates.length} dias para quarto ${roomId}`);
  481 │       
  482 │       // Atualizar disponibilidade para cada data
  483 │       const availabilityUpdates: {[date: string]: boolean} = {};
  484 │       
  485 │       dates.forEach(date => {
  486 │         const dateString = date.toISOString().split('T')[0]; // formato YYYY-MM-DD
  487 │         availabilityUpdates[dateString] = false; // false significa indisponível
  488 │       });
  489 │       
  490 │       // Atualizar disponibilidade do quarto
  491 │       if (Object.keys(availabilityUpdates).length > 0) {
  492 │         try {
  493 │           // Obter o documento do quarto
  494 │           const roomRef = doc(db, 'rooms', roomId);
  495 │           const roomSnap = await getDoc(roomRef);
  496 │           
  497 │           if (roomSnap.exists()) {
  498 │             const roomData = roomSnap.data();
  499 │             const currentAvailability = roomData.availabilityDates || {};
  500 │             
  501 │             // Mesclar a disponibilidade atual com as novas atualizações
  502 │             const updatedAvailability = {
  503 │               ...currentAvailability,
  504 │               ...availabilityUpdates
  505 │             };
  506 │             
  507 │             // Atualizar o documento do quarto
  508 │             await updateDoc(roomRef, {
  509 │               availabilityDates: updatedAvailability,
  510 │               updatedAt: serverTimestamp()
  511 │             });
  512 │             
  513 │             console.log(`Disponibilidade atualizada com sucesso para quarto ${roomId}`);
  514 │             
  515 │             // Criar log da reserva
  516 │             await addDoc(collection(db, 'bookingLogs'), {
  517 │               bookingId,
  518 │               roomId,
  519 │               action: 'status_updated',
  520 │               previousStatus: bookingData.status,
  521 │               newStatus,
  522 │               previousPaymentStatus: bookingData.paymentStatus,
  523 │               newPaymentStatus,
  524 │               datesBlocked: Object.keys(availabilityUpdates),
  525 │               timestamp: serverTimestamp(),
  526 │               userId: bookingData.userId || 'system'
  527 │             });
  528 │           } else {
  529 │             console.error(`Quarto ${roomId} não encontrado ao atualizar disponibilidade`);
  530 │           }
  531 │         } catch (error) {
  532 │           console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  533 │         }
  534 │       }
  535 │     }
  536 │     
  537 │     return true;
  538 │   } catch (error) {
  539 │     console.error(`Erro ao atualizar status da reserva ${bookingId}:`, error);
  540 │     return false;
  541 │   }
  542 │ }
  543 │ 
  544 │ export const getUserBookings = async (userId: string): Promise<Booking[]> => {
  545 │   return getDocuments<Booking>('bookings', [
  546 │     where('userId', '==', userId),
  547 │     orderBy('createdAt', 'desc')
  548 │   ])
  549 │ }
  550 │ 
  551 │ export const getRecentBookings = async (count = 5): Promise<Booking[]> => {
  552 │   return getDocuments<Booking>('bookings', [
  553 │     orderBy('createdAt', 'desc'),
  554 │     limit(count)
  555 │   ])
  556 │ }
  557 │ 
  558 │ export const getRoomBookings = async (roomId: string): Promise<Booking[]> => {
  559 │   try {
  560 │     const constraints: QueryConstraint[] = [
  561 │       where('roomId', '==', roomId),
  562 │       orderBy('checkIn', 'asc')
  563 │     ];
  564 │     
  565 │     return await getDocuments<Booking>('bookings', constraints);
  566 │   } catch (error) {
  567 │     console.error(`Erro ao buscar reservas do quarto ${roomId}:`, error);
  568 │     return [];
  569 │   }
  570 │ };
  571 │ 
  572 │ // Funções específicas para contatos
  573 │ export const createContactMessage = async (contactData: Contact) => {
  574 │   try {
  575 │     const contactsCollection = collection(db, 'contacts')
  576 │     
  577 │     // Garantir que o status seja 'new' para novos contatos
  578 │     const contactWithDefaults = {
  579 │       ...contactData,
  580 │       status: contactData.status || 'new',
  581 │       createdAt: contactData.createdAt || Timestamp.now()
  582 │     }
  583 │     
  584 │     // Se tiver detalhes de reserva, adicionar metadados
  585 │     if (contactWithDefaults.reservationDetails) {
  586 │       // Ajustar subject para indicar que é relacionado a reserva
  587 │       if (!contactWithDefaults.subject.includes('Reserva')) {
  588 │         contactWithDefaults.subject = `Reserva: ${contactWithDefaults.subject}`;
  589 │       }
  590 │     }
  591 │     
  592 │     const docRef = await addDoc(contactsCollection, contactWithDefaults)
  593 │     return docRef
  594 │   } catch (error) {
  595 │     console.error('Erro ao criar mensagem de contato:', error)
  596 │     throw error
  597 │   }
  598 │ }
  599 │ 
  600 │ export const getNewContactMessages = async (): Promise<Contact[]> => {
  601 │   return getDocuments<Contact>('contacts', [
  602 │     where('status', '==', 'new'),
  603 │     orderBy('createdAt', 'desc')
  604 │   ])
  605 │ }
  606 │ 
  607 │ // Funções para Dashboard com dados reais
  608 │ 
  609 │ export const getDashboardStats = async () => {
  610 │   try {
  611 │     const [totalBookings, totalRevenue, occupancyRate, bookingsByPlatform] = await Promise.all([
  612 │       getTotalBookings(),
  613 │       getMonthlyRevenue(),
  614 │       getOccupancyRate(),
  615 │       getBookingsByPlatform()
  616 │     ]);
  617 │ 
  618 │     return {
  619 │       totalBookings,
  620 │       totalRevenue,
  621 │       occupancyRate,
  622 │       bookingsByPlatform
  623 │     };
  624 │   } catch (error) {
  625 │     console.error('Erro ao obter estatísticas do dashboard:', error);
  626 │     throw error;
  627 │   }
  628 │ };
  629 │ 
  630 │ // Obter total de reservas
  631 │ export const getTotalBookings = async () => {
  632 │   try {
  633 │     // Obter todas as reservas
  634 │     const bookings = await getDocuments<Booking>('bookings');
  635 │     
  636 │     // Contar reservas por status
  637 │     const confirmed = bookings.filter(b => b.status === 'confirmed').length;
  638 │     const pending = bookings.filter(b => b.status === 'pending').length;
  639 │     const cancelled = bookings.filter(b => b.status === 'cancelled').length;
  640 │     const completed = bookings.filter(b => b.status === 'completed').length;
  641 │     
  642 │     // Calcular crescimento em relação ao mês anterior (simulado por enquanto)
  643 │     // Em uma implementação real, você compararia com dados do mês anterior
  644 │     const growth = ((confirmed + completed) / (bookings.length || 1) * 100) - 50;
  645 │     
  646 │     return {
  647 │       total: bookings.length,
  648 │       confirmed,
  649 │       pending,
  650 │       cancelled,
  651 │       completed,
  652 │       growth: Math.round(growth) // Arredonda para número inteiro
  653 │     };
  654 │   } catch (error) {
  655 │     console.error('Erro ao obter total de reservas:', error);
  656 │     return {
  657 │       total: 0,
  658 │       confirmed: 0,
  659 │       pending: 0, 
  660 │       cancelled: 0,
  661 │       completed: 0,
  662 │       growth: 0
  663 │     };
  664 │   }
  665 │ };
  666 │ 
  667 │ // Obter receita mensal
  668 │ export const getMonthlyRevenue = async () => {
  669 │   try {
  670 │     const bookings = await getDocuments<Booking>('bookings');
  671 │     
  672 │     // Filtrar reservas confirmadas e concluídas
  673 │     const validBookings = bookings.filter(b => 
  674 │       b.status === 'confirmed' || b.status === 'completed'
  675 │     );
  676 │     
  677 │     // Calcular receita total
  678 │     const totalRevenue = validBookings.reduce((acc, booking) => acc + booking.totalPrice, 0);
  679 │     
  680 │     // Agrupar receita por mês
  681 │     const revenueByMonth = validBookings.reduce((acc, booking) => {
  682 │       const date = booking.checkIn.toDate();
  683 │       const month = date.getMonth(); // 0-11
  684 │       const year = date.getFullYear();
  685 │       const key = `${year}-${month}`;
  686 │       
  687 │       if (!acc[key]) {
  688 │         acc[key] = 0;
  689 │       }
  690 │       acc[key] += booking.totalPrice;
  691 │       return acc;
  692 │     }, {} as Record<string, number>);
  693 │     
  694 │     // Converter para formato de array para gráfico
  695 │     const monthNames = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
  696 │     
  697 │     const currentDate = new Date();
  698 │     const currentMonth = currentDate.getMonth();
  699 │     const currentYear = currentDate.getFullYear();
  700 │     
  701 │     const revenueData = [];
  702 │     
  703 │     // Gerar dados dos últimos 12 meses
  704 │     for (let i = 0; i < 12; i++) {
  705 │       const month = (currentMonth - i + 12) % 12;
  706 │       const year = currentMonth - i < 0 ? currentYear - 1 : currentYear;
  707 │       const key = `${year}-${month}`;
  708 │       
  709 │       revenueData.unshift({
  710 │         month: monthNames[month],
  711 │         value: revenueByMonth[key] || 0
  712 │       });
  713 │     }
  714 │     
  715 │     // Calcular crescimento em relação ao mês anterior
  716 │     const lastMonthRevenue = revenueData[revenueData.length - 2]?.value || 0;
  717 │     const currentMonthRevenue = revenueData[revenueData.length - 1]?.value || 0;
  718 │     
  719 │     const growth = lastMonthRevenue ? ((currentMonthRevenue - lastMonthRevenue) / lastMonthRevenue) * 100 : 0;
  720 │     
  721 │     return {
  722 │       monthly: currentMonthRevenue,
  723 │       total: totalRevenue,
  724 │       growth: Math.round(growth),
  725 │       revenueData
  726 │     };
  727 │   } catch (error) {
  728 │     console.error('Erro ao obter receita mensal:', error);
  729 │     return {
  730 │       monthly: 0,
  731 │       total: 0,
  732 │       growth: 0,
  733 │       revenueData: []
  734 │     };
  735 │   }
  736 │ };
  737 │ 
  738 │ // Calcular taxa de ocupação
  739 │ export const getOccupancyRate = async () => {
  740 │   try {
  741 │     // Obter todos os quartos
  742 │     const rooms = await getDocuments<Room>('rooms');
  743 │     const totalRooms = rooms.length;
  744 │     
  745 │     if (totalRooms === 0) {
  746 │       return { rate: 0, growth: 0 };
  747 │     }
  748 │     
  749 │     // Obter todas as reservas
  750 │     const bookings = await getDocuments<Booking>('bookings');
  751 │     
  752 │     // Filtrar reservas confirmadas e concluídas para o mês atual
  753 │     const currentDate = new Date();
  754 │     const currentMonth = currentDate.getMonth();
  755 │     const currentYear = currentDate.getFullYear();
  756 │     
  757 │     const currentMonthBookings = bookings.filter(booking => {
  758 │       const checkInDate = booking.checkIn.toDate();
  759 │       return (
  760 │         (booking.status === 'confirmed' || booking.status === 'completed') &&
  761 │         checkInDate.getMonth() === currentMonth &&
  762 │         checkInDate.getFullYear() === currentYear
  763 │       );
  764 │     });
  765 │     
  766 │     // Calcular dias ocupados por quarto
  767 │     const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
  768 │     const totalPossibleRoomDays = totalRooms * daysInMonth;
  769 │     
  770 │     // Contar dias ocupados (simplificado - em produção seria mais complexo)
  771 │     let occupiedDays = 0;
  772 │     
  773 │     currentMonthBookings.forEach(booking => {
  774 │       const checkIn = booking.checkIn.toDate();
  775 │       const checkOut = booking.checkOut.toDate();
  776 │       
  777 │       // Ajustar datas para considerar apenas o mês atual
  778 │       const startDate = new Date(Math.max(
  779 │         checkIn.getTime(),
  780 │         new Date(currentYear, currentMonth, 1).getTime()
  781 │       ));
  782 │       const endDate = new Date(Math.min(
  783 │         checkOut.getTime(),
  784 │         new Date(currentYear, currentMonth + 1, 0).getTime()
  785 │       ));
  786 │       
  787 │       // Calcular dias entre datas (incluindo check-in, excluindo check-out)
  788 │       const days = Math.max(0, Math.floor((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)));
  789 │       occupiedDays += days;
  790 │     });
  791 │     
  792 │     const occupancyRate = (occupiedDays / totalPossibleRoomDays) * 100;
  793 │     
  794 │     // Simulação de crescimento (em produção, compararia com mês anterior)
  795 │     const growth = occupancyRate > 50 ? 5 : -3;
  796 │     
  797 │     return {
  798 │       rate: Math.round(occupancyRate),
  799 │       growth: Math.round(growth)
  800 │     };
  801 │   } catch (error) {
  802 │     console.error('Erro ao calcular taxa de ocupação:', error);
  803 │     return { rate: 0, growth: 0 };
  804 │   }
  805 │ };
  806 │ 
  807 │ // Obter reservas agrupadas por plataforma
  808 │ export const getBookingsByPlatform = async () => {
  809 │   try {
  810 │     const bookings = await getDocuments<Booking>('bookings');
  811 │     
  812 │     // Categorizar reservas por origem
  813 │     const platforms = [
  814 │       { 
  815 │         platform: "Booking.com", 
  816 │         color: "#003580", 
  817 │         icon: "Globe",
  818 │         bookings: []
  819 │       },
  820 │       { 
  821 │         platform: "Airbnb", 
  822 │         color: "#FF5A5F", 
  823 │         icon: "Heart",
  824 │         bookings: []
  825 │       },
  826 │       { 
  827 │         platform: "Direto", 
  828 │         color: "#4CAF50", 
  829 │         icon: "Home",
  830 │         bookings: []
  831 │       }
  832 │     ];
  833 │     
  834 │     // Para fins de demonstração, colocar todas as reservas como "Direto" por enquanto
  835 │     // Em produção, usaria um campo "platformOrigin" ou similar na tabela de reservas
  836 │     const platformIndex = 2; // Índice da plataforma "Direto"
  837 │     
  838 │     bookings.forEach(booking => {
  839 │       // Transformar para o formato esperado pelo componente
  840 │       const transformedBooking = {
  841 │         id: booking.id || '',
  842 │         guestName: booking.guestName,
  843 │         roomName: booking.roomName,
  844 │         checkIn: booking.checkIn.toDate().toLocaleDateString('pt-PT'),
  845 │         checkOut: booking.checkOut.toDate().toLocaleDateString('pt-PT'),
  846 │         status: booking.status,
  847 │         value: new Intl.NumberFormat('pt-PT', {
  848 │           style: 'currency',
  849 │           currency: 'EUR'
  850 │         }).format(booking.totalPrice)
  851 │       };
  852 │       
  853 │       // Adicionar à plataforma "Direto"
  854 │       (platforms[platformIndex] as any).bookings.push(transformedBooking);
  855 │     });
  856 │     
  857 │     return platforms;
  858 │   } catch (error) {
  859 │     console.error('Erro ao obter reservas por plataforma:', error);
  860 │     return [];
  861 │   }
  862 │ };
  863 │ 
  864 │ // Função para obter o preço de um quarto para uma data específica
  865 │ export const getRoomPriceForDate = async (roomId: string, date: Date): Promise<number> => {
  866 │   try {
  867 │     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  868 │     
  869 │     if (!roomDoc.exists()) {
  870 │       throw new Error("Quarto não encontrado");
  871 │     }
  872 │     
  873 │     const roomData = roomDoc.data() as Room;
  874 │     const basePrice = roomData.price;
  875 │     
  876 │     if (!roomData.seasonalPrices || roomData.seasonalPrices.length === 0) {
  877 │       return basePrice;
  878 │     }
  879 │     
  880 │     // Verificar se a data está dentro de algum período sazonal
  881 │     for (const seasonalPrice of roomData.seasonalPrices) {
  882 │       const startDate = new Date(seasonalPrice.startDate);
  883 │       const endDate = new Date(seasonalPrice.endDate);
  884 │       
  885 │       if (date >= startDate && date <= endDate) {
  886 │         return seasonalPrice.price;
  887 │       }
  888 │     }
  889 │     
  890 │     // Se não cair em nenhum período sazonal, retorna o preço base
  891 │     return basePrice;
  892 │   } catch (error) {
  893 │     console.error("Erro ao obter preço do quarto:", error);
  894 │     throw error;
  895 │   }
  896 │ }
  897 │ 
  898 │ // Função para calcular o preço total de uma estadia
  899 │ export const calculateStayPrice = async (
  900 │   roomId: string, 
  901 │   checkIn: Date, 
  902 │   checkOut: Date
  903 │ ): Promise<{
  904 │   totalPrice: number;
  905 │   nightlyPrices: { date: string; price: number }[];
  906 │   serviceFee: number;
  907 │   totalWithFee: number;
  908 │ }> => {
  909 │   try {
  910 │     console.log(`🔍 Iniciando cálculo de preço para estadia: ${checkIn.toISOString().split('T')[0]} até ${checkOut.toISOString().split('T')[0]}`);
  911 │     
  912 │     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  913 │     
  914 │     if (!roomDoc.exists()) {
  915 │       throw new Error("Quarto não encontrado");
  916 │     }
  917 │     
  918 │     const roomData = roomDoc.data() as Room;
  919 │     console.log(`📝 Dados do quarto ${roomId}:`, {
  920 │       nome: roomData.name,
  921 │       precoBase: roomData.price,
  922 │       taxaServico: roomData.serviceFeePct || 0,
  923 │       temPrecosSazonais: !!roomData.seasonalPrices?.length
  924 │     });
  925 │     
  926 │     const nightlyPrices: { date: string; price: number }[] = [];
  927 │     let totalPrice = 0;
  928 │     
  929 │     // Calcular o número de noites - corrigido para usar o método correto de cálculo
  930 │     // O número de noites é a diferença em dias (estadia = checkout - checkin)
  931 │     const noites = differenceInDays(checkOut, checkIn);
  932 │     console.log(`🗓️ Número de noites calculado: ${noites}`);
  933 │     
  934 │     if (noites <= 0) {
  935 │       console.error(`⚠️ Erro: número de noites inválido (${noites})`);
  936 │       throw new Error("Data de check-out deve ser posterior à data de check-in");
  937 │     }
  938 │     
  939 │     // Para cada noite, verificar o preço aplicável (preço base ou sazonal)
  940 │     // Começamos exatamente do dia de check-in
  941 │     const currentDate = new Date(checkIn);
  942 │     currentDate.setHours(0, 0, 0, 0); // Normalizar para meia-noite
  943 │     
  944 │     // Processamos cada dia de estadia (noite)
  945 │     console.log(`📊 Calculando preços por noite:`);
  946 │     for (let i = 0; i < noites; i++) {
  947 │       // Obtemos o preço para esta data
  948 │       const dateCopy = new Date(currentDate);
  949 │       const priceForDate = await getRoomPriceForDate(roomId, dateCopy);
  950 │       const dateString = dateCopy.toISOString().split('T')[0]; // YYYY-MM-DD
  951 │       
  952 │       console.log(`   - ${dateString}: €${priceForDate}`);
  953 │       
  954 │       nightlyPrices.push({
  955 │         date: dateString,
  956 │         price: priceForDate
  957 │       });
  958 │       
  959 │       totalPrice += priceForDate;
  960 │       
  961 │       // Avançamos para o próximo dia
  962 │       currentDate.setDate(currentDate.getDate() + 1);
  963 │     }
  964 │     
  965 │     // Verificação de segurança para o cálculo do totalPrice
  966 │     const manualTotal = nightlyPrices.reduce((sum, night) => sum + night.price, 0);
  967 │     if (Math.abs(totalPrice - manualTotal) > 1) {
  968 │       console.error(`⚠️ Discrepância detectada no cálculo do preço total!`);
  969 │       console.error(`   - Total calculado iterativamente: €${totalPrice}`);
  970 │       console.error(`   - Total calculado via reduce: €${manualTotal}`);
  971 │       console.error(`   - Usando o valor recalculado para segurança!`);
  972 │       totalPrice = manualTotal;
  973 │     }
  974 │     
  975 │     // Calcular taxa de serviço
  976 │     const serviceFee = (totalPrice * (roomData.serviceFeePct || 0)) / 100;
  977 │     const totalWithFee = totalPrice + serviceFee;
  978 │     
  979 │     console.log(`💰 Resumo do cálculo:`);
  980 │     console.log(`   - Total das diárias: €${totalPrice}`);
  981 │     console.log(`   - Taxa de serviço (${roomData.serviceFeePct || 0}%): €${serviceFee}`);
  982 │     console.log(`   - Total com taxas: €${totalWithFee}`);
  983 │     
  984 │     return {
  985 │       totalPrice,
  986 │       nightlyPrices,
  987 │       serviceFee,
  988 │       totalWithFee
  989 │     };
  990 │   } catch (error) {
  991 │     console.error("❌ Erro ao calcular preço da estadia:", error);
  992 │     throw error;
  993 │   }
  994 │ } 
  995 │ import { 
  996 │   collection, 
  997 │   getDocs, 
  998 │   getDoc, 
  999 │   doc, 
 1000 │   setDoc, 
 1001 │   addDoc, 
 1002 │   updateDoc, 
 1003 │   deleteDoc,
 1004 │   query,
 1005 │   where,
 1006 │   orderBy,
 1007 │   limit,
 1008 │   serverTimestamp
 1009 │ } from 'firebase/firestore';
 1010 │ import { db } from './config';
      ·          ─┬
      ·           ╰── `db` redefined here
 1011 │ 
 1012 │ // Get all documents from a collection
 1013 │ export async function getDocuments<T>(collectionName: string, forceRefresh = false): Promise<T[]> {
      ╰────

  × the name `getDocuments` is defined multiple times
      ╭─[/home/runner/workspace/lib/firebase/firestore.ts:112:1]
  112 │   }
  113 │ }
  114 │ 
  115 │ export const getDocuments = async <T>(
      ·              ──────┬─────
      ·                    ╰── previous definition of `getDocuments` here
  116 │   collectionName: string,
  117 │   constraints: QueryConstraint[] = [],
  118 │   forceRefresh = false
  119 │ ): Promise<T[]> => {
  120 │   try {
  121 │     const collectionRef = collection(db, collectionName)
  122 │     const q = query(collectionRef, ...constraints)
  123 │     
  124 │     // Se forceRefresh for verdadeiro, adicionar opções que forçam uma nova consulta ao Firestore
  125 │     const querySnapshot = await getDocs(q)
  126 │     
  127 │     console.log(`Buscando documentos na coleção ${collectionName} - Força atualização: ${forceRefresh}`);
  128 │     
  129 │     return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }) as T)
  130 │   } catch (error) {
  131 │     console.error(`Erro ao buscar documentos da coleção ${collectionName}:`, error);
  132 │     return [];
  133 │   }
  134 │ }
  135 │ 
  136 │ export const updateDocument = async <T extends DocumentData>(
  137 │   collectionName: string,
  138 │   id: string,
  139 │   data: Partial<T>
  140 │ ): Promise<void> => {
  141 │   const docRef = doc(db, collectionName, id)
  142 │   await updateDoc(docRef, {
  143 │     ...data,
  144 │     updatedAt: serverTimestamp()
  145 │   })
  146 │ }
  147 │ 
  148 │ export const deleteDocument = async (
  149 │   collectionName: string,
  150 │   id: string
  151 │ ): Promise<boolean> => {
  152 │   const docRef = doc(db, collectionName, id)
  153 │   await deleteDoc(docRef)
  154 │   return true
  155 │ }
  156 │ 
  157 │ // Funções para gerenciar quartos
  158 │ export const getRooms = async (forceRefresh = false): Promise<Room[]> => {
  159 │   try {
  160 │     const constraints: QueryConstraint[] = []
  161 │     
  162 │     constraints.push(orderBy('name', 'asc'))
  163 │     
  164 │     const rooms = await getDocuments<Room>('rooms', constraints, forceRefresh)
  165 │     
  166 │     // Garantir que todos os campos necessários estejam presentes
  167 │     return rooms.map(room => {
  168 │       console.log(`Firebase - Quarto ${room.id} dados brutos:`, room);
  169 │       
  170 │       // Garantir que serviceFeePct seja um número
  171 │       const serviceFeePct = room.serviceFeePct !== undefined 
  172 │         ? Number(room.serviceFeePct) 
  173 │         : 10;
  174 │         
  175 │       console.log(`Firebase - Quarto ${room.id} serviceFeePct:`, {
  176 │         original: room.serviceFeePct,
  177 │         tipo: typeof room.serviceFeePct,
  178 │         convertido: serviceFeePct
  179 │       });
  180 │       
  181 │       return {
  182 │         id: room.id,
  183 │         name: room.name || '',
  184 │         type: room.type || 'standard',
  185 │         description: room.description || '',
  186 │         price: room.price || 0,
  187 │         capacity: room.capacity || 2,
  188 │         size: room.size || 0,
  189 │         available: room.available !== undefined ? room.available : true,
  190 │         serviceFeePct: serviceFeePct,
  191 │         images: room.images || [],
  192 │         amenities: room.amenities || [],
  193 │         additionalServices: room.additionalServices || [],
  194 │         highlights: room.highlights || [],
  195 │         createdAt: room.createdAt,
  196 │         updatedAt: room.updatedAt
  197 │       };
  198 │     });
  199 │   } catch (error) {
  200 │     console.error('Erro ao buscar quartos:', error)
  201 │     return []
  202 │   }
  203 │ }
  204 │ 
  205 │ export const getAvailableRooms = async (
  206 │   checkIn: Date,
  207 │   checkOut: Date
  208 │ ): Promise<Room[]> => {
  209 │   try {
  210 │     // Buscar todos os quartos que estão marcados como disponíveis em geral
  211 │     const constraints: QueryConstraint[] = [
  212 │       where('available', '==', true)
  213 │     ]
  214 │     
  215 │     const rooms = await getDocuments<Room>('rooms', constraints);
  216 │     
  217 │     // Filtrar os quartos que estão disponíveis nas datas específicas
  218 │     return filterAvailableRoomsByDate(rooms, checkIn, checkOut);
  219 │   } catch (error) {
  220 │     console.error('Erro ao buscar quartos disponíveis:', error)
  221 │     return []
  222 │   }
  223 │ }
  224 │ 
  225 │ // Função auxiliar para verificar disponibilidade entre datas
  226 │ export const filterAvailableRoomsByDate = (
  227 │   rooms: Room[],
  228 │   checkIn: Date,
  229 │   checkOut: Date
  230 │ ): Room[] => {
  231 │   // Converter checkIn e checkOut para ISO strings
  232 │   const dateStrings = getDatesInRange(checkIn, checkOut);
  233 │   
  234 │   return rooms.filter(room => {
  235 │     // Se não tiver controle de disponibilidade específico, considera disponível
  236 │     if (!room.availabilityDates) return true;
  237 │     
  238 │     // Verificar se alguma data no intervalo está indisponível
  239 │     return !dateStrings.some(dateStr => 
  240 │       room.availabilityDates?.[dateStr] === false
  241 │     );
  242 │   });
  243 │ };
  244 │ 
  245 │ // Função para obter disponibilidade de um quarto específico
  246 │ export const getRoomAvailability = async (
  247 │   roomId: string, 
  248 │   startDate: Date, 
  249 │   endDate: Date
  250 │ ): Promise<{[date: string]: boolean}> => {
  251 │   try {
  252 │     const room = await getRoomById(roomId);
  253 │     if (!room) throw new Error(`Quarto com ID ${roomId} não encontrado`);
  254 │     
  255 │     // Gerar datas no intervalo
  256 │     const dateStrings = getDatesInRange(startDate, endDate);
  257 │     
  258 │     // Se não tiver configuração de disponibilidade específica, assume tudo disponível
  259 │     if (!room.availabilityDates) {
  260 │       return dateStrings.reduce((acc, date) => {
  261 │         acc[date] = true;
  262 │         return acc;
  263 │       }, {} as {[date: string]: boolean});
  264 │     }
  265 │     
  266 │     // Preencher com os dados de disponibilidade existentes
  267 │     return dateStrings.reduce((acc, date) => {
  268 │       acc[date] = room.availabilityDates?.[date] !== false; // disponível por padrão se não estiver explicitamente indisponível
  269 │       return acc;
  270 │     }, {} as {[date: string]: boolean});
  271 │   } catch (error) {
  272 │     console.error(`Erro ao verificar disponibilidade do quarto ${roomId}:`, error);
  273 │     throw error;
  274 │   }
  275 │ };
  276 │ 
  277 │ // Função para atualizar disponibilidade de um quarto
  278 │ export const updateRoomAvailability = async (
  279 │   roomId: string,
  280 │   availabilityDates: {[date: string]: boolean}
  281 │ ): Promise<boolean> => {
  282 │   try {
  283 │     await updateDocument('rooms', roomId, {
  284 │       availabilityDates,
  285 │       updatedAt: serverTimestamp()
  286 │     });
  287 │     return true;
  288 │   } catch (error) {
  289 │     console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  290 │     return false;
  291 │   }
  292 │ };
  293 │ 
  294 │ // Função auxiliar para gerar array de strings de data entre um intervalo
  295 │ export const getDatesInRange = (startDate: Date, endDate: Date): string[] => {
  296 │   const dates: string[] = [];
  297 │   const currentDate = new Date(startDate);
  298 │   
  299 │   // Normalizar para meia-noite no fuso horário local
  300 │   currentDate.setHours(0, 0, 0, 0);
  301 │   const endDateNormalized = new Date(endDate);
  302 │   endDateNormalized.setHours(0, 0, 0, 0);
  303 │   
  304 │   // Adicionar cada data no intervalo EXCETO o dia de checkout
  305 │   // Usando < em vez de <= para não incluir o dia de checkout
  306 │   while (currentDate < endDateNormalized) {
  307 │     dates.push(currentDate.toISOString().split('T')[0]); // Formato YYYY-MM-DD
  308 │     currentDate.setDate(currentDate.getDate() + 1);
  309 │   }
  310 │   
  311 │   return dates;
  312 │ };
  313 │ 
  314 │ export const getRoomById = async (id: string): Promise<Room | null> => {
  315 │   try {
  316 │     const room = await getDocument<Room>('rooms', id);
  317 │     
  318 │     if (!room) return null;
  319 │     
  320 │     console.log(`Firebase - getRoomById ${id} dados brutos:`, room);
  321 │     
  322 │     // Log específico para serviceFeePct
  323 │     console.log(`serviceFeePct no Firestore:`, room.serviceFeePct);
  324 │     
  325 │     // Garantir que todos os campos necessários estejam presentes
  326 │     return {
  327 │       ...room,
  328 │       name: room.name || '',
  329 │       type: room.type || 'standard',
  330 │       description: room.description || '',
  331 │       price: room.price || 0,
  332 │       capacity: room.capacity || 2,
  333 │       size: room.size || 0,
  334 │       available: room.available !== undefined ? room.available : true,
  335 │       serviceFeePct: room.serviceFeePct !== undefined ? room.serviceFeePct : 10,
  336 │       images: room.images || [],
  337 │       amenities: room.amenities || [],
  338 │       additionalServices: room.additionalServices || [],
  339 │       highlights: room.highlights || []
  340 │     };
  341 │   } catch (error) {
  342 │     console.error(`Erro ao buscar quarto com ID ${id}:`, error);
  343 │     return null;
  344 │   }
  345 │ }
  346 │ 
  347 │ export const createRoom = async (roomData: Omit<Room, 'id' | 'createdAt' | 'updatedAt'>): Promise<Room> => {
  348 │   try {
  349 │     console.log("createRoom - Dados recebidos:", roomData);
  350 │     
  351 │     const roomWithTimestamps = {
  352 │       ...roomData,
  353 │       available: roomData.available !== undefined ? roomData.available : true,
  354 │       featured: roomData.featured || false,
  355 │       amenities: roomData.amenities || [],
  356 │       additionalServices: roomData.additionalServices || [],
  357 │       highlights: roomData.highlights || [],
  358 │       createdAt: serverTimestamp(),
  359 │       updatedAt: serverTimestamp()
  360 │     }
  361 │     
  362 │     console.log("createRoom - Dados a serem salvos:", roomWithTimestamps);
  363 │     
  364 │     const id = await createDocument('rooms', roomWithTimestamps)
  365 │     
  366 │     return {
  367 │       id,
  368 │       ...roomData,
  369 │       amenities: roomData.amenities || [],
  370 │       additionalServices: roomData.additionalServices || [],
  371 │       highlights: roomData.highlights || [],
  372 │       createdAt: Timestamp.now(),
  373 │       updatedAt: Timestamp.now()
  374 │     }
  375 │   } catch (error) {
  376 │     console.error('Erro ao criar quarto:', error)
  377 │     throw error
  378 │   }
  379 │ }
  380 │ 
  381 │ export const updateRoom = async (id: string, roomData: Partial<Omit<Room, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Room> => {
  382 │   try {
  383 │     console.log(`updateRoom - ID: ${id}, Dados recebidos:`, roomData);
  384 │     
  385 │     // Garantir que estamos lidando explicitamente com o serviceFeePct se ele for 0
  386 │     if (roomData.serviceFeePct === 0) {
  387 │       console.log("updateRoom - Detectado serviceFeePct com valor 0, salvando explicitamente.", roomData.serviceFeePct);
  388 │     }
  389 │     
  390 │     // Adicionar timestamp de atualização
  391 │     const roomWithTimestamp = {
  392 │       ...roomData,
  393 │       amenities: roomData.amenities || [],
  394 │       additionalServices: roomData.additionalServices || [],
  395 │       highlights: roomData.highlights || [],
  396 │       updatedAt: serverTimestamp()
  397 │     }
  398 │     
  399 │     console.log(`updateRoom - Dados a serem salvos:`, roomWithTimestamp);
  400 │     
  401 │     await updateDocument('rooms', id, roomWithTimestamp)
  402 │     
  403 │     const updatedRoom = await getRoomById(id)
  404 │     if (!updatedRoom) {
  405 │       throw new Error(`Quarto com ID ${id} não encontrado após atualização`)
  406 │     }
  407 │     
  408 │     return updatedRoom
  409 │   } catch (error) {
  410 │     console.error('Erro ao atualizar quarto:', error)
  411 │     throw error
  412 │   }
  413 │ }
  414 │ 
  415 │ export const deleteRoom = async (id: string): Promise<boolean> => {
  416 │   return await deleteDocument('rooms', id)
  417 │ }
  418 │ 
  419 │ // Funções específicas para reservas
  420 │ export const createBooking = async (bookingData: any) => {
  421 │   try {
  422 │     const bookingsCollection = collection(db, 'bookings');
  423 │     const docRef = await addDoc(bookingsCollection, bookingData);
  424 │     
  425 │     // CORREÇÃO: Não bloquear a data no momento da criação da reserva
  426 │     // O bloqueio será feito apenas quando o pagamento for confirmado
  427 │     // através da função updateBookingStatus
  428 │     
  429 │     return docRef;
  430 │   } catch (error) {
  431 │     console.error('Erro ao criar reserva:', error);
  432 │     throw error;
  433 │   }
  434 │ };
  435 │ 
  436 │ // Nova função para atualizar status da reserva e bloquear as datas da estadia
  437 │ export const updateBookingStatus = async (
  438 │   bookingId: string, 
  439 │   newStatus: 'pending' | 'confirmed' | 'cancelled' | 'completed',
  440 │   newPaymentStatus: 'pending' | 'paid' | 'refunded'
  441 │ ): Promise<boolean> => {
  442 │   try {
  443 │     // Referência ao documento da reserva
  444 │     const bookingRef = doc(db, 'bookings', bookingId);
  445 │     const bookingSnap = await getDoc(bookingRef);
  446 │     
  447 │     if (!bookingSnap.exists()) {
  448 │       console.error(`Booking ${bookingId} não existe ao atualizar status`);
  449 │       return false;
  450 │     }
  451 │     
  452 │     const bookingData = bookingSnap.data();
  453 │     
  454 │     // Atualizar o status da reserva
  455 │     await updateDoc(bookingRef, {
  456 │       status: newStatus,
  457 │       paymentStatus: newPaymentStatus,
  458 │       updatedAt: serverTimestamp(),
  459 │       ...(newStatus === 'confirmed' && { confirmedAt: serverTimestamp() })
  460 │     });
  461 │     
  462 │     // Se a reserva está sendo confirmada, precisamos bloquear as datas
  463 │     if (newStatus === 'confirmed') {
  464 │       console.log(`Atualizando disponibilidade para reserva confirmada: ${bookingId}`);
  465 │       
  466 │       // Recuperar datas de check-in e check-out
  467 │       const checkIn = bookingData.checkIn.toDate();
  468 │       const checkOut = bookingData.checkOut.toDate();
  469 │       const roomId = bookingData.roomId;
  470 │       
  471 │       // Obter todas as datas entre check-in e check-out
  472 │       const dates: Date[] = [];
  473 │       const currentDate = new Date(checkIn);
  474 │       
  475 │       while (currentDate < checkOut) {
  476 │         dates.push(new Date(currentDate));
  477 │         currentDate.setDate(currentDate.getDate() + 1);
  478 │       }
  479 │       
  480 │       console.log(`Bloqueando ${dates.length} dias para quarto ${roomId}`);
  481 │       
  482 │       // Atualizar disponibilidade para cada data
  483 │       const availabilityUpdates: {[date: string]: boolean} = {};
  484 │       
  485 │       dates.forEach(date => {
  486 │         const dateString = date.toISOString().split('T')[0]; // formato YYYY-MM-DD
  487 │         availabilityUpdates[dateString] = false; // false significa indisponível
  488 │       });
  489 │       
  490 │       // Atualizar disponibilidade do quarto
  491 │       if (Object.keys(availabilityUpdates).length > 0) {
  492 │         try {
  493 │           // Obter o documento do quarto
  494 │           const roomRef = doc(db, 'rooms', roomId);
  495 │           const roomSnap = await getDoc(roomRef);
  496 │           
  497 │           if (roomSnap.exists()) {
  498 │             const roomData = roomSnap.data();
  499 │             const currentAvailability = roomData.availabilityDates || {};
  500 │             
  501 │             // Mesclar a disponibilidade atual com as novas atualizações
  502 │             const updatedAvailability = {
  503 │               ...currentAvailability,
  504 │               ...availabilityUpdates
  505 │             };
  506 │             
  507 │             // Atualizar o documento do quarto
  508 │             await updateDoc(roomRef, {
  509 │               availabilityDates: updatedAvailability,
  510 │               updatedAt: serverTimestamp()
  511 │             });
  512 │             
  513 │             console.log(`Disponibilidade atualizada com sucesso para quarto ${roomId}`);
  514 │             
  515 │             // Criar log da reserva
  516 │             await addDoc(collection(db, 'bookingLogs'), {
  517 │               bookingId,
  518 │               roomId,
  519 │               action: 'status_updated',
  520 │               previousStatus: bookingData.status,
  521 │               newStatus,
  522 │               previousPaymentStatus: bookingData.paymentStatus,
  523 │               newPaymentStatus,
  524 │               datesBlocked: Object.keys(availabilityUpdates),
  525 │               timestamp: serverTimestamp(),
  526 │               userId: bookingData.userId || 'system'
  527 │             });
  528 │           } else {
  529 │             console.error(`Quarto ${roomId} não encontrado ao atualizar disponibilidade`);
  530 │           }
  531 │         } catch (error) {
  532 │           console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  533 │         }
  534 │       }
  535 │     }
  536 │     
  537 │     return true;
  538 │   } catch (error) {
  539 │     console.error(`Erro ao atualizar status da reserva ${bookingId}:`, error);
  540 │     return false;
  541 │   }
  542 │ }
  543 │ 
  544 │ export const getUserBookings = async (userId: string): Promise<Booking[]> => {
  545 │   return getDocuments<Booking>('bookings', [
  546 │     where('userId', '==', userId),
  547 │     orderBy('createdAt', 'desc')
  548 │   ])
  549 │ }
  550 │ 
  551 │ export const getRecentBookings = async (count = 5): Promise<Booking[]> => {
  552 │   return getDocuments<Booking>('bookings', [
  553 │     orderBy('createdAt', 'desc'),
  554 │     limit(count)
  555 │   ])
  556 │ }
  557 │ 
  558 │ export const getRoomBookings = async (roomId: string): Promise<Booking[]> => {
  559 │   try {
  560 │     const constraints: QueryConstraint[] = [
  561 │       where('roomId', '==', roomId),
  562 │       orderBy('checkIn', 'asc')
  563 │     ];
  564 │     
  565 │     return await getDocuments<Booking>('bookings', constraints);
  566 │   } catch (error) {
  567 │     console.error(`Erro ao buscar reservas do quarto ${roomId}:`, error);
  568 │     return [];
  569 │   }
  570 │ };
  571 │ 
  572 │ // Funções específicas para contatos
  573 │ export const createContactMessage = async (contactData: Contact) => {
  574 │   try {
  575 │     const contactsCollection = collection(db, 'contacts')
  576 │     
  577 │     // Garantir que o status seja 'new' para novos contatos
  578 │     const contactWithDefaults = {
  579 │       ...contactData,
  580 │       status: contactData.status || 'new',
  581 │       createdAt: contactData.createdAt || Timestamp.now()
  582 │     }
  583 │     
  584 │     // Se tiver detalhes de reserva, adicionar metadados
  585 │     if (contactWithDefaults.reservationDetails) {
  586 │       // Ajustar subject para indicar que é relacionado a reserva
  587 │       if (!contactWithDefaults.subject.includes('Reserva')) {
  588 │         contactWithDefaults.subject = `Reserva: ${contactWithDefaults.subject}`;
  589 │       }
  590 │     }
  591 │     
  592 │     const docRef = await addDoc(contactsCollection, contactWithDefaults)
  593 │     return docRef
  594 │   } catch (error) {
  595 │     console.error('Erro ao criar mensagem de contato:', error)
  596 │     throw error
  597 │   }
  598 │ }
  599 │ 
  600 │ export const getNewContactMessages = async (): Promise<Contact[]> => {
  601 │   return getDocuments<Contact>('contacts', [
  602 │     where('status', '==', 'new'),
  603 │     orderBy('createdAt', 'desc')
  604 │   ])
  605 │ }
  606 │ 
  607 │ // Funções para Dashboard com dados reais
  608 │ 
  609 │ export const getDashboardStats = async () => {
  610 │   try {
  611 │     const [totalBookings, totalRevenue, occupancyRate, bookingsByPlatform] = await Promise.all([
  612 │       getTotalBookings(),
  613 │       getMonthlyRevenue(),
  614 │       getOccupancyRate(),
  615 │       getBookingsByPlatform()
  616 │     ]);
  617 │ 
  618 │     return {
  619 │       totalBookings,
  620 │       totalRevenue,
  621 │       occupancyRate,
  622 │       bookingsByPlatform
  623 │     };
  624 │   } catch (error) {
  625 │     console.error('Erro ao obter estatísticas do dashboard:', error);
  626 │     throw error;
  627 │   }
  628 │ };
  629 │ 
  630 │ // Obter total de reservas
  631 │ export const getTotalBookings = async () => {
  632 │   try {
  633 │     // Obter todas as reservas
  634 │     const bookings = await getDocuments<Booking>('bookings');
  635 │     
  636 │     // Contar reservas por status
  637 │     const confirmed = bookings.filter(b => b.status === 'confirmed').length;
  638 │     const pending = bookings.filter(b => b.status === 'pending').length;
  639 │     const cancelled = bookings.filter(b => b.status === 'cancelled').length;
  640 │     const completed = bookings.filter(b => b.status === 'completed').length;
  641 │     
  642 │     // Calcular crescimento em relação ao mês anterior (simulado por enquanto)
  643 │     // Em uma implementação real, você compararia com dados do mês anterior
  644 │     const growth = ((confirmed + completed) / (bookings.length || 1) * 100) - 50;
  645 │     
  646 │     return {
  647 │       total: bookings.length,
  648 │       confirmed,
  649 │       pending,
  650 │       cancelled,
  651 │       completed,
  652 │       growth: Math.round(growth) // Arredonda para número inteiro
  653 │     };
  654 │   } catch (error) {
  655 │     console.error('Erro ao obter total de reservas:', error);
  656 │     return {
  657 │       total: 0,
  658 │       confirmed: 0,
  659 │       pending: 0, 
  660 │       cancelled: 0,
  661 │       completed: 0,
  662 │       growth: 0
  663 │     };
  664 │   }
  665 │ };
  666 │ 
  667 │ // Obter receita mensal
  668 │ export const getMonthlyRevenue = async () => {
  669 │   try {
  670 │     const bookings = await getDocuments<Booking>('bookings');
  671 │     
  672 │     // Filtrar reservas confirmadas e concluídas
  673 │     const validBookings = bookings.filter(b => 
  674 │       b.status === 'confirmed' || b.status === 'completed'
  675 │     );
  676 │     
  677 │     // Calcular receita total
  678 │     const totalRevenue = validBookings.reduce((acc, booking) => acc + booking.totalPrice, 0);
  679 │     
  680 │     // Agrupar receita por mês
  681 │     const revenueByMonth = validBookings.reduce((acc, booking) => {
  682 │       const date = booking.checkIn.toDate();
  683 │       const month = date.getMonth(); // 0-11
  684 │       const year = date.getFullYear();
  685 │       const key = `${year}-${month}`;
  686 │       
  687 │       if (!acc[key]) {
  688 │         acc[key] = 0;
  689 │       }
  690 │       acc[key] += booking.totalPrice;
  691 │       return acc;
  692 │     }, {} as Record<string, number>);
  693 │     
  694 │     // Converter para formato de array para gráfico
  695 │     const monthNames = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
  696 │     
  697 │     const currentDate = new Date();
  698 │     const currentMonth = currentDate.getMonth();
  699 │     const currentYear = currentDate.getFullYear();
  700 │     
  701 │     const revenueData = [];
  702 │     
  703 │     // Gerar dados dos últimos 12 meses
  704 │     for (let i = 0; i < 12; i++) {
  705 │       const month = (currentMonth - i + 12) % 12;
  706 │       const year = currentMonth - i < 0 ? currentYear - 1 : currentYear;
  707 │       const key = `${year}-${month}`;
  708 │       
  709 │       revenueData.unshift({
  710 │         month: monthNames[month],
  711 │         value: revenueByMonth[key] || 0
  712 │       });
  713 │     }
  714 │     
  715 │     // Calcular crescimento em relação ao mês anterior
  716 │     const lastMonthRevenue = revenueData[revenueData.length - 2]?.value || 0;
  717 │     const currentMonthRevenue = revenueData[revenueData.length - 1]?.value || 0;
  718 │     
  719 │     const growth = lastMonthRevenue ? ((currentMonthRevenue - lastMonthRevenue) / lastMonthRevenue) * 100 : 0;
  720 │     
  721 │     return {
  722 │       monthly: currentMonthRevenue,
  723 │       total: totalRevenue,
  724 │       growth: Math.round(growth),
  725 │       revenueData
  726 │     };
  727 │   } catch (error) {
  728 │     console.error('Erro ao obter receita mensal:', error);
  729 │     return {
  730 │       monthly: 0,
  731 │       total: 0,
  732 │       growth: 0,
  733 │       revenueData: []
  734 │     };
  735 │   }
  736 │ };
  737 │ 
  738 │ // Calcular taxa de ocupação
  739 │ export const getOccupancyRate = async () => {
  740 │   try {
  741 │     // Obter todos os quartos
  742 │     const rooms = await getDocuments<Room>('rooms');
  743 │     const totalRooms = rooms.length;
  744 │     
  745 │     if (totalRooms === 0) {
  746 │       return { rate: 0, growth: 0 };
  747 │     }
  748 │     
  749 │     // Obter todas as reservas
  750 │     const bookings = await getDocuments<Booking>('bookings');
  751 │     
  752 │     // Filtrar reservas confirmadas e concluídas para o mês atual
  753 │     const currentDate = new Date();
  754 │     const currentMonth = currentDate.getMonth();
  755 │     const currentYear = currentDate.getFullYear();
  756 │     
  757 │     const currentMonthBookings = bookings.filter(booking => {
  758 │       const checkInDate = booking.checkIn.toDate();
  759 │       return (
  760 │         (booking.status === 'confirmed' || booking.status === 'completed') &&
  761 │         checkInDate.getMonth() === currentMonth &&
  762 │         checkInDate.getFullYear() === currentYear
  763 │       );
  764 │     });
  765 │     
  766 │     // Calcular dias ocupados por quarto
  767 │     const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
  768 │     const totalPossibleRoomDays = totalRooms * daysInMonth;
  769 │     
  770 │     // Contar dias ocupados (simplificado - em produção seria mais complexo)
  771 │     let occupiedDays = 0;
  772 │     
  773 │     currentMonthBookings.forEach(booking => {
  774 │       const checkIn = booking.checkIn.toDate();
  775 │       const checkOut = booking.checkOut.toDate();
  776 │       
  777 │       // Ajustar datas para considerar apenas o mês atual
  778 │       const startDate = new Date(Math.max(
  779 │         checkIn.getTime(),
  780 │         new Date(currentYear, currentMonth, 1).getTime()
  781 │       ));
  782 │       const endDate = new Date(Math.min(
  783 │         checkOut.getTime(),
  784 │         new Date(currentYear, currentMonth + 1, 0).getTime()
  785 │       ));
  786 │       
  787 │       // Calcular dias entre datas (incluindo check-in, excluindo check-out)
  788 │       const days = Math.max(0, Math.floor((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)));
  789 │       occupiedDays += days;
  790 │     });
  791 │     
  792 │     const occupancyRate = (occupiedDays / totalPossibleRoomDays) * 100;
  793 │     
  794 │     // Simulação de crescimento (em produção, compararia com mês anterior)
  795 │     const growth = occupancyRate > 50 ? 5 : -3;
  796 │     
  797 │     return {
  798 │       rate: Math.round(occupancyRate),
  799 │       growth: Math.round(growth)
  800 │     };
  801 │   } catch (error) {
  802 │     console.error('Erro ao calcular taxa de ocupação:', error);
  803 │     return { rate: 0, growth: 0 };
  804 │   }
  805 │ };
  806 │ 
  807 │ // Obter reservas agrupadas por plataforma
  808 │ export const getBookingsByPlatform = async () => {
  809 │   try {
  810 │     const bookings = await getDocuments<Booking>('bookings');
  811 │     
  812 │     // Categorizar reservas por origem
  813 │     const platforms = [
  814 │       { 
  815 │         platform: "Booking.com", 
  816 │         color: "#003580", 
  817 │         icon: "Globe",
  818 │         bookings: []
  819 │       },
  820 │       { 
  821 │         platform: "Airbnb", 
  822 │         color: "#FF5A5F", 
  823 │         icon: "Heart",
  824 │         bookings: []
  825 │       },
  826 │       { 
  827 │         platform: "Direto", 
  828 │         color: "#4CAF50", 
  829 │         icon: "Home",
  830 │         bookings: []
  831 │       }
  832 │     ];
  833 │     
  834 │     // Para fins de demonstração, colocar todas as reservas como "Direto" por enquanto
  835 │     // Em produção, usaria um campo "platformOrigin" ou similar na tabela de reservas
  836 │     const platformIndex = 2; // Índice da plataforma "Direto"
  837 │     
  838 │     bookings.forEach(booking => {
  839 │       // Transformar para o formato esperado pelo componente
  840 │       const transformedBooking = {
  841 │         id: booking.id || '',
  842 │         guestName: booking.guestName,
  843 │         roomName: booking.roomName,
  844 │         checkIn: booking.checkIn.toDate().toLocaleDateString('pt-PT'),
  845 │         checkOut: booking.checkOut.toDate().toLocaleDateString('pt-PT'),
  846 │         status: booking.status,
  847 │         value: new Intl.NumberFormat('pt-PT', {
  848 │           style: 'currency',
  849 │           currency: 'EUR'
  850 │         }).format(booking.totalPrice)
  851 │       };
  852 │       
  853 │       // Adicionar à plataforma "Direto"
  854 │       (platforms[platformIndex] as any).bookings.push(transformedBooking);
  855 │     });
  856 │     
  857 │     return platforms;
  858 │   } catch (error) {
  859 │     console.error('Erro ao obter reservas por plataforma:', error);
  860 │     return [];
  861 │   }
  862 │ };
  863 │ 
  864 │ // Função para obter o preço de um quarto para uma data específica
  865 │ export const getRoomPriceForDate = async (roomId: string, date: Date): Promise<number> => {
  866 │   try {
  867 │     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  868 │     
  869 │     if (!roomDoc.exists()) {
  870 │       throw new Error("Quarto não encontrado");
  871 │     }
  872 │     
  873 │     const roomData = roomDoc.data() as Room;
  874 │     const basePrice = roomData.price;
  875 │     
  876 │     if (!roomData.seasonalPrices || roomData.seasonalPrices.length === 0) {
  877 │       return basePrice;
  878 │     }
  879 │     
  880 │     // Verificar se a data está dentro de algum período sazonal
  881 │     for (const seasonalPrice of roomData.seasonalPrices) {
  882 │       const startDate = new Date(seasonalPrice.startDate);
  883 │       const endDate = new Date(seasonalPrice.endDate);
  884 │       
  885 │       if (date >= startDate && date <= endDate) {
  886 │         return seasonalPrice.price;
  887 │       }
  888 │     }
  889 │     
  890 │     // Se não cair em nenhum período sazonal, retorna o preço base
  891 │     return basePrice;
  892 │   } catch (error) {
  893 │     console.error("Erro ao obter preço do quarto:", error);
  894 │     throw error;
  895 │   }
  896 │ }
  897 │ 
  898 │ // Função para calcular o preço total de uma estadia
  899 │ export const calculateStayPrice = async (
  900 │   roomId: string, 
  901 │   checkIn: Date, 
  902 │   checkOut: Date
  903 │ ): Promise<{
  904 │   totalPrice: number;
  905 │   nightlyPrices: { date: string; price: number }[];
  906 │   serviceFee: number;
  907 │   totalWithFee: number;
  908 │ }> => {
  909 │   try {
  910 │     console.log(`🔍 Iniciando cálculo de preço para estadia: ${checkIn.toISOString().split('T')[0]} até ${checkOut.toISOString().split('T')[0]}`);
  911 │     
  912 │     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  913 │     
  914 │     if (!roomDoc.exists()) {
  915 │       throw new Error("Quarto não encontrado");
  916 │     }
  917 │     
  918 │     const roomData = roomDoc.data() as Room;
  919 │     console.log(`📝 Dados do quarto ${roomId}:`, {
  920 │       nome: roomData.name,
  921 │       precoBase: roomData.price,
  922 │       taxaServico: roomData.serviceFeePct || 0,
  923 │       temPrecosSazonais: !!roomData.seasonalPrices?.length
  924 │     });
  925 │     
  926 │     const nightlyPrices: { date: string; price: number }[] = [];
  927 │     let totalPrice = 0;
  928 │     
  929 │     // Calcular o número de noites - corrigido para usar o método correto de cálculo
  930 │     // O número de noites é a diferença em dias (estadia = checkout - checkin)
  931 │     const noites = differenceInDays(checkOut, checkIn);
  932 │     console.log(`🗓️ Número de noites calculado: ${noites}`);
  933 │     
  934 │     if (noites <= 0) {
  935 │       console.error(`⚠️ Erro: número de noites inválido (${noites})`);
  936 │       throw new Error("Data de check-out deve ser posterior à data de check-in");
  937 │     }
  938 │     
  939 │     // Para cada noite, verificar o preço aplicável (preço base ou sazonal)
  940 │     // Começamos exatamente do dia de check-in
  941 │     const currentDate = new Date(checkIn);
  942 │     currentDate.setHours(0, 0, 0, 0); // Normalizar para meia-noite
  943 │     
  944 │     // Processamos cada dia de estadia (noite)
  945 │     console.log(`📊 Calculando preços por noite:`);
  946 │     for (let i = 0; i < noites; i++) {
  947 │       // Obtemos o preço para esta data
  948 │       const dateCopy = new Date(currentDate);
  949 │       const priceForDate = await getRoomPriceForDate(roomId, dateCopy);
  950 │       const dateString = dateCopy.toISOString().split('T')[0]; // YYYY-MM-DD
  951 │       
  952 │       console.log(`   - ${dateString}: €${priceForDate}`);
  953 │       
  954 │       nightlyPrices.push({
  955 │         date: dateString,
  956 │         price: priceForDate
  957 │       });
  958 │       
  959 │       totalPrice += priceForDate;
  960 │       
  961 │       // Avançamos para o próximo dia
  962 │       currentDate.setDate(currentDate.getDate() + 1);
  963 │     }
  964 │     
  965 │     // Verificação de segurança para o cálculo do totalPrice
  966 │     const manualTotal = nightlyPrices.reduce((sum, night) => sum + night.price, 0);
  967 │     if (Math.abs(totalPrice - manualTotal) > 1) {
  968 │       console.error(`⚠️ Discrepância detectada no cálculo do preço total!`);
  969 │       console.error(`   - Total calculado iterativamente: €${totalPrice}`);
  970 │       console.error(`   - Total calculado via reduce: €${manualTotal}`);
  971 │       console.error(`   - Usando o valor recalculado para segurança!`);
  972 │       totalPrice = manualTotal;
  973 │     }
  974 │     
  975 │     // Calcular taxa de serviço
  976 │     const serviceFee = (totalPrice * (roomData.serviceFeePct || 0)) / 100;
  977 │     const totalWithFee = totalPrice + serviceFee;
  978 │     
  979 │     console.log(`💰 Resumo do cálculo:`);
  980 │     console.log(`   - Total das diárias: €${totalPrice}`);
  981 │     console.log(`   - Taxa de serviço (${roomData.serviceFeePct || 0}%): €${serviceFee}`);
  982 │     console.log(`   - Total com taxas: €${totalWithFee}`);
  983 │     
  984 │     return {
  985 │       totalPrice,
  986 │       nightlyPrices,
  987 │       serviceFee,
  988 │       totalWithFee
  989 │     };
  990 │   } catch (error) {
  991 │     console.error("❌ Erro ao calcular preço da estadia:", error);
  992 │     throw error;
  993 │   }
  994 │ } 
  995 │ import { 
  996 │   collection, 
  997 │   getDocs, 
  998 │   getDoc, 
  999 │   doc, 
 1000 │   setDoc, 
 1001 │   addDoc, 
 1002 │   updateDoc, 
 1003 │   deleteDoc,
 1004 │   query,
 1005 │   where,
 1006 │   orderBy,
 1007 │   limit,
 1008 │   serverTimestamp
 1009 │ } from 'firebase/firestore';
 1010 │ import { db } from './config';
 1011 │ 
 1012 │ // Get all documents from a collection
 1013 │ export async function getDocuments<T>(collectionName: string, forceRefresh = false): Promise<T[]> {
      ·                       ──────┬─────
      ·                             ╰── `getDocuments` redefined here
 1014 │   console.log(`Buscando documentos na coleção ${collectionName} - Força atualização: ${forceRefresh}`);
 1015 │   try {
 1016 │     const querySnapshot = await getDocs(collection(db, collectionName));
      ╰────

  × the name `updateDocument` is defined multiple times
      ╭─[/home/runner/workspace/lib/firebase/firestore.ts:133:1]
  133 │   }
  134 │ }
  135 │ 
  136 │ export const updateDocument = async <T extends DocumentData>(
      ·              ───────┬──────
      ·                     ╰── previous definition of `updateDocument` here
  137 │   collectionName: string,
  138 │   id: string,
  139 │   data: Partial<T>
  140 │ ): Promise<void> => {
  141 │   const docRef = doc(db, collectionName, id)
  142 │   await updateDoc(docRef, {
  143 │     ...data,
  144 │     updatedAt: serverTimestamp()
  145 │   })
  146 │ }
  147 │ 
  148 │ export const deleteDocument = async (
  149 │   collectionName: string,
  150 │   id: string
  151 │ ): Promise<boolean> => {
  152 │   const docRef = doc(db, collectionName, id)
  153 │   await deleteDoc(docRef)
  154 │   return true
  155 │ }
  156 │ 
  157 │ // Funções para gerenciar quartos
  158 │ export const getRooms = async (forceRefresh = false): Promise<Room[]> => {
  159 │   try {
  160 │     const constraints: QueryConstraint[] = []
  161 │     
  162 │     constraints.push(orderBy('name', 'asc'))
  163 │     
  164 │     const rooms = await getDocuments<Room>('rooms', constraints, forceRefresh)
  165 │     
  166 │     // Garantir que todos os campos necessários estejam presentes
  167 │     return rooms.map(room => {
  168 │       console.log(`Firebase - Quarto ${room.id} dados brutos:`, room);
  169 │       
  170 │       // Garantir que serviceFeePct seja um número
  171 │       const serviceFeePct = room.serviceFeePct !== undefined 
  172 │         ? Number(room.serviceFeePct) 
  173 │         : 10;
  174 │         
  175 │       console.log(`Firebase - Quarto ${room.id} serviceFeePct:`, {
  176 │         original: room.serviceFeePct,
  177 │         tipo: typeof room.serviceFeePct,
  178 │         convertido: serviceFeePct
  179 │       });
  180 │       
  181 │       return {
  182 │         id: room.id,
  183 │         name: room.name || '',
  184 │         type: room.type || 'standard',
  185 │         description: room.description || '',
  186 │         price: room.price || 0,
  187 │         capacity: room.capacity || 2,
  188 │         size: room.size || 0,
  189 │         available: room.available !== undefined ? room.available : true,
  190 │         serviceFeePct: serviceFeePct,
  191 │         images: room.images || [],
  192 │         amenities: room.amenities || [],
  193 │         additionalServices: room.additionalServices || [],
  194 │         highlights: room.highlights || [],
  195 │         createdAt: room.createdAt,
  196 │         updatedAt: room.updatedAt
  197 │       };
  198 │     });
  199 │   } catch (error) {
  200 │     console.error('Erro ao buscar quartos:', error)
  201 │     return []
  202 │   }
  203 │ }
  204 │ 
  205 │ export const getAvailableRooms = async (
  206 │   checkIn: Date,
  207 │   checkOut: Date
  208 │ ): Promise<Room[]> => {
  209 │   try {
  210 │     // Buscar todos os quartos que estão marcados como disponíveis em geral
  211 │     const constraints: QueryConstraint[] = [
  212 │       where('available', '==', true)
  213 │     ]
  214 │     
  215 │     const rooms = await getDocuments<Room>('rooms', constraints);
  216 │     
  217 │     // Filtrar os quartos que estão disponíveis nas datas específicas
  218 │     return filterAvailableRoomsByDate(rooms, checkIn, checkOut);
  219 │   } catch (error) {
  220 │     console.error('Erro ao buscar quartos disponíveis:', error)
  221 │     return []
  222 │   }
  223 │ }
  224 │ 
  225 │ // Função auxiliar para verificar disponibilidade entre datas
  226 │ export const filterAvailableRoomsByDate = (
  227 │   rooms: Room[],
  228 │   checkIn: Date,
  229 │   checkOut: Date
  230 │ ): Room[] => {
  231 │   // Converter checkIn e checkOut para ISO strings
  232 │   const dateStrings = getDatesInRange(checkIn, checkOut);
  233 │   
  234 │   return rooms.filter(room => {
  235 │     // Se não tiver controle de disponibilidade específico, considera disponível
  236 │     if (!room.availabilityDates) return true;
  237 │     
  238 │     // Verificar se alguma data no intervalo está indisponível
  239 │     return !dateStrings.some(dateStr => 
  240 │       room.availabilityDates?.[dateStr] === false
  241 │     );
  242 │   });
  243 │ };
  244 │ 
  245 │ // Função para obter disponibilidade de um quarto específico
  246 │ export const getRoomAvailability = async (
  247 │   roomId: string, 
  248 │   startDate: Date, 
  249 │   endDate: Date
  250 │ ): Promise<{[date: string]: boolean}> => {
  251 │   try {
  252 │     const room = await getRoomById(roomId);
  253 │     if (!room) throw new Error(`Quarto com ID ${roomId} não encontrado`);
  254 │     
  255 │     // Gerar datas no intervalo
  256 │     const dateStrings = getDatesInRange(startDate, endDate);
  257 │     
  258 │     // Se não tiver configuração de disponibilidade específica, assume tudo disponível
  259 │     if (!room.availabilityDates) {
  260 │       return dateStrings.reduce((acc, date) => {
  261 │         acc[date] = true;
  262 │         return acc;
  263 │       }, {} as {[date: string]: boolean});
  264 │     }
  265 │     
  266 │     // Preencher com os dados de disponibilidade existentes
  267 │     return dateStrings.reduce((acc, date) => {
  268 │       acc[date] = room.availabilityDates?.[date] !== false; // disponível por padrão se não estiver explicitamente indisponível
  269 │       return acc;
  270 │     }, {} as {[date: string]: boolean});
  271 │   } catch (error) {
  272 │     console.error(`Erro ao verificar disponibilidade do quarto ${roomId}:`, error);
  273 │     throw error;
  274 │   }
  275 │ };
  276 │ 
  277 │ // Função para atualizar disponibilidade de um quarto
  278 │ export const updateRoomAvailability = async (
  279 │   roomId: string,
  280 │   availabilityDates: {[date: string]: boolean}
  281 │ ): Promise<boolean> => {
  282 │   try {
  283 │     await updateDocument('rooms', roomId, {
  284 │       availabilityDates,
  285 │       updatedAt: serverTimestamp()
  286 │     });
  287 │     return true;
  288 │   } catch (error) {
  289 │     console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  290 │     return false;
  291 │   }
  292 │ };
  293 │ 
  294 │ // Função auxiliar para gerar array de strings de data entre um intervalo
  295 │ export const getDatesInRange = (startDate: Date, endDate: Date): string[] => {
  296 │   const dates: string[] = [];
  297 │   const currentDate = new Date(startDate);
  298 │   
  299 │   // Normalizar para meia-noite no fuso horário local
  300 │   currentDate.setHours(0, 0, 0, 0);
  301 │   const endDateNormalized = new Date(endDate);
  302 │   endDateNormalized.setHours(0, 0, 0, 0);
  303 │   
  304 │   // Adicionar cada data no intervalo EXCETO o dia de checkout
  305 │   // Usando < em vez de <= para não incluir o dia de checkout
  306 │   while (currentDate < endDateNormalized) {
  307 │     dates.push(currentDate.toISOString().split('T')[0]); // Formato YYYY-MM-DD
  308 │     currentDate.setDate(currentDate.getDate() + 1);
  309 │   }
  310 │   
  311 │   return dates;
  312 │ };
  313 │ 
  314 │ export const getRoomById = async (id: string): Promise<Room | null> => {
  315 │   try {
  316 │     const room = await getDocument<Room>('rooms', id);
  317 │     
  318 │     if (!room) return null;
  319 │     
  320 │     console.log(`Firebase - getRoomById ${id} dados brutos:`, room);
  321 │     
  322 │     // Log específico para serviceFeePct
  323 │     console.log(`serviceFeePct no Firestore:`, room.serviceFeePct);
  324 │     
  325 │     // Garantir que todos os campos necessários estejam presentes
  326 │     return {
  327 │       ...room,
  328 │       name: room.name || '',
  329 │       type: room.type || 'standard',
  330 │       description: room.description || '',
  331 │       price: room.price || 0,
  332 │       capacity: room.capacity || 2,
  333 │       size: room.size || 0,
  334 │       available: room.available !== undefined ? room.available : true,
  335 │       serviceFeePct: room.serviceFeePct !== undefined ? room.serviceFeePct : 10,
  336 │       images: room.images || [],
  337 │       amenities: room.amenities || [],
  338 │       additionalServices: room.additionalServices || [],
  339 │       highlights: room.highlights || []
  340 │     };
  341 │   } catch (error) {
  342 │     console.error(`Erro ao buscar quarto com ID ${id}:`, error);
  343 │     return null;
  344 │   }
  345 │ }
  346 │ 
  347 │ export const createRoom = async (roomData: Omit<Room, 'id' | 'createdAt' | 'updatedAt'>): Promise<Room> => {
  348 │   try {
  349 │     console.log("createRoom - Dados recebidos:", roomData);
  350 │     
  351 │     const roomWithTimestamps = {
  352 │       ...roomData,
  353 │       available: roomData.available !== undefined ? roomData.available : true,
  354 │       featured: roomData.featured || false,
  355 │       amenities: roomData.amenities || [],
  356 │       additionalServices: roomData.additionalServices || [],
  357 │       highlights: roomData.highlights || [],
  358 │       createdAt: serverTimestamp(),
  359 │       updatedAt: serverTimestamp()
  360 │     }
  361 │     
  362 │     console.log("createRoom - Dados a serem salvos:", roomWithTimestamps);
  363 │     
  364 │     const id = await createDocument('rooms', roomWithTimestamps)
  365 │     
  366 │     return {
  367 │       id,
  368 │       ...roomData,
  369 │       amenities: roomData.amenities || [],
  370 │       additionalServices: roomData.additionalServices || [],
  371 │       highlights: roomData.highlights || [],
  372 │       createdAt: Timestamp.now(),
  373 │       updatedAt: Timestamp.now()
  374 │     }
  375 │   } catch (error) {
  376 │     console.error('Erro ao criar quarto:', error)
  377 │     throw error
  378 │   }
  379 │ }
  380 │ 
  381 │ export const updateRoom = async (id: string, roomData: Partial<Omit<Room, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Room> => {
  382 │   try {
  383 │     console.log(`updateRoom - ID: ${id}, Dados recebidos:`, roomData);
  384 │     
  385 │     // Garantir que estamos lidando explicitamente com o serviceFeePct se ele for 0
  386 │     if (roomData.serviceFeePct === 0) {
  387 │       console.log("updateRoom - Detectado serviceFeePct com valor 0, salvando explicitamente.", roomData.serviceFeePct);
  388 │     }
  389 │     
  390 │     // Adicionar timestamp de atualização
  391 │     const roomWithTimestamp = {
  392 │       ...roomData,
  393 │       amenities: roomData.amenities || [],
  394 │       additionalServices: roomData.additionalServices || [],
  395 │       highlights: roomData.highlights || [],
  396 │       updatedAt: serverTimestamp()
  397 │     }
  398 │     
  399 │     console.log(`updateRoom - Dados a serem salvos:`, roomWithTimestamp);
  400 │     
  401 │     await updateDocument('rooms', id, roomWithTimestamp)
  402 │     
  403 │     const updatedRoom = await getRoomById(id)
  404 │     if (!updatedRoom) {
  405 │       throw new Error(`Quarto com ID ${id} não encontrado após atualização`)
  406 │     }
  407 │     
  408 │     return updatedRoom
  409 │   } catch (error) {
  410 │     console.error('Erro ao atualizar quarto:', error)
  411 │     throw error
  412 │   }
  413 │ }
  414 │ 
  415 │ export const deleteRoom = async (id: string): Promise<boolean> => {
  416 │   return await deleteDocument('rooms', id)
  417 │ }
  418 │ 
  419 │ // Funções específicas para reservas
  420 │ export const createBooking = async (bookingData: any) => {
  421 │   try {
  422 │     const bookingsCollection = collection(db, 'bookings');
  423 │     const docRef = await addDoc(bookingsCollection, bookingData);
  424 │     
  425 │     // CORREÇÃO: Não bloquear a data no momento da criação da reserva
  426 │     // O bloqueio será feito apenas quando o pagamento for confirmado
  427 │     // através da função updateBookingStatus
  428 │     
  429 │     return docRef;
  430 │   } catch (error) {
  431 │     console.error('Erro ao criar reserva:', error);
  432 │     throw error;
  433 │   }
  434 │ };
  435 │ 
  436 │ // Nova função para atualizar status da reserva e bloquear as datas da estadia
  437 │ export const updateBookingStatus = async (
  438 │   bookingId: string, 
  439 │   newStatus: 'pending' | 'confirmed' | 'cancelled' | 'completed',
  440 │   newPaymentStatus: 'pending' | 'paid' | 'refunded'
  441 │ ): Promise<boolean> => {
  442 │   try {
  443 │     // Referência ao documento da reserva
  444 │     const bookingRef = doc(db, 'bookings', bookingId);
  445 │     const bookingSnap = await getDoc(bookingRef);
  446 │     
  447 │     if (!bookingSnap.exists()) {
  448 │       console.error(`Booking ${bookingId} não existe ao atualizar status`);
  449 │       return false;
  450 │     }
  451 │     
  452 │     const bookingData = bookingSnap.data();
  453 │     
  454 │     // Atualizar o status da reserva
  455 │     await updateDoc(bookingRef, {
  456 │       status: newStatus,
  457 │       paymentStatus: newPaymentStatus,
  458 │       updatedAt: serverTimestamp(),
  459 │       ...(newStatus === 'confirmed' && { confirmedAt: serverTimestamp() })
  460 │     });
  461 │     
  462 │     // Se a reserva está sendo confirmada, precisamos bloquear as datas
  463 │     if (newStatus === 'confirmed') {
  464 │       console.log(`Atualizando disponibilidade para reserva confirmada: ${bookingId}`);
  465 │       
  466 │       // Recuperar datas de check-in e check-out
  467 │       const checkIn = bookingData.checkIn.toDate();
  468 │       const checkOut = bookingData.checkOut.toDate();
  469 │       const roomId = bookingData.roomId;
  470 │       
  471 │       // Obter todas as datas entre check-in e check-out
  472 │       const dates: Date[] = [];
  473 │       const currentDate = new Date(checkIn);
  474 │       
  475 │       while (currentDate < checkOut) {
  476 │         dates.push(new Date(currentDate));
  477 │         currentDate.setDate(currentDate.getDate() + 1);
  478 │       }
  479 │       
  480 │       console.log(`Bloqueando ${dates.length} dias para quarto ${roomId}`);
  481 │       
  482 │       // Atualizar disponibilidade para cada data
  483 │       const availabilityUpdates: {[date: string]: boolean} = {};
  484 │       
  485 │       dates.forEach(date => {
  486 │         const dateString = date.toISOString().split('T')[0]; // formato YYYY-MM-DD
  487 │         availabilityUpdates[dateString] = false; // false significa indisponível
  488 │       });
  489 │       
  490 │       // Atualizar disponibilidade do quarto
  491 │       if (Object.keys(availabilityUpdates).length > 0) {
  492 │         try {
  493 │           // Obter o documento do quarto
  494 │           const roomRef = doc(db, 'rooms', roomId);
  495 │           const roomSnap = await getDoc(roomRef);
  496 │           
  497 │           if (roomSnap.exists()) {
  498 │             const roomData = roomSnap.data();
  499 │             const currentAvailability = roomData.availabilityDates || {};
  500 │             
  501 │             // Mesclar a disponibilidade atual com as novas atualizações
  502 │             const updatedAvailability = {
  503 │               ...currentAvailability,
  504 │               ...availabilityUpdates
  505 │             };
  506 │             
  507 │             // Atualizar o documento do quarto
  508 │             await updateDoc(roomRef, {
  509 │               availabilityDates: updatedAvailability,
  510 │               updatedAt: serverTimestamp()
  511 │             });
  512 │             
  513 │             console.log(`Disponibilidade atualizada com sucesso para quarto ${roomId}`);
  514 │             
  515 │             // Criar log da reserva
  516 │             await addDoc(collection(db, 'bookingLogs'), {
  517 │               bookingId,
  518 │               roomId,
  519 │               action: 'status_updated',
  520 │               previousStatus: bookingData.status,
  521 │               newStatus,
  522 │               previousPaymentStatus: bookingData.paymentStatus,
  523 │               newPaymentStatus,
  524 │               datesBlocked: Object.keys(availabilityUpdates),
  525 │               timestamp: serverTimestamp(),
  526 │               userId: bookingData.userId || 'system'
  527 │             });
  528 │           } else {
  529 │             console.error(`Quarto ${roomId} não encontrado ao atualizar disponibilidade`);
  530 │           }
  531 │         } catch (error) {
  532 │           console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  533 │         }
  534 │       }
  535 │     }
  536 │     
  537 │     return true;
  538 │   } catch (error) {
  539 │     console.error(`Erro ao atualizar status da reserva ${bookingId}:`, error);
  540 │     return false;
  541 │   }
  542 │ }
  543 │ 
  544 │ export const getUserBookings = async (userId: string): Promise<Booking[]> => {
  545 │   return getDocuments<Booking>('bookings', [
  546 │     where('userId', '==', userId),
  547 │     orderBy('createdAt', 'desc')
  548 │   ])
  549 │ }
  550 │ 
  551 │ export const getRecentBookings = async (count = 5): Promise<Booking[]> => {
  552 │   return getDocuments<Booking>('bookings', [
  553 │     orderBy('createdAt', 'desc'),
  554 │     limit(count)
  555 │   ])
  556 │ }
  557 │ 
  558 │ export const getRoomBookings = async (roomId: string): Promise<Booking[]> => {
  559 │   try {
  560 │     const constraints: QueryConstraint[] = [
  561 │       where('roomId', '==', roomId),
  562 │       orderBy('checkIn', 'asc')
  563 │     ];
  564 │     
  565 │     return await getDocuments<Booking>('bookings', constraints);
  566 │   } catch (error) {
  567 │     console.error(`Erro ao buscar reservas do quarto ${roomId}:`, error);
  568 │     return [];
  569 │   }
  570 │ };
  571 │ 
  572 │ // Funções específicas para contatos
  573 │ export const createContactMessage = async (contactData: Contact) => {
  574 │   try {
  575 │     const contactsCollection = collection(db, 'contacts')
  576 │     
  577 │     // Garantir que o status seja 'new' para novos contatos
  578 │     const contactWithDefaults = {
  579 │       ...contactData,
  580 │       status: contactData.status || 'new',
  581 │       createdAt: contactData.createdAt || Timestamp.now()
  582 │     }
  583 │     
  584 │     // Se tiver detalhes de reserva, adicionar metadados
  585 │     if (contactWithDefaults.reservationDetails) {
  586 │       // Ajustar subject para indicar que é relacionado a reserva
  587 │       if (!contactWithDefaults.subject.includes('Reserva')) {
  588 │         contactWithDefaults.subject = `Reserva: ${contactWithDefaults.subject}`;
  589 │       }
  590 │     }
  591 │     
  592 │     const docRef = await addDoc(contactsCollection, contactWithDefaults)
  593 │     return docRef
  594 │   } catch (error) {
  595 │     console.error('Erro ao criar mensagem de contato:', error)
  596 │     throw error
  597 │   }
  598 │ }
  599 │ 
  600 │ export const getNewContactMessages = async (): Promise<Contact[]> => {
  601 │   return getDocuments<Contact>('contacts', [
  602 │     where('status', '==', 'new'),
  603 │     orderBy('createdAt', 'desc')
  604 │   ])
  605 │ }
  606 │ 
  607 │ // Funções para Dashboard com dados reais
  608 │ 
  609 │ export const getDashboardStats = async () => {
  610 │   try {
  611 │     const [totalBookings, totalRevenue, occupancyRate, bookingsByPlatform] = await Promise.all([
  612 │       getTotalBookings(),
  613 │       getMonthlyRevenue(),
  614 │       getOccupancyRate(),
  615 │       getBookingsByPlatform()
  616 │     ]);
  617 │ 
  618 │     return {
  619 │       totalBookings,
  620 │       totalRevenue,
  621 │       occupancyRate,
  622 │       bookingsByPlatform
  623 │     };
  624 │   } catch (error) {
  625 │     console.error('Erro ao obter estatísticas do dashboard:', error);
  626 │     throw error;
  627 │   }
  628 │ };
  629 │ 
  630 │ // Obter total de reservas
  631 │ export const getTotalBookings = async () => {
  632 │   try {
  633 │     // Obter todas as reservas
  634 │     const bookings = await getDocuments<Booking>('bookings');
  635 │     
  636 │     // Contar reservas por status
  637 │     const confirmed = bookings.filter(b => b.status === 'confirmed').length;
  638 │     const pending = bookings.filter(b => b.status === 'pending').length;
  639 │     const cancelled = bookings.filter(b => b.status === 'cancelled').length;
  640 │     const completed = bookings.filter(b => b.status === 'completed').length;
  641 │     
  642 │     // Calcular crescimento em relação ao mês anterior (simulado por enquanto)
  643 │     // Em uma implementação real, você compararia com dados do mês anterior
  644 │     const growth = ((confirmed + completed) / (bookings.length || 1) * 100) - 50;
  645 │     
  646 │     return {
  647 │       total: bookings.length,
  648 │       confirmed,
  649 │       pending,
  650 │       cancelled,
  651 │       completed,
  652 │       growth: Math.round(growth) // Arredonda para número inteiro
  653 │     };
  654 │   } catch (error) {
  655 │     console.error('Erro ao obter total de reservas:', error);
  656 │     return {
  657 │       total: 0,
  658 │       confirmed: 0,
  659 │       pending: 0, 
  660 │       cancelled: 0,
  661 │       completed: 0,
  662 │       growth: 0
  663 │     };
  664 │   }
  665 │ };
  666 │ 
  667 │ // Obter receita mensal
  668 │ export const getMonthlyRevenue = async () => {
  669 │   try {
  670 │     const bookings = await getDocuments<Booking>('bookings');
  671 │     
  672 │     // Filtrar reservas confirmadas e concluídas
  673 │     const validBookings = bookings.filter(b => 
  674 │       b.status === 'confirmed' || b.status === 'completed'
  675 │     );
  676 │     
  677 │     // Calcular receita total
  678 │     const totalRevenue = validBookings.reduce((acc, booking) => acc + booking.totalPrice, 0);
  679 │     
  680 │     // Agrupar receita por mês
  681 │     const revenueByMonth = validBookings.reduce((acc, booking) => {
  682 │       const date = booking.checkIn.toDate();
  683 │       const month = date.getMonth(); // 0-11
  684 │       const year = date.getFullYear();
  685 │       const key = `${year}-${month}`;
  686 │       
  687 │       if (!acc[key]) {
  688 │         acc[key] = 0;
  689 │       }
  690 │       acc[key] += booking.totalPrice;
  691 │       return acc;
  692 │     }, {} as Record<string, number>);
  693 │     
  694 │     // Converter para formato de array para gráfico
  695 │     const monthNames = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
  696 │     
  697 │     const currentDate = new Date();
  698 │     const currentMonth = currentDate.getMonth();
  699 │     const currentYear = currentDate.getFullYear();
  700 │     
  701 │     const revenueData = [];
  702 │     
  703 │     // Gerar dados dos últimos 12 meses
  704 │     for (let i = 0; i < 12; i++) {
  705 │       const month = (currentMonth - i + 12) % 12;
  706 │       const year = currentMonth - i < 0 ? currentYear - 1 : currentYear;
  707 │       const key = `${year}-${month}`;
  708 │       
  709 │       revenueData.unshift({
  710 │         month: monthNames[month],
  711 │         value: revenueByMonth[key] || 0
  712 │       });
  713 │     }
  714 │     
  715 │     // Calcular crescimento em relação ao mês anterior
  716 │     const lastMonthRevenue = revenueData[revenueData.length - 2]?.value || 0;
  717 │     const currentMonthRevenue = revenueData[revenueData.length - 1]?.value || 0;
  718 │     
  719 │     const growth = lastMonthRevenue ? ((currentMonthRevenue - lastMonthRevenue) / lastMonthRevenue) * 100 : 0;
  720 │     
  721 │     return {
  722 │       monthly: currentMonthRevenue,
  723 │       total: totalRevenue,
  724 │       growth: Math.round(growth),
  725 │       revenueData
  726 │     };
  727 │   } catch (error) {
  728 │     console.error('Erro ao obter receita mensal:', error);
  729 │     return {
  730 │       monthly: 0,
  731 │       total: 0,
  732 │       growth: 0,
  733 │       revenueData: []
  734 │     };
  735 │   }
  736 │ };
  737 │ 
  738 │ // Calcular taxa de ocupação
  739 │ export const getOccupancyRate = async () => {
  740 │   try {
  741 │     // Obter todos os quartos
  742 │     const rooms = await getDocuments<Room>('rooms');
  743 │     const totalRooms = rooms.length;
  744 │     
  745 │     if (totalRooms === 0) {
  746 │       return { rate: 0, growth: 0 };
  747 │     }
  748 │     
  749 │     // Obter todas as reservas
  750 │     const bookings = await getDocuments<Booking>('bookings');
  751 │     
  752 │     // Filtrar reservas confirmadas e concluídas para o mês atual
  753 │     const currentDate = new Date();
  754 │     const currentMonth = currentDate.getMonth();
  755 │     const currentYear = currentDate.getFullYear();
  756 │     
  757 │     const currentMonthBookings = bookings.filter(booking => {
  758 │       const checkInDate = booking.checkIn.toDate();
  759 │       return (
  760 │         (booking.status === 'confirmed' || booking.status === 'completed') &&
  761 │         checkInDate.getMonth() === currentMonth &&
  762 │         checkInDate.getFullYear() === currentYear
  763 │       );
  764 │     });
  765 │     
  766 │     // Calcular dias ocupados por quarto
  767 │     const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
  768 │     const totalPossibleRoomDays = totalRooms * daysInMonth;
  769 │     
  770 │     // Contar dias ocupados (simplificado - em produção seria mais complexo)
  771 │     let occupiedDays = 0;
  772 │     
  773 │     currentMonthBookings.forEach(booking => {
  774 │       const checkIn = booking.checkIn.toDate();
  775 │       const checkOut = booking.checkOut.toDate();
  776 │       
  777 │       // Ajustar datas para considerar apenas o mês atual
  778 │       const startDate = new Date(Math.max(
  779 │         checkIn.getTime(),
  780 │         new Date(currentYear, currentMonth, 1).getTime()
  781 │       ));
  782 │       const endDate = new Date(Math.min(
  783 │         checkOut.getTime(),
  784 │         new Date(currentYear, currentMonth + 1, 0).getTime()
  785 │       ));
  786 │       
  787 │       // Calcular dias entre datas (incluindo check-in, excluindo check-out)
  788 │       const days = Math.max(0, Math.floor((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)));
  789 │       occupiedDays += days;
  790 │     });
  791 │     
  792 │     const occupancyRate = (occupiedDays / totalPossibleRoomDays) * 100;
  793 │     
  794 │     // Simulação de crescimento (em produção, compararia com mês anterior)
  795 │     const growth = occupancyRate > 50 ? 5 : -3;
  796 │     
  797 │     return {
  798 │       rate: Math.round(occupancyRate),
  799 │       growth: Math.round(growth)
  800 │     };
  801 │   } catch (error) {
  802 │     console.error('Erro ao calcular taxa de ocupação:', error);
  803 │     return { rate: 0, growth: 0 };
  804 │   }
  805 │ };
  806 │ 
  807 │ // Obter reservas agrupadas por plataforma
  808 │ export const getBookingsByPlatform = async () => {
  809 │   try {
  810 │     const bookings = await getDocuments<Booking>('bookings');
  811 │     
  812 │     // Categorizar reservas por origem
  813 │     const platforms = [
  814 │       { 
  815 │         platform: "Booking.com", 
  816 │         color: "#003580", 
  817 │         icon: "Globe",
  818 │         bookings: []
  819 │       },
  820 │       { 
  821 │         platform: "Airbnb", 
  822 │         color: "#FF5A5F", 
  823 │         icon: "Heart",
  824 │         bookings: []
  825 │       },
  826 │       { 
  827 │         platform: "Direto", 
  828 │         color: "#4CAF50", 
  829 │         icon: "Home",
  830 │         bookings: []
  831 │       }
  832 │     ];
  833 │     
  834 │     // Para fins de demonstração, colocar todas as reservas como "Direto" por enquanto
  835 │     // Em produção, usaria um campo "platformOrigin" ou similar na tabela de reservas
  836 │     const platformIndex = 2; // Índice da plataforma "Direto"
  837 │     
  838 │     bookings.forEach(booking => {
  839 │       // Transformar para o formato esperado pelo componente
  840 │       const transformedBooking = {
  841 │         id: booking.id || '',
  842 │         guestName: booking.guestName,
  843 │         roomName: booking.roomName,
  844 │         checkIn: booking.checkIn.toDate().toLocaleDateString('pt-PT'),
  845 │         checkOut: booking.checkOut.toDate().toLocaleDateString('pt-PT'),
  846 │         status: booking.status,
  847 │         value: new Intl.NumberFormat('pt-PT', {
  848 │           style: 'currency',
  849 │           currency: 'EUR'
  850 │         }).format(booking.totalPrice)
  851 │       };
  852 │       
  853 │       // Adicionar à plataforma "Direto"
  854 │       (platforms[platformIndex] as any).bookings.push(transformedBooking);
  855 │     });
  856 │     
  857 │     return platforms;
  858 │   } catch (error) {
  859 │     console.error('Erro ao obter reservas por plataforma:', error);
  860 │     return [];
  861 │   }
  862 │ };
  863 │ 
  864 │ // Função para obter o preço de um quarto para uma data específica
  865 │ export const getRoomPriceForDate = async (roomId: string, date: Date): Promise<number> => {
  866 │   try {
  867 │     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  868 │     
  869 │     if (!roomDoc.exists()) {
  870 │       throw new Error("Quarto não encontrado");
  871 │     }
  872 │     
  873 │     const roomData = roomDoc.data() as Room;
  874 │     const basePrice = roomData.price;
  875 │     
  876 │     if (!roomData.seasonalPrices || roomData.seasonalPrices.length === 0) {
  877 │       return basePrice;
  878 │     }
  879 │     
  880 │     // Verificar se a data está dentro de algum período sazonal
  881 │     for (const seasonalPrice of roomData.seasonalPrices) {
  882 │       const startDate = new Date(seasonalPrice.startDate);
  883 │       const endDate = new Date(seasonalPrice.endDate);
  884 │       
  885 │       if (date >= startDate && date <= endDate) {
  886 │         return seasonalPrice.price;
  887 │       }
  888 │     }
  889 │     
  890 │     // Se não cair em nenhum período sazonal, retorna o preço base
  891 │     return basePrice;
  892 │   } catch (error) {
  893 │     console.error("Erro ao obter preço do quarto:", error);
  894 │     throw error;
  895 │   }
  896 │ }
  897 │ 
  898 │ // Função para calcular o preço total de uma estadia
  899 │ export const calculateStayPrice = async (
  900 │   roomId: string, 
  901 │   checkIn: Date, 
  902 │   checkOut: Date
  903 │ ): Promise<{
  904 │   totalPrice: number;
  905 │   nightlyPrices: { date: string; price: number }[];
  906 │   serviceFee: number;
  907 │   totalWithFee: number;
  908 │ }> => {
  909 │   try {
  910 │     console.log(`🔍 Iniciando cálculo de preço para estadia: ${checkIn.toISOString().split('T')[0]} até ${checkOut.toISOString().split('T')[0]}`);
  911 │     
  912 │     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  913 │     
  914 │     if (!roomDoc.exists()) {
  915 │       throw new Error("Quarto não encontrado");
  916 │     }
  917 │     
  918 │     const roomData = roomDoc.data() as Room;
  919 │     console.log(`📝 Dados do quarto ${roomId}:`, {
  920 │       nome: roomData.name,
  921 │       precoBase: roomData.price,
  922 │       taxaServico: roomData.serviceFeePct || 0,
  923 │       temPrecosSazonais: !!roomData.seasonalPrices?.length
  924 │     });
  925 │     
  926 │     const nightlyPrices: { date: string; price: number }[] = [];
  927 │     let totalPrice = 0;
  928 │     
  929 │     // Calcular o número de noites - corrigido para usar o método correto de cálculo
  930 │     // O número de noites é a diferença em dias (estadia = checkout - checkin)
  931 │     const noites = differenceInDays(checkOut, checkIn);
  932 │     console.log(`🗓️ Número de noites calculado: ${noites}`);
  933 │     
  934 │     if (noites <= 0) {
  935 │       console.error(`⚠️ Erro: número de noites inválido (${noites})`);
  936 │       throw new Error("Data de check-out deve ser posterior à data de check-in");
  937 │     }
  938 │     
  939 │     // Para cada noite, verificar o preço aplicável (preço base ou sazonal)
  940 │     // Começamos exatamente do dia de check-in
  941 │     const currentDate = new Date(checkIn);
  942 │     currentDate.setHours(0, 0, 0, 0); // Normalizar para meia-noite
  943 │     
  944 │     // Processamos cada dia de estadia (noite)
  945 │     console.log(`📊 Calculando preços por noite:`);
  946 │     for (let i = 0; i < noites; i++) {
  947 │       // Obtemos o preço para esta data
  948 │       const dateCopy = new Date(currentDate);
  949 │       const priceForDate = await getRoomPriceForDate(roomId, dateCopy);
  950 │       const dateString = dateCopy.toISOString().split('T')[0]; // YYYY-MM-DD
  951 │       
  952 │       console.log(`   - ${dateString}: €${priceForDate}`);
  953 │       
  954 │       nightlyPrices.push({
  955 │         date: dateString,
  956 │         price: priceForDate
  957 │       });
  958 │       
  959 │       totalPrice += priceForDate;
  960 │       
  961 │       // Avançamos para o próximo dia
  962 │       currentDate.setDate(currentDate.getDate() + 1);
  963 │     }
  964 │     
  965 │     // Verificação de segurança para o cálculo do totalPrice
  966 │     const manualTotal = nightlyPrices.reduce((sum, night) => sum + night.price, 0);
  967 │     if (Math.abs(totalPrice - manualTotal) > 1) {
  968 │       console.error(`⚠️ Discrepância detectada no cálculo do preço total!`);
  969 │       console.error(`   - Total calculado iterativamente: €${totalPrice}`);
  970 │       console.error(`   - Total calculado via reduce: €${manualTotal}`);
  971 │       console.error(`   - Usando o valor recalculado para segurança!`);
  972 │       totalPrice = manualTotal;
  973 │     }
  974 │     
  975 │     // Calcular taxa de serviço
  976 │     const serviceFee = (totalPrice * (roomData.serviceFeePct || 0)) / 100;
  977 │     const totalWithFee = totalPrice + serviceFee;
  978 │     
  979 │     console.log(`💰 Resumo do cálculo:`);
  980 │     console.log(`   - Total das diárias: €${totalPrice}`);
  981 │     console.log(`   - Taxa de serviço (${roomData.serviceFeePct || 0}%): €${serviceFee}`);
  982 │     console.log(`   - Total com taxas: €${totalWithFee}`);
  983 │     
  984 │     return {
  985 │       totalPrice,
  986 │       nightlyPrices,
  987 │       serviceFee,
  988 │       totalWithFee
  989 │     };
  990 │   } catch (error) {
  991 │     console.error("❌ Erro ao calcular preço da estadia:", error);
  992 │     throw error;
  993 │   }
  994 │ } 
  995 │ import { 
  996 │   collection, 
  997 │   getDocs, 
  998 │   getDoc, 
  999 │   doc, 
 1000 │   setDoc, 
 1001 │   addDoc, 
 1002 │   updateDoc, 
 1003 │   deleteDoc,
 1004 │   query,
 1005 │   where,
 1006 │   orderBy,
 1007 │   limit,
 1008 │   serverTimestamp
 1009 │ } from 'firebase/firestore';
 1010 │ import { db } from './config';
 1011 │ 
 1012 │ // Get all documents from a collection
 1013 │ export async function getDocuments<T>(collectionName: string, forceRefresh = false): Promise<T[]> {
 1014 │   console.log(`Buscando documentos na coleção ${collectionName} - Força atualização: ${forceRefresh}`);
 1015 │   try {
 1016 │     const querySnapshot = await getDocs(collection(db, collectionName));
 1017 │     return querySnapshot.docs.map(doc => ({
 1018 │       id: doc.id,
 1019 │       ...doc.data()
 1020 │     })) as T[];
 1021 │   } catch (error) {
 1022 │     console.error('Erro ao buscar documentos:', error);
 1023 │     return [];
 1024 │   }
 1025 │ }
 1026 │ 
 1027 │ // Get a document by ID
 1028 │ export async function getDocumentById<T>(collectionName: string, docId: string): Promise<T | null> {
 1029 │   try {
 1030 │     const docRef = doc(db, collectionName, docId);
 1031 │     const docSnap = await getDoc(docRef);
 1032 │     
 1033 │     if (docSnap.exists()) {
 1034 │       return {
 1035 │         id: docSnap.id,
 1036 │         ...docSnap.data()
 1037 │       } as T;
 1038 │     } else {
 1039 │       return null;
 1040 │     }
 1041 │   } catch (error) {
 1042 │     console.error('Erro ao buscar documento:', error);
 1043 │     return null;
 1044 │   }
 1045 │ }
 1046 │ 
 1047 │ // Add a new document
 1048 │ export async function addDocument<T>(collectionName: string, data: any): Promise<T | null> {
 1049 │   try {
 1050 │     const docRef = await addDoc(collection(db, collectionName), {
 1051 │       ...data,
 1052 │       createdAt: serverTimestamp()
 1053 │     });
 1054 │     
 1055 │     return {
 1056 │       id: docRef.id,
 1057 │       ...data
 1058 │     } as T;
 1059 │   } catch (error) {
 1060 │     console.error('Erro ao adicionar documento:', error);
 1061 │     return null;
 1062 │   }
 1063 │ }
 1064 │ 
 1065 │ // Update a document
 1066 │ export async function updateDocument(collectionName: string, docId: string, data: any): Promise<boolean> {
      ·                       ───────┬──────
      ·                              ╰── `updateDocument` redefined here
 1067 │   try {
 1068 │     const docRef = doc(db, collectionName, docId);
 1069 │     await updateDoc(docRef, {
      ╰────

  × the name `deleteDocument` is defined multiple times
      ╭─[/home/runner/workspace/lib/firebase/firestore.ts:145:1]
  145 │   })
  146 │ }
  147 │ 
  148 │ export const deleteDocument = async (
      ·              ───────┬──────
      ·                     ╰── previous definition of `deleteDocument` here
  149 │   collectionName: string,
  150 │   id: string
  151 │ ): Promise<boolean> => {
  152 │   const docRef = doc(db, collectionName, id)
  153 │   await deleteDoc(docRef)
  154 │   return true
  155 │ }
  156 │ 
  157 │ // Funções para gerenciar quartos
  158 │ export const getRooms = async (forceRefresh = false): Promise<Room[]> => {
  159 │   try {
  160 │     const constraints: QueryConstraint[] = []
  161 │     
  162 │     constraints.push(orderBy('name', 'asc'))
  163 │     
  164 │     const rooms = await getDocuments<Room>('rooms', constraints, forceRefresh)
  165 │     
  166 │     // Garantir que todos os campos necessários estejam presentes
  167 │     return rooms.map(room => {
  168 │       console.log(`Firebase - Quarto ${room.id} dados brutos:`, room);
  169 │       
  170 │       // Garantir que serviceFeePct seja um número
  171 │       const serviceFeePct = room.serviceFeePct !== undefined 
  172 │         ? Number(room.serviceFeePct) 
  173 │         : 10;
  174 │         
  175 │       console.log(`Firebase - Quarto ${room.id} serviceFeePct:`, {
  176 │         original: room.serviceFeePct,
  177 │         tipo: typeof room.serviceFeePct,
  178 │         convertido: serviceFeePct
  179 │       });
  180 │       
  181 │       return {
  182 │         id: room.id,
  183 │         name: room.name || '',
  184 │         type: room.type || 'standard',
  185 │         description: room.description || '',
  186 │         price: room.price || 0,
  187 │         capacity: room.capacity || 2,
  188 │         size: room.size || 0,
  189 │         available: room.available !== undefined ? room.available : true,
  190 │         serviceFeePct: serviceFeePct,
  191 │         images: room.images || [],
  192 │         amenities: room.amenities || [],
  193 │         additionalServices: room.additionalServices || [],
  194 │         highlights: room.highlights || [],
  195 │         createdAt: room.createdAt,
  196 │         updatedAt: room.updatedAt
  197 │       };
  198 │     });
  199 │   } catch (error) {
  200 │     console.error('Erro ao buscar quartos:', error)
  201 │     return []
  202 │   }
  203 │ }
  204 │ 
  205 │ export const getAvailableRooms = async (
  206 │   checkIn: Date,
  207 │   checkOut: Date
  208 │ ): Promise<Room[]> => {
  209 │   try {
  210 │     // Buscar todos os quartos que estão marcados como disponíveis em geral
  211 │     const constraints: QueryConstraint[] = [
  212 │       where('available', '==', true)
  213 │     ]
  214 │     
  215 │     const rooms = await getDocuments<Room>('rooms', constraints);
  216 │     
  217 │     // Filtrar os quartos que estão disponíveis nas datas específicas
  218 │     return filterAvailableRoomsByDate(rooms, checkIn, checkOut);
  219 │   } catch (error) {
  220 │     console.error('Erro ao buscar quartos disponíveis:', error)
  221 │     return []
  222 │   }
  223 │ }
  224 │ 
  225 │ // Função auxiliar para verificar disponibilidade entre datas
  226 │ export const filterAvailableRoomsByDate = (
  227 │   rooms: Room[],
  228 │   checkIn: Date,
  229 │   checkOut: Date
  230 │ ): Room[] => {
  231 │   // Converter checkIn e checkOut para ISO strings
  232 │   const dateStrings = getDatesInRange(checkIn, checkOut);
  233 │   
  234 │   return rooms.filter(room => {
  235 │     // Se não tiver controle de disponibilidade específico, considera disponível
  236 │     if (!room.availabilityDates) return true;
  237 │     
  238 │     // Verificar se alguma data no intervalo está indisponível
  239 │     return !dateStrings.some(dateStr => 
  240 │       room.availabilityDates?.[dateStr] === false
  241 │     );
  242 │   });
  243 │ };
  244 │ 
  245 │ // Função para obter disponibilidade de um quarto específico
  246 │ export const getRoomAvailability = async (
  247 │   roomId: string, 
  248 │   startDate: Date, 
  249 │   endDate: Date
  250 │ ): Promise<{[date: string]: boolean}> => {
  251 │   try {
  252 │     const room = await getRoomById(roomId);
  253 │     if (!room) throw new Error(`Quarto com ID ${roomId} não encontrado`);
  254 │     
  255 │     // Gerar datas no intervalo
  256 │     const dateStrings = getDatesInRange(startDate, endDate);
  257 │     
  258 │     // Se não tiver configuração de disponibilidade específica, assume tudo disponível
  259 │     if (!room.availabilityDates) {
  260 │       return dateStrings.reduce((acc, date) => {
  261 │         acc[date] = true;
  262 │         return acc;
  263 │       }, {} as {[date: string]: boolean});
  264 │     }
  265 │     
  266 │     // Preencher com os dados de disponibilidade existentes
  267 │     return dateStrings.reduce((acc, date) => {
  268 │       acc[date] = room.availabilityDates?.[date] !== false; // disponível por padrão se não estiver explicitamente indisponível
  269 │       return acc;
  270 │     }, {} as {[date: string]: boolean});
  271 │   } catch (error) {
  272 │     console.error(`Erro ao verificar disponibilidade do quarto ${roomId}:`, error);
  273 │     throw error;
  274 │   }
  275 │ };
  276 │ 
  277 │ // Função para atualizar disponibilidade de um quarto
  278 │ export const updateRoomAvailability = async (
  279 │   roomId: string,
  280 │   availabilityDates: {[date: string]: boolean}
  281 │ ): Promise<boolean> => {
  282 │   try {
  283 │     await updateDocument('rooms', roomId, {
  284 │       availabilityDates,
  285 │       updatedAt: serverTimestamp()
  286 │     });
  287 │     return true;
  288 │   } catch (error) {
  289 │     console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  290 │     return false;
  291 │   }
  292 │ };
  293 │ 
  294 │ // Função auxiliar para gerar array de strings de data entre um intervalo
  295 │ export const getDatesInRange = (startDate: Date, endDate: Date): string[] => {
  296 │   const dates: string[] = [];
  297 │   const currentDate = new Date(startDate);
  298 │   
  299 │   // Normalizar para meia-noite no fuso horário local
  300 │   currentDate.setHours(0, 0, 0, 0);
  301 │   const endDateNormalized = new Date(endDate);
  302 │   endDateNormalized.setHours(0, 0, 0, 0);
  303 │   
  304 │   // Adicionar cada data no intervalo EXCETO o dia de checkout
  305 │   // Usando < em vez de <= para não incluir o dia de checkout
  306 │   while (currentDate < endDateNormalized) {
  307 │     dates.push(currentDate.toISOString().split('T')[0]); // Formato YYYY-MM-DD
  308 │     currentDate.setDate(currentDate.getDate() + 1);
  309 │   }
  310 │   
  311 │   return dates;
  312 │ };
  313 │ 
  314 │ export const getRoomById = async (id: string): Promise<Room | null> => {
  315 │   try {
  316 │     const room = await getDocument<Room>('rooms', id);
  317 │     
  318 │     if (!room) return null;
  319 │     
  320 │     console.log(`Firebase - getRoomById ${id} dados brutos:`, room);
  321 │     
  322 │     // Log específico para serviceFeePct
  323 │     console.log(`serviceFeePct no Firestore:`, room.serviceFeePct);
  324 │     
  325 │     // Garantir que todos os campos necessários estejam presentes
  326 │     return {
  327 │       ...room,
  328 │       name: room.name || '',
  329 │       type: room.type || 'standard',
  330 │       description: room.description || '',
  331 │       price: room.price || 0,
  332 │       capacity: room.capacity || 2,
  333 │       size: room.size || 0,
  334 │       available: room.available !== undefined ? room.available : true,
  335 │       serviceFeePct: room.serviceFeePct !== undefined ? room.serviceFeePct : 10,
  336 │       images: room.images || [],
  337 │       amenities: room.amenities || [],
  338 │       additionalServices: room.additionalServices || [],
  339 │       highlights: room.highlights || []
  340 │     };
  341 │   } catch (error) {
  342 │     console.error(`Erro ao buscar quarto com ID ${id}:`, error);
  343 │     return null;
  344 │   }
  345 │ }
  346 │ 
  347 │ export const createRoom = async (roomData: Omit<Room, 'id' | 'createdAt' | 'updatedAt'>): Promise<Room> => {
  348 │   try {
  349 │     console.log("createRoom - Dados recebidos:", roomData);
  350 │     
  351 │     const roomWithTimestamps = {
  352 │       ...roomData,
  353 │       available: roomData.available !== undefined ? roomData.available : true,
  354 │       featured: roomData.featured || false,
  355 │       amenities: roomData.amenities || [],
  356 │       additionalServices: roomData.additionalServices || [],
  357 │       highlights: roomData.highlights || [],
  358 │       createdAt: serverTimestamp(),
  359 │       updatedAt: serverTimestamp()
  360 │     }
  361 │     
  362 │     console.log("createRoom - Dados a serem salvos:", roomWithTimestamps);
  363 │     
  364 │     const id = await createDocument('rooms', roomWithTimestamps)
  365 │     
  366 │     return {
  367 │       id,
  368 │       ...roomData,
  369 │       amenities: roomData.amenities || [],
  370 │       additionalServices: roomData.additionalServices || [],
  371 │       highlights: roomData.highlights || [],
  372 │       createdAt: Timestamp.now(),
  373 │       updatedAt: Timestamp.now()
  374 │     }
  375 │   } catch (error) {
  376 │     console.error('Erro ao criar quarto:', error)
  377 │     throw error
  378 │   }
  379 │ }
  380 │ 
  381 │ export const updateRoom = async (id: string, roomData: Partial<Omit<Room, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Room> => {
  382 │   try {
  383 │     console.log(`updateRoom - ID: ${id}, Dados recebidos:`, roomData);
  384 │     
  385 │     // Garantir que estamos lidando explicitamente com o serviceFeePct se ele for 0
  386 │     if (roomData.serviceFeePct === 0) {
  387 │       console.log("updateRoom - Detectado serviceFeePct com valor 0, salvando explicitamente.", roomData.serviceFeePct);
  388 │     }
  389 │     
  390 │     // Adicionar timestamp de atualização
  391 │     const roomWithTimestamp = {
  392 │       ...roomData,
  393 │       amenities: roomData.amenities || [],
  394 │       additionalServices: roomData.additionalServices || [],
  395 │       highlights: roomData.highlights || [],
  396 │       updatedAt: serverTimestamp()
  397 │     }
  398 │     
  399 │     console.log(`updateRoom - Dados a serem salvos:`, roomWithTimestamp);
  400 │     
  401 │     await updateDocument('rooms', id, roomWithTimestamp)
  402 │     
  403 │     const updatedRoom = await getRoomById(id)
  404 │     if (!updatedRoom) {
  405 │       throw new Error(`Quarto com ID ${id} não encontrado após atualização`)
  406 │     }
  407 │     
  408 │     return updatedRoom
  409 │   } catch (error) {
  410 │     console.error('Erro ao atualizar quarto:', error)
  411 │     throw error
  412 │   }
  413 │ }
  414 │ 
  415 │ export const deleteRoom = async (id: string): Promise<boolean> => {
  416 │   return await deleteDocument('rooms', id)
  417 │ }
  418 │ 
  419 │ // Funções específicas para reservas
  420 │ export const createBooking = async (bookingData: any) => {
  421 │   try {
  422 │     const bookingsCollection = collection(db, 'bookings');
  423 │     const docRef = await addDoc(bookingsCollection, bookingData);
  424 │     
  425 │     // CORREÇÃO: Não bloquear a data no momento da criação da reserva
  426 │     // O bloqueio será feito apenas quando o pagamento for confirmado
  427 │     // através da função updateBookingStatus
  428 │     
  429 │     return docRef;
  430 │   } catch (error) {
  431 │     console.error('Erro ao criar reserva:', error);
  432 │     throw error;
  433 │   }
  434 │ };
  435 │ 
  436 │ // Nova função para atualizar status da reserva e bloquear as datas da estadia
  437 │ export const updateBookingStatus = async (
  438 │   bookingId: string, 
  439 │   newStatus: 'pending' | 'confirmed' | 'cancelled' | 'completed',
  440 │   newPaymentStatus: 'pending' | 'paid' | 'refunded'
  441 │ ): Promise<boolean> => {
  442 │   try {
  443 │     // Referência ao documento da reserva
  444 │     const bookingRef = doc(db, 'bookings', bookingId);
  445 │     const bookingSnap = await getDoc(bookingRef);
  446 │     
  447 │     if (!bookingSnap.exists()) {
  448 │       console.error(`Booking ${bookingId} não existe ao atualizar status`);
  449 │       return false;
  450 │     }
  451 │     
  452 │     const bookingData = bookingSnap.data();
  453 │     
  454 │     // Atualizar o status da reserva
  455 │     await updateDoc(bookingRef, {
  456 │       status: newStatus,
  457 │       paymentStatus: newPaymentStatus,
  458 │       updatedAt: serverTimestamp(),
  459 │       ...(newStatus === 'confirmed' && { confirmedAt: serverTimestamp() })
  460 │     });
  461 │     
  462 │     // Se a reserva está sendo confirmada, precisamos bloquear as datas
  463 │     if (newStatus === 'confirmed') {
  464 │       console.log(`Atualizando disponibilidade para reserva confirmada: ${bookingId}`);
  465 │       
  466 │       // Recuperar datas de check-in e check-out
  467 │       const checkIn = bookingData.checkIn.toDate();
  468 │       const checkOut = bookingData.checkOut.toDate();
  469 │       const roomId = bookingData.roomId;
  470 │       
  471 │       // Obter todas as datas entre check-in e check-out
  472 │       const dates: Date[] = [];
  473 │       const currentDate = new Date(checkIn);
  474 │       
  475 │       while (currentDate < checkOut) {
  476 │         dates.push(new Date(currentDate));
  477 │         currentDate.setDate(currentDate.getDate() + 1);
  478 │       }
  479 │       
  480 │       console.log(`Bloqueando ${dates.length} dias para quarto ${roomId}`);
  481 │       
  482 │       // Atualizar disponibilidade para cada data
  483 │       const availabilityUpdates: {[date: string]: boolean} = {};
  484 │       
  485 │       dates.forEach(date => {
  486 │         const dateString = date.toISOString().split('T')[0]; // formato YYYY-MM-DD
  487 │         availabilityUpdates[dateString] = false; // false significa indisponível
  488 │       });
  489 │       
  490 │       // Atualizar disponibilidade do quarto
  491 │       if (Object.keys(availabilityUpdates).length > 0) {
  492 │         try {
  493 │           // Obter o documento do quarto
  494 │           const roomRef = doc(db, 'rooms', roomId);
  495 │           const roomSnap = await getDoc(roomRef);
  496 │           
  497 │           if (roomSnap.exists()) {
  498 │             const roomData = roomSnap.data();
  499 │             const currentAvailability = roomData.availabilityDates || {};
  500 │             
  501 │             // Mesclar a disponibilidade atual com as novas atualizações
  502 │             const updatedAvailability = {
  503 │               ...currentAvailability,
  504 │               ...availabilityUpdates
  505 │             };
  506 │             
  507 │             // Atualizar o documento do quarto
  508 │             await updateDoc(roomRef, {
  509 │               availabilityDates: updatedAvailability,
  510 │               updatedAt: serverTimestamp()
  511 │             });
  512 │             
  513 │             console.log(`Disponibilidade atualizada com sucesso para quarto ${roomId}`);
  514 │             
  515 │             // Criar log da reserva
  516 │             await addDoc(collection(db, 'bookingLogs'), {
  517 │               bookingId,
  518 │               roomId,
  519 │               action: 'status_updated',
  520 │               previousStatus: bookingData.status,
  521 │               newStatus,
  522 │               previousPaymentStatus: bookingData.paymentStatus,
  523 │               newPaymentStatus,
  524 │               datesBlocked: Object.keys(availabilityUpdates),
  525 │               timestamp: serverTimestamp(),
  526 │               userId: bookingData.userId || 'system'
  527 │             });
  528 │           } else {
  529 │             console.error(`Quarto ${roomId} não encontrado ao atualizar disponibilidade`);
  530 │           }
  531 │         } catch (error) {
  532 │           console.error(`Erro ao atualizar disponibilidade do quarto ${roomId}:`, error);
  533 │         }
  534 │       }
  535 │     }
  536 │     
  537 │     return true;
  538 │   } catch (error) {
  539 │     console.error(`Erro ao atualizar status da reserva ${bookingId}:`, error);
  540 │     return false;
  541 │   }
  542 │ }
  543 │ 
  544 │ export const getUserBookings = async (userId: string): Promise<Booking[]> => {
  545 │   return getDocuments<Booking>('bookings', [
  546 │     where('userId', '==', userId),
  547 │     orderBy('createdAt', 'desc')
  548 │   ])
  549 │ }
  550 │ 
  551 │ export const getRecentBookings = async (count = 5): Promise<Booking[]> => {
  552 │   return getDocuments<Booking>('bookings', [
  553 │     orderBy('createdAt', 'desc'),
  554 │     limit(count)
  555 │   ])
  556 │ }
  557 │ 
  558 │ export const getRoomBookings = async (roomId: string): Promise<Booking[]> => {
  559 │   try {
  560 │     const constraints: QueryConstraint[] = [
  561 │       where('roomId', '==', roomId),
  562 │       orderBy('checkIn', 'asc')
  563 │     ];
  564 │     
  565 │     return await getDocuments<Booking>('bookings', constraints);
  566 │   } catch (error) {
  567 │     console.error(`Erro ao buscar reservas do quarto ${roomId}:`, error);
  568 │     return [];
  569 │   }
  570 │ };
  571 │ 
  572 │ // Funções específicas para contatos
  573 │ export const createContactMessage = async (contactData: Contact) => {
  574 │   try {
  575 │     const contactsCollection = collection(db, 'contacts')
  576 │     
  577 │     // Garantir que o status seja 'new' para novos contatos
  578 │     const contactWithDefaults = {
  579 │       ...contactData,
  580 │       status: contactData.status || 'new',
  581 │       createdAt: contactData.createdAt || Timestamp.now()
  582 │     }
  583 │     
  584 │     // Se tiver detalhes de reserva, adicionar metadados
  585 │     if (contactWithDefaults.reservationDetails) {
  586 │       // Ajustar subject para indicar que é relacionado a reserva
  587 │       if (!contactWithDefaults.subject.includes('Reserva')) {
  588 │         contactWithDefaults.subject = `Reserva: ${contactWithDefaults.subject}`;
  589 │       }
  590 │     }
  591 │     
  592 │     const docRef = await addDoc(contactsCollection, contactWithDefaults)
  593 │     return docRef
  594 │   } catch (error) {
  595 │     console.error('Erro ao criar mensagem de contato:', error)
  596 │     throw error
  597 │   }
  598 │ }
  599 │ 
  600 │ export const getNewContactMessages = async (): Promise<Contact[]> => {
  601 │   return getDocuments<Contact>('contacts', [
  602 │     where('status', '==', 'new'),
  603 │     orderBy('createdAt', 'desc')
  604 │   ])
  605 │ }
  606 │ 
  607 │ // Funções para Dashboard com dados reais
  608 │ 
  609 │ export const getDashboardStats = async () => {
  610 │   try {
  611 │     const [totalBookings, totalRevenue, occupancyRate, bookingsByPlatform] = await Promise.all([
  612 │       getTotalBookings(),
  613 │       getMonthlyRevenue(),
  614 │       getOccupancyRate(),
  615 │       getBookingsByPlatform()
  616 │     ]);
  617 │ 
  618 │     return {
  619 │       totalBookings,
  620 │       totalRevenue,
  621 │       occupancyRate,
  622 │       bookingsByPlatform
  623 │     };
  624 │   } catch (error) {
  625 │     console.error('Erro ao obter estatísticas do dashboard:', error);
  626 │     throw error;
  627 │   }
  628 │ };
  629 │ 
  630 │ // Obter total de reservas
  631 │ export const getTotalBookings = async () => {
  632 │   try {
  633 │     // Obter todas as reservas
  634 │     const bookings = await getDocuments<Booking>('bookings');
  635 │     
  636 │     // Contar reservas por status
  637 │     const confirmed = bookings.filter(b => b.status === 'confirmed').length;
  638 │     const pending = bookings.filter(b => b.status === 'pending').length;
  639 │     const cancelled = bookings.filter(b => b.status === 'cancelled').length;
  640 │     const completed = bookings.filter(b => b.status === 'completed').length;
  641 │     
  642 │     // Calcular crescimento em relação ao mês anterior (simulado por enquanto)
  643 │     // Em uma implementação real, você compararia com dados do mês anterior
  644 │     const growth = ((confirmed + completed) / (bookings.length || 1) * 100) - 50;
  645 │     
  646 │     return {
  647 │       total: bookings.length,
  648 │       confirmed,
  649 │       pending,
  650 │       cancelled,
  651 │       completed,
  652 │       growth: Math.round(growth) // Arredonda para número inteiro
  653 │     };
  654 │   } catch (error) {
  655 │     console.error('Erro ao obter total de reservas:', error);
  656 │     return {
  657 │       total: 0,
  658 │       confirmed: 0,
  659 │       pending: 0, 
  660 │       cancelled: 0,
  661 │       completed: 0,
  662 │       growth: 0
  663 │     };
  664 │   }
  665 │ };
  666 │ 
  667 │ // Obter receita mensal
  668 │ export const getMonthlyRevenue = async () => {
  669 │   try {
  670 │     const bookings = await getDocuments<Booking>('bookings');
  671 │     
  672 │     // Filtrar reservas confirmadas e concluídas
  673 │     const validBookings = bookings.filter(b => 
  674 │       b.status === 'confirmed' || b.status === 'completed'
  675 │     );
  676 │     
  677 │     // Calcular receita total
  678 │     const totalRevenue = validBookings.reduce((acc, booking) => acc + booking.totalPrice, 0);
  679 │     
  680 │     // Agrupar receita por mês
  681 │     const revenueByMonth = validBookings.reduce((acc, booking) => {
  682 │       const date = booking.checkIn.toDate();
  683 │       const month = date.getMonth(); // 0-11
  684 │       const year = date.getFullYear();
  685 │       const key = `${year}-${month}`;
  686 │       
  687 │       if (!acc[key]) {
  688 │         acc[key] = 0;
  689 │       }
  690 │       acc[key] += booking.totalPrice;
  691 │       return acc;
  692 │     }, {} as Record<string, number>);
  693 │     
  694 │     // Converter para formato de array para gráfico
  695 │     const monthNames = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
  696 │     
  697 │     const currentDate = new Date();
  698 │     const currentMonth = currentDate.getMonth();
  699 │     const currentYear = currentDate.getFullYear();
  700 │     
  701 │     const revenueData = [];
  702 │     
  703 │     // Gerar dados dos últimos 12 meses
  704 │     for (let i = 0; i < 12; i++) {
  705 │       const month = (currentMonth - i + 12) % 12;
  706 │       const year = currentMonth - i < 0 ? currentYear - 1 : currentYear;
  707 │       const key = `${year}-${month}`;
  708 │       
  709 │       revenueData.unshift({
  710 │         month: monthNames[month],
  711 │         value: revenueByMonth[key] || 0
  712 │       });
  713 │     }
  714 │     
  715 │     // Calcular crescimento em relação ao mês anterior
  716 │     const lastMonthRevenue = revenueData[revenueData.length - 2]?.value || 0;
  717 │     const currentMonthRevenue = revenueData[revenueData.length - 1]?.value || 0;
  718 │     
  719 │     const growth = lastMonthRevenue ? ((currentMonthRevenue - lastMonthRevenue) / lastMonthRevenue) * 100 : 0;
  720 │     
  721 │     return {
  722 │       monthly: currentMonthRevenue,
  723 │       total: totalRevenue,
  724 │       growth: Math.round(growth),
  725 │       revenueData
  726 │     };
  727 │   } catch (error) {
  728 │     console.error('Erro ao obter receita mensal:', error);
  729 │     return {
  730 │       monthly: 0,
  731 │       total: 0,
  732 │       growth: 0,
  733 │       revenueData: []
  734 │     };
  735 │   }
  736 │ };
  737 │ 
  738 │ // Calcular taxa de ocupação
  739 │ export const getOccupancyRate = async () => {
  740 │   try {
  741 │     // Obter todos os quartos
  742 │     const rooms = await getDocuments<Room>('rooms');
  743 │     const totalRooms = rooms.length;
  744 │     
  745 │     if (totalRooms === 0) {
  746 │       return { rate: 0, growth: 0 };
  747 │     }
  748 │     
  749 │     // Obter todas as reservas
  750 │     const bookings = await getDocuments<Booking>('bookings');
  751 │     
  752 │     // Filtrar reservas confirmadas e concluídas para o mês atual
  753 │     const currentDate = new Date();
  754 │     const currentMonth = currentDate.getMonth();
  755 │     const currentYear = currentDate.getFullYear();
  756 │     
  757 │     const currentMonthBookings = bookings.filter(booking => {
  758 │       const checkInDate = booking.checkIn.toDate();
  759 │       return (
  760 │         (booking.status === 'confirmed' || booking.status === 'completed') &&
  761 │         checkInDate.getMonth() === currentMonth &&
  762 │         checkInDate.getFullYear() === currentYear
  763 │       );
  764 │     });
  765 │     
  766 │     // Calcular dias ocupados por quarto
  767 │     const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
  768 │     const totalPossibleRoomDays = totalRooms * daysInMonth;
  769 │     
  770 │     // Contar dias ocupados (simplificado - em produção seria mais complexo)
  771 │     let occupiedDays = 0;
  772 │     
  773 │     currentMonthBookings.forEach(booking => {
  774 │       const checkIn = booking.checkIn.toDate();
  775 │       const checkOut = booking.checkOut.toDate();
  776 │       
  777 │       // Ajustar datas para considerar apenas o mês atual
  778 │       const startDate = new Date(Math.max(
  779 │         checkIn.getTime(),
  780 │         new Date(currentYear, currentMonth, 1).getTime()
  781 │       ));
  782 │       const endDate = new Date(Math.min(
  783 │         checkOut.getTime(),
  784 │         new Date(currentYear, currentMonth + 1, 0).getTime()
  785 │       ));
  786 │       
  787 │       // Calcular dias entre datas (incluindo check-in, excluindo check-out)
  788 │       const days = Math.max(0, Math.floor((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)));
  789 │       occupiedDays += days;
  790 │     });
  791 │     
  792 │     const occupancyRate = (occupiedDays / totalPossibleRoomDays) * 100;
  793 │     
  794 │     // Simulação de crescimento (em produção, compararia com mês anterior)
  795 │     const growth = occupancyRate > 50 ? 5 : -3;
  796 │     
  797 │     return {
  798 │       rate: Math.round(occupancyRate),
  799 │       growth: Math.round(growth)
  800 │     };
  801 │   } catch (error) {
  802 │     console.error('Erro ao calcular taxa de ocupação:', error);
  803 │     return { rate: 0, growth: 0 };
  804 │   }
  805 │ };
  806 │ 
  807 │ // Obter reservas agrupadas por plataforma
  808 │ export const getBookingsByPlatform = async () => {
  809 │   try {
  810 │     const bookings = await getDocuments<Booking>('bookings');
  811 │     
  812 │     // Categorizar reservas por origem
  813 │     const platforms = [
  814 │       { 
  815 │         platform: "Booking.com", 
  816 │         color: "#003580", 
  817 │         icon: "Globe",
  818 │         bookings: []
  819 │       },
  820 │       { 
  821 │         platform: "Airbnb", 
  822 │         color: "#FF5A5F", 
  823 │         icon: "Heart",
  824 │         bookings: []
  825 │       },
  826 │       { 
  827 │         platform: "Direto", 
  828 │         color: "#4CAF50", 
  829 │         icon: "Home",
  830 │         bookings: []
  831 │       }
  832 │     ];
  833 │     
  834 │     // Para fins de demonstração, colocar todas as reservas como "Direto" por enquanto
  835 │     // Em produção, usaria um campo "platformOrigin" ou similar na tabela de reservas
  836 │     const platformIndex = 2; // Índice da plataforma "Direto"
  837 │     
  838 │     bookings.forEach(booking => {
  839 │       // Transformar para o formato esperado pelo componente
  840 │       const transformedBooking = {
  841 │         id: booking.id || '',
  842 │         guestName: booking.guestName,
  843 │         roomName: booking.roomName,
  844 │         checkIn: booking.checkIn.toDate().toLocaleDateString('pt-PT'),
  845 │         checkOut: booking.checkOut.toDate().toLocaleDateString('pt-PT'),
  846 │         status: booking.status,
  847 │         value: new Intl.NumberFormat('pt-PT', {
  848 │           style: 'currency',
  849 │           currency: 'EUR'
  850 │         }).format(booking.totalPrice)
  851 │       };
  852 │       
  853 │       // Adicionar à plataforma "Direto"
  854 │       (platforms[platformIndex] as any).bookings.push(transformedBooking);
  855 │     });
  856 │     
  857 │     return platforms;
  858 │   } catch (error) {
  859 │     console.error('Erro ao obter reservas por plataforma:', error);
  860 │     return [];
  861 │   }
  862 │ };
  863 │ 
  864 │ // Função para obter o preço de um quarto para uma data específica
  865 │ export const getRoomPriceForDate = async (roomId: string, date: Date): Promise<number> => {
  866 │   try {
  867 │     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  868 │     
  869 │     if (!roomDoc.exists()) {
  870 │       throw new Error("Quarto não encontrado");
  871 │     }
  872 │     
  873 │     const roomData = roomDoc.data() as Room;
  874 │     const basePrice = roomData.price;
  875 │     
  876 │     if (!roomData.seasonalPrices || roomData.seasonalPrices.length === 0) {
  877 │       return basePrice;
  878 │     }
  879 │     
  880 │     // Verificar se a data está dentro de algum período sazonal
  881 │     for (const seasonalPrice of roomData.seasonalPrices) {
  882 │       const startDate = new Date(seasonalPrice.startDate);
  883 │       const endDate = new Date(seasonalPrice.endDate);
  884 │       
  885 │       if (date >= startDate && date <= endDate) {
  886 │         return seasonalPrice.price;
  887 │       }
  888 │     }
  889 │     
  890 │     // Se não cair em nenhum período sazonal, retorna o preço base
  891 │     return basePrice;
  892 │   } catch (error) {
  893 │     console.error("Erro ao obter preço do quarto:", error);
  894 │     throw error;
  895 │   }
  896 │ }
  897 │ 
  898 │ // Função para calcular o preço total de uma estadia
  899 │ export const calculateStayPrice = async (
  900 │   roomId: string, 
  901 │   checkIn: Date, 
  902 │   checkOut: Date
  903 │ ): Promise<{
  904 │   totalPrice: number;
  905 │   nightlyPrices: { date: string; price: number }[];
  906 │   serviceFee: number;
  907 │   totalWithFee: number;
  908 │ }> => {
  909 │   try {
  910 │     console.log(`🔍 Iniciando cálculo de preço para estadia: ${checkIn.toISOString().split('T')[0]} até ${checkOut.toISOString().split('T')[0]}`);
  911 │     
  912 │     const roomDoc = await getDoc(doc(db, "rooms", roomId));
  913 │     
  914 │     if (!roomDoc.exists()) {
  915 │       throw new Error("Quarto não encontrado");
  916 │     }
  917 │     
  918 │     const roomData = roomDoc.data() as Room;
  919 │     console.log(`📝 Dados do quarto ${roomId}:`, {
  920 │       nome: roomData.name,
  921 │       precoBase: roomData.price,
  922 │       taxaServico: roomData.serviceFeePct || 0,
  923 │       temPrecosSazonais: !!roomData.seasonalPrices?.length
  924 │     });
  925 │     
  926 │     const nightlyPrices: { date: string; price: number }[] = [];
  927 │     let totalPrice = 0;
  928 │     
  929 │     // Calcular o número de noites - corrigido para usar o método correto de cálculo
  930 │     // O número de noites é a diferença em dias (estadia = checkout - checkin)
  931 │     const noites = differenceInDays(checkOut, checkIn);
  932 │     console.log(`🗓️ Número de noites calculado: ${noites}`);
  933 │     
  934 │     if (noites <= 0) {
  935 │       console.error(`⚠️ Erro: número de noites inválido (${noites})`);
  936 │       throw new Error("Data de check-out deve ser posterior à data de check-in");
  937 │     }
  938 │     
  939 │     // Para cada noite, verificar o preço aplicável (preço base ou sazonal)
  940 │     // Começamos exatamente do dia de check-in
  941 │     const currentDate = new Date(checkIn);
  942 │     currentDate.setHours(0, 0, 0, 0); // Normalizar para meia-noite
  943 │     
  944 │     // Processamos cada dia de estadia (noite)
  945 │     console.log(`📊 Calculando preços por noite:`);
  946 │     for (let i = 0; i < noites; i++) {
  947 │       // Obtemos o preço para esta data
  948 │       const dateCopy = new Date(currentDate);
  949 │       const priceForDate = await getRoomPriceForDate(roomId, dateCopy);
  950 │       const dateString = dateCopy.toISOString().split('T')[0]; // YYYY-MM-DD
  951 │       
  952 │       console.log(`   - ${dateString}: €${priceForDate}`);
  953 │       
  954 │       nightlyPrices.push({
  955 │         date: dateString,
  956 │         price: priceForDate
  957 │       });
  958 │       
  959 │       totalPrice += priceForDate;
  960 │       
  961 │       // Avançamos para o próximo dia
  962 │       currentDate.setDate(currentDate.getDate() + 1);
  963 │     }
  964 │     
  965 │     // Verificação de segurança para o cálculo do totalPrice
  966 │     const manualTotal = nightlyPrices.reduce((sum, night) => sum + night.price, 0);
  967 │     if (Math.abs(totalPrice - manualTotal) > 1) {
  968 │       console.error(`⚠️ Discrepância detectada no cálculo do preço total!`);
  969 │       console.error(`   - Total calculado iterativamente: €${totalPrice}`);
  970 │       console.error(`   - Total calculado via reduce: €${manualTotal}`);
  971 │       console.error(`   - Usando o valor recalculado para segurança!`);
  972 │       totalPrice = manualTotal;
  973 │     }
  974 │     
  975 │     // Calcular taxa de serviço
  976 │     const serviceFee = (totalPrice * (roomData.serviceFeePct || 0)) / 100;
  977 │     const totalWithFee = totalPrice + serviceFee;
  978 │     
  979 │     console.log(`💰 Resumo do cálculo:`);
  980 │     console.log(`   - Total das diárias: €${totalPrice}`);
  981 │     console.log(`   - Taxa de serviço (${roomData.serviceFeePct || 0}%): €${serviceFee}`);
  982 │     console.log(`   - Total com taxas: €${totalWithFee}`);
  983 │     
  984 │     return {
  985 │       totalPrice,
  986 │       nightlyPrices,
  987 │       serviceFee,
  988 │       totalWithFee
  989 │     };
  990 │   } catch (error) {
  991 │     console.error("❌ Erro ao calcular preço da estadia:", error);
  992 │     throw error;
  993 │   }
  994 │ } 
  995 │ import { 
  996 │   collection, 
  997 │   getDocs, 
  998 │   getDoc, 
  999 │   doc, 
 1000 │   setDoc, 
 1001 │   addDoc, 
 1002 │   updateDoc, 
 1003 │   deleteDoc,
 1004 │   query,
 1005 │   where,
 1006 │   orderBy,
 1007 │   limit,
 1008 │   serverTimestamp
 1009 │ } from 'firebase/firestore';
 1010 │ import { db } from './config';
 1011 │ 
 1012 │ // Get all documents from a collection
 1013 │ export async function getDocuments<T>(collectionName: string, forceRefresh = false): Promise<T[]> {
 1014 │   console.log(`Buscando documentos na coleção ${collectionName} - Força atualização: ${forceRefresh}`);
 1015 │   try {
 1016 │     const querySnapshot = await getDocs(collection(db, collectionName));
 1017 │     return querySnapshot.docs.map(doc => ({
 1018 │       id: doc.id,
 1019 │       ...doc.data()
 1020 │     })) as T[];
 1021 │   } catch (error) {
 1022 │     console.error('Erro ao buscar documentos:', error);
 1023 │     return [];
 1024 │   }
 1025 │ }
 1026 │ 
 1027 │ // Get a document by ID
 1028 │ export async function getDocumentById<T>(collectionName: string, docId: string): Promise<T | null> {
 1029 │   try {
 1030 │     const docRef = doc(db, collectionName, docId);
 1031 │     const docSnap = await getDoc(docRef);
 1032 │     
 1033 │     if (docSnap.exists()) {
 1034 │       return {
 1035 │         id: docSnap.id,
 1036 │         ...docSnap.data()
 1037 │       } as T;
 1038 │     } else {
 1039 │       return null;
 1040 │     }
 1041 │   } catch (error) {
 1042 │     console.error('Erro ao buscar documento:', error);
 1043 │     return null;
 1044 │   }
 1045 │ }
 1046 │ 
 1047 │ // Add a new document
 1048 │ export async function addDocument<T>(collectionName: string, data: any): Promise<T | null> {
 1049 │   try {
 1050 │     const docRef = await addDoc(collection(db, collectionName), {
 1051 │       ...data,
 1052 │       createdAt: serverTimestamp()
 1053 │     });
 1054 │     
 1055 │     return {
 1056 │       id: docRef.id,
 1057 │       ...data
 1058 │     } as T;
 1059 │   } catch (error) {
 1060 │     console.error('Erro ao adicionar documento:', error);
 1061 │     return null;
 1062 │   }
 1063 │ }
 1064 │ 
 1065 │ // Update a document
 1066 │ export async function updateDocument(collectionName: string, docId: string, data: any): Promise<boolean> {
 1067 │   try {
 1068 │     const docRef = doc(db, collectionName, docId);
 1069 │     await updateDoc(docRef, {
 1070 │       ...data,
 1071 │       updatedAt: serverTimestamp()
 1072 │     });
 1073 │     return true;
 1074 │   } catch (error) {
 1075 │     console.error('Erro ao atualizar documento:', error);
 1076 │     return false;
 1077 │   }
 1078 │ }
 1079 │ 
 1080 │ // Delete a document
 1081 │ export async function deleteDocument(collectionName: string, docId: string): Promise<boolean> {
      ·                       ───────┬──────
      ·                              ╰── `deleteDocument` redefined here
 1082 │   try {
 1083 │     const docRef = doc(db, collectionName, docId);
 1084 │     await deleteDoc(docRef);
      ╰────

    at processResult (/home/runner/workspace/node_modules/next/dist/compiled/webpack/bundle5.js:28:398653)
    at <unknown> (/home/runner/workspace/node_modules/next/dist/compiled/webpack/bundle5.js:28:400370)
    at <unknown> (/home/runner/workspace/node_modules/next/dist/compiled/loader-runner/LoaderRunner.js:1:8645)
    at <unknown> (/home/runner/workspace/node_modules/next/dist/compiled/loader-runner/LoaderRunner.js:1:5019)
    at r.callback (/home/runner/workspace/node_modules/next/dist/compiled/loader-runner/LoaderRunner.js:1:4039)
client.js:1 ./lib/firebase/firestore.ts
Error: 
  × the name `collection` is defined multiple times
     ╭─[/home/runner/workspace/lib/firebase/firestore.ts:1:1]
   1 │ import {
   2 │   collection,
     ·   ─────┬────
     ·        ╰── previous definition of `collection` here
   3 │   doc,
   4 │   setDoc,
   5 │   addDoc,
   6 │   getDoc,
   7 │   getDocs,
   8 │   updateDoc,
   9 │   deleteDoc,
  10 │   query,
  11 │   where,
  12 │   orderBy,
  13 │   limit,
  14 │   DocumentData,
  15 │   QueryConstraint,
  16 │   Timestamp,
  17 │   serverTimestamp
  18 │ } from 'firebase/firestore'
  19 │ import { db } from './config'
  20 │ import { Room, SeasonalPrice } from '@/lib/types'
  21 │ import { differenceInDays } from 'date-fns'
  22 │ 
  23 │ // Tipos de dados
  24 │ export interface Booking {
  25 │   id?: string
  26 │   userId?: string
  27 │   guestName: string
  28 │   guestEmail: string
  29 │   guestPhone: string
  30 │   roomId: string
  31 │   roomName: string
  32 │   checkIn: Timestamp
  33 │   checkOut: Timestamp
  34 │   adults: number
  35 │   children: number
  36 │   totalPrice: number
  37 │   status: 'pending' | 'confirmed' | 'cancelled' | 'completed'
  38 │   paymentStatus: 'pending' | 'paid' | 'refunded'
  39 │   specialRequests?: string
  40 │   createdAt?: Timestamp
  41 │   updatedAt?: Timestamp
  42 │ }
  43 │ 
  44 │ export interface Contact {
  45 │   id?: string
  46 │   name: string
  47 │   email: string
  48 │   phone?: string
  49 │   subject: string
  50 │   message: string
  51 │   status: 'new' | 'read' | 'replied'
  52 │   createdAt: Timestamp
  53 │   updatedAt?: Timestamp
  54 │   repliedAt?: Timestamp
  55 │   replyContent?: string
  56 │   reservationDetails?: {
  57 │     checkIn?: Timestamp
  58 │     checkOut?: Timestamp
  59 │     roomId?: string
  60 │     roomName?: string
  61 │     totalGuests?: number
  62 │     totalPrice?: number
  63 │   }
  64 │ }
  65 │ 
  66 │ // Funções genéricas para CRUD
  67 │ export const createDocument = async <T extends DocumentData>(
  68 │   collectionName: string,
  69 │   data: T
  70 │ ): Promise<string> => {
  71 │   const docRef = await addDoc(collection(db, collectionName), {
  72 │     ...data,
  73 │     createdAt: serverTimestamp(),
  74 │     updatedAt: serverTimestamp()
  75 │   })
  76 │   return docRef.id
  77 │ }
  78 │ 
  79 │ export const createDocumentWithId = async <T extends DocumentData>(
  80 │   collectionName: string,
  81 │   id: string,
  82 │   data: T
  83 │ ): Promise<void> => {
  84 │   await setDoc(doc(db, collectionName, id), {
  85 │     ...data,
  86 │     createdAt: serverTimestamp(),
  87 │     updatedAt: serverTimestamp()
  88 │   })
  89 │ }
  90 │ 
  91 │ export const getDocument = async <T>(
  92 │   collectionName: string,
  93 │   id: string
  94 │ ): Promise<T | null> => {
  95 │   const docRef = doc(db, collectionName, id)
  96 │   const docSnap = await getDoc(docRef)
  97 │   
  98 │   if (docSnap.exists()) {
  99 │     const data = docSnap.data();
 100 │     console.log("Dados brutos recuperados do Firestore para quarto:", id, data);
 101 │     
 102 │     if (data?.serviceFeePct !== undefined) {
 103 │       console.log("serviceFeePct antes da conversão:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
 104 │       // Garantir que serviceFeePct seja um número
 105 │       data.serviceFeePct = Number(data.serviceFeePct);
 106 │       console.log("serviceFeePct após conversão:", data.serviceFeePct, "tipo:", typeof data.serviceFeePct);
 107 │     }
 108 │     
 109 │     return { id: docSnap.id, ...data } as T
 110 │   } else {
 111 │     return null
 112 │   }
 113 │ }
 114 │ 
 115 │ export const getDocuments = async <T>(
 116 │   collectionName: string,
 117 │   constraints: QueryConstraint[] = [],
 118 │   forceRefresh = false
 119 │ ): Promise<T[]> => {
 120 │   try {
 121 │     const collectionRef = collection(db, collectionName)
 122 │     const q = query(collectionRef, ...constraints)
 123 │     
 124 │     // Se forceRefresh for verdadeiro, adicionar opções que forçam uma nova consulta ao Firestore
 125 │     const querySnapshot = await getDocs(q)
 126 │     
 127 │     console.log(`Buscando documentos na coleção ${collectionName} - Força atualização: ${forceRefresh}`);
 128 │     
 129 │     return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }) as T)
 130 │   } catch (error) {
 131 │     console.error(`Erro ao buscar documentos da coleção ${collectionName}:`, error);
 132 │     return [];
 133 │   }
 134 │ }
 135 │ 
 136 │ export const updateDocument = async <T extends DocumentData>(
 137 │   collectionName: string,
 138 │   id: string,
 139 │   data: Partial<T>
 140 │ ): Promise<void> => {
 141 │   const docRef = doc(db, collectionName, id)
 142 │   await updateDoc(docRef, {
 143 │     ...data,
 144 │     updatedAt: serverTimestamp()
 145 │   })
 146 │ }
 147 │ 
 148 │ export const deleteDocument = async (
 149 │   collectionName: string,
 150 │   id: string
 1
console.error @ client.js:1
/favicon.ico:1 
            
            
           Failed to load resource: the server responded with a status of 404 (Not Found)
